
Projet-Master1.elf:     file format elf32-littlenios2
Projet-Master1.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x02000248

Program Header:
    LOAD off    0x00001000 vaddr 0x02000000 paddr 0x02000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x0001fb28 memsz 0x0001fb28 flags r-x
    LOAD off    0x00020b48 vaddr 0x0201fb48 paddr 0x02021730 align 2**12
         filesz 0x00001be8 memsz 0x00001be8 flags rw-
    LOAD off    0x00023318 vaddr 0x02023318 paddr 0x02023318 align 2**12
         filesz 0x00000000 memsz 0x0000b430 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02000000  02000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000228  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0001f1cc  02000248  02000248  00001248  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000734  0201f414  0201f414  00020414  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001be8  0201fb48  02021730  00020b48  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000b430  02023318  02023318  00023318  2**2
                  ALLOC, SMALL_DATA
  6 .mem_Nios_PI  00000000  00200000  00200000  00022730  2**0
                  CONTENTS
  7 .sdram_controller 00000000  0202e748  0202e748  00022730  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00022730  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001180  00000000  00000000  00022758  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002d3b1  00000000  00000000  000238d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000a7a8  00000000  00000000  00050c89  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000e2e2  00000000  00000000  0005b431  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00003870  00000000  00000000  00069714  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000057c2  00000000  00000000  0006cf84  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00009061  00000000  00000000  00072746  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000030  00000000  00000000  0007b7a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000013d8  00000000  00000000  0007b7d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00081cf2  2**0
                  CONTENTS, READONLY
 19 .cpu          00000003  00000000  00000000  00081cf8  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00081cfb  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00081cfc  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00081cfd  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00081d01  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00081d05  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   00000009  00000000  00000000  00081d09  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    00000009  00000000  00000000  00081d12  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   00000009  00000000  00000000  00081d1b  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000009  00000000  00000000  00081d24  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 00000034  00000000  00000000  00081d2d  2**0
                  CONTENTS, READONLY
 30 .jdi          00003d7f  00000000  00000000  00081d61  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     0005d33a  00000000  00000000  00085ae0  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02000000 l    d  .entry	00000000 .entry
02000020 l    d  .exceptions	00000000 .exceptions
02000248 l    d  .text	00000000 .text
0201f414 l    d  .rodata	00000000 .rodata
0201fb48 l    d  .rwdata	00000000 .rwdata
02023318 l    d  .bss	00000000 .bss
00200000 l    d  .mem_Nios_PI	00000000 .mem_Nios_PI
0202e748 l    d  .sdram_controller	00000000 .sdram_controller
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Projet-Master1_bsp//obj/HAL/src/crt0.o
02000290 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_ucosii.c
00000000 l    df *ABS*	00000000 physics.c
00000000 l    df *ABS*	00000000 s_fmin.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 w_sqrt.c
00000000 l    df *ABS*	00000000 e_sqrt.c
02021660 l     O .rwdata	00000008 one
02021668 l     O .rwdata	00000008 tiny
00000000 l    df *ABS*	00000000 s_lib_ver.c
00000000 l    df *ABS*	00000000 s_matherr.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 impure.c
0201fb78 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
02006e2c l     F .text	000000f0 __sbprintf
0200903c l     F .text	0000020c cvt
02009248 l     F .text	00000140 exponent
0201f802 l     O .rodata	00000010 blanks.4403
0201f812 l     O .rodata	00000010 zeroes.4404
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
02009528 l     F .text	000003b4 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0200b834 l     F .text	000000f4 std
02023350 l     O .bss	00000004 __sfp_lock
02023354 l     O .bss	00000004 __sinit_lock
0200bd30 l     F .text	00000024 __fp_lock
0200bd54 l     F .text	00000024 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0201ff9c l     O .rwdata	00000038 lconv
0201ffd4 l     O .rwdata	00000020 lc_ctype_charset
0201fff4 l     O .rwdata	00000020 lc_message_charset
02023364 l     O .bss	00000004 lc_ctype_cjk_lang
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
0200d084 l     F .text	000003b4 malloc_extend_top
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0201f964 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
02010f30 l     F .text	000000f0 __sbprintf
0201f9ba l     O .rodata	00000010 blanks.4348
0201f9ca l     O .rodata	00000010 zeroes.4349
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_close.c
02013c3c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
02013d48 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
02013d74 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
02013e60 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
02013f40 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
0201402c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_read.c
020141f8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
020216a4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_write.c
02014444 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
020216a8 l     O .rwdata	00000004 lockid
02023388 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
020216ac l     O .rwdata	00000004 lockid
02023390 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
02015e74 l     F .text	00000048 OS_InitMisc
02015ebc l     F .text	0000006c OS_InitRdyList
02016028 l     F .text	000000e4 OS_InitTCBList
02015d94 l     F .text	000000e0 OS_InitEventList
02015f28 l     F .text	00000080 OS_InitTaskIdle
02015fa8 l     F .text	00000080 OS_InitTaskStat
02016298 l     F .text	00000074 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
02017fa8 l     F .text	000000f4 OS_FlagTaskRdy
02017d68 l     F .text	00000160 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mbox.c
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0201cb14 l     F .text	00000034 alt_dev_reg
020205c4 l     O .rwdata	0000106c jtag_uart
02021630 l     O .rwdata	0000002c accelerometer_spi_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0201ce8c l     F .text	000002a8 altera_avalon_jtag_uart_irq
0201d134 l     F .text	00000104 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0201d910 l     F .text	0000007c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_up_avalon_accelerometer_spi.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0201df24 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0201e188 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0201e448 l     F .text	0000003c alt_get_errno
0201e484 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
020233f8 l     O .bss	00000004 __atexit_lock
00000000 l    df *ABS*	00000000 alt_exit.c
020233f4 g     O .bss	00000004 alt_instruction_exception_handler
0200fb3c g     F .text	000000b0 _mprec_log10
020216fa g     O .rwdata	00000002 OSTaskNameSize
0200fcbc g     F .text	00000134 __any_on
02012a18 g     F .text	00000060 _isatty_r
0201f93c g     O .rodata	00000028 __mprec_tinytens
0201413c g     F .text	000000bc alt_main
0202331c g     O .bss	00000004 MailBox9
02006be8 g     F .text	00000118 _puts_r
0202e648 g     O .bss	00000100 alt_irq
02023320 g     O .bss	00000004 MailBox6
02012a78 g     F .text	00000070 _lseek_r
02019290 g     F .text	000000cc OS_MemInit
020036bc g     F .text	00000174 sqrt
02021730 g       *ABS*	00000000 __flash_rwdata_start
0201cab4 g     F .text	00000060 OSTimeSet
02005228 g     F .text	00000088 .hidden __eqdf2
02014ae8 g     F .text	00000610 OSEventPendMulti
0202e748 g       *ABS*	00000000 __alt_heap_start
0201ea90 g     F .text	00000024 OSTaskCreateHook
02023424 g     O .bss	00002000 task1_stk
02006b80 g     F .text	00000068 printf
020216d2 g     O .rwdata	00000002 OSMboxEn
02015150 g     F .text	0000004c OSIntEnter
02012d00 g     F .text	000000d4 _wcrtomb_r
02010bc0 g     F .text	000000a0 __sseek
0200bbd8 g     F .text	000000d8 __sinit
02012b58 g     F .text	00000168 __swbuf_r
020216e2 g     O .rwdata	00000002 OSQEn
0200ccb4 g     F .text	00000084 _setlocale_r
0200b928 g     F .text	000000a4 __sfmoreglue
020147bc g     F .text	000000cc __malloc_unlock
0201eaf8 g     F .text	00000020 OSTaskStatHook
02023398 g     O .bss	00000001 OSLockNesting
02021720 g     O .rwdata	00000002 OSDataSize
02023399 g     O .bss	00000001 OSRunning
0200e170 g     F .text	00000208 memmove
0201eb38 g     F .text	00000020 OSInitHookBegin
02021718 g     O .rwdata	00000002 OSTmrSize
0200bba4 g     F .text	00000034 _cleanup
0202165c g     O .rwdata	00000004 accel_name
0200e378 g     F .text	00000130 _Balloc
0202339c g     O .bss	00000004 OSIdleCtr
020052b0 g     F .text	000000dc .hidden __gtdf2
0201e840 g     F .text	00000024 altera_nios2_gen2_irq_init
0201e910 g       .text	00000000 OSStartTsk
020067b0 g     F .text	00000020 __errno
020165c8 g     F .text	000002d4 OS_TCBInit
02000000 g     F .entry	0000001c __reset
00200000 g       *ABS*	00000000 __alt_mem_mem_Nios_PI
0201db4c g     F .text	000000cc alt_up_accelerometer_spi_read_x_axis
0202171e g     O .rwdata	00000002 OSTmrWheelTblSize
02000020 g       *ABS*	00000000 __flash_exceptions_start
020216be g     O .rwdata	00000002 OSEventSize
020233a0 g     O .bss	00000001 OSPrioHighRdy
020129b0 g     F .text	00000068 _fstat_r
0201eab4 g     F .text	00000024 OSTaskDelHook
02023374 g     O .bss	00000004 errno
02010adc g     F .text	00000030 __seofread
0201e8f0 g       .text	00000000 OSStartHighRdy
0201b55c g     F .text	000001e4 OSTaskCreateExt
02000000 g       *ABS*	00000000 __alt_mem_sdram_controller
020178b0 g     F .text	00000060 OSFlagPendGetFlagsRdy
020216fe g     O .rwdata	00000002 OSTaskStatStkSize
02016a2c g     F .text	00000308 OSFlagAccept
020198c8 g     F .text	000000b8 OSQFlush
0201935c g     F .text	00000140 OSQAccept
02023380 g     O .bss	00000004 alt_argv
0202965c g       *ABS*	00000000 _gp
0201b3b0 g     F .text	000001ac OSTaskCreate
02003418 g     F .text	000000f4 damping
0201aec0 g     F .text	000004f0 OSTaskChangePrio
02023394 g     O .bss	00000004 alt_heapsem
02002820 g     F .text	000000cc task4
0201689c g     F .text	00000190 OSDebugInit
0201b740 g     F .text	00000344 OSTaskDel
02020444 g     O .rwdata	00000180 alt_fd_list
0202b424 g     O .bss	00000370 OSFlagTbl
02015b74 g     F .text	000000b8 OS_EventTaskRemove
0201e0c4 g     F .text	00000090 alt_find_dev
020067d0 g     F .text	00000188 memcpy
020216e8 g     O .rwdata	00000002 OSRdyTblSize
02023324 g     O .bss	00000004 MailBox3
0200bb60 g     F .text	00000044 _cleanup_r
02013ab8 g     F .text	000000dc .hidden __floatsidf
0201e24c g     F .text	0000007c alt_io_redirect
0200538c g     F .text	000000f4 .hidden __ltdf2
0201f414 g       *ABS*	00000000 __DTOR_END__
02006d00 g     F .text	00000038 puts
0201ee30 g     F .text	0000009c alt_exception_cause_generated_bad_addr
02014888 g     F .text	00000120 OSEventNameGet
020216cc g     O .rwdata	00000002 OSFlagMax
020035b8 g     F .text	00000104 __fpclassifyd
0200fa20 g     F .text	0000011c __ratio
0201519c g     F .text	000000f8 OSIntExit
02011020 g     F .text	00000050 __vfiprintf_internal
02021706 g     O .rwdata	00000002 OSTCBSize
020233a1 g     O .bss	00000001 OSPrioCur
0201d390 g     F .text	000002bc altera_avalon_jtag_uart_read
02006b1c g     F .text	00000064 _printf_r
02003fd8 g     F .text	00000064 .hidden __udivsi3
02013e9c g     F .text	000000a4 isatty
020216ec g     O .rwdata	00000002 OSStkWidth
0201f84c g     O .rodata	000000c8 __mprec_tens
020216e0 g     O .rwdata	00000002 OSPtrSize
0200cd38 g     F .text	00000024 __locale_charset
020216c0 g     O .rwdata	00000002 OSEventTblSize
0201e864 g       .text	00000000 OSCtxSw
0201eda0 g     F .text	00000090 alt_icache_flush
02023368 g     O .bss	00000004 __malloc_top_pad
020233a4 g     O .bss	00000004 OSTCBList
02023378 g     O .bss	00000004 alt_fd_list_lock
0202167c g     O .rwdata	00000004 __mb_cur_max
0200cdc0 g     F .text	00000028 _localeconv_r
0200e9c0 g     F .text	00000058 __i2b
0200c524 g     F .text	000005dc __sfvwrite_r
0202b794 g     O .bss	00000c30 OSMemTbl
020233a8 g     O .bss	00000001 OSTickStepState
020109e0 g     F .text	00000060 _sbrk_r
020216e4 g     O .rwdata	00000002 OSQMax
0202c3c4 g     O .bss	00000800 OSTaskStatStk
02018ecc g     F .text	000000f0 OSMemNameGet
02025424 g     O .bss	00002000 task4_stk
020216c4 g     O .rwdata	00000002 OSFlagEn
02012ae8 g     F .text	00000070 _read_r
0202170a g     O .rwdata	00000002 OSTimeTickHookEn
02019d78 g     F .text	00000168 OSQPost
0201809c g     F .text	000000a4 OS_FlagUnlink
0202169c g     O .rwdata	00000004 alt_max_fd
02016160 g     F .text	00000068 OS_MemCopy
020161c8 g     F .text	000000d0 OS_Sched
02012568 g     F .text	0000012c _fclose_r
02018ddc g     F .text	000000f0 OSMemGet
02018af8 g     F .text	00000110 OSMboxQuery
0201bd6c g     F .text	000001b4 OSTaskNameSet
0200b7e0 g     F .text	00000054 fflush
0202336c g     O .bss	00000004 __malloc_max_sbrked_mem
020233ac g     O .bss	00000004 OSCtxSwCtr
0201eb18 g     F .text	00000020 OSTimeTickHook
0201e2c8 g     F .text	00000180 alt_irq_register
020216ce g     O .rwdata	00000002 OSFlagNameSize
02023328 g     O .bss	00000004 AnimationFlagGrp
02006494 g     F .text	00000110 .hidden __extendsfdf2
02015c2c g     F .text	00000100 OS_EventTaskRemoveMulti
02004094 g     F .text	000008ac .hidden __adddf3
02015a24 g     F .text	00000150 OS_EventTaskWaitMulti
0200f5dc g     F .text	00000204 __b2d
020216e6 g     O .rwdata	00000002 OSQSize
02013500 g     F .text	00000538 .hidden __umoddi3
02014068 g     F .text	000000d4 lseek
0201a828 g     F .text	0000020c OSSemPend
02021670 g     O .rwdata	00000004 __fdlib_version
02002da8 g     F .text	00000064 momentum
02021678 g     O .rwdata	00000004 _global_impure_ptr
0200fdf0 g     F .text	00000bf0 _realloc_r
020216d0 g     O .rwdata	00000002 OSLowestPrio
0202e748 g       *ABS*	00000000 __bss_end
0201eb98 g     F .text	00000024 OSTCBInitHook
02021716 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0201e738 g     F .text	00000108 alt_tick
0201888c g     F .text	00000110 OSMboxPost
02012f88 g     F .text	00000578 .hidden __udivdi3
020128c0 g     F .text	00000088 _fputwc_r
020216b8 g     O .rwdata	00000002 OSEventEn
0201f914 g     O .rodata	00000028 __mprec_bigtens
0200e6b8 g     F .text	0000018c __s2b
02021712 g     O .rwdata	00000002 OSTmrCfgNameSize
02013b94 g     F .text	000000a8 .hidden __floatunsidf
0200f158 g     F .text	00000114 __mcmp
0200bd78 g     F .text	00000040 __fp_lock_all
0202332c g     O .bss	00000004 MailBox5
02017ec8 g     F .text	000000e0 OS_FlagInit
0201e69c g     F .text	0000009c alt_alarm_stop
020216f4 g     O .rwdata	00000002 OSTaskIdleStkSize
020233e8 g     O .bss	00000004 alt_irq_active
0201a460 g     F .text	000000b0 OSSemAccept
020190d0 g     F .text	000000d8 OSMemPut
02018c08 g     F .text	000001d4 OSMemCreate
020233b0 g     O .bss	00000004 OSIdleCtrMax
020000fc g     F .exceptions	000000d8 alt_irq_handler
0202041c g     O .rwdata	00000028 alt_dev_null
02021708 g     O .rwdata	00000002 OSTicksPerSec
0201e864 g       .text	00000000 OSIntCtxSw
0201dedc g     F .text	00000048 alt_dcache_flush_all
0200e844 g     F .text	00000090 __hi0bits
02013a38 g     F .text	00000080 .hidden __fixdfsi
020233b4 g     O .bss	00000004 OSTCBFreeList
02021730 g       *ABS*	00000000 __ram_rwdata_end
0201aa34 g     F .text	0000016c OSSemPendAbort
02021694 g     O .rwdata	00000008 alt_dev_list
02014480 g     F .text	000000f8 write
02023330 g     O .bss	00000004 ActivateTask4Grp
0202170c g     O .rwdata	00000002 OSVersionNbr
0201fb48 g       *ABS*	00000000 __ram_rodata_end
02013db0 g     F .text	000000b0 fstat
0200538c g     F .text	000000f4 .hidden __ledf2
020216b4 g     O .rwdata	00000004 OSEndiannessTest
0200ede8 g     F .text	00000178 __pow5mult
02011070 g     F .text	000012c4 ___vfiprintf_internal_r
02023358 g     O .bss	00000004 __nlocale_changed
0200403c g     F .text	00000058 .hidden __umodsi3
020216c6 g     O .rwdata	00000002 OSFlagGrpSize
0202e748 g       *ABS*	00000000 end
0201cd50 g     F .text	0000013c altera_avalon_jtag_uart_init
02016430 g     F .text	000000cc OS_TaskStat
020001d4 g     F .exceptions	00000074 alt_instruction_exception_entry
0201f414 g       *ABS*	00000000 __CTOR_LIST__
04000000 g       *ABS*	00000000 __alt_stack_pointer
0201d98c g     F .text	00000074 alt_avalon_timer_sc_init
0200674c g     F .text	00000064 .hidden __clzsi2
0201d64c g     F .text	000002c4 altera_avalon_jtag_uart_write
0200bcb0 g     F .text	00000020 __sfp_lock_acquire
0200dfb4 g     F .text	000001bc memchr
0201610c g     F .text	00000054 OS_MemClr
02006f6c g     F .text	000020d0 ___vfprintf_internal_r
0201e934 g     F .text	0000015c OSTaskStkInit
02000294 g     F .text	00000368 task1
0201fb48 g     O .rwdata	00000030 whole_list
0200bdf8 g     F .text	00000560 _free_r
0200cd5c g     F .text	00000020 __locale_mb_cur_max
0201577c g     F .text	00000198 OS_EventTaskRdy
0201f1f4 g     F .text	000001ec __call_exitprocs
020233b8 g     O .bss	00000001 OSCPUUsage
0202335c g     O .bss	00000004 __mlocale_changed
02021684 g     O .rwdata	00000004 __malloc_sbrk_base
02000248 g     F .text	0000004c _start
020005fc g     F .text	00001e8c task2
020233ec g     O .bss	00000004 _alt_tick_rate
02019980 g     F .text	0000028c OSQPend
0201c62c g     F .text	00000104 OSTimeDly
02002c50 g     F .text	00000158 borderCollide
0200ef60 g     F .text	000001f8 __lshift
020233f0 g     O .bss	00000004 _alt_nticks
02014234 g     F .text	000000fc read
0201cb80 g     F .text	0000006c alt_sys_init
0201da3c g     F .text	00000044 alt_up_accelerometer_spi_read_address_register
0201f084 g     F .text	00000170 __register_exitproc
020233b9 g     O .bss	00000001 OSTaskCtr
02023334 g     O .bss	00000004 MailBox2
0201c730 g     F .text	00000154 OSTimeDlyHMSM
0200ea18 g     F .text	000003d0 __multiply
0201d238 g     F .text	00000068 altera_avalon_jtag_uart_close
0201fb48 g       *ABS*	00000000 __ram_rwdata_start
0201f414 g       *ABS*	00000000 __ram_rodata_start
020233fc g     O .bss	00000028 __malloc_current_mallinfo
020216ba g     O .rwdata	00000002 OSEventMax
0200f7e0 g     F .text	00000240 __d2b
0201aba0 g     F .text	00000110 OSSemPost
02015320 g     F .text	000000dc OSSchedUnlock
0200350c g     F .text	000000ac fmin
0201cbec g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0201ecc4 g     F .text	000000dc alt_get_fd
020233bc g     O .bss	00000004 OSMemFreeList
0201546c g     F .text	000000b0 OSStatInit
02017ca4 g     F .text	000000c4 OSFlagQuery
0201dc18 g     F .text	000000cc alt_up_accelerometer_spi_read_y_axis
020216f0 g     O .rwdata	00000002 OSTaskCreateExtEn
020123a4 g     F .text	00000060 _close_r
0201ef50 g     F .text	00000134 memcmp
0201575c g     F .text	00000020 OS_Dummy
0201ccac g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0202e748 g       *ABS*	00000000 __alt_stack_base
0201ccfc g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
02009388 g     F .text	000001a0 __swsetup_r
0202cbc4 g     O .bss	000001e0 OSQTbl
02004940 g     F .text	000008e8 .hidden __divdf3
0200b9cc g     F .text	00000194 __sfp
0200fbec g     F .text	000000d0 __copybits
02020014 g     O .rwdata	00000408 __malloc_av_
0200bd10 g     F .text	00000020 __sinit_lock_release
020233c0 g     O .bss	00000004 OSTCBHighRdy
02005480 g     F .text	00000718 .hidden __muldf3
02010a40 g     F .text	0000009c __sread
020233c4 g     O .bss	00000004 OSQFreeList
0201ebbc g     F .text	00000108 alt_find_file
0201df60 g     F .text	000000a4 alt_dev_llist_insert
0201469c g     F .text	00000120 __malloc_lock
02014394 g     F .text	000000b0 sbrk
020149a8 g     F .text	00000140 OSEventNameSet
0200b758 g     F .text	00000088 _fflush_r
02012404 g     F .text	00000164 _calloc_r
020233c8 g     O .bss	00000001 OSRdyGrp
02023318 g       *ABS*	00000000 __bss_start
02006958 g     F .text	000001c4 memset
020028ec g     F .text	000001f0 main
02023384 g     O .bss	00000004 alt_envp
02023338 g     O .bss	00000004 MailBox8
02023370 g     O .bss	00000004 __malloc_max_total_mem
020033ac g     F .text	0000006c moveBall
0201cc4c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
02012cc0 g     F .text	00000040 __swbuf
0201f9f8 g     O .rodata	00000100 OSUnMapTbl
020216ea g     O .rwdata	00000002 OSSemEn
02017910 g     F .text	00000394 OSFlagPost
02010c60 g     F .text	00000054 __sclose
02003e78 g     F .text	00000068 matherr
04000000 g       *ABS*	00000000 __alt_heap_limit
02012694 g     F .text	00000038 fclose
02015914 g     F .text	00000110 OS_EventTaskWait
02027424 g     O .bss	00002000 task2_stk
020065a4 g     F .text	000001a8 .hidden __truncdfsf2
020164fc g     F .text	000000cc OS_TaskStatStkChk
0201ba84 g     F .text	00000150 OSTaskDelReq
020098dc g     F .text	00001b78 _dtoa_r
0200d438 g     F .text	00000b7c _malloc_r
02012f10 g     F .text	00000078 __ascii_wctomb
020216a0 g     O .rwdata	00000004 alt_errno
020153fc g     F .text	00000070 OSStart
02029424 g     O .bss	00002000 task3_stk
0201463c g     F .text	00000060 __env_unlock
0200cb00 g     F .text	000000d8 _fwalk
0201bf20 g     F .text	000001d4 OSTaskResume
020191a8 g     F .text	000000e8 OSMemQuery
020216fc g     O .rwdata	00000002 OSTaskStatEn
020216d6 g     O .rwdata	00000002 OSMemMax
02019ee0 g     F .text	00000170 OSQPostFront
02003ee0 g     F .text	00000084 .hidden __divsi3
020233c9 g     O .bss	00000003 OSRdyTbl
020216b0 g     O .rwdata	00000002 OSDebugEn
0200c358 g     F .text	000001cc _malloc_trim_r
0202333c g     O .bss	00000004 MailBox4
0201f414 g       *ABS*	00000000 __CTOR_END__
02023340 g     O .bss	00000004 MailBox7
020216c8 g     O .rwdata	00000002 OSFlagNodeSize
02021710 g     O .rwdata	00000002 OSTmrCfgMax
02010cb4 g     F .text	00000140 strcmp
0201949c g     F .text	000001ac OSQCreate
0201bbd4 g     F .text	00000198 OSTaskNameGet
0201f414 g       *ABS*	00000000 __flash_rodata_start
0201a050 g     F .text	0000020c OSQPostOpt
0201551c g     F .text	00000220 OSTimeTick
020216f8 g     O .rwdata	00000002 OSTaskMax
0201f414 g       *ABS*	00000000 __DTOR_LIST__
0201a510 g     F .text	000000d8 OSSemCreate
0202171c g     O .rwdata	00000002 OSTmrWheelSize
02005228 g     F .text	00000088 .hidden __nedf2
020216f2 g     O .rwdata	00000002 OSTaskDelEn
0201acb0 g     F .text	00000110 OSSemQuery
02019648 g     F .text	00000280 OSQDel
02019c0c g     F .text	0000016c OSQPendAbort
0201cb48 g     F .text	00000038 alt_irq_init
02014330 g     F .text	00000064 alt_release_fd
0201f699 g     O .rodata	00000100 .hidden __clz_tab
02023360 g     O .bss	00000004 _PathLocale
0201eecc g     F .text	0000003c atexit
02012334 g     F .text	00000070 _write_r
02015294 g     F .text	0000008c OSSchedLock
0200cde8 g     F .text	00000040 setlocale
02016d34 g     F .text	00000108 OSFlagCreate
02021674 g     O .rwdata	00000004 _impure_ptr
0202337c g     O .bss	00000004 alt_argc
0200b454 g     F .text	00000304 __sflush_r
0201e064 g     F .text	00000060 _do_dtors
0200cda0 g     F .text	00000020 __locale_cjk_lang
020216c2 g     O .rwdata	00000002 OSEventMultiEn
02016e3c g     F .text	00000248 OSFlagDel
020233cc g     O .bss	00000004 OSEventFreeList
02000020 g       .exceptions	00000000 alt_irq_entry
02018720 g     F .text	0000016c OSMboxPendAbort
02023318 g     O .bss	00000004 accel_spi
0200f510 g     F .text	000000cc __ulp
0202170e g     O .rwdata	00000002 OSTmrEn
020172f8 g     F .text	000005b8 OSFlagPend
0200bdb8 g     F .text	00000040 __fp_unlock_all
0202168c g     O .rwdata	00000008 alt_fs_list
0201630c g     F .text	00000074 OS_StrCopy
020216d8 g     O .rwdata	00000002 OSMemNameSize
0201eb58 g     F .text	00000020 OSInitHookEnd
02000020 g       *ABS*	00000000 __ram_exceptions_start
0201da00 g     F .text	0000003c alt_up_accelerometer_spi_open_dev
02021704 g     O .rwdata	00000002 OSTCBPrioTblMax
0200ce28 g     F .text	00000030 localeconv
02003830 g     F .text	00000648 __ieee754_sqrt
02021700 g     O .rwdata	00000002 OSTaskStatStkChkEn
020181d8 g     F .text	000000d4 OSMboxCreate
020216d4 g     O .rwdata	00000002 OSMemEn
020216de g     O .rwdata	00000002 OSMutexEn
02021730 g       *ABS*	00000000 _edata
02002ecc g     F .text	000004e0 collide_calc
0202e748 g       *ABS*	00000000 _end
020233d0 g     O .bss	00000001 OSIntNesting
020126cc g     F .text	000001f4 __fputwc
02000248 g       *ABS*	00000000 __ram_exceptions_end
0201d2a0 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0201c884 g     F .text	000001d4 OSTimeDlyResume
020171ac g     F .text	0000014c OSFlagNameSet
020184ec g     F .text	00000234 OSMboxPend
02002adc g     F .text	00000174 whole_collide
0201c0f4 g     F .text	000001c0 OSTaskStkChk
020216da g     O .rwdata	00000002 OSMemSize
02010b0c g     F .text	000000b4 __swrite
02021680 g     O .rwdata	00000004 __malloc_trim_threshold
0200cd7c g     F .text	00000024 __locale_msgcharset
020233d4 g     O .bss	00000004 OSTCBCur
0201ef08 g     F .text	00000048 exit
020216dc g     O .rwdata	00000002 OSMemTblSize
0200cbd8 g     F .text	000000dc _fwalk_reent
02023344 g     O .bss	00000004 MailBox1
0200f26c g     F .text	000002a4 __mdiff
02003f64 g     F .text	00000074 .hidden __modsi3
0201dce4 g     F .text	000000cc alt_up_accelerometer_spi_read_z_axis
02018140 g     F .text	00000098 OSMboxAccept
04000000 g       *ABS*	00000000 __alt_data_end
02000020 g     F .exceptions	00000000 alt_exception
0200bcd0 g     F .text	00000020 __sfp_lock_release
020150f8 g     F .text	00000058 OSInit
0201c498 g     F .text	00000124 OSTaskQuery
0201a3b8 g     F .text	000000a8 OS_QInit
02016380 g     F .text	00000054 OS_StrLen
02018fbc g     F .text	00000114 OSMemNameSet
020216f6 g     O .rwdata	00000002 OSTaskProfileEn
020233d8 g     O .bss	00000004 OSTime
02023348 g     O .bss	00000004 isActiveFlagGrp
0202cda4 g     O .bss	00000800 OSTaskIdleStk
0201f3e0 g     F .text	00000034 _exit
0201899c g     F .text	0000015c OSMboxPostOpt
0201ddb0 g     F .text	0000012c alt_alarm_start
02017084 g     F .text	00000128 OSFlagNameGet
02002e0c g     F .text	000000c0 detect_collide
0201ca58 g     F .text	0000005c OSTimeGet
0201da80 g     F .text	00000068 alt_up_accelerometer_spi_read
0201dae8 g     F .text	00000064 alt_up_accelerometer_spi_write
0200ce58 g     F .text	0000022c __smakebuf_r
02006d38 g     F .text	000000f4 strlen
0201ead8 g     F .text	00000020 OSTaskSwHook
0201e548 g     F .text	00000154 open
0202d5a4 g     O .bss	00000b40 OSEventTbl
020052b0 g     F .text	000000dc .hidden __gedf2
0202e0e4 g     O .bss	00000510 OSTCBTbl
0201adc0 g     F .text	00000100 OSSemSet
02021688 g     O .rwdata	00000004 __wctomb
0202334c g     O .bss	00000004 StartGameGrp
02010df4 g     F .text	0000013c __sprint_r
0201e154 g     F .text	00000034 alt_icache_flush_all
02021724 g     O .rwdata	00000004 alt_priority_mask
0201a5e8 g     F .text	00000240 OSSemDel
020233dc g     O .bss	00000004 OSFlagFreeList
02002488 g     F .text	00000398 task3
020216bc g     O .rwdata	00000002 OSEventNameSize
020182ac g     F .text	00000240 OSMboxDel
02006f1c g     F .text	00000050 __vfprintf_internal
020233e0 g     O .bss	00000001 OSStatRdy
0202e5f4 g     O .bss	00000054 OSTCBPrioTbl
02012eac g     F .text	00000064 _wctomb_r
02014578 g     F .text	000000c4 __env_lock
02021702 g     O .rwdata	00000002 OSTaskSwHookEn
02005b98 g     F .text	000008fc .hidden __subdf3
0200e8d4 g     F .text	000000ec __lo0bits
02021728 g     O .rwdata	00000008 alt_alarm_list
020216ca g     O .rwdata	00000002 OSFlagWidth
0201e004 g     F .text	00000060 _do_ctors
02012dd4 g     F .text	000000d8 wcrtomb
02013c78 g     F .text	000000d0 close
0202338c g     O .bss	00000004 alt_envsem
020233e4 g     O .bss	00000004 OSIdleCtrRun
0201573c g     F .text	00000020 OSVersion
02021714 g     O .rwdata	00000002 OSTmrCfgWheelSize
02013fa8 g     F .text	00000084 alt_load
0201c5bc g     F .text	00000070 OS_TaskStkClr
020216ee g     O .rwdata	00000002 OSTaskCreateEn
02015d2c g     F .text	00000068 OS_EventWaitListInit
02012948 g     F .text	00000068 fputwc
0201eb78 g     F .text	00000020 OSTaskIdleHook
0200bcf0 g     F .text	00000020 __sinit_lock_acquire
0200e524 g     F .text	00000194 __multadd
0201c2b4 g     F .text	000001e4 OSTaskSuspend
0200e4a8 g     F .text	0000007c _Bfree
020163d4 g     F .text	0000005c OS_TaskIdle
0202171a g     O .rwdata	00000002 OSTmrTblSize
0201a25c g     F .text	0000015c OSQQuery



Disassembly of section .entry:

02000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 2000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 200000c:	00bffd16 	blt	zero,r2,2000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2000010:	00408034 	movhi	at,512
    ori r1, r1, %lo(_start)
 2000014:	08409214 	ori	at,at,584
    jmp r1
 2000018:	0800683a 	jmp	at
 200001c:	00000000 	call	0 <OSTCBStkPtr_OFFSET>

Disassembly of section .exceptions:

02000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 2000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 2000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 2000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 200002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 2000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 2000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 2000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 200003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 2000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 2000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 2000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 200004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 2000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 2000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 2000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 200005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 2000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 2000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 2000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 200006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 2000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 2000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 2000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 200007c:	10000326 	beq	r2,zero,200008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 2000080:	20000226 	beq	r4,zero,200008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 2000084:	20000fc0 	call	20000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 2000088:	00000706 	br	20000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 200008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 2000090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 2000094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 2000098:	20001d40 	call	20001d4 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 200009c:	1000021e 	bne	r2,zero,20000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 20000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 20000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 20000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 20000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 20000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 20000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 20000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 20000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 20000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 20000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 20000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 20000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 20000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 20000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 20000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 20000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 20000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 20000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 20000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 20000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 20000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 20000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 20000f8:	ef80083a 	eret

020000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 20000fc:	defff904 	addi	sp,sp,-28
 2000100:	dfc00615 	stw	ra,24(sp)
 2000104:	df000515 	stw	fp,20(sp)
 2000108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 200010c:	20151500 	call	2015150 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2000110:	0005313a 	rdctl	r2,ipending
 2000114:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2000118:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 200011c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 2000120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 2000124:	00800044 	movi	r2,1
 2000128:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 200012c:	e0fffb17 	ldw	r3,-20(fp)
 2000130:	e0bffc17 	ldw	r2,-16(fp)
 2000134:	1884703a 	and	r2,r3,r2
 2000138:	10001526 	beq	r2,zero,2000190 <alt_irq_handler+0x94>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 200013c:	008080f4 	movhi	r2,515
 2000140:	10b99204 	addi	r2,r2,-6584
 2000144:	e0fffd17 	ldw	r3,-12(fp)
 2000148:	180690fa 	slli	r3,r3,3
 200014c:	10c5883a 	add	r2,r2,r3
 2000150:	10c00017 	ldw	r3,0(r2)
 2000154:	008080f4 	movhi	r2,515
 2000158:	10b99204 	addi	r2,r2,-6584
 200015c:	e13ffd17 	ldw	r4,-12(fp)
 2000160:	200890fa 	slli	r4,r4,3
 2000164:	1105883a 	add	r2,r2,r4
 2000168:	10800104 	addi	r2,r2,4
 200016c:	10800017 	ldw	r2,0(r2)
 2000170:	e17ffd17 	ldw	r5,-12(fp)
 2000174:	1009883a 	mov	r4,r2
 2000178:	183ee83a 	callr	r3
#endif
        break;
 200017c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2000180:	0005313a 	rdctl	r2,ipending
 2000184:	e0bfff15 	stw	r2,-4(fp)

  return active;
 2000188:	e0bfff17 	ldw	r2,-4(fp)
 200018c:	00000706 	br	20001ac <alt_irq_handler+0xb0>
      }
      mask <<= 1;
 2000190:	e0bffc17 	ldw	r2,-16(fp)
 2000194:	1085883a 	add	r2,r2,r2
 2000198:	e0bffc15 	stw	r2,-16(fp)
      i++;
 200019c:	e0bffd17 	ldw	r2,-12(fp)
 20001a0:	10800044 	addi	r2,r2,1
 20001a4:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 20001a8:	003fe006 	br	200012c <alt_irq_handler+0x30>

    active = alt_irq_pending ();
 20001ac:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 20001b0:	e0bffb17 	ldw	r2,-20(fp)
 20001b4:	103fda1e 	bne	r2,zero,2000120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 20001b8:	201519c0 	call	201519c <OSIntExit>
}
 20001bc:	0001883a 	nop
 20001c0:	e037883a 	mov	sp,fp
 20001c4:	dfc00117 	ldw	ra,4(sp)
 20001c8:	df000017 	ldw	fp,0(sp)
 20001cc:	dec00204 	addi	sp,sp,8
 20001d0:	f800283a 	ret

020001d4 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 20001d4:	defffb04 	addi	sp,sp,-20
 20001d8:	dfc00415 	stw	ra,16(sp)
 20001dc:	df000315 	stw	fp,12(sp)
 20001e0:	df000304 	addi	fp,sp,12
 20001e4:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 20001e8:	000531fa 	rdctl	r2,exception
 20001ec:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 20001f0:	e0bffd17 	ldw	r2,-12(fp)
 20001f4:	10801f0c 	andi	r2,r2,124
 20001f8:	1004d0ba 	srli	r2,r2,2
 20001fc:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 2000200:	0005333a 	rdctl	r2,badaddr
 2000204:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 2000208:	d0a76617 	ldw	r2,-25192(gp)
 200020c:	10000726 	beq	r2,zero,200022c <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 2000210:	d0a76617 	ldw	r2,-25192(gp)
 2000214:	e0fffd17 	ldw	r3,-12(fp)
 2000218:	e1bffe17 	ldw	r6,-8(fp)
 200021c:	e17fff17 	ldw	r5,-4(fp)
 2000220:	1809883a 	mov	r4,r3
 2000224:	103ee83a 	callr	r2
 2000228:	00000206 	br	2000234 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 200022c:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 2000230:	0005883a 	mov	r2,zero
}
 2000234:	e037883a 	mov	sp,fp
 2000238:	dfc00117 	ldw	ra,4(sp)
 200023c:	df000017 	ldw	fp,0(sp)
 2000240:	dec00204 	addi	sp,sp,8
 2000244:	f800283a 	ret

Disassembly of section .text:

02000248 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 2000248:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 200024c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 2000250:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 2000254:	00bffd16 	blt	zero,r2,200024c <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 2000258:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 200025c:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 2000260:	068080b4 	movhi	gp,514
    ori gp, gp, %lo(_gp)
 2000264:	d6a59714 	ori	gp,gp,38492
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 2000268:	008080b4 	movhi	r2,514
    ori r2, r2, %lo(__bss_start)
 200026c:	108cc614 	ori	r2,r2,13080

    movhi r3, %hi(__bss_end)
 2000270:	00c080b4 	movhi	r3,514
    ori r3, r3, %lo(__bss_end)
 2000274:	18f9d214 	ori	r3,r3,59208

    beq r2, r3, 1f
 2000278:	10c00326 	beq	r2,r3,2000288 <_start+0x40>

0:
    stw zero, (r2)
 200027c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 2000280:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 2000284:	10fffd36 	bltu	r2,r3,200027c <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 2000288:	2013fa80 	call	2013fa8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 200028c:	201413c0 	call	201413c <alt_main>

02000290 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 2000290:	003fff06 	br	2000290 <alt_after_alt_main>

02000294 <task1>:


/*  */

void task1(void* pdata)
{
 2000294:	deffe704 	addi	sp,sp,-100
 2000298:	dfc01815 	stw	ra,96(sp)
 200029c:	df001715 	stw	fp,92(sp)
 20002a0:	df001704 	addi	fp,sp,92
 20002a4:	e13fff15 	stw	r4,-4(fp)

	INT8U err;
	int shoot = 0;
 20002a8:	e03fea15 	stw	zero,-88(fp)
	int x_axis,y_axis;


	//volatile int * MTL_controller = (int *) MTL_IP_BASE;
	int count_old = 0;
 20002ac:	e03ff315 	stw	zero,-52(fp)
	int count = 0;
 20002b0:	e03feb15 	stw	zero,-84(fp)

	int x1_gesture_start, x1_gesture_stop, x2_gesture_start, x2_gesture_stop ;
	int y1_gesture_start, y1_gesture_stop, y2_gesture_start, y2_gesture_stop;

	int gesture_detected = 0;
 20002b4:	e03ff015 	stw	zero,-64(fp)

	while (1)
	{


        DEBUG_PRINT("[Task 1] wait for isActive\n");
 20002b8:	010080b4 	movhi	r4,514
 20002bc:	213d0c04 	addi	r4,r4,-3024
 20002c0:	2006d000 	call	2006d00 <puts>
		OSFlagPend(isActiveFlagGrp, IS_ACTIVE, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0,&err); // wait for a flag and consume it
 20002c4:	d0e73b17 	ldw	r3,-25364(gp)
 20002c8:	e0bffa04 	addi	r2,fp,-24
 20002cc:	d8800015 	stw	r2,0(sp)
 20002d0:	000f883a 	mov	r7,zero
 20002d4:	01802084 	movi	r6,130
 20002d8:	01400044 	movi	r5,1
 20002dc:	1809883a 	mov	r4,r3
 20002e0:	20172f80 	call	20172f8 <OSFlagPend>
		IOWR(MTL_IP_BASE,13,0);
 20002e4:	0007883a 	mov	r3,zero
 20002e8:	008000b4 	movhi	r2,2
 20002ec:	10800d04 	addi	r2,r2,52
 20002f0:	10c00035 	stwio	r3,0(r2)
		/*
		 * Tant que le mouvement n'est pas terminé : On effectue la détection
		 */
		while(!gesture_detected)
 20002f4:	00004c06 	br	2000428 <task1+0x194>
		{
			count_old = count;
 20002f8:	e0bfeb17 	ldw	r2,-84(fp)
 20002fc:	e0bff315 	stw	r2,-52(fp)
			count = IORD(MTL_IP_BASE,10); // récupère le nombre de doigts présent sur l'écran
 2000300:	008000b4 	movhi	r2,2
 2000304:	10800a04 	addi	r2,r2,40
 2000308:	10800037 	ldwio	r2,0(r2)
 200030c:	e0bfeb15 	stw	r2,-84(fp)
			int pos1 = IORD(MTL_IP_BASE,11);
 2000310:	008000b4 	movhi	r2,2
 2000314:	10800b04 	addi	r2,r2,44
 2000318:	10800037 	ldwio	r2,0(r2)
 200031c:	e0bff415 	stw	r2,-48(fp)
			int pos2 = IORD(MTL_IP_BASE,12);
 2000320:	008000b4 	movhi	r2,2
 2000324:	10800c04 	addi	r2,r2,48
 2000328:	10800037 	ldwio	r2,0(r2)
 200032c:	e0bff515 	stw	r2,-44(fp)
			if(count_old == 1 && count == 2) // si on passe de 1 à deux doigts
 2000330:	e0bff317 	ldw	r2,-52(fp)
 2000334:	10800058 	cmpnei	r2,r2,1
 2000338:	1000121e 	bne	r2,zero,2000384 <task1+0xf0>
 200033c:	e0bfeb17 	ldw	r2,-84(fp)
 2000340:	10800098 	cmpnei	r2,r2,2
 2000344:	10000f1e 	bne	r2,zero,2000384 <task1+0xf0>
			{
				DEBUG_PRINT("[Task 1] start gesture\n");
 2000348:	010080b4 	movhi	r4,514
 200034c:	213d1304 	addi	r4,r4,-2996
 2000350:	2006d000 	call	2006d00 <puts>
				x1_gesture_start = pos1 & 0x0003FF;
 2000354:	e0bff417 	ldw	r2,-48(fp)
 2000358:	1080ffcc 	andi	r2,r2,1023
 200035c:	e0bfec15 	stw	r2,-80(fp)
				y1_gesture_start = pos1 >> 10;
 2000360:	e0bff417 	ldw	r2,-48(fp)
 2000364:	1005d2ba 	srai	r2,r2,10
 2000368:	e0bfee15 	stw	r2,-72(fp)

				x2_gesture_start = pos2 & 0x0003FF;
 200036c:	e0bff517 	ldw	r2,-44(fp)
 2000370:	1080ffcc 	andi	r2,r2,1023
 2000374:	e0bff615 	stw	r2,-40(fp)
				y2_gesture_start = pos2 >> 10;
 2000378:	e0bff517 	ldw	r2,-44(fp)
 200037c:	1005d2ba 	srai	r2,r2,10
 2000380:	e0bff715 	stw	r2,-36(fp)
			}
			if(count_old == 2 && count == 1) // si on pass de 2 à 1 doigt
 2000384:	e0bff317 	ldw	r2,-52(fp)
 2000388:	10800098 	cmpnei	r2,r2,2
 200038c:	1000261e 	bne	r2,zero,2000428 <task1+0x194>
 2000390:	e0bfeb17 	ldw	r2,-84(fp)
 2000394:	10800058 	cmpnei	r2,r2,1
 2000398:	1000231e 	bne	r2,zero,2000428 <task1+0x194>
			{
				DEBUG_PRINT("[Task 1] stop gesture\n");
 200039c:	010080b4 	movhi	r4,514
 20003a0:	213d1904 	addi	r4,r4,-2972
 20003a4:	2006d000 	call	2006d00 <puts>

				x1_gesture_stop = pos1 & 0x0003FF;
 20003a8:	e0bff417 	ldw	r2,-48(fp)
 20003ac:	1080ffcc 	andi	r2,r2,1023
 20003b0:	e0bff815 	stw	r2,-32(fp)
				y1_gesture_stop = pos1 >> 10;
 20003b4:	e0bff417 	ldw	r2,-48(fp)
 20003b8:	1005d2ba 	srai	r2,r2,10
 20003bc:	e0bff915 	stw	r2,-28(fp)

				x2_gesture_stop = pos2 & 0x0003FF;
 20003c0:	e0bff517 	ldw	r2,-44(fp)
 20003c4:	1080ffcc 	andi	r2,r2,1023
 20003c8:	e0bfed15 	stw	r2,-76(fp)
				y2_gesture_stop = pos2 >> 10;
 20003cc:	e0bff517 	ldw	r2,-44(fp)
 20003d0:	1005d2ba 	srai	r2,r2,10
 20003d4:	e0bfef15 	stw	r2,-68(fp)
				gesture_detected =     (x1_gesture_start -30 <= x1_gesture_stop && x1_gesture_stop <= x1_gesture_start + 30)
 20003d8:	e0bfec17 	ldw	r2,-80(fp)
 20003dc:	10bff884 	addi	r2,r2,-30
									&& (y1_gesture_start -30 <= y1_gesture_stop && y1_gesture_stop <= y1_gesture_start + 30);
 20003e0:	e0fff817 	ldw	r3,-32(fp)
 20003e4:	18800e16 	blt	r3,r2,2000420 <task1+0x18c>
				x1_gesture_stop = pos1 & 0x0003FF;
				y1_gesture_stop = pos1 >> 10;

				x2_gesture_stop = pos2 & 0x0003FF;
				y2_gesture_stop = pos2 >> 10;
				gesture_detected =     (x1_gesture_start -30 <= x1_gesture_stop && x1_gesture_stop <= x1_gesture_start + 30)
 20003e8:	e0bfec17 	ldw	r2,-80(fp)
 20003ec:	10c00784 	addi	r3,r2,30
 20003f0:	e0bff817 	ldw	r2,-32(fp)
 20003f4:	18800a16 	blt	r3,r2,2000420 <task1+0x18c>
									&& (y1_gesture_start -30 <= y1_gesture_stop && y1_gesture_stop <= y1_gesture_start + 30);
 20003f8:	e0bfee17 	ldw	r2,-72(fp)
 20003fc:	10bff884 	addi	r2,r2,-30
 2000400:	e0fff917 	ldw	r3,-28(fp)
 2000404:	18800616 	blt	r3,r2,2000420 <task1+0x18c>
 2000408:	e0bfee17 	ldw	r2,-72(fp)
 200040c:	10c00784 	addi	r3,r2,30
 2000410:	e0bff917 	ldw	r2,-28(fp)
 2000414:	18800216 	blt	r3,r2,2000420 <task1+0x18c>
 2000418:	00800044 	movi	r2,1
 200041c:	00000106 	br	2000424 <task1+0x190>
 2000420:	0005883a 	mov	r2,zero
				x1_gesture_stop = pos1 & 0x0003FF;
				y1_gesture_stop = pos1 >> 10;

				x2_gesture_stop = pos2 & 0x0003FF;
				y2_gesture_stop = pos2 >> 10;
				gesture_detected =     (x1_gesture_start -30 <= x1_gesture_stop && x1_gesture_stop <= x1_gesture_start + 30)
 2000424:	e0bff015 	stw	r2,-64(fp)
		OSFlagPend(isActiveFlagGrp, IS_ACTIVE, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0,&err); // wait for a flag and consume it
		IOWR(MTL_IP_BASE,13,0);
		/*
		 * Tant que le mouvement n'est pas terminé : On effectue la détection
		 */
		while(!gesture_detected)
 2000428:	e0bff017 	ldw	r2,-64(fp)
 200042c:	103fb226 	beq	r2,zero,20002f8 <task1+0x64>

			//*(MTL_controller + 5) = (y1_gesture_start << 10) + x1_gesture_start;
			//*(MTL_controller + 6) = (y2_gesture_start << 10) + x2_gesture_start;
			//*(MTL_controller + 7) = (y2_gesture_stop << 10) + x2_gesture_stop;
		}
		IOWR(MTL_IP_BASE,13, 1);
 2000430:	00c00044 	movi	r3,1
 2000434:	008000b4 	movhi	r2,2
 2000438:	10800d04 	addi	r2,r2,52
 200043c:	10c00035 	stwio	r3,0(r2)

		count_old = 0;
 2000440:	e03ff315 	stw	zero,-52(fp)
		count = 0;
 2000444:	e03feb15 	stw	zero,-84(fp)
		shoot = 0;
 2000448:	e03fea15 	stw	zero,-88(fp)
  		int x = 446;
 200044c:	00806f84 	movi	r2,446
 2000450:	e0bff115 	stw	r2,-60(fp)
  		int y = 263;
 2000454:	008041c4 	movi	r2,263
 2000458:	e0bff215 	stw	r2,-56(fp)
  		IOWR(MTL_IP_BASE,11,(y<<10)+x);
 200045c:	e0bff217 	ldw	r2,-56(fp)
 2000460:	100692ba 	slli	r3,r2,10
 2000464:	e0bff117 	ldw	r2,-60(fp)
 2000468:	1887883a 	add	r3,r3,r2
 200046c:	008000b4 	movhi	r2,2
 2000470:	10800b04 	addi	r2,r2,44
 2000474:	10c00035 	stwio	r3,0(r2)
  		OSTimeDlyHMSM(0, 0, 0, 500);
 2000478:	01c07d04 	movi	r7,500
 200047c:	000d883a 	mov	r6,zero
 2000480:	000b883a 	mov	r5,zero
 2000484:	0009883a 	mov	r4,zero
 2000488:	201c7300 	call	201c730 <OSTimeDlyHMSM>

  		while(!shoot)
 200048c:	00003506 	br	2000564 <task1+0x2d0>
  		{
  			count_old = count;
 2000490:	e0bfeb17 	ldw	r2,-84(fp)
 2000494:	e0bff315 	stw	r2,-52(fp)
  			count = IORD(MTL_IP_BASE,10);
 2000498:	008000b4 	movhi	r2,2
 200049c:	10800a04 	addi	r2,r2,40
 20004a0:	10800037 	ldwio	r2,0(r2)
 20004a4:	e0bfeb15 	stw	r2,-84(fp)
  			if(count_old == 0 && count == 1)
 20004a8:	e0bff317 	ldw	r2,-52(fp)
 20004ac:	1000061e 	bne	r2,zero,20004c8 <task1+0x234>
 20004b0:	e0bfeb17 	ldw	r2,-84(fp)
 20004b4:	10800058 	cmpnei	r2,r2,1
 20004b8:	1000031e 	bne	r2,zero,20004c8 <task1+0x234>
  				shoot = 1;
 20004bc:	00800044 	movi	r2,1
 20004c0:	e0bfea15 	stw	r2,-88(fp)
 20004c4:	00002206 	br	2000550 <task1+0x2bc>
  			else{
  			   alt_up_accelerometer_spi_read_y_axis(accel_spi,  &y_axis);
 20004c8:	d0a72f17 	ldw	r2,-25412(gp)
 20004cc:	e0fffc04 	addi	r3,fp,-16
 20004d0:	180b883a 	mov	r5,r3
 20004d4:	1009883a 	mov	r4,r2
 20004d8:	201dc180 	call	201dc18 <alt_up_accelerometer_spi_read_y_axis>
  		       alt_up_accelerometer_spi_read_x_axis(accel_spi,  &x_axis);
 20004dc:	d0a72f17 	ldw	r2,-25412(gp)
 20004e0:	e0fffb04 	addi	r3,fp,-20
 20004e4:	180b883a 	mov	r5,r3
 20004e8:	1009883a 	mov	r4,r2
 20004ec:	201db4c0 	call	201db4c <alt_up_accelerometer_spi_read_x_axis>
  		       //printf("Accelerometer : (%d, %d)\n",x_axis, y_axis);
  		       y += -(x_axis) / 10;
 20004f0:	e0bffb17 	ldw	r2,-20(fp)
 20004f4:	0085c83a 	sub	r2,zero,r2
 20004f8:	01400284 	movi	r5,10
 20004fc:	1009883a 	mov	r4,r2
 2000500:	2003ee00 	call	2003ee0 <__divsi3>
 2000504:	1007883a 	mov	r3,r2
 2000508:	e0bff217 	ldw	r2,-56(fp)
 200050c:	10c5883a 	add	r2,r2,r3
 2000510:	e0bff215 	stw	r2,-56(fp)
  		       x += y_axis / 10;
 2000514:	e0bffc17 	ldw	r2,-16(fp)
 2000518:	01400284 	movi	r5,10
 200051c:	1009883a 	mov	r4,r2
 2000520:	2003ee00 	call	2003ee0 <__divsi3>
 2000524:	1007883a 	mov	r3,r2
 2000528:	e0bff117 	ldw	r2,-60(fp)
 200052c:	10c5883a 	add	r2,r2,r3
 2000530:	e0bff115 	stw	r2,-60(fp)
  		       IOWR(MTL_IP_BASE,11,(y<<10)+x);
 2000534:	e0bff217 	ldw	r2,-56(fp)
 2000538:	100692ba 	slli	r3,r2,10
 200053c:	e0bff117 	ldw	r2,-60(fp)
 2000540:	1887883a 	add	r3,r3,r2
 2000544:	008000b4 	movhi	r2,2
 2000548:	10800b04 	addi	r2,r2,44
 200054c:	10c00035 	stwio	r3,0(r2)
  				// play with the accelerometer

  			}
  			OSTimeDlyHMSM(0, 0, 0, 50);
 2000550:	01c00c84 	movi	r7,50
 2000554:	000d883a 	mov	r6,zero
 2000558:	000b883a 	mov	r5,zero
 200055c:	0009883a 	mov	r4,zero
 2000560:	201c7300 	call	201c730 <OSTimeDlyHMSM>
  		int x = 446;
  		int y = 263;
  		IOWR(MTL_IP_BASE,11,(y<<10)+x);
  		OSTimeDlyHMSM(0, 0, 0, 500);

  		while(!shoot)
 2000564:	e0bfea17 	ldw	r2,-88(fp)
 2000568:	103fc926 	beq	r2,zero,2000490 <task1+0x1fc>
  				// play with the accelerometer

  			}
  			OSTimeDlyHMSM(0, 0, 0, 50);
  		}
  		IOWR(MTL_IP_BASE,13, 0);
 200056c:	0007883a 	mov	r3,zero
 2000570:	008000b4 	movhi	r2,2
 2000574:	10800d04 	addi	r2,r2,52
 2000578:	10c00035 	stwio	r3,0(r2)

		int x_dir = (x2_gesture_stop - x1_gesture_start);
 200057c:	e0ffed17 	ldw	r3,-76(fp)
 2000580:	e0bfec17 	ldw	r2,-80(fp)
 2000584:	1885c83a 	sub	r2,r3,r2
 2000588:	e0bffd15 	stw	r2,-12(fp)
		int y_dir = (y2_gesture_stop - y1_gesture_start);
 200058c:	e0ffef17 	ldw	r3,-68(fp)
 2000590:	e0bfee17 	ldw	r2,-72(fp)
 2000594:	1885c83a 	sub	r2,r3,r2
 2000598:	e0bffe15 	stw	r2,-8(fp)
		DEBUG_PRINT("[Task 1] Send value : (%d, %d)\n", x_dir, y_dir);
 200059c:	e0bffd17 	ldw	r2,-12(fp)
 20005a0:	e0fffe17 	ldw	r3,-8(fp)
 20005a4:	180d883a 	mov	r6,r3
 20005a8:	100b883a 	mov	r5,r2
 20005ac:	010080b4 	movhi	r4,514
 20005b0:	213d1f04 	addi	r4,r4,-2948
 20005b4:	2006b800 	call	2006b80 <printf>
		OSMboxPost(MailBox1, &x_dir);
 20005b8:	d0a73a17 	ldw	r2,-25368(gp)
 20005bc:	e0fffd04 	addi	r3,fp,-12
 20005c0:	180b883a 	mov	r5,r3
 20005c4:	1009883a 	mov	r4,r2
 20005c8:	201888c0 	call	201888c <OSMboxPost>
		OSMboxPost(MailBox2, &y_dir);
 20005cc:	d0a73617 	ldw	r2,-25384(gp)
 20005d0:	e0fffe04 	addi	r3,fp,-8
 20005d4:	180b883a 	mov	r5,r3
 20005d8:	1009883a 	mov	r4,r2
 20005dc:	201888c0 	call	201888c <OSMboxPost>
		gesture_detected = 0;
 20005e0:	e03ff015 	stw	zero,-64(fp)
		OSTimeDlyHMSM(0, 0, 0, 500);
 20005e4:	01c07d04 	movi	r7,500
 20005e8:	000d883a 	mov	r6,zero
 20005ec:	000b883a 	mov	r5,zero
 20005f0:	0009883a 	mov	r4,zero
 20005f4:	201c7300 	call	201c730 <OSTimeDlyHMSM>
	}
 20005f8:	003f2f06 	br	20002b8 <task1+0x24>

020005fc <task2>:
}

void task2(void* pdata)
{
 20005fc:	deff3c04 	addi	sp,sp,-784
 2000600:	dfc0c315 	stw	ra,780(sp)
 2000604:	df00c215 	stw	fp,776(sp)
 2000608:	dd40c115 	stw	r21,772(sp)
 200060c:	dd00c015 	stw	r20,768(sp)
 2000610:	dcc0bf15 	stw	r19,764(sp)
 2000614:	dc80be15 	stw	r18,760(sp)
 2000618:	dc40bd15 	stw	r17,756(sp)
 200061c:	dc00bc15 	stw	r16,752(sp)
 2000620:	df00c204 	addi	fp,sp,776
 2000624:	e13ff915 	stw	r4,-28(fp)

  INT8U err;
  INT8U opt_task2;
  volatile int * display = (int *) MTL_IP_BASE;
 2000628:	008000b4 	movhi	r2,2
 200062c:	e0bf4415 	stw	r2,-752(fp)

  float ball[10][2] =  {{266.0, 263.0}, // white
 2000630:	008080b4 	movhi	r2,514
 2000634:	10bd4504 	addi	r2,r2,-2796
 2000638:	e0ff4d04 	addi	r3,fp,-716
 200063c:	1009883a 	mov	r4,r2
 2000640:	00801404 	movi	r2,80
 2000644:	100d883a 	mov	r6,r2
 2000648:	200b883a 	mov	r5,r4
 200064c:	1809883a 	mov	r4,r3
 2000650:	20067d00 	call	20067d0 <memcpy>
		  	  	  	  	{649.0, 222.0},
		  	  	  	  	{649.0, 249.0},
		  	  	  	  	{649.0, 277.0},
		  	  	  	  	{649.0, 304.0}};

  IOWR(display,1,((int)  (ball[0][1]) << 10) + (int) (ball[0][0]));
 2000654:	e0bf4417 	ldw	r2,-752(fp)
 2000658:	10800104 	addi	r2,r2,4
 200065c:	e0ff4e17 	ldw	r3,-712(fp)
 2000660:	1807fe72 	custom	249,r3,r3,zero
 2000664:	180892ba 	slli	r4,r3,10
 2000668:	e0ff4d17 	ldw	r3,-716(fp)
 200066c:	1807fe72 	custom	249,r3,r3,zero
 2000670:	20c7883a 	add	r3,r4,r3
 2000674:	10c00035 	stwio	r3,0(r2)
  IOWR(display,2,((int)  (ball[1][1]) << 10) + (int) (ball[1][0]));
 2000678:	e0bf4417 	ldw	r2,-752(fp)
 200067c:	10800204 	addi	r2,r2,8
 2000680:	e0ff5017 	ldw	r3,-704(fp)
 2000684:	1807fe72 	custom	249,r3,r3,zero
 2000688:	180892ba 	slli	r4,r3,10
 200068c:	e0ff4f17 	ldw	r3,-708(fp)
 2000690:	1807fe72 	custom	249,r3,r3,zero
 2000694:	20c7883a 	add	r3,r4,r3
 2000698:	10c00035 	stwio	r3,0(r2)
  IOWR(display,3,((int)  (ball[2][1]) << 10) + (int) (ball[2][0]));
 200069c:	e0bf4417 	ldw	r2,-752(fp)
 20006a0:	10800304 	addi	r2,r2,12
 20006a4:	e0ff5217 	ldw	r3,-696(fp)
 20006a8:	1807fe72 	custom	249,r3,r3,zero
 20006ac:	180892ba 	slli	r4,r3,10
 20006b0:	e0ff5117 	ldw	r3,-700(fp)
 20006b4:	1807fe72 	custom	249,r3,r3,zero
 20006b8:	20c7883a 	add	r3,r4,r3
 20006bc:	10c00035 	stwio	r3,0(r2)
  IOWR(display,4,((int)  (ball[3][1]) << 10) + (int) (ball[3][0]));
 20006c0:	e0bf4417 	ldw	r2,-752(fp)
 20006c4:	10800404 	addi	r2,r2,16
 20006c8:	e0ff5417 	ldw	r3,-688(fp)
 20006cc:	1807fe72 	custom	249,r3,r3,zero
 20006d0:	180892ba 	slli	r4,r3,10
 20006d4:	e0ff5317 	ldw	r3,-692(fp)
 20006d8:	1807fe72 	custom	249,r3,r3,zero
 20006dc:	20c7883a 	add	r3,r4,r3
 20006e0:	10c00035 	stwio	r3,0(r2)
  IOWR(display,5,((int)  (ball[4][1]) << 10) + (int) (ball[4][0]));
 20006e4:	e0bf4417 	ldw	r2,-752(fp)
 20006e8:	10800504 	addi	r2,r2,20
 20006ec:	e0ff5617 	ldw	r3,-680(fp)
 20006f0:	1807fe72 	custom	249,r3,r3,zero
 20006f4:	180892ba 	slli	r4,r3,10
 20006f8:	e0ff5517 	ldw	r3,-684(fp)
 20006fc:	1807fe72 	custom	249,r3,r3,zero
 2000700:	20c7883a 	add	r3,r4,r3
 2000704:	10c00035 	stwio	r3,0(r2)
  IOWR(display,6,((int)  (ball[5][1]) << 10) + (int) (ball[5][0]));
 2000708:	e0bf4417 	ldw	r2,-752(fp)
 200070c:	10800604 	addi	r2,r2,24
 2000710:	e0ff5817 	ldw	r3,-672(fp)
 2000714:	1807fe72 	custom	249,r3,r3,zero
 2000718:	180892ba 	slli	r4,r3,10
 200071c:	e0ff5717 	ldw	r3,-676(fp)
 2000720:	1807fe72 	custom	249,r3,r3,zero
 2000724:	20c7883a 	add	r3,r4,r3
 2000728:	10c00035 	stwio	r3,0(r2)
  IOWR(display,7,((int)  (ball[6][1]) << 10) + (int) (ball[6][0]));
 200072c:	e0bf4417 	ldw	r2,-752(fp)
 2000730:	10800704 	addi	r2,r2,28
 2000734:	e0ff5a17 	ldw	r3,-664(fp)
 2000738:	1807fe72 	custom	249,r3,r3,zero
 200073c:	180892ba 	slli	r4,r3,10
 2000740:	e0ff5917 	ldw	r3,-668(fp)
 2000744:	1807fe72 	custom	249,r3,r3,zero
 2000748:	20c7883a 	add	r3,r4,r3
 200074c:	10c00035 	stwio	r3,0(r2)
  IOWR(display,8,((int)  (ball[7][1]) << 10) + (int) (ball[7][0]));
 2000750:	e0bf4417 	ldw	r2,-752(fp)
 2000754:	10800804 	addi	r2,r2,32
 2000758:	e0ff5c17 	ldw	r3,-656(fp)
 200075c:	1807fe72 	custom	249,r3,r3,zero
 2000760:	180892ba 	slli	r4,r3,10
 2000764:	e0ff5b17 	ldw	r3,-660(fp)
 2000768:	1807fe72 	custom	249,r3,r3,zero
 200076c:	20c7883a 	add	r3,r4,r3
 2000770:	10c00035 	stwio	r3,0(r2)
  IOWR(display,9,((int)  (ball[8][1]) << 10) + (int) (ball[8][0]));
 2000774:	e0bf4417 	ldw	r2,-752(fp)
 2000778:	10800904 	addi	r2,r2,36
 200077c:	e0ff5e17 	ldw	r3,-648(fp)
 2000780:	1807fe72 	custom	249,r3,r3,zero
 2000784:	180892ba 	slli	r4,r3,10
 2000788:	e0ff5d17 	ldw	r3,-652(fp)
 200078c:	1807fe72 	custom	249,r3,r3,zero
 2000790:	20c7883a 	add	r3,r4,r3
 2000794:	10c00035 	stwio	r3,0(r2)
  IOWR(display,10,((int) (ball[9][1]) << 10) + (int) (ball[9][0]));
 2000798:	e0bf4417 	ldw	r2,-752(fp)
 200079c:	10800a04 	addi	r2,r2,40
 20007a0:	e0ff6017 	ldw	r3,-640(fp)
 20007a4:	1807fe72 	custom	249,r3,r3,zero
 20007a8:	180892ba 	slli	r4,r3,10
 20007ac:	e0ff5f17 	ldw	r3,-644(fp)
 20007b0:	1807fe72 	custom	249,r3,r3,zero
 20007b4:	20c7883a 	add	r3,r4,r3
 20007b8:	10c00035 	stwio	r3,0(r2)

  int collision[45][2]={{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
 20007bc:	e0bf6104 	addi	r2,fp,-636
 20007c0:	00c05a04 	movi	r3,360
 20007c4:	180d883a 	mov	r6,r3
 20007c8:	000b883a 	mov	r5,zero
 20007cc:	1009883a 	mov	r4,r2
 20007d0:	20069580 	call	2006958 <memset>
  	  	  	  	        {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},
  	  	  	         	{0,0},{0,0},{0,0},{0,0},{0,0}};

  while (1)
  {
   opt_task2= OS_FLAG_SET;
 20007d4:	00800044 	movi	r2,1
 20007d8:	e0bf4505 	stb	r2,-748(fp)
   OSFlagPost(AnimationFlagGrp,ANIMATION,opt_task2,&err);
 20007dc:	d0a73317 	ldw	r2,-25396(gp)
 20007e0:	e0ff4503 	ldbu	r3,-748(fp)
 20007e4:	e13f4c04 	addi	r4,fp,-720
 20007e8:	200f883a 	mov	r7,r4
 20007ec:	180d883a 	mov	r6,r3
 20007f0:	01400044 	movi	r5,1
 20007f4:	1009883a 	mov	r4,r2
 20007f8:	20179100 	call	2017910 <OSFlagPost>
   int *vector_x = OSMboxPend(MailBox4,0,&err);
 20007fc:	d0a73817 	ldw	r2,-25376(gp)
 2000800:	e0ff4c04 	addi	r3,fp,-720
 2000804:	180d883a 	mov	r6,r3
 2000808:	000b883a 	mov	r5,zero
 200080c:	1009883a 	mov	r4,r2
 2000810:	20184ec0 	call	20184ec <OSMboxPend>
 2000814:	e0bf4615 	stw	r2,-744(fp)
   int *vector_y = OSMboxPend(MailBox5,0,&err);
 2000818:	d0a73417 	ldw	r2,-25392(gp)
 200081c:	e0ff4c04 	addi	r3,fp,-720
 2000820:	180d883a 	mov	r6,r3
 2000824:	000b883a 	mov	r5,zero
 2000828:	1009883a 	mov	r4,r2
 200082c:	20184ec0 	call	20184ec <OSMboxPend>
 2000830:	e0bf4715 	stw	r2,-740(fp)

   //int score = OSMboxPend(MailBox8,0,&err);
   int *nbr_ball = OSMboxPend(MailBox9,0,&err);
 2000834:	d0a73017 	ldw	r2,-25408(gp)
 2000838:	e0ff4c04 	addi	r3,fp,-720
 200083c:	180d883a 	mov	r6,r3
 2000840:	000b883a 	mov	r5,zero
 2000844:	1009883a 	mov	r4,r2
 2000848:	20184ec0 	call	20184ec <OSMboxPend>
 200084c:	e0bf4815 	stw	r2,-736(fp)


   float x = (float) *vector_x;
 2000850:	e0bf4617 	ldw	r2,-744(fp)
 2000854:	10800017 	ldw	r2,0(r2)
 2000858:	1005feb2 	custom	250,r2,r2,zero
 200085c:	e0bf4915 	stw	r2,-732(fp)
   float y = (float) *vector_y;
 2000860:	e0bf4717 	ldw	r2,-740(fp)
 2000864:	10800017 	ldw	r2,0(r2)
 2000868:	1005feb2 	custom	250,r2,r2,zero
 200086c:	e0bf4a15 	stw	r2,-728(fp)

   float length = sqrt(x*x + y*y);
 2000870:	e0ff4917 	ldw	r3,-732(fp)
 2000874:	e0bf4917 	ldw	r2,-732(fp)
 2000878:	1887ff32 	custom	252,r3,r3,r2
 200087c:	e13f4a17 	ldw	r4,-728(fp)
 2000880:	e0bf4a17 	ldw	r2,-728(fp)
 2000884:	2085ff32 	custom	252,r2,r4,r2
 2000888:	1885ff72 	custom	253,r2,r3,r2
 200088c:	1009883a 	mov	r4,r2
 2000890:	20064940 	call	2006494 <__extendsfdf2>
 2000894:	100b883a 	mov	r5,r2
 2000898:	180d883a 	mov	r6,r3
 200089c:	2809883a 	mov	r4,r5
 20008a0:	300b883a 	mov	r5,r6
 20008a4:	20036bc0 	call	20036bc <sqrt>
 20008a8:	100b883a 	mov	r5,r2
 20008ac:	180d883a 	mov	r6,r3
 20008b0:	2809883a 	mov	r4,r5
 20008b4:	300b883a 	mov	r5,r6
 20008b8:	20065a40 	call	20065a4 <__truncdfsf2>
 20008bc:	1007883a 	mov	r3,r2
 20008c0:	e0ff4b15 	stw	r3,-724(fp)
   float direction [] = {x/length, y/length};
 20008c4:	e0ff4917 	ldw	r3,-732(fp)
 20008c8:	e0bf4b17 	ldw	r2,-724(fp)
 20008cc:	1885fff2 	custom	255,r2,r3,r2
 20008d0:	e0bfbb15 	stw	r2,-276(fp)
 20008d4:	e0ff4a17 	ldw	r3,-728(fp)
 20008d8:	e0bf4b17 	ldw	r2,-724(fp)
 20008dc:	1885fff2 	custom	255,r2,r3,r2
 20008e0:	e0bfbc15 	stw	r2,-272(fp)
   float speed = fmin(length / 2.0, 400.0);
 20008e4:	e13f4b17 	ldw	r4,-724(fp)
 20008e8:	20064940 	call	2006494 <__extendsfdf2>
 20008ec:	1011883a 	mov	r8,r2
 20008f0:	1813883a 	mov	r9,r3
 20008f4:	000d883a 	mov	r6,zero
 20008f8:	01d00034 	movhi	r7,16384
 20008fc:	4009883a 	mov	r4,r8
 2000900:	480b883a 	mov	r5,r9
 2000904:	20049400 	call	2004940 <__divdf3>
 2000908:	1009883a 	mov	r4,r2
 200090c:	180b883a 	mov	r5,r3
 2000910:	2005883a 	mov	r2,r4
 2000914:	2807883a 	mov	r3,r5
 2000918:	000d883a 	mov	r6,zero
 200091c:	01d01e74 	movhi	r7,16505
 2000920:	1009883a 	mov	r4,r2
 2000924:	180b883a 	mov	r5,r3
 2000928:	200350c0 	call	200350c <fmin>
 200092c:	100b883a 	mov	r5,r2
 2000930:	180d883a 	mov	r6,r3
 2000934:	2809883a 	mov	r4,r5
 2000938:	300b883a 	mov	r5,r6
 200093c:	20065a40 	call	20065a4 <__truncdfsf2>
 2000940:	1007883a 	mov	r3,r2
 2000944:	e0ff4315 	stw	r3,-756(fp)

   float velocity [10][2] = {{direction[0] * speed/80.0, direction[1] * speed/80.0},
 2000948:	e0bfe504 	addi	r2,fp,-108
 200094c:	00c01404 	movi	r3,80
 2000950:	180d883a 	mov	r6,r3
 2000954:	000b883a 	mov	r5,zero
 2000958:	1009883a 	mov	r4,r2
 200095c:	20069580 	call	2006958 <memset>
 2000960:	e0ffbb17 	ldw	r3,-276(fp)
 2000964:	e0bf4317 	ldw	r2,-756(fp)
 2000968:	1887ff32 	custom	252,r3,r3,r2
 200096c:	0090a834 	movhi	r2,17056
 2000970:	1885fff2 	custom	255,r2,r3,r2
 2000974:	e0bfe515 	stw	r2,-108(fp)
 2000978:	e0ffbc17 	ldw	r3,-272(fp)
 200097c:	e0bf4317 	ldw	r2,-756(fp)
 2000980:	1887ff32 	custom	252,r3,r3,r2
 2000984:	0090a834 	movhi	r2,17056
 2000988:	1885fff2 	custom	255,r2,r3,r2
 200098c:	e0bfe615 	stw	r2,-104(fp)
		   	   	   	   	   	 {0.0, 0.0},
		   	   	   	   	   	 {0.0, 0.0},
		   	   	   	   	   	 {0.0, 0.0},
		   	   	   	   	   	 {0.0, 0.0}};

   DEBUG_PRINT("[Task 2] Launch animation : (%d, %d) - initial speed : %f - initial velocity : (%f, %f)\n",*vector_x, *vector_y, speed, velocity[0][0], velocity[0][1]);
 2000990:	e0bf4617 	ldw	r2,-744(fp)
 2000994:	15000017 	ldw	r20,0(r2)
 2000998:	e0bf4717 	ldw	r2,-740(fp)
 200099c:	15400017 	ldw	r21,0(r2)
 20009a0:	e13f4317 	ldw	r4,-756(fp)
 20009a4:	20064940 	call	2006494 <__extendsfdf2>
 20009a8:	1025883a 	mov	r18,r2
 20009ac:	1827883a 	mov	r19,r3
 20009b0:	e0bfe517 	ldw	r2,-108(fp)
 20009b4:	1009883a 	mov	r4,r2
 20009b8:	20064940 	call	2006494 <__extendsfdf2>
 20009bc:	1021883a 	mov	r16,r2
 20009c0:	1823883a 	mov	r17,r3
 20009c4:	e0bfe617 	ldw	r2,-104(fp)
 20009c8:	1009883a 	mov	r4,r2
 20009cc:	20064940 	call	2006494 <__extendsfdf2>
 20009d0:	1009883a 	mov	r4,r2
 20009d4:	180b883a 	mov	r5,r3
 20009d8:	d9000315 	stw	r4,12(sp)
 20009dc:	d9400415 	stw	r5,16(sp)
 20009e0:	dc000115 	stw	r16,4(sp)
 20009e4:	dc400215 	stw	r17,8(sp)
 20009e8:	dcc00015 	stw	r19,0(sp)
 20009ec:	900f883a 	mov	r7,r18
 20009f0:	a80d883a 	mov	r6,r21
 20009f4:	a00b883a 	mov	r5,r20
 20009f8:	010080b4 	movhi	r4,514
 20009fc:	213d2704 	addi	r4,r4,-2916
 2000a00:	2006b800 	call	2006b80 <printf>

   int border_collision [10][4] = {{0, 0, 0, 0},{0, 0, 0, 0},{0,0,0,0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}};
 2000a04:	e0bfbd04 	addi	r2,fp,-268
 2000a08:	00c02804 	movi	r3,160
 2000a0c:	180d883a 	mov	r6,r3
 2000a10:	000b883a 	mov	r5,zero
 2000a14:	1009883a 	mov	r4,r2
 2000a18:	20069580 	call	2006958 <memset>

   while(speed >= 0.1)
 2000a1c:	00067306 	br	20023ec <task2+0x1df0>
   {
	   //Border Collide

	   borderCollide(ball[0], border_collision[0], velocity[0]);
 2000a20:	e13fe504 	addi	r4,fp,-108
 2000a24:	e0ffbd04 	addi	r3,fp,-268
 2000a28:	e0bf4d04 	addi	r2,fp,-716
 2000a2c:	200d883a 	mov	r6,r4
 2000a30:	180b883a 	mov	r5,r3
 2000a34:	1009883a 	mov	r4,r2
 2000a38:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[1], border_collision[1], velocity[1]);
 2000a3c:	e0bfe504 	addi	r2,fp,-108
 2000a40:	11000204 	addi	r4,r2,8
 2000a44:	e0bfbd04 	addi	r2,fp,-268
 2000a48:	10c00404 	addi	r3,r2,16
 2000a4c:	e0bf4d04 	addi	r2,fp,-716
 2000a50:	10800204 	addi	r2,r2,8
 2000a54:	200d883a 	mov	r6,r4
 2000a58:	180b883a 	mov	r5,r3
 2000a5c:	1009883a 	mov	r4,r2
 2000a60:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[2], border_collision[2], velocity[2]);
 2000a64:	e0bfe504 	addi	r2,fp,-108
 2000a68:	11000404 	addi	r4,r2,16
 2000a6c:	e0bfbd04 	addi	r2,fp,-268
 2000a70:	10c00804 	addi	r3,r2,32
 2000a74:	e0bf4d04 	addi	r2,fp,-716
 2000a78:	10800404 	addi	r2,r2,16
 2000a7c:	200d883a 	mov	r6,r4
 2000a80:	180b883a 	mov	r5,r3
 2000a84:	1009883a 	mov	r4,r2
 2000a88:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[3], border_collision[3], velocity[3]);
 2000a8c:	e0bfe504 	addi	r2,fp,-108
 2000a90:	11000604 	addi	r4,r2,24
 2000a94:	e0bfbd04 	addi	r2,fp,-268
 2000a98:	10c00c04 	addi	r3,r2,48
 2000a9c:	e0bf4d04 	addi	r2,fp,-716
 2000aa0:	10800604 	addi	r2,r2,24
 2000aa4:	200d883a 	mov	r6,r4
 2000aa8:	180b883a 	mov	r5,r3
 2000aac:	1009883a 	mov	r4,r2
 2000ab0:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[4], border_collision[4], velocity[4]);
 2000ab4:	e0bfe504 	addi	r2,fp,-108
 2000ab8:	11000804 	addi	r4,r2,32
 2000abc:	e0bfbd04 	addi	r2,fp,-268
 2000ac0:	10c01004 	addi	r3,r2,64
 2000ac4:	e0bf4d04 	addi	r2,fp,-716
 2000ac8:	10800804 	addi	r2,r2,32
 2000acc:	200d883a 	mov	r6,r4
 2000ad0:	180b883a 	mov	r5,r3
 2000ad4:	1009883a 	mov	r4,r2
 2000ad8:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[5], border_collision[5], velocity[5]);
 2000adc:	e0bfe504 	addi	r2,fp,-108
 2000ae0:	11000a04 	addi	r4,r2,40
 2000ae4:	e0bfbd04 	addi	r2,fp,-268
 2000ae8:	10c01404 	addi	r3,r2,80
 2000aec:	e0bf4d04 	addi	r2,fp,-716
 2000af0:	10800a04 	addi	r2,r2,40
 2000af4:	200d883a 	mov	r6,r4
 2000af8:	180b883a 	mov	r5,r3
 2000afc:	1009883a 	mov	r4,r2
 2000b00:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[6], border_collision[6], velocity[6]);
 2000b04:	e0bfe504 	addi	r2,fp,-108
 2000b08:	11000c04 	addi	r4,r2,48
 2000b0c:	e0bfbd04 	addi	r2,fp,-268
 2000b10:	10c01804 	addi	r3,r2,96
 2000b14:	e0bf4d04 	addi	r2,fp,-716
 2000b18:	10800c04 	addi	r2,r2,48
 2000b1c:	200d883a 	mov	r6,r4
 2000b20:	180b883a 	mov	r5,r3
 2000b24:	1009883a 	mov	r4,r2
 2000b28:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[7], border_collision[7], velocity[7]);
 2000b2c:	e0bfe504 	addi	r2,fp,-108
 2000b30:	11000e04 	addi	r4,r2,56
 2000b34:	e0bfbd04 	addi	r2,fp,-268
 2000b38:	10c01c04 	addi	r3,r2,112
 2000b3c:	e0bf4d04 	addi	r2,fp,-716
 2000b40:	10800e04 	addi	r2,r2,56
 2000b44:	200d883a 	mov	r6,r4
 2000b48:	180b883a 	mov	r5,r3
 2000b4c:	1009883a 	mov	r4,r2
 2000b50:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[8], border_collision[8], velocity[8]);
 2000b54:	e0bfe504 	addi	r2,fp,-108
 2000b58:	11001004 	addi	r4,r2,64
 2000b5c:	e0bfbd04 	addi	r2,fp,-268
 2000b60:	10c02004 	addi	r3,r2,128
 2000b64:	e0bf4d04 	addi	r2,fp,-716
 2000b68:	10801004 	addi	r2,r2,64
 2000b6c:	200d883a 	mov	r6,r4
 2000b70:	180b883a 	mov	r5,r3
 2000b74:	1009883a 	mov	r4,r2
 2000b78:	2002c500 	call	2002c50 <borderCollide>
       borderCollide(ball[9], border_collision[9], velocity[9]);
 2000b7c:	e0bfe504 	addi	r2,fp,-108
 2000b80:	11001204 	addi	r4,r2,72
 2000b84:	e0bfbd04 	addi	r2,fp,-268
 2000b88:	10c02404 	addi	r3,r2,144
 2000b8c:	e0bf4d04 	addi	r2,fp,-716
 2000b90:	10801204 	addi	r2,r2,72
 2000b94:	200d883a 	mov	r6,r4
 2000b98:	180b883a 	mov	r5,r3
 2000b9c:	1009883a 	mov	r4,r2
 2000ba0:	2002c500 	call	2002c50 <borderCollide>

       //Move the ball

       moveBall(ball[0], velocity[0]);
 2000ba4:	e0ffe504 	addi	r3,fp,-108
 2000ba8:	e0bf4d04 	addi	r2,fp,-716
 2000bac:	180b883a 	mov	r5,r3
 2000bb0:	1009883a 	mov	r4,r2
 2000bb4:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[1], velocity[1]);
 2000bb8:	e0bfe504 	addi	r2,fp,-108
 2000bbc:	10c00204 	addi	r3,r2,8
 2000bc0:	e0bf4d04 	addi	r2,fp,-716
 2000bc4:	10800204 	addi	r2,r2,8
 2000bc8:	180b883a 	mov	r5,r3
 2000bcc:	1009883a 	mov	r4,r2
 2000bd0:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[2], velocity[2]);
 2000bd4:	e0bfe504 	addi	r2,fp,-108
 2000bd8:	10c00404 	addi	r3,r2,16
 2000bdc:	e0bf4d04 	addi	r2,fp,-716
 2000be0:	10800404 	addi	r2,r2,16
 2000be4:	180b883a 	mov	r5,r3
 2000be8:	1009883a 	mov	r4,r2
 2000bec:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[3], velocity[3]);
 2000bf0:	e0bfe504 	addi	r2,fp,-108
 2000bf4:	10c00604 	addi	r3,r2,24
 2000bf8:	e0bf4d04 	addi	r2,fp,-716
 2000bfc:	10800604 	addi	r2,r2,24
 2000c00:	180b883a 	mov	r5,r3
 2000c04:	1009883a 	mov	r4,r2
 2000c08:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[4], velocity[4]);
 2000c0c:	e0bfe504 	addi	r2,fp,-108
 2000c10:	10c00804 	addi	r3,r2,32
 2000c14:	e0bf4d04 	addi	r2,fp,-716
 2000c18:	10800804 	addi	r2,r2,32
 2000c1c:	180b883a 	mov	r5,r3
 2000c20:	1009883a 	mov	r4,r2
 2000c24:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[5], velocity[5]);
 2000c28:	e0bfe504 	addi	r2,fp,-108
 2000c2c:	10c00a04 	addi	r3,r2,40
 2000c30:	e0bf4d04 	addi	r2,fp,-716
 2000c34:	10800a04 	addi	r2,r2,40
 2000c38:	180b883a 	mov	r5,r3
 2000c3c:	1009883a 	mov	r4,r2
 2000c40:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[6], velocity[6]);
 2000c44:	e0bfe504 	addi	r2,fp,-108
 2000c48:	10c00c04 	addi	r3,r2,48
 2000c4c:	e0bf4d04 	addi	r2,fp,-716
 2000c50:	10800c04 	addi	r2,r2,48
 2000c54:	180b883a 	mov	r5,r3
 2000c58:	1009883a 	mov	r4,r2
 2000c5c:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[7], velocity[7]);
 2000c60:	e0bfe504 	addi	r2,fp,-108
 2000c64:	10c00e04 	addi	r3,r2,56
 2000c68:	e0bf4d04 	addi	r2,fp,-716
 2000c6c:	10800e04 	addi	r2,r2,56
 2000c70:	180b883a 	mov	r5,r3
 2000c74:	1009883a 	mov	r4,r2
 2000c78:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[8], velocity[8]);
 2000c7c:	e0bfe504 	addi	r2,fp,-108
 2000c80:	10c01004 	addi	r3,r2,64
 2000c84:	e0bf4d04 	addi	r2,fp,-716
 2000c88:	10801004 	addi	r2,r2,64
 2000c8c:	180b883a 	mov	r5,r3
 2000c90:	1009883a 	mov	r4,r2
 2000c94:	20033ac0 	call	20033ac <moveBall>
       moveBall(ball[9], velocity[9]);
 2000c98:	e0bfe504 	addi	r2,fp,-108
 2000c9c:	10c01204 	addi	r3,r2,72
 2000ca0:	e0bf4d04 	addi	r2,fp,-716
 2000ca4:	10801204 	addi	r2,r2,72
 2000ca8:	180b883a 	mov	r5,r3
 2000cac:	1009883a 	mov	r4,r2
 2000cb0:	20033ac0 	call	20033ac <moveBall>

       //Whole collision

       whole_collide(ball[1],velocity[1]);
 2000cb4:	e0bfe504 	addi	r2,fp,-108
 2000cb8:	10c00204 	addi	r3,r2,8
 2000cbc:	e0bf4d04 	addi	r2,fp,-716
 2000cc0:	10800204 	addi	r2,r2,8
 2000cc4:	180b883a 	mov	r5,r3
 2000cc8:	1009883a 	mov	r4,r2
 2000ccc:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[2],velocity[2]);
 2000cd0:	e0bfe504 	addi	r2,fp,-108
 2000cd4:	10c00404 	addi	r3,r2,16
 2000cd8:	e0bf4d04 	addi	r2,fp,-716
 2000cdc:	10800404 	addi	r2,r2,16
 2000ce0:	180b883a 	mov	r5,r3
 2000ce4:	1009883a 	mov	r4,r2
 2000ce8:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[3],velocity[3]);
 2000cec:	e0bfe504 	addi	r2,fp,-108
 2000cf0:	10c00604 	addi	r3,r2,24
 2000cf4:	e0bf4d04 	addi	r2,fp,-716
 2000cf8:	10800604 	addi	r2,r2,24
 2000cfc:	180b883a 	mov	r5,r3
 2000d00:	1009883a 	mov	r4,r2
 2000d04:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[4],velocity[4]);
 2000d08:	e0bfe504 	addi	r2,fp,-108
 2000d0c:	10c00804 	addi	r3,r2,32
 2000d10:	e0bf4d04 	addi	r2,fp,-716
 2000d14:	10800804 	addi	r2,r2,32
 2000d18:	180b883a 	mov	r5,r3
 2000d1c:	1009883a 	mov	r4,r2
 2000d20:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[5],velocity[5]);
 2000d24:	e0bfe504 	addi	r2,fp,-108
 2000d28:	10c00a04 	addi	r3,r2,40
 2000d2c:	e0bf4d04 	addi	r2,fp,-716
 2000d30:	10800a04 	addi	r2,r2,40
 2000d34:	180b883a 	mov	r5,r3
 2000d38:	1009883a 	mov	r4,r2
 2000d3c:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[6],velocity[6]);
 2000d40:	e0bfe504 	addi	r2,fp,-108
 2000d44:	10c00c04 	addi	r3,r2,48
 2000d48:	e0bf4d04 	addi	r2,fp,-716
 2000d4c:	10800c04 	addi	r2,r2,48
 2000d50:	180b883a 	mov	r5,r3
 2000d54:	1009883a 	mov	r4,r2
 2000d58:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[7],velocity[7]);
 2000d5c:	e0bfe504 	addi	r2,fp,-108
 2000d60:	10c00e04 	addi	r3,r2,56
 2000d64:	e0bf4d04 	addi	r2,fp,-716
 2000d68:	10800e04 	addi	r2,r2,56
 2000d6c:	180b883a 	mov	r5,r3
 2000d70:	1009883a 	mov	r4,r2
 2000d74:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[8],velocity[8]);
 2000d78:	e0bfe504 	addi	r2,fp,-108
 2000d7c:	10c01004 	addi	r3,r2,64
 2000d80:	e0bf4d04 	addi	r2,fp,-716
 2000d84:	10801004 	addi	r2,r2,64
 2000d88:	180b883a 	mov	r5,r3
 2000d8c:	1009883a 	mov	r4,r2
 2000d90:	2002adc0 	call	2002adc <whole_collide>
       whole_collide(ball[9],velocity[9]);
 2000d94:	e0bfe504 	addi	r2,fp,-108
 2000d98:	10c01204 	addi	r3,r2,72
 2000d9c:	e0bf4d04 	addi	r2,fp,-716
 2000da0:	10801204 	addi	r2,r2,72
 2000da4:	180b883a 	mov	r5,r3
 2000da8:	1009883a 	mov	r4,r2
 2000dac:	2002adc0 	call	2002adc <whole_collide>

       //Collision

       detect_collide(ball[0],ball[1],collision[0]);
 2000db0:	e13f6104 	addi	r4,fp,-636
 2000db4:	e0bf4d04 	addi	r2,fp,-716
 2000db8:	10c00204 	addi	r3,r2,8
 2000dbc:	e0bf4d04 	addi	r2,fp,-716
 2000dc0:	200d883a 	mov	r6,r4
 2000dc4:	180b883a 	mov	r5,r3
 2000dc8:	1009883a 	mov	r4,r2
 2000dcc:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[2],collision[1]);
 2000dd0:	e0bf6104 	addi	r2,fp,-636
 2000dd4:	11000204 	addi	r4,r2,8
 2000dd8:	e0bf4d04 	addi	r2,fp,-716
 2000ddc:	10c00404 	addi	r3,r2,16
 2000de0:	e0bf4d04 	addi	r2,fp,-716
 2000de4:	200d883a 	mov	r6,r4
 2000de8:	180b883a 	mov	r5,r3
 2000dec:	1009883a 	mov	r4,r2
 2000df0:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[3],collision[2]);
 2000df4:	e0bf6104 	addi	r2,fp,-636
 2000df8:	11000404 	addi	r4,r2,16
 2000dfc:	e0bf4d04 	addi	r2,fp,-716
 2000e00:	10c00604 	addi	r3,r2,24
 2000e04:	e0bf4d04 	addi	r2,fp,-716
 2000e08:	200d883a 	mov	r6,r4
 2000e0c:	180b883a 	mov	r5,r3
 2000e10:	1009883a 	mov	r4,r2
 2000e14:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[4],collision[3]);
 2000e18:	e0bf6104 	addi	r2,fp,-636
 2000e1c:	11000604 	addi	r4,r2,24
 2000e20:	e0bf4d04 	addi	r2,fp,-716
 2000e24:	10c00804 	addi	r3,r2,32
 2000e28:	e0bf4d04 	addi	r2,fp,-716
 2000e2c:	200d883a 	mov	r6,r4
 2000e30:	180b883a 	mov	r5,r3
 2000e34:	1009883a 	mov	r4,r2
 2000e38:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[5],collision[4]);
 2000e3c:	e0bf6104 	addi	r2,fp,-636
 2000e40:	11000804 	addi	r4,r2,32
 2000e44:	e0bf4d04 	addi	r2,fp,-716
 2000e48:	10c00a04 	addi	r3,r2,40
 2000e4c:	e0bf4d04 	addi	r2,fp,-716
 2000e50:	200d883a 	mov	r6,r4
 2000e54:	180b883a 	mov	r5,r3
 2000e58:	1009883a 	mov	r4,r2
 2000e5c:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[6],collision[5]);
 2000e60:	e0bf6104 	addi	r2,fp,-636
 2000e64:	11000a04 	addi	r4,r2,40
 2000e68:	e0bf4d04 	addi	r2,fp,-716
 2000e6c:	10c00c04 	addi	r3,r2,48
 2000e70:	e0bf4d04 	addi	r2,fp,-716
 2000e74:	200d883a 	mov	r6,r4
 2000e78:	180b883a 	mov	r5,r3
 2000e7c:	1009883a 	mov	r4,r2
 2000e80:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[7],collision[6]);
 2000e84:	e0bf6104 	addi	r2,fp,-636
 2000e88:	11000c04 	addi	r4,r2,48
 2000e8c:	e0bf4d04 	addi	r2,fp,-716
 2000e90:	10c00e04 	addi	r3,r2,56
 2000e94:	e0bf4d04 	addi	r2,fp,-716
 2000e98:	200d883a 	mov	r6,r4
 2000e9c:	180b883a 	mov	r5,r3
 2000ea0:	1009883a 	mov	r4,r2
 2000ea4:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[8],collision[7]);
 2000ea8:	e0bf6104 	addi	r2,fp,-636
 2000eac:	11000e04 	addi	r4,r2,56
 2000eb0:	e0bf4d04 	addi	r2,fp,-716
 2000eb4:	10c01004 	addi	r3,r2,64
 2000eb8:	e0bf4d04 	addi	r2,fp,-716
 2000ebc:	200d883a 	mov	r6,r4
 2000ec0:	180b883a 	mov	r5,r3
 2000ec4:	1009883a 	mov	r4,r2
 2000ec8:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[0],ball[9],collision[8]);
 2000ecc:	e0bf6104 	addi	r2,fp,-636
 2000ed0:	11001004 	addi	r4,r2,64
 2000ed4:	e0bf4d04 	addi	r2,fp,-716
 2000ed8:	10c01204 	addi	r3,r2,72
 2000edc:	e0bf4d04 	addi	r2,fp,-716
 2000ee0:	200d883a 	mov	r6,r4
 2000ee4:	180b883a 	mov	r5,r3
 2000ee8:	1009883a 	mov	r4,r2
 2000eec:	2002e0c0 	call	2002e0c <detect_collide>

       detect_collide(ball[1],ball[2],collision[9]);
 2000ef0:	e0bf6104 	addi	r2,fp,-636
 2000ef4:	11001204 	addi	r4,r2,72
 2000ef8:	e0bf4d04 	addi	r2,fp,-716
 2000efc:	10c00404 	addi	r3,r2,16
 2000f00:	e0bf4d04 	addi	r2,fp,-716
 2000f04:	10800204 	addi	r2,r2,8
 2000f08:	200d883a 	mov	r6,r4
 2000f0c:	180b883a 	mov	r5,r3
 2000f10:	1009883a 	mov	r4,r2
 2000f14:	2002e0c0 	call	2002e0c <detect_collide>
       detect_collide(ball[1],ball[3],collision[10]);
 2000f18:	e0bf6104 	addi	r2,fp,-636
 2000f1c:	11001404 	addi	r4,r2,80
 2000f20:	e0bf4d04 	addi	r2,fp,-716
 2000f24:	10c00604 	addi	r3,r2,24
 2000f28:	e0bf4d04 	addi	r2,fp,-716
 2000f2c:	10800204 	addi	r2,r2,8
 2000f30:	200d883a 	mov	r6,r4
 2000f34:	180b883a 	mov	r5,r3
 2000f38:	1009883a 	mov	r4,r2
 2000f3c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[4],collision[11]);
 2000f40:	e0bf6104 	addi	r2,fp,-636
 2000f44:	11001604 	addi	r4,r2,88
 2000f48:	e0bf4d04 	addi	r2,fp,-716
 2000f4c:	10c00804 	addi	r3,r2,32
 2000f50:	e0bf4d04 	addi	r2,fp,-716
 2000f54:	10800204 	addi	r2,r2,8
 2000f58:	200d883a 	mov	r6,r4
 2000f5c:	180b883a 	mov	r5,r3
 2000f60:	1009883a 	mov	r4,r2
 2000f64:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[5],collision[12]);
 2000f68:	e0bf6104 	addi	r2,fp,-636
 2000f6c:	11001804 	addi	r4,r2,96
 2000f70:	e0bf4d04 	addi	r2,fp,-716
 2000f74:	10c00a04 	addi	r3,r2,40
 2000f78:	e0bf4d04 	addi	r2,fp,-716
 2000f7c:	10800204 	addi	r2,r2,8
 2000f80:	200d883a 	mov	r6,r4
 2000f84:	180b883a 	mov	r5,r3
 2000f88:	1009883a 	mov	r4,r2
 2000f8c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[6],collision[13]);
 2000f90:	e0bf6104 	addi	r2,fp,-636
 2000f94:	11001a04 	addi	r4,r2,104
 2000f98:	e0bf4d04 	addi	r2,fp,-716
 2000f9c:	10c00c04 	addi	r3,r2,48
 2000fa0:	e0bf4d04 	addi	r2,fp,-716
 2000fa4:	10800204 	addi	r2,r2,8
 2000fa8:	200d883a 	mov	r6,r4
 2000fac:	180b883a 	mov	r5,r3
 2000fb0:	1009883a 	mov	r4,r2
 2000fb4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[7],collision[14]);
 2000fb8:	e0bf6104 	addi	r2,fp,-636
 2000fbc:	11001c04 	addi	r4,r2,112
 2000fc0:	e0bf4d04 	addi	r2,fp,-716
 2000fc4:	10c00e04 	addi	r3,r2,56
 2000fc8:	e0bf4d04 	addi	r2,fp,-716
 2000fcc:	10800204 	addi	r2,r2,8
 2000fd0:	200d883a 	mov	r6,r4
 2000fd4:	180b883a 	mov	r5,r3
 2000fd8:	1009883a 	mov	r4,r2
 2000fdc:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[8],collision[15]);
 2000fe0:	e0bf6104 	addi	r2,fp,-636
 2000fe4:	11001e04 	addi	r4,r2,120
 2000fe8:	e0bf4d04 	addi	r2,fp,-716
 2000fec:	10c01004 	addi	r3,r2,64
 2000ff0:	e0bf4d04 	addi	r2,fp,-716
 2000ff4:	10800204 	addi	r2,r2,8
 2000ff8:	200d883a 	mov	r6,r4
 2000ffc:	180b883a 	mov	r5,r3
 2001000:	1009883a 	mov	r4,r2
 2001004:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[1],ball[9],collision[16]);
 2001008:	e0bf6104 	addi	r2,fp,-636
 200100c:	11002004 	addi	r4,r2,128
 2001010:	e0bf4d04 	addi	r2,fp,-716
 2001014:	10c01204 	addi	r3,r2,72
 2001018:	e0bf4d04 	addi	r2,fp,-716
 200101c:	10800204 	addi	r2,r2,8
 2001020:	200d883a 	mov	r6,r4
 2001024:	180b883a 	mov	r5,r3
 2001028:	1009883a 	mov	r4,r2
 200102c:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[2],ball[3],collision[17]);
 2001030:	e0bf6104 	addi	r2,fp,-636
 2001034:	11002204 	addi	r4,r2,136
 2001038:	e0bf4d04 	addi	r2,fp,-716
 200103c:	10c00604 	addi	r3,r2,24
 2001040:	e0bf4d04 	addi	r2,fp,-716
 2001044:	10800404 	addi	r2,r2,16
 2001048:	200d883a 	mov	r6,r4
 200104c:	180b883a 	mov	r5,r3
 2001050:	1009883a 	mov	r4,r2
 2001054:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[4],collision[18]);
 2001058:	e0bf6104 	addi	r2,fp,-636
 200105c:	11002404 	addi	r4,r2,144
 2001060:	e0bf4d04 	addi	r2,fp,-716
 2001064:	10c00804 	addi	r3,r2,32
 2001068:	e0bf4d04 	addi	r2,fp,-716
 200106c:	10800404 	addi	r2,r2,16
 2001070:	200d883a 	mov	r6,r4
 2001074:	180b883a 	mov	r5,r3
 2001078:	1009883a 	mov	r4,r2
 200107c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[5],collision[19]);
 2001080:	e0bf6104 	addi	r2,fp,-636
 2001084:	11002604 	addi	r4,r2,152
 2001088:	e0bf4d04 	addi	r2,fp,-716
 200108c:	10c00a04 	addi	r3,r2,40
 2001090:	e0bf4d04 	addi	r2,fp,-716
 2001094:	10800404 	addi	r2,r2,16
 2001098:	200d883a 	mov	r6,r4
 200109c:	180b883a 	mov	r5,r3
 20010a0:	1009883a 	mov	r4,r2
 20010a4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[6],collision[20]);
 20010a8:	e0bf6104 	addi	r2,fp,-636
 20010ac:	11002804 	addi	r4,r2,160
 20010b0:	e0bf4d04 	addi	r2,fp,-716
 20010b4:	10c00c04 	addi	r3,r2,48
 20010b8:	e0bf4d04 	addi	r2,fp,-716
 20010bc:	10800404 	addi	r2,r2,16
 20010c0:	200d883a 	mov	r6,r4
 20010c4:	180b883a 	mov	r5,r3
 20010c8:	1009883a 	mov	r4,r2
 20010cc:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[7],collision[21]);
 20010d0:	e0bf6104 	addi	r2,fp,-636
 20010d4:	11002a04 	addi	r4,r2,168
 20010d8:	e0bf4d04 	addi	r2,fp,-716
 20010dc:	10c00e04 	addi	r3,r2,56
 20010e0:	e0bf4d04 	addi	r2,fp,-716
 20010e4:	10800404 	addi	r2,r2,16
 20010e8:	200d883a 	mov	r6,r4
 20010ec:	180b883a 	mov	r5,r3
 20010f0:	1009883a 	mov	r4,r2
 20010f4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[8],collision[22]);
 20010f8:	e0bf6104 	addi	r2,fp,-636
 20010fc:	11002c04 	addi	r4,r2,176
 2001100:	e0bf4d04 	addi	r2,fp,-716
 2001104:	10c01004 	addi	r3,r2,64
 2001108:	e0bf4d04 	addi	r2,fp,-716
 200110c:	10800404 	addi	r2,r2,16
 2001110:	200d883a 	mov	r6,r4
 2001114:	180b883a 	mov	r5,r3
 2001118:	1009883a 	mov	r4,r2
 200111c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[2],ball[9],collision[23]);
 2001120:	e0bf6104 	addi	r2,fp,-636
 2001124:	11002e04 	addi	r4,r2,184
 2001128:	e0bf4d04 	addi	r2,fp,-716
 200112c:	10c01204 	addi	r3,r2,72
 2001130:	e0bf4d04 	addi	r2,fp,-716
 2001134:	10800404 	addi	r2,r2,16
 2001138:	200d883a 	mov	r6,r4
 200113c:	180b883a 	mov	r5,r3
 2001140:	1009883a 	mov	r4,r2
 2001144:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[3],ball[4],collision[24]);
 2001148:	e0bf6104 	addi	r2,fp,-636
 200114c:	11003004 	addi	r4,r2,192
 2001150:	e0bf4d04 	addi	r2,fp,-716
 2001154:	10c00804 	addi	r3,r2,32
 2001158:	e0bf4d04 	addi	r2,fp,-716
 200115c:	10800604 	addi	r2,r2,24
 2001160:	200d883a 	mov	r6,r4
 2001164:	180b883a 	mov	r5,r3
 2001168:	1009883a 	mov	r4,r2
 200116c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[3],ball[5],collision[25]);
 2001170:	e0bf6104 	addi	r2,fp,-636
 2001174:	11003204 	addi	r4,r2,200
 2001178:	e0bf4d04 	addi	r2,fp,-716
 200117c:	10c00a04 	addi	r3,r2,40
 2001180:	e0bf4d04 	addi	r2,fp,-716
 2001184:	10800604 	addi	r2,r2,24
 2001188:	200d883a 	mov	r6,r4
 200118c:	180b883a 	mov	r5,r3
 2001190:	1009883a 	mov	r4,r2
 2001194:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[3],ball[6],collision[26]);
 2001198:	e0bf6104 	addi	r2,fp,-636
 200119c:	11003404 	addi	r4,r2,208
 20011a0:	e0bf4d04 	addi	r2,fp,-716
 20011a4:	10c00c04 	addi	r3,r2,48
 20011a8:	e0bf4d04 	addi	r2,fp,-716
 20011ac:	10800604 	addi	r2,r2,24
 20011b0:	200d883a 	mov	r6,r4
 20011b4:	180b883a 	mov	r5,r3
 20011b8:	1009883a 	mov	r4,r2
 20011bc:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[3],ball[7],collision[27]);
 20011c0:	e0bf6104 	addi	r2,fp,-636
 20011c4:	11003604 	addi	r4,r2,216
 20011c8:	e0bf4d04 	addi	r2,fp,-716
 20011cc:	10c00e04 	addi	r3,r2,56
 20011d0:	e0bf4d04 	addi	r2,fp,-716
 20011d4:	10800604 	addi	r2,r2,24
 20011d8:	200d883a 	mov	r6,r4
 20011dc:	180b883a 	mov	r5,r3
 20011e0:	1009883a 	mov	r4,r2
 20011e4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[3],ball[8],collision[28]);
 20011e8:	e0bf6104 	addi	r2,fp,-636
 20011ec:	11003804 	addi	r4,r2,224
 20011f0:	e0bf4d04 	addi	r2,fp,-716
 20011f4:	10c01004 	addi	r3,r2,64
 20011f8:	e0bf4d04 	addi	r2,fp,-716
 20011fc:	10800604 	addi	r2,r2,24
 2001200:	200d883a 	mov	r6,r4
 2001204:	180b883a 	mov	r5,r3
 2001208:	1009883a 	mov	r4,r2
 200120c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[3],ball[9],collision[29]);
 2001210:	e0bf6104 	addi	r2,fp,-636
 2001214:	11003a04 	addi	r4,r2,232
 2001218:	e0bf4d04 	addi	r2,fp,-716
 200121c:	10c01204 	addi	r3,r2,72
 2001220:	e0bf4d04 	addi	r2,fp,-716
 2001224:	10800604 	addi	r2,r2,24
 2001228:	200d883a 	mov	r6,r4
 200122c:	180b883a 	mov	r5,r3
 2001230:	1009883a 	mov	r4,r2
 2001234:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[4],ball[5],collision[30]);
 2001238:	e0bf6104 	addi	r2,fp,-636
 200123c:	11003c04 	addi	r4,r2,240
 2001240:	e0bf4d04 	addi	r2,fp,-716
 2001244:	10c00a04 	addi	r3,r2,40
 2001248:	e0bf4d04 	addi	r2,fp,-716
 200124c:	10800804 	addi	r2,r2,32
 2001250:	200d883a 	mov	r6,r4
 2001254:	180b883a 	mov	r5,r3
 2001258:	1009883a 	mov	r4,r2
 200125c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[4],ball[6],collision[31]);
 2001260:	e0bf6104 	addi	r2,fp,-636
 2001264:	11003e04 	addi	r4,r2,248
 2001268:	e0bf4d04 	addi	r2,fp,-716
 200126c:	10c00c04 	addi	r3,r2,48
 2001270:	e0bf4d04 	addi	r2,fp,-716
 2001274:	10800804 	addi	r2,r2,32
 2001278:	200d883a 	mov	r6,r4
 200127c:	180b883a 	mov	r5,r3
 2001280:	1009883a 	mov	r4,r2
 2001284:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[4],ball[7],collision[32]);
 2001288:	e0bf6104 	addi	r2,fp,-636
 200128c:	11004004 	addi	r4,r2,256
 2001290:	e0bf4d04 	addi	r2,fp,-716
 2001294:	10c00e04 	addi	r3,r2,56
 2001298:	e0bf4d04 	addi	r2,fp,-716
 200129c:	10800804 	addi	r2,r2,32
 20012a0:	200d883a 	mov	r6,r4
 20012a4:	180b883a 	mov	r5,r3
 20012a8:	1009883a 	mov	r4,r2
 20012ac:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[4],ball[8],collision[33]);
 20012b0:	e0bf6104 	addi	r2,fp,-636
 20012b4:	11004204 	addi	r4,r2,264
 20012b8:	e0bf4d04 	addi	r2,fp,-716
 20012bc:	10c01004 	addi	r3,r2,64
 20012c0:	e0bf4d04 	addi	r2,fp,-716
 20012c4:	10800804 	addi	r2,r2,32
 20012c8:	200d883a 	mov	r6,r4
 20012cc:	180b883a 	mov	r5,r3
 20012d0:	1009883a 	mov	r4,r2
 20012d4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[4],ball[9],collision[34]);
 20012d8:	e0bf6104 	addi	r2,fp,-636
 20012dc:	11004404 	addi	r4,r2,272
 20012e0:	e0bf4d04 	addi	r2,fp,-716
 20012e4:	10c01204 	addi	r3,r2,72
 20012e8:	e0bf4d04 	addi	r2,fp,-716
 20012ec:	10800804 	addi	r2,r2,32
 20012f0:	200d883a 	mov	r6,r4
 20012f4:	180b883a 	mov	r5,r3
 20012f8:	1009883a 	mov	r4,r2
 20012fc:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[5],ball[6],collision[35]);
 2001300:	e0bf6104 	addi	r2,fp,-636
 2001304:	11004604 	addi	r4,r2,280
 2001308:	e0bf4d04 	addi	r2,fp,-716
 200130c:	10c00c04 	addi	r3,r2,48
 2001310:	e0bf4d04 	addi	r2,fp,-716
 2001314:	10800a04 	addi	r2,r2,40
 2001318:	200d883a 	mov	r6,r4
 200131c:	180b883a 	mov	r5,r3
 2001320:	1009883a 	mov	r4,r2
 2001324:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[5],ball[7],collision[36]);
 2001328:	e0bf6104 	addi	r2,fp,-636
 200132c:	11004804 	addi	r4,r2,288
 2001330:	e0bf4d04 	addi	r2,fp,-716
 2001334:	10c00e04 	addi	r3,r2,56
 2001338:	e0bf4d04 	addi	r2,fp,-716
 200133c:	10800a04 	addi	r2,r2,40
 2001340:	200d883a 	mov	r6,r4
 2001344:	180b883a 	mov	r5,r3
 2001348:	1009883a 	mov	r4,r2
 200134c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[5],ball[8],collision[37]);
 2001350:	e0bf6104 	addi	r2,fp,-636
 2001354:	11004a04 	addi	r4,r2,296
 2001358:	e0bf4d04 	addi	r2,fp,-716
 200135c:	10c01004 	addi	r3,r2,64
 2001360:	e0bf4d04 	addi	r2,fp,-716
 2001364:	10800a04 	addi	r2,r2,40
 2001368:	200d883a 	mov	r6,r4
 200136c:	180b883a 	mov	r5,r3
 2001370:	1009883a 	mov	r4,r2
 2001374:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[5],ball[9],collision[38]);
 2001378:	e0bf6104 	addi	r2,fp,-636
 200137c:	11004c04 	addi	r4,r2,304
 2001380:	e0bf4d04 	addi	r2,fp,-716
 2001384:	10c01204 	addi	r3,r2,72
 2001388:	e0bf4d04 	addi	r2,fp,-716
 200138c:	10800a04 	addi	r2,r2,40
 2001390:	200d883a 	mov	r6,r4
 2001394:	180b883a 	mov	r5,r3
 2001398:	1009883a 	mov	r4,r2
 200139c:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[6],ball[7],collision[39]);
 20013a0:	e0bf6104 	addi	r2,fp,-636
 20013a4:	11004e04 	addi	r4,r2,312
 20013a8:	e0bf4d04 	addi	r2,fp,-716
 20013ac:	10c00e04 	addi	r3,r2,56
 20013b0:	e0bf4d04 	addi	r2,fp,-716
 20013b4:	10800c04 	addi	r2,r2,48
 20013b8:	200d883a 	mov	r6,r4
 20013bc:	180b883a 	mov	r5,r3
 20013c0:	1009883a 	mov	r4,r2
 20013c4:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[6],ball[8],collision[40]);
 20013c8:	e0bf6104 	addi	r2,fp,-636
 20013cc:	11005004 	addi	r4,r2,320
 20013d0:	e0bf4d04 	addi	r2,fp,-716
 20013d4:	10c01004 	addi	r3,r2,64
 20013d8:	e0bf4d04 	addi	r2,fp,-716
 20013dc:	10800c04 	addi	r2,r2,48
 20013e0:	200d883a 	mov	r6,r4
 20013e4:	180b883a 	mov	r5,r3
 20013e8:	1009883a 	mov	r4,r2
 20013ec:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[6],ball[9],collision[41]);
 20013f0:	e0bf6104 	addi	r2,fp,-636
 20013f4:	11005204 	addi	r4,r2,328
 20013f8:	e0bf4d04 	addi	r2,fp,-716
 20013fc:	10c01204 	addi	r3,r2,72
 2001400:	e0bf4d04 	addi	r2,fp,-716
 2001404:	10800c04 	addi	r2,r2,48
 2001408:	200d883a 	mov	r6,r4
 200140c:	180b883a 	mov	r5,r3
 2001410:	1009883a 	mov	r4,r2
 2001414:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[7],ball[8],collision[42]);
 2001418:	e0bf6104 	addi	r2,fp,-636
 200141c:	11005404 	addi	r4,r2,336
 2001420:	e0bf4d04 	addi	r2,fp,-716
 2001424:	10c01004 	addi	r3,r2,64
 2001428:	e0bf4d04 	addi	r2,fp,-716
 200142c:	10800e04 	addi	r2,r2,56
 2001430:	200d883a 	mov	r6,r4
 2001434:	180b883a 	mov	r5,r3
 2001438:	1009883a 	mov	r4,r2
 200143c:	2002e0c0 	call	2002e0c <detect_collide>
	   detect_collide(ball[7],ball[9],collision[43]);
 2001440:	e0bf6104 	addi	r2,fp,-636
 2001444:	11005604 	addi	r4,r2,344
 2001448:	e0bf4d04 	addi	r2,fp,-716
 200144c:	10c01204 	addi	r3,r2,72
 2001450:	e0bf4d04 	addi	r2,fp,-716
 2001454:	10800e04 	addi	r2,r2,56
 2001458:	200d883a 	mov	r6,r4
 200145c:	180b883a 	mov	r5,r3
 2001460:	1009883a 	mov	r4,r2
 2001464:	2002e0c0 	call	2002e0c <detect_collide>

	   detect_collide(ball[8],ball[9],collision[44]);
 2001468:	e0bf6104 	addi	r2,fp,-636
 200146c:	11005804 	addi	r4,r2,352
 2001470:	e0bf4d04 	addi	r2,fp,-716
 2001474:	10c01204 	addi	r3,r2,72
 2001478:	e0bf4d04 	addi	r2,fp,-716
 200147c:	10801004 	addi	r2,r2,64
 2001480:	200d883a 	mov	r6,r4
 2001484:	180b883a 	mov	r5,r3
 2001488:	1009883a 	mov	r4,r2
 200148c:	2002e0c0 	call	2002e0c <detect_collide>

	   //Calcul of collision

  	   collide_calc(ball[0],ball[1],velocity[0],velocity[1],collision[0],0);
 2001490:	e0bfe504 	addi	r2,fp,-108
 2001494:	11800204 	addi	r6,r2,8
 2001498:	e17fe504 	addi	r5,fp,-108
 200149c:	e0bf4d04 	addi	r2,fp,-716
 20014a0:	11000204 	addi	r4,r2,8
 20014a4:	e0ff4d04 	addi	r3,fp,-716
 20014a8:	d8000115 	stw	zero,4(sp)
 20014ac:	e0bf6104 	addi	r2,fp,-636
 20014b0:	d8800015 	stw	r2,0(sp)
 20014b4:	300f883a 	mov	r7,r6
 20014b8:	280d883a 	mov	r6,r5
 20014bc:	200b883a 	mov	r5,r4
 20014c0:	1809883a 	mov	r4,r3
 20014c4:	2002ecc0 	call	2002ecc <collide_calc>
  	   collide_calc(ball[0],ball[2],velocity[0],velocity[2],collision[1],1);
 20014c8:	e0bfe504 	addi	r2,fp,-108
 20014cc:	11800404 	addi	r6,r2,16
 20014d0:	e17fe504 	addi	r5,fp,-108
 20014d4:	e0bf4d04 	addi	r2,fp,-716
 20014d8:	11000404 	addi	r4,r2,16
 20014dc:	e0ff4d04 	addi	r3,fp,-716
 20014e0:	00800044 	movi	r2,1
 20014e4:	d8800115 	stw	r2,4(sp)
 20014e8:	e0bf6104 	addi	r2,fp,-636
 20014ec:	10800204 	addi	r2,r2,8
 20014f0:	d8800015 	stw	r2,0(sp)
 20014f4:	300f883a 	mov	r7,r6
 20014f8:	280d883a 	mov	r6,r5
 20014fc:	200b883a 	mov	r5,r4
 2001500:	1809883a 	mov	r4,r3
 2001504:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[0],ball[3],velocity[0],velocity[3],collision[2],2);
 2001508:	e0bfe504 	addi	r2,fp,-108
 200150c:	11800604 	addi	r6,r2,24
 2001510:	e17fe504 	addi	r5,fp,-108
 2001514:	e0bf4d04 	addi	r2,fp,-716
 2001518:	11000604 	addi	r4,r2,24
 200151c:	e0ff4d04 	addi	r3,fp,-716
 2001520:	00800084 	movi	r2,2
 2001524:	d8800115 	stw	r2,4(sp)
 2001528:	e0bf6104 	addi	r2,fp,-636
 200152c:	10800404 	addi	r2,r2,16
 2001530:	d8800015 	stw	r2,0(sp)
 2001534:	300f883a 	mov	r7,r6
 2001538:	280d883a 	mov	r6,r5
 200153c:	200b883a 	mov	r5,r4
 2001540:	1809883a 	mov	r4,r3
 2001544:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[0],ball[4],velocity[0],velocity[4],collision[3],3);
 2001548:	e0bfe504 	addi	r2,fp,-108
 200154c:	11800804 	addi	r6,r2,32
 2001550:	e17fe504 	addi	r5,fp,-108
 2001554:	e0bf4d04 	addi	r2,fp,-716
 2001558:	11000804 	addi	r4,r2,32
 200155c:	e0ff4d04 	addi	r3,fp,-716
 2001560:	008000c4 	movi	r2,3
 2001564:	d8800115 	stw	r2,4(sp)
 2001568:	e0bf6104 	addi	r2,fp,-636
 200156c:	10800604 	addi	r2,r2,24
 2001570:	d8800015 	stw	r2,0(sp)
 2001574:	300f883a 	mov	r7,r6
 2001578:	280d883a 	mov	r6,r5
 200157c:	200b883a 	mov	r5,r4
 2001580:	1809883a 	mov	r4,r3
 2001584:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[0],ball[5],velocity[0],velocity[5],collision[4],4);
 2001588:	e0bfe504 	addi	r2,fp,-108
 200158c:	11800a04 	addi	r6,r2,40
 2001590:	e17fe504 	addi	r5,fp,-108
 2001594:	e0bf4d04 	addi	r2,fp,-716
 2001598:	11000a04 	addi	r4,r2,40
 200159c:	e0ff4d04 	addi	r3,fp,-716
 20015a0:	00800104 	movi	r2,4
 20015a4:	d8800115 	stw	r2,4(sp)
 20015a8:	e0bf6104 	addi	r2,fp,-636
 20015ac:	10800804 	addi	r2,r2,32
 20015b0:	d8800015 	stw	r2,0(sp)
 20015b4:	300f883a 	mov	r7,r6
 20015b8:	280d883a 	mov	r6,r5
 20015bc:	200b883a 	mov	r5,r4
 20015c0:	1809883a 	mov	r4,r3
 20015c4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[0],ball[6],velocity[0],velocity[6],collision[5],5);
 20015c8:	e0bfe504 	addi	r2,fp,-108
 20015cc:	11800c04 	addi	r6,r2,48
 20015d0:	e17fe504 	addi	r5,fp,-108
 20015d4:	e0bf4d04 	addi	r2,fp,-716
 20015d8:	11000c04 	addi	r4,r2,48
 20015dc:	e0ff4d04 	addi	r3,fp,-716
 20015e0:	00800144 	movi	r2,5
 20015e4:	d8800115 	stw	r2,4(sp)
 20015e8:	e0bf6104 	addi	r2,fp,-636
 20015ec:	10800a04 	addi	r2,r2,40
 20015f0:	d8800015 	stw	r2,0(sp)
 20015f4:	300f883a 	mov	r7,r6
 20015f8:	280d883a 	mov	r6,r5
 20015fc:	200b883a 	mov	r5,r4
 2001600:	1809883a 	mov	r4,r3
 2001604:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[0],ball[7],velocity[0],velocity[7],collision[6],6);
 2001608:	e0bfe504 	addi	r2,fp,-108
 200160c:	11800e04 	addi	r6,r2,56
 2001610:	e17fe504 	addi	r5,fp,-108
 2001614:	e0bf4d04 	addi	r2,fp,-716
 2001618:	11000e04 	addi	r4,r2,56
 200161c:	e0ff4d04 	addi	r3,fp,-716
 2001620:	00800184 	movi	r2,6
 2001624:	d8800115 	stw	r2,4(sp)
 2001628:	e0bf6104 	addi	r2,fp,-636
 200162c:	10800c04 	addi	r2,r2,48
 2001630:	d8800015 	stw	r2,0(sp)
 2001634:	300f883a 	mov	r7,r6
 2001638:	280d883a 	mov	r6,r5
 200163c:	200b883a 	mov	r5,r4
 2001640:	1809883a 	mov	r4,r3
 2001644:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[0],ball[8],velocity[0],velocity[8],collision[7],7);
 2001648:	e0bfe504 	addi	r2,fp,-108
 200164c:	11801004 	addi	r6,r2,64
 2001650:	e17fe504 	addi	r5,fp,-108
 2001654:	e0bf4d04 	addi	r2,fp,-716
 2001658:	11001004 	addi	r4,r2,64
 200165c:	e0ff4d04 	addi	r3,fp,-716
 2001660:	008001c4 	movi	r2,7
 2001664:	d8800115 	stw	r2,4(sp)
 2001668:	e0bf6104 	addi	r2,fp,-636
 200166c:	10800e04 	addi	r2,r2,56
 2001670:	d8800015 	stw	r2,0(sp)
 2001674:	300f883a 	mov	r7,r6
 2001678:	280d883a 	mov	r6,r5
 200167c:	200b883a 	mov	r5,r4
 2001680:	1809883a 	mov	r4,r3
 2001684:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[0],ball[9],velocity[0],velocity[9],collision[8],8);
 2001688:	e0bfe504 	addi	r2,fp,-108
 200168c:	11801204 	addi	r6,r2,72
 2001690:	e17fe504 	addi	r5,fp,-108
 2001694:	e0bf4d04 	addi	r2,fp,-716
 2001698:	11001204 	addi	r4,r2,72
 200169c:	e0ff4d04 	addi	r3,fp,-716
 20016a0:	00800204 	movi	r2,8
 20016a4:	d8800115 	stw	r2,4(sp)
 20016a8:	e0bf6104 	addi	r2,fp,-636
 20016ac:	10801004 	addi	r2,r2,64
 20016b0:	d8800015 	stw	r2,0(sp)
 20016b4:	300f883a 	mov	r7,r6
 20016b8:	280d883a 	mov	r6,r5
 20016bc:	200b883a 	mov	r5,r4
 20016c0:	1809883a 	mov	r4,r3
 20016c4:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[1],ball[2],velocity[1],velocity[2],collision[9],9);
 20016c8:	e0bfe504 	addi	r2,fp,-108
 20016cc:	11800404 	addi	r6,r2,16
 20016d0:	e0bfe504 	addi	r2,fp,-108
 20016d4:	11400204 	addi	r5,r2,8
 20016d8:	e0bf4d04 	addi	r2,fp,-716
 20016dc:	11000404 	addi	r4,r2,16
 20016e0:	e0bf4d04 	addi	r2,fp,-716
 20016e4:	10c00204 	addi	r3,r2,8
 20016e8:	00800244 	movi	r2,9
 20016ec:	d8800115 	stw	r2,4(sp)
 20016f0:	e0bf6104 	addi	r2,fp,-636
 20016f4:	10801204 	addi	r2,r2,72
 20016f8:	d8800015 	stw	r2,0(sp)
 20016fc:	300f883a 	mov	r7,r6
 2001700:	280d883a 	mov	r6,r5
 2001704:	200b883a 	mov	r5,r4
 2001708:	1809883a 	mov	r4,r3
 200170c:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[1],ball[3],velocity[1],velocity[3],collision[10],10);
 2001710:	e0bfe504 	addi	r2,fp,-108
 2001714:	11800604 	addi	r6,r2,24
 2001718:	e0bfe504 	addi	r2,fp,-108
 200171c:	11400204 	addi	r5,r2,8
 2001720:	e0bf4d04 	addi	r2,fp,-716
 2001724:	11000604 	addi	r4,r2,24
 2001728:	e0bf4d04 	addi	r2,fp,-716
 200172c:	10c00204 	addi	r3,r2,8
 2001730:	00800284 	movi	r2,10
 2001734:	d8800115 	stw	r2,4(sp)
 2001738:	e0bf6104 	addi	r2,fp,-636
 200173c:	10801404 	addi	r2,r2,80
 2001740:	d8800015 	stw	r2,0(sp)
 2001744:	300f883a 	mov	r7,r6
 2001748:	280d883a 	mov	r6,r5
 200174c:	200b883a 	mov	r5,r4
 2001750:	1809883a 	mov	r4,r3
 2001754:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[1],ball[4],velocity[1],velocity[4],collision[11],11);
 2001758:	e0bfe504 	addi	r2,fp,-108
 200175c:	11800804 	addi	r6,r2,32
 2001760:	e0bfe504 	addi	r2,fp,-108
 2001764:	11400204 	addi	r5,r2,8
 2001768:	e0bf4d04 	addi	r2,fp,-716
 200176c:	11000804 	addi	r4,r2,32
 2001770:	e0bf4d04 	addi	r2,fp,-716
 2001774:	10c00204 	addi	r3,r2,8
 2001778:	008002c4 	movi	r2,11
 200177c:	d8800115 	stw	r2,4(sp)
 2001780:	e0bf6104 	addi	r2,fp,-636
 2001784:	10801604 	addi	r2,r2,88
 2001788:	d8800015 	stw	r2,0(sp)
 200178c:	300f883a 	mov	r7,r6
 2001790:	280d883a 	mov	r6,r5
 2001794:	200b883a 	mov	r5,r4
 2001798:	1809883a 	mov	r4,r3
 200179c:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[1],ball[5],velocity[1],velocity[5],collision[12],12);
 20017a0:	e0bfe504 	addi	r2,fp,-108
 20017a4:	11800a04 	addi	r6,r2,40
 20017a8:	e0bfe504 	addi	r2,fp,-108
 20017ac:	11400204 	addi	r5,r2,8
 20017b0:	e0bf4d04 	addi	r2,fp,-716
 20017b4:	11000a04 	addi	r4,r2,40
 20017b8:	e0bf4d04 	addi	r2,fp,-716
 20017bc:	10c00204 	addi	r3,r2,8
 20017c0:	00800304 	movi	r2,12
 20017c4:	d8800115 	stw	r2,4(sp)
 20017c8:	e0bf6104 	addi	r2,fp,-636
 20017cc:	10801804 	addi	r2,r2,96
 20017d0:	d8800015 	stw	r2,0(sp)
 20017d4:	300f883a 	mov	r7,r6
 20017d8:	280d883a 	mov	r6,r5
 20017dc:	200b883a 	mov	r5,r4
 20017e0:	1809883a 	mov	r4,r3
 20017e4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[1],ball[6],velocity[1],velocity[6],collision[13],13);
 20017e8:	e0bfe504 	addi	r2,fp,-108
 20017ec:	11800c04 	addi	r6,r2,48
 20017f0:	e0bfe504 	addi	r2,fp,-108
 20017f4:	11400204 	addi	r5,r2,8
 20017f8:	e0bf4d04 	addi	r2,fp,-716
 20017fc:	11000c04 	addi	r4,r2,48
 2001800:	e0bf4d04 	addi	r2,fp,-716
 2001804:	10c00204 	addi	r3,r2,8
 2001808:	00800344 	movi	r2,13
 200180c:	d8800115 	stw	r2,4(sp)
 2001810:	e0bf6104 	addi	r2,fp,-636
 2001814:	10801a04 	addi	r2,r2,104
 2001818:	d8800015 	stw	r2,0(sp)
 200181c:	300f883a 	mov	r7,r6
 2001820:	280d883a 	mov	r6,r5
 2001824:	200b883a 	mov	r5,r4
 2001828:	1809883a 	mov	r4,r3
 200182c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[1],ball[7],velocity[1],velocity[7],collision[14],14);
 2001830:	e0bfe504 	addi	r2,fp,-108
 2001834:	11800e04 	addi	r6,r2,56
 2001838:	e0bfe504 	addi	r2,fp,-108
 200183c:	11400204 	addi	r5,r2,8
 2001840:	e0bf4d04 	addi	r2,fp,-716
 2001844:	11000e04 	addi	r4,r2,56
 2001848:	e0bf4d04 	addi	r2,fp,-716
 200184c:	10c00204 	addi	r3,r2,8
 2001850:	00800384 	movi	r2,14
 2001854:	d8800115 	stw	r2,4(sp)
 2001858:	e0bf6104 	addi	r2,fp,-636
 200185c:	10801c04 	addi	r2,r2,112
 2001860:	d8800015 	stw	r2,0(sp)
 2001864:	300f883a 	mov	r7,r6
 2001868:	280d883a 	mov	r6,r5
 200186c:	200b883a 	mov	r5,r4
 2001870:	1809883a 	mov	r4,r3
 2001874:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[1],ball[8],velocity[1],velocity[8],collision[15],15);
 2001878:	e0bfe504 	addi	r2,fp,-108
 200187c:	11801004 	addi	r6,r2,64
 2001880:	e0bfe504 	addi	r2,fp,-108
 2001884:	11400204 	addi	r5,r2,8
 2001888:	e0bf4d04 	addi	r2,fp,-716
 200188c:	11001004 	addi	r4,r2,64
 2001890:	e0bf4d04 	addi	r2,fp,-716
 2001894:	10c00204 	addi	r3,r2,8
 2001898:	008003c4 	movi	r2,15
 200189c:	d8800115 	stw	r2,4(sp)
 20018a0:	e0bf6104 	addi	r2,fp,-636
 20018a4:	10801e04 	addi	r2,r2,120
 20018a8:	d8800015 	stw	r2,0(sp)
 20018ac:	300f883a 	mov	r7,r6
 20018b0:	280d883a 	mov	r6,r5
 20018b4:	200b883a 	mov	r5,r4
 20018b8:	1809883a 	mov	r4,r3
 20018bc:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[1],ball[9],velocity[1],velocity[9],collision[16],16);
 20018c0:	e0bfe504 	addi	r2,fp,-108
 20018c4:	11801204 	addi	r6,r2,72
 20018c8:	e0bfe504 	addi	r2,fp,-108
 20018cc:	11400204 	addi	r5,r2,8
 20018d0:	e0bf4d04 	addi	r2,fp,-716
 20018d4:	11001204 	addi	r4,r2,72
 20018d8:	e0bf4d04 	addi	r2,fp,-716
 20018dc:	10c00204 	addi	r3,r2,8
 20018e0:	00800404 	movi	r2,16
 20018e4:	d8800115 	stw	r2,4(sp)
 20018e8:	e0bf6104 	addi	r2,fp,-636
 20018ec:	10802004 	addi	r2,r2,128
 20018f0:	d8800015 	stw	r2,0(sp)
 20018f4:	300f883a 	mov	r7,r6
 20018f8:	280d883a 	mov	r6,r5
 20018fc:	200b883a 	mov	r5,r4
 2001900:	1809883a 	mov	r4,r3
 2001904:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[2],ball[3],velocity[2],velocity[3],collision[17],17);
 2001908:	e0bfe504 	addi	r2,fp,-108
 200190c:	11800604 	addi	r6,r2,24
 2001910:	e0bfe504 	addi	r2,fp,-108
 2001914:	11400404 	addi	r5,r2,16
 2001918:	e0bf4d04 	addi	r2,fp,-716
 200191c:	11000604 	addi	r4,r2,24
 2001920:	e0bf4d04 	addi	r2,fp,-716
 2001924:	10c00404 	addi	r3,r2,16
 2001928:	00800444 	movi	r2,17
 200192c:	d8800115 	stw	r2,4(sp)
 2001930:	e0bf6104 	addi	r2,fp,-636
 2001934:	10802204 	addi	r2,r2,136
 2001938:	d8800015 	stw	r2,0(sp)
 200193c:	300f883a 	mov	r7,r6
 2001940:	280d883a 	mov	r6,r5
 2001944:	200b883a 	mov	r5,r4
 2001948:	1809883a 	mov	r4,r3
 200194c:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[4],velocity[2],velocity[4],collision[18],18);
 2001950:	e0bfe504 	addi	r2,fp,-108
 2001954:	11800804 	addi	r6,r2,32
 2001958:	e0bfe504 	addi	r2,fp,-108
 200195c:	11400404 	addi	r5,r2,16
 2001960:	e0bf4d04 	addi	r2,fp,-716
 2001964:	11000804 	addi	r4,r2,32
 2001968:	e0bf4d04 	addi	r2,fp,-716
 200196c:	10c00404 	addi	r3,r2,16
 2001970:	00800484 	movi	r2,18
 2001974:	d8800115 	stw	r2,4(sp)
 2001978:	e0bf6104 	addi	r2,fp,-636
 200197c:	10802404 	addi	r2,r2,144
 2001980:	d8800015 	stw	r2,0(sp)
 2001984:	300f883a 	mov	r7,r6
 2001988:	280d883a 	mov	r6,r5
 200198c:	200b883a 	mov	r5,r4
 2001990:	1809883a 	mov	r4,r3
 2001994:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[5],velocity[2],velocity[5],collision[19],19);
 2001998:	e0bfe504 	addi	r2,fp,-108
 200199c:	11800a04 	addi	r6,r2,40
 20019a0:	e0bfe504 	addi	r2,fp,-108
 20019a4:	11400404 	addi	r5,r2,16
 20019a8:	e0bf4d04 	addi	r2,fp,-716
 20019ac:	11000a04 	addi	r4,r2,40
 20019b0:	e0bf4d04 	addi	r2,fp,-716
 20019b4:	10c00404 	addi	r3,r2,16
 20019b8:	008004c4 	movi	r2,19
 20019bc:	d8800115 	stw	r2,4(sp)
 20019c0:	e0bf6104 	addi	r2,fp,-636
 20019c4:	10802604 	addi	r2,r2,152
 20019c8:	d8800015 	stw	r2,0(sp)
 20019cc:	300f883a 	mov	r7,r6
 20019d0:	280d883a 	mov	r6,r5
 20019d4:	200b883a 	mov	r5,r4
 20019d8:	1809883a 	mov	r4,r3
 20019dc:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[6],velocity[2],velocity[6],collision[20],20);
 20019e0:	e0bfe504 	addi	r2,fp,-108
 20019e4:	11800c04 	addi	r6,r2,48
 20019e8:	e0bfe504 	addi	r2,fp,-108
 20019ec:	11400404 	addi	r5,r2,16
 20019f0:	e0bf4d04 	addi	r2,fp,-716
 20019f4:	11000c04 	addi	r4,r2,48
 20019f8:	e0bf4d04 	addi	r2,fp,-716
 20019fc:	10c00404 	addi	r3,r2,16
 2001a00:	00800504 	movi	r2,20
 2001a04:	d8800115 	stw	r2,4(sp)
 2001a08:	e0bf6104 	addi	r2,fp,-636
 2001a0c:	10802804 	addi	r2,r2,160
 2001a10:	d8800015 	stw	r2,0(sp)
 2001a14:	300f883a 	mov	r7,r6
 2001a18:	280d883a 	mov	r6,r5
 2001a1c:	200b883a 	mov	r5,r4
 2001a20:	1809883a 	mov	r4,r3
 2001a24:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[7],velocity[2],velocity[7],collision[21],21);
 2001a28:	e0bfe504 	addi	r2,fp,-108
 2001a2c:	11800e04 	addi	r6,r2,56
 2001a30:	e0bfe504 	addi	r2,fp,-108
 2001a34:	11400404 	addi	r5,r2,16
 2001a38:	e0bf4d04 	addi	r2,fp,-716
 2001a3c:	11000e04 	addi	r4,r2,56
 2001a40:	e0bf4d04 	addi	r2,fp,-716
 2001a44:	10c00404 	addi	r3,r2,16
 2001a48:	00800544 	movi	r2,21
 2001a4c:	d8800115 	stw	r2,4(sp)
 2001a50:	e0bf6104 	addi	r2,fp,-636
 2001a54:	10802a04 	addi	r2,r2,168
 2001a58:	d8800015 	stw	r2,0(sp)
 2001a5c:	300f883a 	mov	r7,r6
 2001a60:	280d883a 	mov	r6,r5
 2001a64:	200b883a 	mov	r5,r4
 2001a68:	1809883a 	mov	r4,r3
 2001a6c:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[8],velocity[2],velocity[8],collision[22],22);
 2001a70:	e0bfe504 	addi	r2,fp,-108
 2001a74:	11801004 	addi	r6,r2,64
 2001a78:	e0bfe504 	addi	r2,fp,-108
 2001a7c:	11400404 	addi	r5,r2,16
 2001a80:	e0bf4d04 	addi	r2,fp,-716
 2001a84:	11001004 	addi	r4,r2,64
 2001a88:	e0bf4d04 	addi	r2,fp,-716
 2001a8c:	10c00404 	addi	r3,r2,16
 2001a90:	00800584 	movi	r2,22
 2001a94:	d8800115 	stw	r2,4(sp)
 2001a98:	e0bf6104 	addi	r2,fp,-636
 2001a9c:	10802c04 	addi	r2,r2,176
 2001aa0:	d8800015 	stw	r2,0(sp)
 2001aa4:	300f883a 	mov	r7,r6
 2001aa8:	280d883a 	mov	r6,r5
 2001aac:	200b883a 	mov	r5,r4
 2001ab0:	1809883a 	mov	r4,r3
 2001ab4:	2002ecc0 	call	2002ecc <collide_calc>
       collide_calc(ball[2],ball[9],velocity[2],velocity[9],collision[23],23);
 2001ab8:	e0bfe504 	addi	r2,fp,-108
 2001abc:	11801204 	addi	r6,r2,72
 2001ac0:	e0bfe504 	addi	r2,fp,-108
 2001ac4:	11400404 	addi	r5,r2,16
 2001ac8:	e0bf4d04 	addi	r2,fp,-716
 2001acc:	11001204 	addi	r4,r2,72
 2001ad0:	e0bf4d04 	addi	r2,fp,-716
 2001ad4:	10c00404 	addi	r3,r2,16
 2001ad8:	008005c4 	movi	r2,23
 2001adc:	d8800115 	stw	r2,4(sp)
 2001ae0:	e0bf6104 	addi	r2,fp,-636
 2001ae4:	10802e04 	addi	r2,r2,184
 2001ae8:	d8800015 	stw	r2,0(sp)
 2001aec:	300f883a 	mov	r7,r6
 2001af0:	280d883a 	mov	r6,r5
 2001af4:	200b883a 	mov	r5,r4
 2001af8:	1809883a 	mov	r4,r3
 2001afc:	2002ecc0 	call	2002ecc <collide_calc>

       collide_calc(ball[3],ball[4],velocity[3],velocity[4],collision[24],24);
 2001b00:	e0bfe504 	addi	r2,fp,-108
 2001b04:	11800804 	addi	r6,r2,32
 2001b08:	e0bfe504 	addi	r2,fp,-108
 2001b0c:	11400604 	addi	r5,r2,24
 2001b10:	e0bf4d04 	addi	r2,fp,-716
 2001b14:	11000804 	addi	r4,r2,32
 2001b18:	e0bf4d04 	addi	r2,fp,-716
 2001b1c:	10c00604 	addi	r3,r2,24
 2001b20:	00800604 	movi	r2,24
 2001b24:	d8800115 	stw	r2,4(sp)
 2001b28:	e0bf6104 	addi	r2,fp,-636
 2001b2c:	10803004 	addi	r2,r2,192
 2001b30:	d8800015 	stw	r2,0(sp)
 2001b34:	300f883a 	mov	r7,r6
 2001b38:	280d883a 	mov	r6,r5
 2001b3c:	200b883a 	mov	r5,r4
 2001b40:	1809883a 	mov	r4,r3
 2001b44:	2002ecc0 	call	2002ecc <collide_calc>
 	   collide_calc(ball[3],ball[5],velocity[3],velocity[5],collision[25],25);
 2001b48:	e0bfe504 	addi	r2,fp,-108
 2001b4c:	11800a04 	addi	r6,r2,40
 2001b50:	e0bfe504 	addi	r2,fp,-108
 2001b54:	11400604 	addi	r5,r2,24
 2001b58:	e0bf4d04 	addi	r2,fp,-716
 2001b5c:	11000a04 	addi	r4,r2,40
 2001b60:	e0bf4d04 	addi	r2,fp,-716
 2001b64:	10c00604 	addi	r3,r2,24
 2001b68:	00800644 	movi	r2,25
 2001b6c:	d8800115 	stw	r2,4(sp)
 2001b70:	e0bf6104 	addi	r2,fp,-636
 2001b74:	10803204 	addi	r2,r2,200
 2001b78:	d8800015 	stw	r2,0(sp)
 2001b7c:	300f883a 	mov	r7,r6
 2001b80:	280d883a 	mov	r6,r5
 2001b84:	200b883a 	mov	r5,r4
 2001b88:	1809883a 	mov	r4,r3
 2001b8c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[3],ball[6],velocity[3],velocity[6],collision[26],26);
 2001b90:	e0bfe504 	addi	r2,fp,-108
 2001b94:	11800c04 	addi	r6,r2,48
 2001b98:	e0bfe504 	addi	r2,fp,-108
 2001b9c:	11400604 	addi	r5,r2,24
 2001ba0:	e0bf4d04 	addi	r2,fp,-716
 2001ba4:	11000c04 	addi	r4,r2,48
 2001ba8:	e0bf4d04 	addi	r2,fp,-716
 2001bac:	10c00604 	addi	r3,r2,24
 2001bb0:	00800684 	movi	r2,26
 2001bb4:	d8800115 	stw	r2,4(sp)
 2001bb8:	e0bf6104 	addi	r2,fp,-636
 2001bbc:	10803404 	addi	r2,r2,208
 2001bc0:	d8800015 	stw	r2,0(sp)
 2001bc4:	300f883a 	mov	r7,r6
 2001bc8:	280d883a 	mov	r6,r5
 2001bcc:	200b883a 	mov	r5,r4
 2001bd0:	1809883a 	mov	r4,r3
 2001bd4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[3],ball[7],velocity[3],velocity[7],collision[27],27);
 2001bd8:	e0bfe504 	addi	r2,fp,-108
 2001bdc:	11800e04 	addi	r6,r2,56
 2001be0:	e0bfe504 	addi	r2,fp,-108
 2001be4:	11400604 	addi	r5,r2,24
 2001be8:	e0bf4d04 	addi	r2,fp,-716
 2001bec:	11000e04 	addi	r4,r2,56
 2001bf0:	e0bf4d04 	addi	r2,fp,-716
 2001bf4:	10c00604 	addi	r3,r2,24
 2001bf8:	008006c4 	movi	r2,27
 2001bfc:	d8800115 	stw	r2,4(sp)
 2001c00:	e0bf6104 	addi	r2,fp,-636
 2001c04:	10803604 	addi	r2,r2,216
 2001c08:	d8800015 	stw	r2,0(sp)
 2001c0c:	300f883a 	mov	r7,r6
 2001c10:	280d883a 	mov	r6,r5
 2001c14:	200b883a 	mov	r5,r4
 2001c18:	1809883a 	mov	r4,r3
 2001c1c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[3],ball[8],velocity[3],velocity[8],collision[28],28);
 2001c20:	e0bfe504 	addi	r2,fp,-108
 2001c24:	11801004 	addi	r6,r2,64
 2001c28:	e0bfe504 	addi	r2,fp,-108
 2001c2c:	11400604 	addi	r5,r2,24
 2001c30:	e0bf4d04 	addi	r2,fp,-716
 2001c34:	11001004 	addi	r4,r2,64
 2001c38:	e0bf4d04 	addi	r2,fp,-716
 2001c3c:	10c00604 	addi	r3,r2,24
 2001c40:	00800704 	movi	r2,28
 2001c44:	d8800115 	stw	r2,4(sp)
 2001c48:	e0bf6104 	addi	r2,fp,-636
 2001c4c:	10803804 	addi	r2,r2,224
 2001c50:	d8800015 	stw	r2,0(sp)
 2001c54:	300f883a 	mov	r7,r6
 2001c58:	280d883a 	mov	r6,r5
 2001c5c:	200b883a 	mov	r5,r4
 2001c60:	1809883a 	mov	r4,r3
 2001c64:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[3],ball[9],velocity[3],velocity[9],collision[29],29);
 2001c68:	e0bfe504 	addi	r2,fp,-108
 2001c6c:	11801204 	addi	r6,r2,72
 2001c70:	e0bfe504 	addi	r2,fp,-108
 2001c74:	11400604 	addi	r5,r2,24
 2001c78:	e0bf4d04 	addi	r2,fp,-716
 2001c7c:	11001204 	addi	r4,r2,72
 2001c80:	e0bf4d04 	addi	r2,fp,-716
 2001c84:	10c00604 	addi	r3,r2,24
 2001c88:	00800744 	movi	r2,29
 2001c8c:	d8800115 	stw	r2,4(sp)
 2001c90:	e0bf6104 	addi	r2,fp,-636
 2001c94:	10803a04 	addi	r2,r2,232
 2001c98:	d8800015 	stw	r2,0(sp)
 2001c9c:	300f883a 	mov	r7,r6
 2001ca0:	280d883a 	mov	r6,r5
 2001ca4:	200b883a 	mov	r5,r4
 2001ca8:	1809883a 	mov	r4,r3
 2001cac:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[4],ball[5],velocity[4],velocity[5],collision[30],30);
 2001cb0:	e0bfe504 	addi	r2,fp,-108
 2001cb4:	11800a04 	addi	r6,r2,40
 2001cb8:	e0bfe504 	addi	r2,fp,-108
 2001cbc:	11400804 	addi	r5,r2,32
 2001cc0:	e0bf4d04 	addi	r2,fp,-716
 2001cc4:	11000a04 	addi	r4,r2,40
 2001cc8:	e0bf4d04 	addi	r2,fp,-716
 2001ccc:	10c00804 	addi	r3,r2,32
 2001cd0:	00800784 	movi	r2,30
 2001cd4:	d8800115 	stw	r2,4(sp)
 2001cd8:	e0bf6104 	addi	r2,fp,-636
 2001cdc:	10803c04 	addi	r2,r2,240
 2001ce0:	d8800015 	stw	r2,0(sp)
 2001ce4:	300f883a 	mov	r7,r6
 2001ce8:	280d883a 	mov	r6,r5
 2001cec:	200b883a 	mov	r5,r4
 2001cf0:	1809883a 	mov	r4,r3
 2001cf4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[4],ball[6],velocity[4],velocity[6],collision[31],31);
 2001cf8:	e0bfe504 	addi	r2,fp,-108
 2001cfc:	11800c04 	addi	r6,r2,48
 2001d00:	e0bfe504 	addi	r2,fp,-108
 2001d04:	11400804 	addi	r5,r2,32
 2001d08:	e0bf4d04 	addi	r2,fp,-716
 2001d0c:	11000c04 	addi	r4,r2,48
 2001d10:	e0bf4d04 	addi	r2,fp,-716
 2001d14:	10c00804 	addi	r3,r2,32
 2001d18:	008007c4 	movi	r2,31
 2001d1c:	d8800115 	stw	r2,4(sp)
 2001d20:	e0bf6104 	addi	r2,fp,-636
 2001d24:	10803e04 	addi	r2,r2,248
 2001d28:	d8800015 	stw	r2,0(sp)
 2001d2c:	300f883a 	mov	r7,r6
 2001d30:	280d883a 	mov	r6,r5
 2001d34:	200b883a 	mov	r5,r4
 2001d38:	1809883a 	mov	r4,r3
 2001d3c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[4],ball[7],velocity[4],velocity[7],collision[32],32);
 2001d40:	e0bfe504 	addi	r2,fp,-108
 2001d44:	11800e04 	addi	r6,r2,56
 2001d48:	e0bfe504 	addi	r2,fp,-108
 2001d4c:	11400804 	addi	r5,r2,32
 2001d50:	e0bf4d04 	addi	r2,fp,-716
 2001d54:	11000e04 	addi	r4,r2,56
 2001d58:	e0bf4d04 	addi	r2,fp,-716
 2001d5c:	10c00804 	addi	r3,r2,32
 2001d60:	00800804 	movi	r2,32
 2001d64:	d8800115 	stw	r2,4(sp)
 2001d68:	e0bf6104 	addi	r2,fp,-636
 2001d6c:	10804004 	addi	r2,r2,256
 2001d70:	d8800015 	stw	r2,0(sp)
 2001d74:	300f883a 	mov	r7,r6
 2001d78:	280d883a 	mov	r6,r5
 2001d7c:	200b883a 	mov	r5,r4
 2001d80:	1809883a 	mov	r4,r3
 2001d84:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[4],ball[8],velocity[4],velocity[8],collision[33],33);
 2001d88:	e0bfe504 	addi	r2,fp,-108
 2001d8c:	11801004 	addi	r6,r2,64
 2001d90:	e0bfe504 	addi	r2,fp,-108
 2001d94:	11400804 	addi	r5,r2,32
 2001d98:	e0bf4d04 	addi	r2,fp,-716
 2001d9c:	11001004 	addi	r4,r2,64
 2001da0:	e0bf4d04 	addi	r2,fp,-716
 2001da4:	10c00804 	addi	r3,r2,32
 2001da8:	00800844 	movi	r2,33
 2001dac:	d8800115 	stw	r2,4(sp)
 2001db0:	e0bf6104 	addi	r2,fp,-636
 2001db4:	10804204 	addi	r2,r2,264
 2001db8:	d8800015 	stw	r2,0(sp)
 2001dbc:	300f883a 	mov	r7,r6
 2001dc0:	280d883a 	mov	r6,r5
 2001dc4:	200b883a 	mov	r5,r4
 2001dc8:	1809883a 	mov	r4,r3
 2001dcc:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[4],ball[9],velocity[4],velocity[9],collision[34],34);
 2001dd0:	e0bfe504 	addi	r2,fp,-108
 2001dd4:	11801204 	addi	r6,r2,72
 2001dd8:	e0bfe504 	addi	r2,fp,-108
 2001ddc:	11400804 	addi	r5,r2,32
 2001de0:	e0bf4d04 	addi	r2,fp,-716
 2001de4:	11001204 	addi	r4,r2,72
 2001de8:	e0bf4d04 	addi	r2,fp,-716
 2001dec:	10c00804 	addi	r3,r2,32
 2001df0:	00800884 	movi	r2,34
 2001df4:	d8800115 	stw	r2,4(sp)
 2001df8:	e0bf6104 	addi	r2,fp,-636
 2001dfc:	10804404 	addi	r2,r2,272
 2001e00:	d8800015 	stw	r2,0(sp)
 2001e04:	300f883a 	mov	r7,r6
 2001e08:	280d883a 	mov	r6,r5
 2001e0c:	200b883a 	mov	r5,r4
 2001e10:	1809883a 	mov	r4,r3
 2001e14:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[5],ball[6],velocity[5],velocity[6],collision[35],35);
 2001e18:	e0bfe504 	addi	r2,fp,-108
 2001e1c:	11800c04 	addi	r6,r2,48
 2001e20:	e0bfe504 	addi	r2,fp,-108
 2001e24:	11400a04 	addi	r5,r2,40
 2001e28:	e0bf4d04 	addi	r2,fp,-716
 2001e2c:	11000c04 	addi	r4,r2,48
 2001e30:	e0bf4d04 	addi	r2,fp,-716
 2001e34:	10c00a04 	addi	r3,r2,40
 2001e38:	008008c4 	movi	r2,35
 2001e3c:	d8800115 	stw	r2,4(sp)
 2001e40:	e0bf6104 	addi	r2,fp,-636
 2001e44:	10804604 	addi	r2,r2,280
 2001e48:	d8800015 	stw	r2,0(sp)
 2001e4c:	300f883a 	mov	r7,r6
 2001e50:	280d883a 	mov	r6,r5
 2001e54:	200b883a 	mov	r5,r4
 2001e58:	1809883a 	mov	r4,r3
 2001e5c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[5],ball[7],velocity[5],velocity[7],collision[36],36);
 2001e60:	e0bfe504 	addi	r2,fp,-108
 2001e64:	11800e04 	addi	r6,r2,56
 2001e68:	e0bfe504 	addi	r2,fp,-108
 2001e6c:	11400a04 	addi	r5,r2,40
 2001e70:	e0bf4d04 	addi	r2,fp,-716
 2001e74:	11000e04 	addi	r4,r2,56
 2001e78:	e0bf4d04 	addi	r2,fp,-716
 2001e7c:	10c00a04 	addi	r3,r2,40
 2001e80:	00800904 	movi	r2,36
 2001e84:	d8800115 	stw	r2,4(sp)
 2001e88:	e0bf6104 	addi	r2,fp,-636
 2001e8c:	10804804 	addi	r2,r2,288
 2001e90:	d8800015 	stw	r2,0(sp)
 2001e94:	300f883a 	mov	r7,r6
 2001e98:	280d883a 	mov	r6,r5
 2001e9c:	200b883a 	mov	r5,r4
 2001ea0:	1809883a 	mov	r4,r3
 2001ea4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[5],ball[8],velocity[5],velocity[8],collision[37],37);
 2001ea8:	e0bfe504 	addi	r2,fp,-108
 2001eac:	11801004 	addi	r6,r2,64
 2001eb0:	e0bfe504 	addi	r2,fp,-108
 2001eb4:	11400a04 	addi	r5,r2,40
 2001eb8:	e0bf4d04 	addi	r2,fp,-716
 2001ebc:	11001004 	addi	r4,r2,64
 2001ec0:	e0bf4d04 	addi	r2,fp,-716
 2001ec4:	10c00a04 	addi	r3,r2,40
 2001ec8:	00800944 	movi	r2,37
 2001ecc:	d8800115 	stw	r2,4(sp)
 2001ed0:	e0bf6104 	addi	r2,fp,-636
 2001ed4:	10804a04 	addi	r2,r2,296
 2001ed8:	d8800015 	stw	r2,0(sp)
 2001edc:	300f883a 	mov	r7,r6
 2001ee0:	280d883a 	mov	r6,r5
 2001ee4:	200b883a 	mov	r5,r4
 2001ee8:	1809883a 	mov	r4,r3
 2001eec:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[5],ball[9],velocity[5],velocity[9],collision[38],38);
 2001ef0:	e0bfe504 	addi	r2,fp,-108
 2001ef4:	11801204 	addi	r6,r2,72
 2001ef8:	e0bfe504 	addi	r2,fp,-108
 2001efc:	11400a04 	addi	r5,r2,40
 2001f00:	e0bf4d04 	addi	r2,fp,-716
 2001f04:	11001204 	addi	r4,r2,72
 2001f08:	e0bf4d04 	addi	r2,fp,-716
 2001f0c:	10c00a04 	addi	r3,r2,40
 2001f10:	00800984 	movi	r2,38
 2001f14:	d8800115 	stw	r2,4(sp)
 2001f18:	e0bf6104 	addi	r2,fp,-636
 2001f1c:	10804c04 	addi	r2,r2,304
 2001f20:	d8800015 	stw	r2,0(sp)
 2001f24:	300f883a 	mov	r7,r6
 2001f28:	280d883a 	mov	r6,r5
 2001f2c:	200b883a 	mov	r5,r4
 2001f30:	1809883a 	mov	r4,r3
 2001f34:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[6],ball[7],velocity[6],velocity[7],collision[39],39);
 2001f38:	e0bfe504 	addi	r2,fp,-108
 2001f3c:	11800e04 	addi	r6,r2,56
 2001f40:	e0bfe504 	addi	r2,fp,-108
 2001f44:	11400c04 	addi	r5,r2,48
 2001f48:	e0bf4d04 	addi	r2,fp,-716
 2001f4c:	11000e04 	addi	r4,r2,56
 2001f50:	e0bf4d04 	addi	r2,fp,-716
 2001f54:	10c00c04 	addi	r3,r2,48
 2001f58:	008009c4 	movi	r2,39
 2001f5c:	d8800115 	stw	r2,4(sp)
 2001f60:	e0bf6104 	addi	r2,fp,-636
 2001f64:	10804e04 	addi	r2,r2,312
 2001f68:	d8800015 	stw	r2,0(sp)
 2001f6c:	300f883a 	mov	r7,r6
 2001f70:	280d883a 	mov	r6,r5
 2001f74:	200b883a 	mov	r5,r4
 2001f78:	1809883a 	mov	r4,r3
 2001f7c:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[6],ball[8],velocity[6],velocity[8],collision[40],40);
 2001f80:	e0bfe504 	addi	r2,fp,-108
 2001f84:	11801004 	addi	r6,r2,64
 2001f88:	e0bfe504 	addi	r2,fp,-108
 2001f8c:	11400c04 	addi	r5,r2,48
 2001f90:	e0bf4d04 	addi	r2,fp,-716
 2001f94:	11001004 	addi	r4,r2,64
 2001f98:	e0bf4d04 	addi	r2,fp,-716
 2001f9c:	10c00c04 	addi	r3,r2,48
 2001fa0:	00800a04 	movi	r2,40
 2001fa4:	d8800115 	stw	r2,4(sp)
 2001fa8:	e0bf6104 	addi	r2,fp,-636
 2001fac:	10805004 	addi	r2,r2,320
 2001fb0:	d8800015 	stw	r2,0(sp)
 2001fb4:	300f883a 	mov	r7,r6
 2001fb8:	280d883a 	mov	r6,r5
 2001fbc:	200b883a 	mov	r5,r4
 2001fc0:	1809883a 	mov	r4,r3
 2001fc4:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[6],ball[9],velocity[6],velocity[9],collision[41],41);
 2001fc8:	e0bfe504 	addi	r2,fp,-108
 2001fcc:	11801204 	addi	r6,r2,72
 2001fd0:	e0bfe504 	addi	r2,fp,-108
 2001fd4:	11400c04 	addi	r5,r2,48
 2001fd8:	e0bf4d04 	addi	r2,fp,-716
 2001fdc:	11001204 	addi	r4,r2,72
 2001fe0:	e0bf4d04 	addi	r2,fp,-716
 2001fe4:	10c00c04 	addi	r3,r2,48
 2001fe8:	00800a44 	movi	r2,41
 2001fec:	d8800115 	stw	r2,4(sp)
 2001ff0:	e0bf6104 	addi	r2,fp,-636
 2001ff4:	10805204 	addi	r2,r2,328
 2001ff8:	d8800015 	stw	r2,0(sp)
 2001ffc:	300f883a 	mov	r7,r6
 2002000:	280d883a 	mov	r6,r5
 2002004:	200b883a 	mov	r5,r4
 2002008:	1809883a 	mov	r4,r3
 200200c:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[7],ball[8],velocity[7],velocity[8],collision[42],42);
 2002010:	e0bfe504 	addi	r2,fp,-108
 2002014:	11801004 	addi	r6,r2,64
 2002018:	e0bfe504 	addi	r2,fp,-108
 200201c:	11400e04 	addi	r5,r2,56
 2002020:	e0bf4d04 	addi	r2,fp,-716
 2002024:	11001004 	addi	r4,r2,64
 2002028:	e0bf4d04 	addi	r2,fp,-716
 200202c:	10c00e04 	addi	r3,r2,56
 2002030:	00800a84 	movi	r2,42
 2002034:	d8800115 	stw	r2,4(sp)
 2002038:	e0bf6104 	addi	r2,fp,-636
 200203c:	10805404 	addi	r2,r2,336
 2002040:	d8800015 	stw	r2,0(sp)
 2002044:	300f883a 	mov	r7,r6
 2002048:	280d883a 	mov	r6,r5
 200204c:	200b883a 	mov	r5,r4
 2002050:	1809883a 	mov	r4,r3
 2002054:	2002ecc0 	call	2002ecc <collide_calc>
	   collide_calc(ball[7],ball[9],velocity[7],velocity[9],collision[43],43);
 2002058:	e0bfe504 	addi	r2,fp,-108
 200205c:	11801204 	addi	r6,r2,72
 2002060:	e0bfe504 	addi	r2,fp,-108
 2002064:	11400e04 	addi	r5,r2,56
 2002068:	e0bf4d04 	addi	r2,fp,-716
 200206c:	11001204 	addi	r4,r2,72
 2002070:	e0bf4d04 	addi	r2,fp,-716
 2002074:	10c00e04 	addi	r3,r2,56
 2002078:	00800ac4 	movi	r2,43
 200207c:	d8800115 	stw	r2,4(sp)
 2002080:	e0bf6104 	addi	r2,fp,-636
 2002084:	10805604 	addi	r2,r2,344
 2002088:	d8800015 	stw	r2,0(sp)
 200208c:	300f883a 	mov	r7,r6
 2002090:	280d883a 	mov	r6,r5
 2002094:	200b883a 	mov	r5,r4
 2002098:	1809883a 	mov	r4,r3
 200209c:	2002ecc0 	call	2002ecc <collide_calc>

	   collide_calc(ball[8],ball[9],velocity[7],velocity[9],collision[44],44);
 20020a0:	e0bfe504 	addi	r2,fp,-108
 20020a4:	11801204 	addi	r6,r2,72
 20020a8:	e0bfe504 	addi	r2,fp,-108
 20020ac:	11400e04 	addi	r5,r2,56
 20020b0:	e0bf4d04 	addi	r2,fp,-716
 20020b4:	11001204 	addi	r4,r2,72
 20020b8:	e0bf4d04 	addi	r2,fp,-716
 20020bc:	10c01004 	addi	r3,r2,64
 20020c0:	00800b04 	movi	r2,44
 20020c4:	d8800115 	stw	r2,4(sp)
 20020c8:	e0bf6104 	addi	r2,fp,-636
 20020cc:	10805804 	addi	r2,r2,352
 20020d0:	d8800015 	stw	r2,0(sp)
 20020d4:	300f883a 	mov	r7,r6
 20020d8:	280d883a 	mov	r6,r5
 20020dc:	200b883a 	mov	r5,r4
 20020e0:	1809883a 	mov	r4,r3
 20020e4:	2002ecc0 	call	2002ecc <collide_calc>


	   // Damping factor

  	   damping(velocity[0]);
 20020e8:	e0bfe504 	addi	r2,fp,-108
 20020ec:	1009883a 	mov	r4,r2
 20020f0:	20034180 	call	2003418 <damping>
  	   damping(velocity[1]);
 20020f4:	e0bfe504 	addi	r2,fp,-108
 20020f8:	10800204 	addi	r2,r2,8
 20020fc:	1009883a 	mov	r4,r2
 2002100:	20034180 	call	2003418 <damping>
  	   damping(velocity[2]);
 2002104:	e0bfe504 	addi	r2,fp,-108
 2002108:	10800404 	addi	r2,r2,16
 200210c:	1009883a 	mov	r4,r2
 2002110:	20034180 	call	2003418 <damping>
  	   damping(velocity[3]);
 2002114:	e0bfe504 	addi	r2,fp,-108
 2002118:	10800604 	addi	r2,r2,24
 200211c:	1009883a 	mov	r4,r2
 2002120:	20034180 	call	2003418 <damping>
  	   damping(velocity[4]);
 2002124:	e0bfe504 	addi	r2,fp,-108
 2002128:	10800804 	addi	r2,r2,32
 200212c:	1009883a 	mov	r4,r2
 2002130:	20034180 	call	2003418 <damping>
  	   damping(velocity[5]);
 2002134:	e0bfe504 	addi	r2,fp,-108
 2002138:	10800a04 	addi	r2,r2,40
 200213c:	1009883a 	mov	r4,r2
 2002140:	20034180 	call	2003418 <damping>
  	   damping(velocity[6]);
 2002144:	e0bfe504 	addi	r2,fp,-108
 2002148:	10800c04 	addi	r2,r2,48
 200214c:	1009883a 	mov	r4,r2
 2002150:	20034180 	call	2003418 <damping>
  	   damping(velocity[7]);
 2002154:	e0bfe504 	addi	r2,fp,-108
 2002158:	10800e04 	addi	r2,r2,56
 200215c:	1009883a 	mov	r4,r2
 2002160:	20034180 	call	2003418 <damping>
  	   damping(velocity[8]);
 2002164:	e0bfe504 	addi	r2,fp,-108
 2002168:	10801004 	addi	r2,r2,64
 200216c:	1009883a 	mov	r4,r2
 2002170:	20034180 	call	2003418 <damping>
  	   damping(velocity[9]);
 2002174:	e0bfe504 	addi	r2,fp,-108
 2002178:	10801204 	addi	r2,r2,72
 200217c:	1009883a 	mov	r4,r2
 2002180:	20034180 	call	2003418 <damping>

       speed=momentum(velocity[0])+momentum(velocity[1])+momentum(velocity[2])
 2002184:	e0bfe504 	addi	r2,fp,-108
 2002188:	1009883a 	mov	r4,r2
 200218c:	2002da80 	call	2002da8 <momentum>
 2002190:	1021883a 	mov	r16,r2
 2002194:	e0bfe504 	addi	r2,fp,-108
 2002198:	10800204 	addi	r2,r2,8
 200219c:	1009883a 	mov	r4,r2
 20021a0:	2002da80 	call	2002da8 <momentum>
 20021a4:	1007883a 	mov	r3,r2
 20021a8:	80e1ff72 	custom	253,r16,r16,r3
 20021ac:	e0bfe504 	addi	r2,fp,-108
 20021b0:	10800404 	addi	r2,r2,16
 20021b4:	1009883a 	mov	r4,r2
 20021b8:	2002da80 	call	2002da8 <momentum>
 20021bc:	1007883a 	mov	r3,r2
 20021c0:	80e1ff72 	custom	253,r16,r16,r3
    		+momentum(velocity[3])+momentum(velocity[4])+momentum(velocity[5])
 20021c4:	e0bfe504 	addi	r2,fp,-108
 20021c8:	10800604 	addi	r2,r2,24
 20021cc:	1009883a 	mov	r4,r2
 20021d0:	2002da80 	call	2002da8 <momentum>
 20021d4:	1007883a 	mov	r3,r2
 20021d8:	80e1ff72 	custom	253,r16,r16,r3
 20021dc:	e0bfe504 	addi	r2,fp,-108
 20021e0:	10800804 	addi	r2,r2,32
 20021e4:	1009883a 	mov	r4,r2
 20021e8:	2002da80 	call	2002da8 <momentum>
 20021ec:	1007883a 	mov	r3,r2
 20021f0:	80e1ff72 	custom	253,r16,r16,r3
 20021f4:	e0bfe504 	addi	r2,fp,-108
 20021f8:	10800a04 	addi	r2,r2,40
 20021fc:	1009883a 	mov	r4,r2
 2002200:	2002da80 	call	2002da8 <momentum>
 2002204:	1007883a 	mov	r3,r2
 2002208:	80e1ff72 	custom	253,r16,r16,r3
    		+momentum(velocity[6])+momentum(velocity[7])+momentum(velocity[8])
 200220c:	e0bfe504 	addi	r2,fp,-108
 2002210:	10800c04 	addi	r2,r2,48
 2002214:	1009883a 	mov	r4,r2
 2002218:	2002da80 	call	2002da8 <momentum>
 200221c:	1007883a 	mov	r3,r2
 2002220:	80e1ff72 	custom	253,r16,r16,r3
 2002224:	e0bfe504 	addi	r2,fp,-108
 2002228:	10800e04 	addi	r2,r2,56
 200222c:	1009883a 	mov	r4,r2
 2002230:	2002da80 	call	2002da8 <momentum>
 2002234:	1007883a 	mov	r3,r2
 2002238:	80e1ff72 	custom	253,r16,r16,r3
 200223c:	e0bfe504 	addi	r2,fp,-108
 2002240:	10801004 	addi	r2,r2,64
 2002244:	1009883a 	mov	r4,r2
 2002248:	2002da80 	call	2002da8 <momentum>
 200224c:	1007883a 	mov	r3,r2
 2002250:	80e1ff72 	custom	253,r16,r16,r3
    		+momentum(velocity[9]);
 2002254:	e0bfe504 	addi	r2,fp,-108
 2002258:	10801204 	addi	r2,r2,72
 200225c:	1009883a 	mov	r4,r2
 2002260:	2002da80 	call	2002da8 <momentum>
 2002264:	1007883a 	mov	r3,r2
  	   damping(velocity[6]);
  	   damping(velocity[7]);
  	   damping(velocity[8]);
  	   damping(velocity[9]);

       speed=momentum(velocity[0])+momentum(velocity[1])+momentum(velocity[2])
 2002268:	80c5ff72 	custom	253,r2,r16,r3
 200226c:	e0bf4315 	stw	r2,-756(fp)
    		+momentum(velocity[3])+momentum(velocity[4])+momentum(velocity[5])
    		+momentum(velocity[6])+momentum(velocity[7])+momentum(velocity[8])
    		+momentum(velocity[9]);


       IOWR(display,1,((int)  (ball[0][1]) << 10) + (int) (ball[0][0]));
 2002270:	e0bf4417 	ldw	r2,-752(fp)
 2002274:	10800104 	addi	r2,r2,4
 2002278:	e0ff4e17 	ldw	r3,-712(fp)
 200227c:	1807fe72 	custom	249,r3,r3,zero
 2002280:	180892ba 	slli	r4,r3,10
 2002284:	e0ff4d17 	ldw	r3,-716(fp)
 2002288:	1807fe72 	custom	249,r3,r3,zero
 200228c:	20c7883a 	add	r3,r4,r3
 2002290:	10c00035 	stwio	r3,0(r2)
       IOWR(display,2,((int)  (ball[1][1]) << 10) + (int) (ball[1][0]));
 2002294:	e0bf4417 	ldw	r2,-752(fp)
 2002298:	10800204 	addi	r2,r2,8
 200229c:	e0ff5017 	ldw	r3,-704(fp)
 20022a0:	1807fe72 	custom	249,r3,r3,zero
 20022a4:	180892ba 	slli	r4,r3,10
 20022a8:	e0ff4f17 	ldw	r3,-708(fp)
 20022ac:	1807fe72 	custom	249,r3,r3,zero
 20022b0:	20c7883a 	add	r3,r4,r3
 20022b4:	10c00035 	stwio	r3,0(r2)
       IOWR(display,3,((int)  (ball[2][1]) << 10) + (int) (ball[2][0]));
 20022b8:	e0bf4417 	ldw	r2,-752(fp)
 20022bc:	10800304 	addi	r2,r2,12
 20022c0:	e0ff5217 	ldw	r3,-696(fp)
 20022c4:	1807fe72 	custom	249,r3,r3,zero
 20022c8:	180892ba 	slli	r4,r3,10
 20022cc:	e0ff5117 	ldw	r3,-700(fp)
 20022d0:	1807fe72 	custom	249,r3,r3,zero
 20022d4:	20c7883a 	add	r3,r4,r3
 20022d8:	10c00035 	stwio	r3,0(r2)
       IOWR(display,4,((int)  (ball[3][1]) << 10) + (int) (ball[3][0]));
 20022dc:	e0bf4417 	ldw	r2,-752(fp)
 20022e0:	10800404 	addi	r2,r2,16
 20022e4:	e0ff5417 	ldw	r3,-688(fp)
 20022e8:	1807fe72 	custom	249,r3,r3,zero
 20022ec:	180892ba 	slli	r4,r3,10
 20022f0:	e0ff5317 	ldw	r3,-692(fp)
 20022f4:	1807fe72 	custom	249,r3,r3,zero
 20022f8:	20c7883a 	add	r3,r4,r3
 20022fc:	10c00035 	stwio	r3,0(r2)
       IOWR(display,5,((int)  (ball[4][1]) << 10) + (int) (ball[4][0]));
 2002300:	e0bf4417 	ldw	r2,-752(fp)
 2002304:	10800504 	addi	r2,r2,20
 2002308:	e0ff5617 	ldw	r3,-680(fp)
 200230c:	1807fe72 	custom	249,r3,r3,zero
 2002310:	180892ba 	slli	r4,r3,10
 2002314:	e0ff5517 	ldw	r3,-684(fp)
 2002318:	1807fe72 	custom	249,r3,r3,zero
 200231c:	20c7883a 	add	r3,r4,r3
 2002320:	10c00035 	stwio	r3,0(r2)
       IOWR(display,6,((int)  (ball[5][1]) << 10) + (int) (ball[5][0]));
 2002324:	e0bf4417 	ldw	r2,-752(fp)
 2002328:	10800604 	addi	r2,r2,24
 200232c:	e0ff5817 	ldw	r3,-672(fp)
 2002330:	1807fe72 	custom	249,r3,r3,zero
 2002334:	180892ba 	slli	r4,r3,10
 2002338:	e0ff5717 	ldw	r3,-676(fp)
 200233c:	1807fe72 	custom	249,r3,r3,zero
 2002340:	20c7883a 	add	r3,r4,r3
 2002344:	10c00035 	stwio	r3,0(r2)
       IOWR(display,7,((int)  (ball[6][1]) << 10) + (int) (ball[6][0]));
 2002348:	e0bf4417 	ldw	r2,-752(fp)
 200234c:	10800704 	addi	r2,r2,28
 2002350:	e0ff5a17 	ldw	r3,-664(fp)
 2002354:	1807fe72 	custom	249,r3,r3,zero
 2002358:	180892ba 	slli	r4,r3,10
 200235c:	e0ff5917 	ldw	r3,-668(fp)
 2002360:	1807fe72 	custom	249,r3,r3,zero
 2002364:	20c7883a 	add	r3,r4,r3
 2002368:	10c00035 	stwio	r3,0(r2)
       IOWR(display,8,((int)  (ball[7][1]) << 10) + (int) (ball[7][0]));
 200236c:	e0bf4417 	ldw	r2,-752(fp)
 2002370:	10800804 	addi	r2,r2,32
 2002374:	e0ff5c17 	ldw	r3,-656(fp)
 2002378:	1807fe72 	custom	249,r3,r3,zero
 200237c:	180892ba 	slli	r4,r3,10
 2002380:	e0ff5b17 	ldw	r3,-660(fp)
 2002384:	1807fe72 	custom	249,r3,r3,zero
 2002388:	20c7883a 	add	r3,r4,r3
 200238c:	10c00035 	stwio	r3,0(r2)
       IOWR(display,9,((int)  (ball[8][1]) << 10) + (int) (ball[8][0]));
 2002390:	e0bf4417 	ldw	r2,-752(fp)
 2002394:	10800904 	addi	r2,r2,36
 2002398:	e0ff5e17 	ldw	r3,-648(fp)
 200239c:	1807fe72 	custom	249,r3,r3,zero
 20023a0:	180892ba 	slli	r4,r3,10
 20023a4:	e0ff5d17 	ldw	r3,-652(fp)
 20023a8:	1807fe72 	custom	249,r3,r3,zero
 20023ac:	20c7883a 	add	r3,r4,r3
 20023b0:	10c00035 	stwio	r3,0(r2)
       IOWR(display,10,((int) (ball[9][1]) << 10) + (int) (ball[9][0]));
 20023b4:	e0bf4417 	ldw	r2,-752(fp)
 20023b8:	10800a04 	addi	r2,r2,40
 20023bc:	e0ff6017 	ldw	r3,-640(fp)
 20023c0:	1807fe72 	custom	249,r3,r3,zero
 20023c4:	180892ba 	slli	r4,r3,10
 20023c8:	e0ff5f17 	ldw	r3,-644(fp)
 20023cc:	1807fe72 	custom	249,r3,r3,zero
 20023d0:	20c7883a 	add	r3,r4,r3
 20023d4:	10c00035 	stwio	r3,0(r2)
       OSTimeDlyHMSM(0, 0, 0, 4);
 20023d8:	01c00104 	movi	r7,4
 20023dc:	000d883a 	mov	r6,zero
 20023e0:	000b883a 	mov	r5,zero
 20023e4:	0009883a 	mov	r4,zero
 20023e8:	201c7300 	call	201c730 <OSTimeDlyHMSM>

   DEBUG_PRINT("[Task 2] Launch animation : (%d, %d) - initial speed : %f - initial velocity : (%f, %f)\n",*vector_x, *vector_y, speed, velocity[0][0], velocity[0][1]);

   int border_collision [10][4] = {{0, 0, 0, 0},{0, 0, 0, 0},{0,0,0,0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0},{0, 0, 0, 0}};

   while(speed >= 0.1)
 20023ec:	e13f4317 	ldw	r4,-756(fp)
 20023f0:	20064940 	call	2006494 <__extendsfdf2>
 20023f4:	1011883a 	mov	r8,r2
 20023f8:	1813883a 	mov	r9,r3
 20023fc:	01a666b4 	movhi	r6,39322
 2002400:	31a66684 	addi	r6,r6,-26214
 2002404:	01cfeeb4 	movhi	r7,16314
 2002408:	39e66644 	addi	r7,r7,-26215
 200240c:	4009883a 	mov	r4,r8
 2002410:	480b883a 	mov	r5,r9
 2002414:	20052b00 	call	20052b0 <__gedf2>
 2002418:	1039810e 	bge	r2,zero,2000a20 <task2+0x424>
       IOWR(display,9,((int)  (ball[8][1]) << 10) + (int) (ball[8][0]));
       IOWR(display,10,((int) (ball[9][1]) << 10) + (int) (ball[9][0]));
       OSTimeDlyHMSM(0, 0, 0, 4);

   }
   OSTimeDlyHMSM(0, 0, 0, 500);
 200241c:	01c07d04 	movi	r7,500
 2002420:	000d883a 	mov	r6,zero
 2002424:	000b883a 	mov	r5,zero
 2002428:	0009883a 	mov	r4,zero
 200242c:	201c7300 	call	201c730 <OSTimeDlyHMSM>

   DEBUG_PRINT("[Task 2] Animation termine\n");
 2002430:	010080b4 	movhi	r4,514
 2002434:	213d3e04 	addi	r4,r4,-2824
 2002438:	2006d000 	call	2006d00 <puts>

   OSTimeDlyHMSM(0, 0, 0, 100);
 200243c:	01c01904 	movi	r7,100
 2002440:	000d883a 	mov	r6,zero
 2002444:	000b883a 	mov	r5,zero
 2002448:	0009883a 	mov	r4,zero
 200244c:	201c7300 	call	201c730 <OSTimeDlyHMSM>

   opt_task2= OS_FLAG_CLR;
 2002450:	e03f4505 	stb	zero,-748(fp)
   OSFlagPost(AnimationFlagGrp,ANIMATION,opt_task2,&err);
 2002454:	d0a73317 	ldw	r2,-25396(gp)
 2002458:	e0ff4503 	ldbu	r3,-748(fp)
 200245c:	e13f4c04 	addi	r4,fp,-720
 2002460:	200f883a 	mov	r7,r4
 2002464:	180d883a 	mov	r6,r3
 2002468:	01400044 	movi	r5,1
 200246c:	1009883a 	mov	r4,r2
 2002470:	20179100 	call	2017910 <OSFlagPost>

   OSMboxPost(MailBox6, nbr_ball);
 2002474:	d0a73117 	ldw	r2,-25404(gp)
 2002478:	e17f4817 	ldw	r5,-736(fp)
 200247c:	1009883a 	mov	r4,r2
 2002480:	201888c0 	call	201888c <OSMboxPost>
   //OSMboxPost(MailBox7, &score);

  }
 2002484:	0038d306 	br	20007d4 <task2+0x1d8>

02002488 <task3>:
}

void task3(void* pdata)
{
 2002488:	deffed04 	addi	sp,sp,-76
 200248c:	dfc01215 	stw	ra,72(sp)
 2002490:	df001115 	stw	fp,68(sp)
 2002494:	df001104 	addi	fp,sp,68
 2002498:	e13fff15 	stw	r4,-4(fp)
	INT8U err;
	INT8U opt_task1;

	int activePlayer;
	//int * nbr_ball;
	int score [2] = {0,0};
 200249c:	e03ffa15 	stw	zero,-24(fp)
 20024a0:	e03ffb15 	stw	zero,-20(fp)
	int * XdirRec = (int*) MEM_NIOS_PI_BASE+11;
	int * YdirRec = (int*) MEM_NIOS_PI_BASE+12;
	*/
	//intermediate variable//

	IOWR(MEM_NIOS_PI_BASE,0,0);
 20024a4:	0007883a 	mov	r3,zero
 20024a8:	00800834 	movhi	r2,32
 20024ac:	10c00035 	stwio	r3,0(r2)
	IOWR(MEM_NIOS_PI_BASE,1,0);
 20024b0:	0007883a 	mov	r3,zero
 20024b4:	00800834 	movhi	r2,32
 20024b8:	10800104 	addi	r2,r2,4
 20024bc:	10c00035 	stwio	r3,0(r2)
	IOWR(MEM_NIOS_PI_BASE,2,0);
 20024c0:	0007883a 	mov	r3,zero
 20024c4:	00800834 	movhi	r2,32
 20024c8:	10800204 	addi	r2,r2,8
 20024cc:	10c00035 	stwio	r3,0(r2)

	IOWR(MEM_NIOS_PI_BASE,3,0);
 20024d0:	0007883a 	mov	r3,zero
 20024d4:	00800834 	movhi	r2,32
 20024d8:	10800304 	addi	r2,r2,12
 20024dc:	10c00035 	stwio	r3,0(r2)

	IOWR(MEM_NIOS_PI_BASE,8,0);
 20024e0:	0007883a 	mov	r3,zero
 20024e4:	00800834 	movhi	r2,32
 20024e8:	10800804 	addi	r2,r2,32
 20024ec:	10c00035 	stwio	r3,0(r2)

	int ready,first_player,game_finish,ready_send;
	int all_rdy;

	ready=0;
 20024f0:	e03ff215 	stw	zero,-56(fp)
	first_player=0;
 20024f4:	e03ff315 	stw	zero,-52(fp)
	all_rdy=0;
 20024f8:	e03ff415 	stw	zero,-48(fp)
	game_finish=0;
 20024fc:	e03ff515 	stw	zero,-44(fp)
	ready_send=0;
 2002500:	e03ff615 	stw	zero,-40(fp)
	int number_of_ball = 10;
 2002504:	00800284 	movi	r2,10
 2002508:	e0bffc15 	stw	r2,-16(fp)
    int time_out = 0;
 200250c:	e03ff115 	stw	zero,-60(fp)
			while(!all_rdy && !time_out){
                time_out = IORD(MEM_NIOS_PI_BASE,15);
                if(time_out) IOWR(MEM_NIOS_PI_BASE,15,1);
				if (IORD(MEM_NIOS_PI_BASE,2)) all_rdy = 1;
			}*/
			activePlayer = ID1;//first_player;
 2002510:	00800084 	movi	r2,2
 2002514:	e0bff015 	stw	r2,-64(fp)
			game_finish = 0;
 2002518:	e03ff515 	stw	zero,-44(fp)
			DEBUG_PRINT("[Task 3] the game can start\n");
 200251c:	010080b4 	movhi	r4,514
 2002520:	213d5904 	addi	r4,r4,-2716
 2002524:	2006d000 	call	2006d00 <puts>
			while(!game_finish && !time_out){
 2002528:	0000b806 	br	200280c <task3+0x384>
                time_out = IORD(MEM_NIOS_PI_BASE,15);
 200252c:	00800834 	movhi	r2,32
 2002530:	10800f04 	addi	r2,r2,60
 2002534:	10800037 	ldwio	r2,0(r2)
 2002538:	e0bff115 	stw	r2,-60(fp)
                if(time_out) IOWR(MEM_NIOS_PI_BASE,15,1);
 200253c:	e0bff117 	ldw	r2,-60(fp)
 2002540:	10000426 	beq	r2,zero,2002554 <task3+0xcc>
 2002544:	00c00044 	movi	r3,1
 2002548:	00800834 	movhi	r2,32
 200254c:	10800f04 	addi	r2,r2,60
 2002550:	10c00035 	stwio	r3,0(r2)
				if(activePlayer==ID1 && !IORD(MEM_NIOS_PI_BASE,8) && !time_out){
 2002554:	e0bff017 	ldw	r2,-64(fp)
 2002558:	10800098 	cmpnei	r2,r2,2
 200255c:	10005d1e 	bne	r2,zero,20026d4 <task3+0x24c>
 2002560:	00800834 	movhi	r2,32
 2002564:	10800804 	addi	r2,r2,32
 2002568:	10800037 	ldwio	r2,0(r2)
 200256c:	1000591e 	bne	r2,zero,20026d4 <task3+0x24c>
 2002570:	e0bff117 	ldw	r2,-60(fp)
 2002574:	1000571e 	bne	r2,zero,20026d4 <task3+0x24c>
						OSFlagPost(isActiveFlagGrp, IS_ACTIVE, OS_FLAG_SET, &err);
 2002578:	d0a73b17 	ldw	r2,-25364(gp)
 200257c:	e0fff944 	addi	r3,fp,-27
 2002580:	180f883a 	mov	r7,r3
 2002584:	01800044 	movi	r6,1
 2002588:	01400044 	movi	r5,1
 200258c:	1009883a 	mov	r4,r2
 2002590:	20179100 	call	2017910 <OSFlagPost>
						DEBUG_PRINT("[Task 3] Wait for value from task 1\n");
 2002594:	010080b4 	movhi	r4,514
 2002598:	213d6004 	addi	r4,r4,-2688
 200259c:	2006d000 	call	2006d00 <puts>
						int *vector_x = (int *) OSMboxPend(MailBox1,0,&err);
 20025a0:	d0a73a17 	ldw	r2,-25368(gp)
 20025a4:	e0fff944 	addi	r3,fp,-27
 20025a8:	180d883a 	mov	r6,r3
 20025ac:	000b883a 	mov	r5,zero
 20025b0:	1009883a 	mov	r4,r2
 20025b4:	20184ec0 	call	20184ec <OSMboxPend>
 20025b8:	e0bff715 	stw	r2,-36(fp)
						int *vector_y = (int *) OSMboxPend(MailBox2,0,&err);
 20025bc:	d0a73617 	ldw	r2,-25384(gp)
 20025c0:	e0fff944 	addi	r3,fp,-27
 20025c4:	180d883a 	mov	r6,r3
 20025c8:	000b883a 	mov	r5,zero
 20025cc:	1009883a 	mov	r4,r2
 20025d0:	20184ec0 	call	20184ec <OSMboxPend>
 20025d4:	e0bff815 	stw	r2,-32(fp)
						DEBUG_PRINT("[Task 3] Get value from task 1 : (%d, %d)\n",*vector_x, *vector_y);
 20025d8:	e0bff717 	ldw	r2,-36(fp)
 20025dc:	10c00017 	ldw	r3,0(r2)
 20025e0:	e0bff817 	ldw	r2,-32(fp)
 20025e4:	10800017 	ldw	r2,0(r2)
 20025e8:	100d883a 	mov	r6,r2
 20025ec:	180b883a 	mov	r5,r3
 20025f0:	010080b4 	movhi	r4,514
 20025f4:	213d6904 	addi	r4,r4,-2652
 20025f8:	2006b800 	call	2006b80 <printf>

						OSMboxPost(MailBox4, vector_x);
 20025fc:	d0a73817 	ldw	r2,-25376(gp)
 2002600:	e17ff717 	ldw	r5,-36(fp)
 2002604:	1009883a 	mov	r4,r2
 2002608:	201888c0 	call	201888c <OSMboxPost>
						OSMboxPost(MailBox5, vector_y);
 200260c:	d0a73417 	ldw	r2,-25392(gp)
 2002610:	e17ff817 	ldw	r5,-32(fp)
 2002614:	1009883a 	mov	r4,r2
 2002618:	201888c0 	call	201888c <OSMboxPost>

						OSMboxPost(MailBox8, &number_of_ball);                 //transmit nbr ball to task 2
 200261c:	d0a73717 	ldw	r2,-25380(gp)
 2002620:	e0fffc04 	addi	r3,fp,-16
 2002624:	180b883a 	mov	r5,r3
 2002628:	1009883a 	mov	r4,r2
 200262c:	201888c0 	call	201888c <OSMboxPost>
						//OSMboxPost(MailBox9, IORD(MEM_NIOS_PI_BASE,10));                //transmit score to task2

						DEBUG_PRINT("[Task 3] Send value to the SPI\n");
 2002630:	010080b4 	movhi	r4,514
 2002634:	213d7404 	addi	r4,r4,-2608
 2002638:	2006d000 	call	2006d00 <puts>
						IOWR(MEM_NIOS_PI_BASE,4,number_of_ball);
 200263c:	e0fffc17 	ldw	r3,-16(fp)
 2002640:	00800834 	movhi	r2,32
 2002644:	10800404 	addi	r2,r2,16
 2002648:	10c00035 	stwio	r3,0(r2)
						//IOWR(MEM_NIOS_PI_BASE,5,*score);
						IOWR(MEM_NIOS_PI_BASE,6,*vector_x);
 200264c:	e0bff717 	ldw	r2,-36(fp)
 2002650:	10c00017 	ldw	r3,0(r2)
 2002654:	00800834 	movhi	r2,32
 2002658:	10800604 	addi	r2,r2,24
 200265c:	10c00035 	stwio	r3,0(r2)
						IOWR(MEM_NIOS_PI_BASE,7,*vector_y);
 2002660:	e0bff817 	ldw	r2,-32(fp)
 2002664:	10c00017 	ldw	r3,0(r2)
 2002668:	00800834 	movhi	r2,32
 200266c:	10800704 	addi	r2,r2,28
 2002670:	10c00035 	stwio	r3,0(r2)
						IOWR(MEM_NIOS_PI_BASE,3,1);             						//*isSend = 1; // value are available
 2002674:	00c00044 	movi	r3,1
 2002678:	00800834 	movhi	r2,32
 200267c:	10800304 	addi	r2,r2,12
 2002680:	10c00035 	stwio	r3,0(r2)

						opt_task1=OS_FLAG_CLR;
 2002684:	e03ff905 	stb	zero,-28(fp)
						OSFlagPost(isActiveFlagGrp,IS_ACTIVE,opt_task1,&err);
 2002688:	d0a73b17 	ldw	r2,-25364(gp)
 200268c:	e0fff903 	ldbu	r3,-28(fp)
 2002690:	e13ff944 	addi	r4,fp,-27
 2002694:	200f883a 	mov	r7,r4
 2002698:	180d883a 	mov	r6,r3
 200269c:	01400044 	movi	r5,1
 20026a0:	1009883a 	mov	r4,r2
 20026a4:	20179100 	call	2017910 <OSFlagPost>
						OSFlagPend(AnimationFlagGrp, ANIMATION, OS_FLAG_WAIT_CLR_ALL, 0, &err);
 20026a8:	d0e73317 	ldw	r3,-25396(gp)
 20026ac:	e0bff944 	addi	r2,fp,-27
 20026b0:	d8800015 	stw	r2,0(sp)
 20026b4:	000f883a 	mov	r7,zero
 20026b8:	000d883a 	mov	r6,zero
 20026bc:	01400044 	movi	r5,1
 20026c0:	1809883a 	mov	r4,r3
 20026c4:	20172f80 	call	20172f8 <OSFlagPend>

						//*nbr_ball = (int *) OSMboxPend(MailBox6,0,&err);
						//*score = (int *) OSMboxPend(MailBox7,0,&err);

						activePlayer = ID2;
 20026c8:	00800044 	movi	r2,1
 20026cc:	e0bff015 	stw	r2,-64(fp)
			game_finish = 0;
			DEBUG_PRINT("[Task 3] the game can start\n");
			while(!game_finish && !time_out){
                time_out = IORD(MEM_NIOS_PI_BASE,15);
                if(time_out) IOWR(MEM_NIOS_PI_BASE,15,1);
				if(activePlayer==ID1 && !IORD(MEM_NIOS_PI_BASE,8) && !time_out){
 20026d0:	00004e06 	br	200280c <task3+0x384>
						//*score = (int *) OSMboxPend(MailBox7,0,&err);

						activePlayer = ID2;

				}
				else if(activePlayer == ID2 && IORD(MEM_NIOS_PI_BASE,8) && !time_out){
 20026d4:	e0bff017 	ldw	r2,-64(fp)
 20026d8:	10800058 	cmpnei	r2,r2,1
 20026dc:	1000461e 	bne	r2,zero,20027f8 <task3+0x370>
 20026e0:	00800834 	movhi	r2,32
 20026e4:	10800804 	addi	r2,r2,32
 20026e8:	10800037 	ldwio	r2,0(r2)
 20026ec:	10004226 	beq	r2,zero,20027f8 <task3+0x370>
 20026f0:	e0bff117 	ldw	r2,-60(fp)
 20026f4:	1000401e 	bne	r2,zero,20027f8 <task3+0x370>

						int x = (int)(IORD(MEM_NIOS_PI_BASE,11));
 20026f8:	00800834 	movhi	r2,32
 20026fc:	10800b04 	addi	r2,r2,44
 2002700:	10800037 	ldwio	r2,0(r2)
 2002704:	e0bffd15 	stw	r2,-12(fp)
						int y = (int)(IORD(MEM_NIOS_PI_BASE,12));
 2002708:	00800834 	movhi	r2,32
 200270c:	10800c04 	addi	r2,r2,48
 2002710:	10800037 	ldwio	r2,0(r2)
 2002714:	e0bffe15 	stw	r2,-8(fp)

						DEBUG_PRINT("[Task 3] %x - %x \n",x,y);
 2002718:	e0bffd17 	ldw	r2,-12(fp)
 200271c:	e0fffe17 	ldw	r3,-8(fp)
 2002720:	180d883a 	mov	r6,r3
 2002724:	100b883a 	mov	r5,r2
 2002728:	010080b4 	movhi	r4,514
 200272c:	213d7c04 	addi	r4,r4,-2576
 2002730:	2006b800 	call	2006b80 <printf>

						OSMboxPost(MailBox4, &x);
 2002734:	d0a73817 	ldw	r2,-25376(gp)
 2002738:	e0fffd04 	addi	r3,fp,-12
 200273c:	180b883a 	mov	r5,r3
 2002740:	1009883a 	mov	r4,r2
 2002744:	201888c0 	call	201888c <OSMboxPost>
						OSMboxPost(MailBox5, &y);
 2002748:	d0a73417 	ldw	r2,-25392(gp)
 200274c:	e0fffe04 	addi	r3,fp,-8
 2002750:	180b883a 	mov	r5,r3
 2002754:	1009883a 	mov	r4,r2
 2002758:	201888c0 	call	201888c <OSMboxPost>
						OSMboxPost(MailBox8, IORD(MEM_NIOS_PI_BASE,9));
 200275c:	d0e73717 	ldw	r3,-25380(gp)
 2002760:	00800834 	movhi	r2,32
 2002764:	10800904 	addi	r2,r2,36
 2002768:	10800037 	ldwio	r2,0(r2)
 200276c:	100b883a 	mov	r5,r2
 2002770:	1809883a 	mov	r4,r3
 2002774:	201888c0 	call	201888c <OSMboxPost>
						OSMboxPost(MailBox9, IORD(MEM_NIOS_PI_BASE,10));
 2002778:	d0e73017 	ldw	r3,-25408(gp)
 200277c:	00800834 	movhi	r2,32
 2002780:	10800a04 	addi	r2,r2,40
 2002784:	10800037 	ldwio	r2,0(r2)
 2002788:	100b883a 	mov	r5,r2
 200278c:	1809883a 	mov	r4,r3
 2002790:	201888c0 	call	201888c <OSMboxPost>

						OSFlagPend(AnimationFlagGrp, ANIMATION, OS_FLAG_WAIT_CLR_ALL, 0, &err);
 2002794:	d0e73317 	ldw	r3,-25396(gp)
 2002798:	e0bff944 	addi	r2,fp,-27
 200279c:	d8800015 	stw	r2,0(sp)
 20027a0:	000f883a 	mov	r7,zero
 20027a4:	000d883a 	mov	r6,zero
 20027a8:	01400044 	movi	r5,1
 20027ac:	1809883a 	mov	r4,r3
 20027b0:	20172f80 	call	20172f8 <OSFlagPend>
						opt_task1=OS_FLAG_SET;
 20027b4:	00800044 	movi	r2,1
 20027b8:	e0bff905 	stb	r2,-28(fp)
						OSFlagPost(isActiveFlagGrp,IS_ACTIVE,opt_task1,&err);
 20027bc:	d0a73b17 	ldw	r2,-25364(gp)
 20027c0:	e0fff903 	ldbu	r3,-28(fp)
 20027c4:	e13ff944 	addi	r4,fp,-27
 20027c8:	200f883a 	mov	r7,r4
 20027cc:	180d883a 	mov	r6,r3
 20027d0:	01400044 	movi	r5,1
 20027d4:	1009883a 	mov	r4,r2
 20027d8:	20179100 	call	2017910 <OSFlagPost>

						IOWR(MEM_NIOS_PI_BASE,8,0);
 20027dc:	0007883a 	mov	r3,zero
 20027e0:	00800834 	movhi	r2,32
 20027e4:	10800804 	addi	r2,r2,32
 20027e8:	10c00035 	stwio	r3,0(r2)
						activePlayer = ID1;
 20027ec:	00800084 	movi	r2,2
 20027f0:	e0bff015 	stw	r2,-64(fp)
						//*score = (int *) OSMboxPend(MailBox7,0,&err);

						activePlayer = ID2;

				}
				else if(activePlayer == ID2 && IORD(MEM_NIOS_PI_BASE,8) && !time_out){
 20027f4:	00000506 	br	200280c <task3+0x384>
						IOWR(MEM_NIOS_PI_BASE,8,0);
						activePlayer = ID1;
						//*nbr_ball = (int *) OSMboxPend(MailBox6,0,&err);
						//*score = (int *) OSMboxPend(MailBox7,0,&err);
				}
				else if(activePlayer == ID2)
 20027f8:	e0bff017 	ldw	r2,-64(fp)
 20027fc:	10800058 	cmpnei	r2,r2,1
 2002800:	1000021e 	bne	r2,zero,200280c <task3+0x384>
				{
					activePlayer = ID1;
 2002804:	00800084 	movi	r2,2
 2002808:	e0bff015 	stw	r2,-64(fp)
				if (IORD(MEM_NIOS_PI_BASE,2)) all_rdy = 1;
			}*/
			activePlayer = ID1;//first_player;
			game_finish = 0;
			DEBUG_PRINT("[Task 3] the game can start\n");
			while(!game_finish && !time_out){
 200280c:	e0bff517 	ldw	r2,-44(fp)
 2002810:	103f3f1e 	bne	r2,zero,2002510 <task3+0x88>
 2002814:	e0bff117 	ldw	r2,-60(fp)
 2002818:	103f4426 	beq	r2,zero,200252c <task3+0xa4>
				{
					activePlayer = ID1;
				}
			}

	}
 200281c:	003f3c06 	br	2002510 <task3+0x88>

02002820 <task4>:

}

void task4(void* pdata)
{
 2002820:	defff704 	addi	sp,sp,-36
 2002824:	dfc00815 	stw	ra,32(sp)
 2002828:	df000715 	stw	fp,28(sp)
 200282c:	df000704 	addi	fp,sp,28
 2002830:	e13fff15 	stw	r4,-4(fp)

	volatile int * MTL_controller = (int *) MTL_IP_BASE;
 2002834:	008000b4 	movhi	r2,2
 2002838:	e0bffc15 	stw	r2,-16(fp)

	int count = 0;
 200283c:	e03ffa15 	stw	zero,-24(fp)
	int count_old = 0;
 2002840:	e03ffd15 	stw	zero,-12(fp)

    int gesture_detected = 0;
 2002844:	e03ffb15 	stw	zero,-20(fp)

	INT8U err;
	//INT8U opt_task4;

	while(1){
		OSFlagPend(ActivateTask4Grp, ACTIVATE_TASK4, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0,&err); // wait for a flag and consume it
 2002848:	d0e73517 	ldw	r3,-25388(gp)
 200284c:	e0bffe04 	addi	r2,fp,-8
 2002850:	d8800015 	stw	r2,0(sp)
 2002854:	000f883a 	mov	r7,zero
 2002858:	01802084 	movi	r6,130
 200285c:	01400044 	movi	r5,1
 2002860:	1809883a 	mov	r4,r3
 2002864:	20172f80 	call	20172f8 <OSFlagPend>
        while(!gesture_detected){
 2002868:	00001006 	br	20028ac <task4+0x8c>
        count_old = count;
 200286c:	e0bffa17 	ldw	r2,-24(fp)
 2002870:	e0bffd15 	stw	r2,-12(fp)
        count = IORD(MTL_controller,10); // récupère le nombre de doigts présent sur l'écran
 2002874:	e0bffc17 	ldw	r2,-16(fp)
 2002878:	10800a04 	addi	r2,r2,40
 200287c:	10800037 	ldwio	r2,0(r2)
 2002880:	e0bffa15 	stw	r2,-24(fp)
		    if (count == 1 && count_old == 0){
 2002884:	e0bffa17 	ldw	r2,-24(fp)
 2002888:	10800058 	cmpnei	r2,r2,1
 200288c:	1000071e 	bne	r2,zero,20028ac <task4+0x8c>
 2002890:	e0bffd17 	ldw	r2,-12(fp)
 2002894:	1000051e 	bne	r2,zero,20028ac <task4+0x8c>
                DEBUG_PRINT("[Task 4] Player touch the screen\n");
 2002898:	010080b4 	movhi	r4,514
 200289c:	213d8104 	addi	r4,r4,-2556
 20028a0:	2006d000 	call	2006d00 <puts>
    			gesture_detected = 1;
 20028a4:	00800044 	movi	r2,1
 20028a8:	e0bffb15 	stw	r2,-20(fp)
	INT8U err;
	//INT8U opt_task4;

	while(1){
		OSFlagPend(ActivateTask4Grp, ACTIVATE_TASK4, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0,&err); // wait for a flag and consume it
        while(!gesture_detected){
 20028ac:	e0bffb17 	ldw	r2,-20(fp)
 20028b0:	103fee26 	beq	r2,zero,200286c <task4+0x4c>
		    if (count == 1 && count_old == 0){
                DEBUG_PRINT("[Task 4] Player touch the screen\n");
    			gesture_detected = 1;
            }
		}
        gesture_detected = 0;
 20028b4:	e03ffb15 	stw	zero,-20(fp)
        OSFlagPost(StartGameGrp,START_THE_GAME,OS_FLAG_SET,&err);
 20028b8:	d0a73c17 	ldw	r2,-25360(gp)
 20028bc:	e0fffe04 	addi	r3,fp,-8
 20028c0:	180f883a 	mov	r7,r3
 20028c4:	01800044 	movi	r6,1
 20028c8:	01400044 	movi	r5,1
 20028cc:	1009883a 	mov	r4,r2
 20028d0:	20179100 	call	2017910 <OSFlagPost>
        OSTimeDlyHMSM(0, 0, 0, 500);
 20028d4:	01c07d04 	movi	r7,500
 20028d8:	000d883a 	mov	r6,zero
 20028dc:	000b883a 	mov	r5,zero
 20028e0:	0009883a 	mov	r4,zero
 20028e4:	201c7300 	call	201c730 <OSTimeDlyHMSM>
	}
 20028e8:	003fd706 	br	2002848 <task4+0x28>

020028ec <main>:
}


/* The main function creates two task and starts multi-tasking */
int main(void)
{
 20028ec:	defff804 	addi	sp,sp,-32
 20028f0:	dfc00715 	stw	ra,28(sp)
 20028f4:	df000615 	stw	fp,24(sp)
 20028f8:	df000604 	addi	fp,sp,24
	INT8U err;

  MailBox1 = OSMboxCreate(NULL);
 20028fc:	0009883a 	mov	r4,zero
 2002900:	20181d80 	call	20181d8 <OSMboxCreate>
 2002904:	d0a73a15 	stw	r2,-25368(gp)
  MailBox2 = OSMboxCreate(NULL);
 2002908:	0009883a 	mov	r4,zero
 200290c:	20181d80 	call	20181d8 <OSMboxCreate>
 2002910:	d0a73615 	stw	r2,-25384(gp)
  MailBox3 = OSMboxCreate(NULL);
 2002914:	0009883a 	mov	r4,zero
 2002918:	20181d80 	call	20181d8 <OSMboxCreate>
 200291c:	d0a73215 	stw	r2,-25400(gp)

  MailBox4 = OSMboxCreate(NULL);
 2002920:	0009883a 	mov	r4,zero
 2002924:	20181d80 	call	20181d8 <OSMboxCreate>
 2002928:	d0a73815 	stw	r2,-25376(gp)
  MailBox5 = OSMboxCreate(NULL);
 200292c:	0009883a 	mov	r4,zero
 2002930:	20181d80 	call	20181d8 <OSMboxCreate>
 2002934:	d0a73415 	stw	r2,-25392(gp)
  MailBox6 = OSMboxCreate(NULL);
 2002938:	0009883a 	mov	r4,zero
 200293c:	20181d80 	call	20181d8 <OSMboxCreate>
 2002940:	d0a73115 	stw	r2,-25404(gp)


  MailBox7 = OSMboxCreate(NULL);
 2002944:	0009883a 	mov	r4,zero
 2002948:	20181d80 	call	20181d8 <OSMboxCreate>
 200294c:	d0a73915 	stw	r2,-25372(gp)
  MailBox8 = OSMboxCreate(NULL);
 2002950:	0009883a 	mov	r4,zero
 2002954:	20181d80 	call	20181d8 <OSMboxCreate>
 2002958:	d0a73715 	stw	r2,-25380(gp)

  isActiveFlagGrp = OSFlagCreate(0, &err);
 200295c:	e17fff04 	addi	r5,fp,-4
 2002960:	0009883a 	mov	r4,zero
 2002964:	2016d340 	call	2016d34 <OSFlagCreate>
 2002968:	d0a73b15 	stw	r2,-25364(gp)
  AnimationFlagGrp = OSFlagCreate(0, &err);
 200296c:	e17fff04 	addi	r5,fp,-4
 2002970:	0009883a 	mov	r4,zero
 2002974:	2016d340 	call	2016d34 <OSFlagCreate>
 2002978:	d0a73315 	stw	r2,-25396(gp)
  ActivateTask4Grp = OSFlagCreate(0,&err);
 200297c:	e17fff04 	addi	r5,fp,-4
 2002980:	0009883a 	mov	r4,zero
 2002984:	2016d340 	call	2016d34 <OSFlagCreate>
 2002988:	d0a73515 	stw	r2,-25388(gp)
  StartGameGrp = OSFlagCreate(0,&err);
 200298c:	e17fff04 	addi	r5,fp,-4
 2002990:	0009883a 	mov	r4,zero
 2002994:	2016d340 	call	2016d34 <OSFlagCreate>
 2002998:	d0a73c15 	stw	r2,-25360(gp)

  accel_spi = alt_up_accelerometer_spi_open_dev(accel_name);
 200299c:	d0a00017 	ldw	r2,-32768(gp)
 20029a0:	1009883a 	mov	r4,r2
 20029a4:	201da000 	call	201da00 <alt_up_accelerometer_spi_open_dev>
 20029a8:	d0a72f15 	stw	r2,-25412(gp)
  	if(accel_spi == NULL){
 20029ac:	d0a72f17 	ldw	r2,-25412(gp)
 20029b0:	1000031e 	bne	r2,zero,20029c0 <main+0xd4>
  		printf("Accelerometer device not found.\n");
 20029b4:	010080b4 	movhi	r4,514
 20029b8:	213d8a04 	addi	r4,r4,-2520
 20029bc:	2006d000 	call	2006d00 <puts>
  	}




  OSTaskCreateExt(task1,
 20029c0:	d8000415 	stw	zero,16(sp)
 20029c4:	d8000315 	stw	zero,12(sp)
 20029c8:	00820004 	movi	r2,2048
 20029cc:	d8800215 	stw	r2,8(sp)
 20029d0:	008080b4 	movhi	r2,514
 20029d4:	108d0904 	addi	r2,r2,13348
 20029d8:	d8800115 	stw	r2,4(sp)
 20029dc:	00800044 	movi	r2,1
 20029e0:	d8800015 	stw	r2,0(sp)
 20029e4:	01c00044 	movi	r7,1
 20029e8:	018080b4 	movhi	r6,514
 20029ec:	31950804 	addi	r6,r6,21536
 20029f0:	000b883a 	mov	r5,zero
 20029f4:	01008034 	movhi	r4,512
 20029f8:	2100a504 	addi	r4,r4,660
 20029fc:	201b55c0 	call	201b55c <OSTaskCreateExt>
                  TASK_STACKSIZE,
                  NULL,
                  0);


  OSTaskCreateExt(task2,
 2002a00:	d8000415 	stw	zero,16(sp)
 2002a04:	d8000315 	stw	zero,12(sp)
 2002a08:	00820004 	movi	r2,2048
 2002a0c:	d8800215 	stw	r2,8(sp)
 2002a10:	008080b4 	movhi	r2,514
 2002a14:	109d0904 	addi	r2,r2,29732
 2002a18:	d8800115 	stw	r2,4(sp)
 2002a1c:	00800084 	movi	r2,2
 2002a20:	d8800015 	stw	r2,0(sp)
 2002a24:	01c00084 	movi	r7,2
 2002a28:	018080f4 	movhi	r6,515
 2002a2c:	31a50804 	addi	r6,r6,-27616
 2002a30:	000b883a 	mov	r5,zero
 2002a34:	01008034 	movhi	r4,512
 2002a38:	21017f04 	addi	r4,r4,1532
 2002a3c:	201b55c0 	call	201b55c <OSTaskCreateExt>
                  TASK2_PRIORITY,
                  task2_stk,
                  TASK_STACKSIZE,
                  NULL,
                  0);
  OSTaskCreateExt(task3,
 2002a40:	d8000415 	stw	zero,16(sp)
 2002a44:	d8000315 	stw	zero,12(sp)
 2002a48:	00820004 	movi	r2,2048
 2002a4c:	d8800215 	stw	r2,8(sp)
 2002a50:	008080f4 	movhi	r2,515
 2002a54:	10a50904 	addi	r2,r2,-27612
 2002a58:	d8800115 	stw	r2,4(sp)
 2002a5c:	008000c4 	movi	r2,3
 2002a60:	d8800015 	stw	r2,0(sp)
 2002a64:	01c000c4 	movi	r7,3
 2002a68:	018080f4 	movhi	r6,515
 2002a6c:	31ad0804 	addi	r6,r6,-19424
 2002a70:	000b883a 	mov	r5,zero
 2002a74:	01008034 	movhi	r4,512
 2002a78:	21092204 	addi	r4,r4,9352
 2002a7c:	201b55c0 	call	201b55c <OSTaskCreateExt>
                   TASK3_PRIORITY,
                   task3_stk,
                   TASK_STACKSIZE,
                   NULL,
                   0);
  OSTaskCreateExt(task4,
 2002a80:	d8000415 	stw	zero,16(sp)
 2002a84:	d8000315 	stw	zero,12(sp)
 2002a88:	00820004 	movi	r2,2048
 2002a8c:	d8800215 	stw	r2,8(sp)
 2002a90:	008080b4 	movhi	r2,514
 2002a94:	10950904 	addi	r2,r2,21540
 2002a98:	d8800115 	stw	r2,4(sp)
 2002a9c:	00800104 	movi	r2,4
 2002aa0:	d8800015 	stw	r2,0(sp)
 2002aa4:	01c00104 	movi	r7,4
 2002aa8:	018080b4 	movhi	r6,514
 2002aac:	319d0804 	addi	r6,r6,29728
 2002ab0:	000b883a 	mov	r5,zero
 2002ab4:	01008034 	movhi	r4,512
 2002ab8:	210a0804 	addi	r4,r4,10272
 2002abc:	201b55c0 	call	201b55c <OSTaskCreateExt>
                     TASK_STACKSIZE,
                     NULL,
                     0);


  OSStart();
 2002ac0:	20153fc0 	call	20153fc <OSStart>
  return 0;
 2002ac4:	0005883a 	mov	r2,zero
}
 2002ac8:	e037883a 	mov	sp,fp
 2002acc:	dfc00117 	ldw	ra,4(sp)
 2002ad0:	df000017 	ldw	fp,0(sp)
 2002ad4:	dec00204 	addi	sp,sp,8
 2002ad8:	f800283a 	ret

02002adc <whole_collide>:
#include "physics.h"
#include <stdio.h>

int whole_list [6][2]={{86,63},{446,63},{806,63},{86,463},{446,463},{806,463}};

int whole_collide(float ball [2], float velocity [2]){
 2002adc:	defff604 	addi	sp,sp,-40
 2002ae0:	dfc00915 	stw	ra,36(sp)
 2002ae4:	df000815 	stw	fp,32(sp)
 2002ae8:	df000804 	addi	fp,sp,32
 2002aec:	e13ffe15 	stw	r4,-8(fp)
 2002af0:	e17fff15 	stw	r5,-4(fp)
	float x = ball[0]+velocity[0];
 2002af4:	e0bffe17 	ldw	r2,-8(fp)
 2002af8:	10c00017 	ldw	r3,0(r2)
 2002afc:	e13fff17 	ldw	r4,-4(fp)
 2002b00:	20800017 	ldw	r2,0(r4)
 2002b04:	1885ff72 	custom	253,r2,r3,r2
 2002b08:	e0bffa15 	stw	r2,-24(fp)
	float y = ball[1]+velocity[1];
 2002b0c:	e0bffe17 	ldw	r2,-8(fp)
 2002b10:	10800104 	addi	r2,r2,4
 2002b14:	10c00017 	ldw	r3,0(r2)
 2002b18:	e0bfff17 	ldw	r2,-4(fp)
 2002b1c:	11000104 	addi	r4,r2,4
 2002b20:	20800017 	ldw	r2,0(r4)
 2002b24:	1885ff72 	custom	253,r2,r3,r2
 2002b28:	e0bffb15 	stw	r2,-20(fp)

	int collision = 0;
 2002b2c:	e03ff815 	stw	zero,-32(fp)
	int cnt;

	for (cnt=0;cnt<6;cnt++){
 2002b30:	e03ff915 	stw	zero,-28(fp)
 2002b34:	00003d06 	br	2002c2c <whole_collide+0x150>
		float dx = whole_list[cnt][0]-x;
 2002b38:	008080b4 	movhi	r2,514
 2002b3c:	10bed204 	addi	r2,r2,-1208
 2002b40:	e0fff917 	ldw	r3,-28(fp)
 2002b44:	180690fa 	slli	r3,r3,3
 2002b48:	10c5883a 	add	r2,r2,r3
 2002b4c:	10800017 	ldw	r2,0(r2)
 2002b50:	1007feb2 	custom	250,r3,r2,zero
 2002b54:	e0bffa17 	ldw	r2,-24(fp)
 2002b58:	1885ffb2 	custom	254,r2,r3,r2
 2002b5c:	e0bffc15 	stw	r2,-16(fp)
		float dy = whole_list[cnt][1]-y;
 2002b60:	008080b4 	movhi	r2,514
 2002b64:	10bed204 	addi	r2,r2,-1208
 2002b68:	e0fff917 	ldw	r3,-28(fp)
 2002b6c:	180690fa 	slli	r3,r3,3
 2002b70:	10c5883a 	add	r2,r2,r3
 2002b74:	10800104 	addi	r2,r2,4
 2002b78:	10800017 	ldw	r2,0(r2)
 2002b7c:	1007feb2 	custom	250,r3,r2,zero
 2002b80:	e0bffb17 	ldw	r2,-20(fp)
 2002b84:	1885ffb2 	custom	254,r2,r3,r2
 2002b88:	e0bffd15 	stw	r2,-12(fp)

		collision = collision || (dx*dx+dy*dy <= ((SIZE+WHOLE_SIZE)*(SIZE+WHOLE_SIZE)*0.85));
 2002b8c:	e0bff817 	ldw	r2,-32(fp)
 2002b90:	1000131e 	bne	r2,zero,2002be0 <whole_collide+0x104>
 2002b94:	e0fffc17 	ldw	r3,-16(fp)
 2002b98:	e0bffc17 	ldw	r2,-16(fp)
 2002b9c:	1887ff32 	custom	252,r3,r3,r2
 2002ba0:	e13ffd17 	ldw	r4,-12(fp)
 2002ba4:	e0bffd17 	ldw	r2,-12(fp)
 2002ba8:	2085ff32 	custom	252,r2,r4,r2
 2002bac:	1885ff72 	custom	253,r2,r3,r2
 2002bb0:	1009883a 	mov	r4,r2
 2002bb4:	20064940 	call	2006494 <__extendsfdf2>
 2002bb8:	1011883a 	mov	r8,r2
 2002bbc:	1813883a 	mov	r9,r3
 2002bc0:	01b33374 	movhi	r6,52429
 2002bc4:	31b33344 	addi	r6,r6,-13107
 2002bc8:	01d021b4 	movhi	r7,16518
 2002bcc:	39d5b304 	addi	r7,r7,22220
 2002bd0:	4009883a 	mov	r4,r8
 2002bd4:	480b883a 	mov	r5,r9
 2002bd8:	200538c0 	call	200538c <__ledf2>
 2002bdc:	00800216 	blt	zero,r2,2002be8 <whole_collide+0x10c>
 2002be0:	00800044 	movi	r2,1
 2002be4:	00000106 	br	2002bec <whole_collide+0x110>
 2002be8:	0005883a 	mov	r2,zero
 2002bec:	e0bff815 	stw	r2,-32(fp)

		if (collision){
 2002bf0:	e0bff817 	ldw	r2,-32(fp)
 2002bf4:	10000a26 	beq	r2,zero,2002c20 <whole_collide+0x144>
			ball[0]=0;
 2002bf8:	e0bffe17 	ldw	r2,-8(fp)
 2002bfc:	10000015 	stw	zero,0(r2)
			ball[1]=0;
 2002c00:	e0bffe17 	ldw	r2,-8(fp)
 2002c04:	10800104 	addi	r2,r2,4
 2002c08:	10000015 	stw	zero,0(r2)
			velocity[0]=0;
 2002c0c:	e0bfff17 	ldw	r2,-4(fp)
 2002c10:	10000015 	stw	zero,0(r2)
			velocity[1]=0;
 2002c14:	e0bfff17 	ldw	r2,-4(fp)
 2002c18:	10800104 	addi	r2,r2,4
 2002c1c:	10000015 	stw	zero,0(r2)
	float y = ball[1]+velocity[1];

	int collision = 0;
	int cnt;

	for (cnt=0;cnt<6;cnt++){
 2002c20:	e0bff917 	ldw	r2,-28(fp)
 2002c24:	10800044 	addi	r2,r2,1
 2002c28:	e0bff915 	stw	r2,-28(fp)
 2002c2c:	e0bff917 	ldw	r2,-28(fp)
 2002c30:	10800190 	cmplti	r2,r2,6
 2002c34:	103fc01e 	bne	r2,zero,2002b38 <whole_collide+0x5c>
			ball[1]=0;
			velocity[0]=0;
			velocity[1]=0;
		}
	}
	return collision;
 2002c38:	e0bff817 	ldw	r2,-32(fp)
}
 2002c3c:	e037883a 	mov	sp,fp
 2002c40:	dfc00117 	ldw	ra,4(sp)
 2002c44:	df000017 	ldw	fp,0(sp)
 2002c48:	dec00204 	addi	sp,sp,8
 2002c4c:	f800283a 	ret

02002c50 <borderCollide>:


void borderCollide(float* ball, int* border_collision, float* velocity)
{
 2002c50:	defffa04 	addi	sp,sp,-24
 2002c54:	df000515 	stw	fp,20(sp)
 2002c58:	df000504 	addi	fp,sp,20
 2002c5c:	e13ffd15 	stw	r4,-12(fp)
 2002c60:	e17ffe15 	stw	r5,-8(fp)
 2002c64:	e1bfff15 	stw	r6,-4(fp)
	int collide_x = 0;
 2002c68:	e03ffb15 	stw	zero,-20(fp)
	int collide_y = 0;
 2002c6c:	e03ffc15 	stw	zero,-16(fp)
	collide_x = (ball[0] < BORDER_X + BORDER + SIZE || ball[0] > (MAX_X + BORDER_X)-(BORDER + SIZE));
 2002c70:	e0bffd17 	ldw	r2,-12(fp)
 2002c74:	10c00017 	ldw	r3,0(r2)
 2002c78:	0090b1b4 	movhi	r2,17094
 2002c7c:	1885f9f2 	custom	231,r2,r3,r2
 2002c80:	1000061e 	bne	r2,zero,2002c9c <borderCollide+0x4c>
 2002c84:	e0bffd17 	ldw	r2,-12(fp)
 2002c88:	10c00017 	ldw	r3,0(r2)
 2002c8c:	009111b4 	movhi	r2,17478
 2002c90:	10900004 	addi	r2,r2,16384
 2002c94:	1885f972 	custom	229,r2,r3,r2
 2002c98:	10000226 	beq	r2,zero,2002ca4 <borderCollide+0x54>
 2002c9c:	00800044 	movi	r2,1
 2002ca0:	00000106 	br	2002ca8 <borderCollide+0x58>
 2002ca4:	0005883a 	mov	r2,zero
 2002ca8:	e0bffb15 	stw	r2,-20(fp)
	collide_y = (ball[1] < BORDER_Y + BORDER + SIZE || ball[1] > (MAX_Y + BORDER_Y)-(BORDER + SIZE));
 2002cac:	e0bffd17 	ldw	r2,-12(fp)
 2002cb0:	10800104 	addi	r2,r2,4
 2002cb4:	10c00017 	ldw	r3,0(r2)
 2002cb8:	0090a634 	movhi	r2,17048
 2002cbc:	1885f9f2 	custom	231,r2,r3,r2
 2002cc0:	1000061e 	bne	r2,zero,2002cdc <borderCollide+0x8c>
 2002cc4:	e0bffd17 	ldw	r2,-12(fp)
 2002cc8:	10800104 	addi	r2,r2,4
 2002ccc:	10c00017 	ldw	r3,0(r2)
 2002cd0:	0090f874 	movhi	r2,17377
 2002cd4:	1885f972 	custom	229,r2,r3,r2
 2002cd8:	10000226 	beq	r2,zero,2002ce4 <borderCollide+0x94>
 2002cdc:	00800044 	movi	r2,1
 2002ce0:	00000106 	br	2002ce8 <borderCollide+0x98>
 2002ce4:	0005883a 	mov	r2,zero
 2002ce8:	e0bffc15 	stw	r2,-16(fp)
	if(!border_collision[0] && collide_x)
 2002cec:	e0bffe17 	ldw	r2,-8(fp)
 2002cf0:	10800017 	ldw	r2,0(r2)
 2002cf4:	1000081e 	bne	r2,zero,2002d18 <borderCollide+0xc8>
 2002cf8:	e0bffb17 	ldw	r2,-20(fp)
 2002cfc:	10000626 	beq	r2,zero,2002d18 <borderCollide+0xc8>
	{
		velocity[0] = 0 - velocity[0];
 2002d00:	e0ffff17 	ldw	r3,-4(fp)
 2002d04:	18800017 	ldw	r2,0(r3)
 2002d08:	0007883a 	mov	r3,zero
 2002d0c:	1887ffb2 	custom	254,r3,r3,r2
 2002d10:	e0bfff17 	ldw	r2,-4(fp)
 2002d14:	10c00015 	stw	r3,0(r2)
	}
	if(!border_collision[2] && collide_y)
 2002d18:	e0bffe17 	ldw	r2,-8(fp)
 2002d1c:	10800204 	addi	r2,r2,8
 2002d20:	10800017 	ldw	r2,0(r2)
 2002d24:	10000a1e 	bne	r2,zero,2002d50 <borderCollide+0x100>
 2002d28:	e0bffc17 	ldw	r2,-16(fp)
 2002d2c:	10000826 	beq	r2,zero,2002d50 <borderCollide+0x100>
	{
		velocity[1] = 0 - velocity[1];
 2002d30:	e0bfff17 	ldw	r2,-4(fp)
 2002d34:	10800104 	addi	r2,r2,4
 2002d38:	e0ffff17 	ldw	r3,-4(fp)
 2002d3c:	19000104 	addi	r4,r3,4
 2002d40:	20c00017 	ldw	r3,0(r4)
 2002d44:	0009883a 	mov	r4,zero
 2002d48:	20c7ffb2 	custom	254,r3,r4,r3
 2002d4c:	10c00015 	stw	r3,0(r2)
	}

	border_collision[0] = border_collision[1];
 2002d50:	e0bffe17 	ldw	r2,-8(fp)
 2002d54:	10c00117 	ldw	r3,4(r2)
 2002d58:	e0bffe17 	ldw	r2,-8(fp)
 2002d5c:	10c00015 	stw	r3,0(r2)
	border_collision[1] = collide_x;
 2002d60:	e0bffe17 	ldw	r2,-8(fp)
 2002d64:	10800104 	addi	r2,r2,4
 2002d68:	e0fffb17 	ldw	r3,-20(fp)
 2002d6c:	10c00015 	stw	r3,0(r2)
	border_collision[2] = border_collision[3];
 2002d70:	e0bffe17 	ldw	r2,-8(fp)
 2002d74:	10800204 	addi	r2,r2,8
 2002d78:	e0fffe17 	ldw	r3,-8(fp)
 2002d7c:	18c00317 	ldw	r3,12(r3)
 2002d80:	10c00015 	stw	r3,0(r2)
	border_collision[3] = collide_y;
 2002d84:	e0bffe17 	ldw	r2,-8(fp)
 2002d88:	10800304 	addi	r2,r2,12
 2002d8c:	e0fffc17 	ldw	r3,-16(fp)
 2002d90:	10c00015 	stw	r3,0(r2)
}
 2002d94:	0001883a 	nop
 2002d98:	e037883a 	mov	sp,fp
 2002d9c:	df000017 	ldw	fp,0(sp)
 2002da0:	dec00104 	addi	sp,sp,4
 2002da4:	f800283a 	ret

02002da8 <momentum>:

float momentum (float* velocity){
 2002da8:	defffd04 	addi	sp,sp,-12
 2002dac:	df000215 	stw	fp,8(sp)
 2002db0:	df000204 	addi	fp,sp,8
 2002db4:	e13fff15 	stw	r4,-4(fp)
	float result=velocity[0]*velocity[0]+velocity[1]*velocity[1];
 2002db8:	e0bfff17 	ldw	r2,-4(fp)
 2002dbc:	10c00017 	ldw	r3,0(r2)
 2002dc0:	e13fff17 	ldw	r4,-4(fp)
 2002dc4:	20800017 	ldw	r2,0(r4)
 2002dc8:	1887ff32 	custom	252,r3,r3,r2
 2002dcc:	e0bfff17 	ldw	r2,-4(fp)
 2002dd0:	10800104 	addi	r2,r2,4
 2002dd4:	11000017 	ldw	r4,0(r2)
 2002dd8:	e0bfff17 	ldw	r2,-4(fp)
 2002ddc:	11400104 	addi	r5,r2,4
 2002de0:	28800017 	ldw	r2,0(r5)
 2002de4:	2085ff32 	custom	252,r2,r4,r2
 2002de8:	1885ff72 	custom	253,r2,r3,r2
 2002dec:	e0bffe15 	stw	r2,-8(fp)
	return result;
 2002df0:	e0bffe17 	ldw	r2,-8(fp)
 2002df4:	1007883a 	mov	r3,r2
}
 2002df8:	1805883a 	mov	r2,r3
 2002dfc:	e037883a 	mov	sp,fp
 2002e00:	df000017 	ldw	fp,0(sp)
 2002e04:	dec00104 	addi	sp,sp,4
 2002e08:	f800283a 	ret

02002e0c <detect_collide>:

void detect_collide(float* ball1, float* ball2, int* collision){
 2002e0c:	defff604 	addi	sp,sp,-40
 2002e10:	df000915 	stw	fp,36(sp)
 2002e14:	df000904 	addi	fp,sp,36
 2002e18:	e13ffd15 	stw	r4,-12(fp)
 2002e1c:	e17ffe15 	stw	r5,-8(fp)
 2002e20:	e1bfff15 	stw	r6,-4(fp)
	collision[0]=collision[1];
 2002e24:	e0bfff17 	ldw	r2,-4(fp)
 2002e28:	10c00117 	ldw	r3,4(r2)
 2002e2c:	e0bfff17 	ldw	r2,-4(fp)
 2002e30:	10c00015 	stw	r3,0(r2)

	float x1,y1,x2,y2,dx,dy;
	x1=ball1[0];
 2002e34:	e0bffd17 	ldw	r2,-12(fp)
 2002e38:	10800017 	ldw	r2,0(r2)
 2002e3c:	e0bff715 	stw	r2,-36(fp)
	x2=ball2[0];
 2002e40:	e0bffe17 	ldw	r2,-8(fp)
 2002e44:	10800017 	ldw	r2,0(r2)
 2002e48:	e0bff815 	stw	r2,-32(fp)

	y1=ball1[1];
 2002e4c:	e0bffd17 	ldw	r2,-12(fp)
 2002e50:	10800117 	ldw	r2,4(r2)
 2002e54:	e0bff915 	stw	r2,-28(fp)
	y2=ball2[1];
 2002e58:	e0bffe17 	ldw	r2,-8(fp)
 2002e5c:	10800117 	ldw	r2,4(r2)
 2002e60:	e0bffa15 	stw	r2,-24(fp)

	dx=x2-x1;
 2002e64:	e0fff817 	ldw	r3,-32(fp)
 2002e68:	e0bff717 	ldw	r2,-36(fp)
 2002e6c:	1885ffb2 	custom	254,r2,r3,r2
 2002e70:	e0bffb15 	stw	r2,-20(fp)
	dy=y2-y1;
 2002e74:	e0fffa17 	ldw	r3,-24(fp)
 2002e78:	e0bff917 	ldw	r2,-28(fp)
 2002e7c:	1885ffb2 	custom	254,r2,r3,r2
 2002e80:	e0bffc15 	stw	r2,-16(fp)
	collision[1]=dx*dx + dy*dy <= 4*SIZE*SIZE;
 2002e84:	e0bfff17 	ldw	r2,-4(fp)
 2002e88:	10800104 	addi	r2,r2,4
 2002e8c:	e13ffb17 	ldw	r4,-20(fp)
 2002e90:	e0fffb17 	ldw	r3,-20(fp)
 2002e94:	20c9ff32 	custom	252,r4,r4,r3
 2002e98:	e17ffc17 	ldw	r5,-16(fp)
 2002e9c:	e0fffc17 	ldw	r3,-16(fp)
 2002ea0:	28c7ff32 	custom	252,r3,r5,r3
 2002ea4:	20c9ff72 	custom	253,r4,r4,r3
 2002ea8:	00d10a74 	movhi	r3,17449
 2002eac:	20c7f9b2 	custom	230,r3,r4,r3
 2002eb0:	18c03fcc 	andi	r3,r3,255
 2002eb4:	10c00015 	stw	r3,0(r2)
}
 2002eb8:	0001883a 	nop
 2002ebc:	e037883a 	mov	sp,fp
 2002ec0:	df000017 	ldw	fp,0(sp)
 2002ec4:	dec00104 	addi	sp,sp,4
 2002ec8:	f800283a 	ret

02002ecc <collide_calc>:


void collide_calc(float* ball1, float* ball2,float* velocity1, float* velocity2, int* collision,int id){
 2002ecc:	deffd204 	addi	sp,sp,-184
 2002ed0:	dfc02d15 	stw	ra,180(sp)
 2002ed4:	df002c15 	stw	fp,176(sp)
 2002ed8:	ddc02b15 	stw	r23,172(sp)
 2002edc:	dd802a15 	stw	r22,168(sp)
 2002ee0:	dd402915 	stw	r21,164(sp)
 2002ee4:	dd002815 	stw	r20,160(sp)
 2002ee8:	dcc02715 	stw	r19,156(sp)
 2002eec:	dc802615 	stw	r18,152(sp)
 2002ef0:	dc402515 	stw	r17,148(sp)
 2002ef4:	dc002415 	stw	r16,144(sp)
 2002ef8:	df002c04 	addi	fp,sp,176
 2002efc:	e13fee15 	stw	r4,-72(fp)
 2002f00:	e17fef15 	stw	r5,-68(fp)
 2002f04:	e1bff015 	stw	r6,-64(fp)
 2002f08:	e1fff115 	stw	r7,-60(fp)
	if ((!collision[0] && collision[1]) || (collision[0] && collision[1] && ball1[0]!=0 && ball1[1] && ball2[0] && ball2[1])){
 2002f0c:	e0800217 	ldw	r2,8(fp)
 2002f10:	10800017 	ldw	r2,0(r2)
 2002f14:	1000041e 	bne	r2,zero,2002f28 <collide_calc+0x5c>
 2002f18:	e0800217 	ldw	r2,8(fp)
 2002f1c:	10800104 	addi	r2,r2,4
 2002f20:	10800017 	ldw	r2,0(r2)
 2002f24:	10001d1e 	bne	r2,zero,2002f9c <collide_calc+0xd0>
 2002f28:	e0800217 	ldw	r2,8(fp)
 2002f2c:	10800017 	ldw	r2,0(r2)
 2002f30:	10011026 	beq	r2,zero,2003374 <collide_calc+0x4a8>
 2002f34:	e0800217 	ldw	r2,8(fp)
 2002f38:	10800104 	addi	r2,r2,4
 2002f3c:	10800017 	ldw	r2,0(r2)
 2002f40:	10010c26 	beq	r2,zero,2003374 <collide_calc+0x4a8>
 2002f44:	e0ffee17 	ldw	r3,-72(fp)
 2002f48:	18800017 	ldw	r2,0(r3)
 2002f4c:	0007883a 	mov	r3,zero
 2002f50:	10c5f8f2 	custom	227,r2,r2,r3
 2002f54:	1001071e 	bne	r2,zero,2003374 <collide_calc+0x4a8>
 2002f58:	e0bfee17 	ldw	r2,-72(fp)
 2002f5c:	10c00104 	addi	r3,r2,4
 2002f60:	18800017 	ldw	r2,0(r3)
 2002f64:	0007883a 	mov	r3,zero
 2002f68:	10c5f8f2 	custom	227,r2,r2,r3
 2002f6c:	1001011e 	bne	r2,zero,2003374 <collide_calc+0x4a8>
 2002f70:	e0ffef17 	ldw	r3,-68(fp)
 2002f74:	18800017 	ldw	r2,0(r3)
 2002f78:	0007883a 	mov	r3,zero
 2002f7c:	10c5f8f2 	custom	227,r2,r2,r3
 2002f80:	1000fc1e 	bne	r2,zero,2003374 <collide_calc+0x4a8>
 2002f84:	e0bfef17 	ldw	r2,-68(fp)
 2002f88:	10c00104 	addi	r3,r2,4
 2002f8c:	18800017 	ldw	r2,0(r3)
 2002f90:	0007883a 	mov	r3,zero
 2002f94:	10c5f8f2 	custom	227,r2,r2,r3
 2002f98:	1000f61e 	bne	r2,zero,2003374 <collide_calc+0x4a8>
		int sign;
		float v21 [2];
		float a;
		float dv;

		x1=ball1[0];
 2002f9c:	e0bfee17 	ldw	r2,-72(fp)
 2002fa0:	10800017 	ldw	r2,0(r2)
 2002fa4:	e0bfe315 	stw	r2,-116(fp)
		x2=ball2[0];
 2002fa8:	e0bfef17 	ldw	r2,-68(fp)
 2002fac:	10800017 	ldw	r2,0(r2)
 2002fb0:	e0bfe415 	stw	r2,-112(fp)
		y1=ball1[1];
 2002fb4:	e0bfee17 	ldw	r2,-72(fp)
 2002fb8:	10800117 	ldw	r2,4(r2)
 2002fbc:	e0bfe515 	stw	r2,-108(fp)
		y2=ball2[1];
 2002fc0:	e0bfef17 	ldw	r2,-68(fp)
 2002fc4:	10800117 	ldw	r2,4(r2)
 2002fc8:	e0bfe615 	stw	r2,-104(fp)

		//m1=1.0;
		//m2=1.0;
		m21 = 1.0; // m1 = 1.0 / m2 = 1.0
 2002fcc:	008fe034 	movhi	r2,16256
 2002fd0:	e0bfe715 	stw	r2,-100(fp)
		x21 = x2-x1;
 2002fd4:	e0ffe417 	ldw	r3,-112(fp)
 2002fd8:	e0bfe317 	ldw	r2,-116(fp)
 2002fdc:	1885ffb2 	custom	254,r2,r3,r2
 2002fe0:	e0bfe115 	stw	r2,-124(fp)
		y21 = y2-y1;
 2002fe4:	e0ffe617 	ldw	r3,-104(fp)
 2002fe8:	e0bfe517 	ldw	r2,-108(fp)
 2002fec:	1885ffb2 	custom	254,r2,r3,r2
 2002ff0:	e0bfe815 	stw	r2,-96(fp)
		v21[0]=velocity2[0]-velocity1[0];
 2002ff4:	e0bff117 	ldw	r2,-60(fp)
 2002ff8:	10c00017 	ldw	r3,0(r2)
 2002ffc:	e13ff017 	ldw	r4,-64(fp)
 2003000:	20800017 	ldw	r2,0(r4)
 2003004:	1885ffb2 	custom	254,r2,r3,r2
 2003008:	e0bfec15 	stw	r2,-80(fp)
		v21[1]=velocity2[1]-velocity1[1];
 200300c:	e0bff117 	ldw	r2,-60(fp)
 2003010:	10800104 	addi	r2,r2,4
 2003014:	10c00017 	ldw	r3,0(r2)
 2003018:	e0bff017 	ldw	r2,-64(fp)
 200301c:	11000104 	addi	r4,r2,4
 2003020:	20800017 	ldw	r2,0(r4)
 2003024:	1885ffb2 	custom	254,r2,r3,r2
 2003028:	e0bfed15 	stw	r2,-76(fp)

		if ((v21[0]*x21 + v21[1]*y21) >=0){
 200302c:	e0ffec17 	ldw	r3,-80(fp)
 2003030:	e0bfe117 	ldw	r2,-124(fp)
 2003034:	1887ff32 	custom	252,r3,r3,r2
 2003038:	e13fed17 	ldw	r4,-76(fp)
 200303c:	e0bfe817 	ldw	r2,-96(fp)
 2003040:	2085ff32 	custom	252,r2,r4,r2
 2003044:	1885ff72 	custom	253,r2,r3,r2
 2003048:	0007883a 	mov	r3,zero
 200304c:	10c5f932 	custom	228,r2,r2,r3
 2003050:	1000c81e 	bne	r2,zero,2003374 <collide_calc+0x4a8>
			//DEBUG_PRINT("error in collision\n");
		}
		else{
			fy21=0.000001*fabs(y21);
 2003054:	e0bfe817 	ldw	r2,-96(fp)
 2003058:	1005f832 	custom	224,r2,r2,zero
 200305c:	1009883a 	mov	r4,r2
 2003060:	20064940 	call	2006494 <__extendsfdf2>
 2003064:	1011883a 	mov	r8,r2
 2003068:	1813883a 	mov	r9,r3
 200306c:	01a82db4 	movhi	r6,41142
 2003070:	31bb6344 	addi	r6,r6,-4723
 2003074:	01cfac74 	movhi	r7,16049
 2003078:	39f1bdc4 	addi	r7,r7,-14601
 200307c:	4009883a 	mov	r4,r8
 2003080:	480b883a 	mov	r5,r9
 2003084:	20054800 	call	2005480 <__muldf3>
 2003088:	1009883a 	mov	r4,r2
 200308c:	180b883a 	mov	r5,r3
 2003090:	2005883a 	mov	r2,r4
 2003094:	2807883a 	mov	r3,r5
 2003098:	1009883a 	mov	r4,r2
 200309c:	180b883a 	mov	r5,r3
 20030a0:	20065a40 	call	20065a4 <__truncdfsf2>
 20030a4:	1007883a 	mov	r3,r2
 20030a8:	e0ffe915 	stw	r3,-92(fp)
			if(fabs(x21) < fy21){
 20030ac:	e0bfe117 	ldw	r2,-124(fp)
 20030b0:	1007f832 	custom	224,r3,r2,zero
 20030b4:	e0bfe917 	ldw	r2,-92(fp)
 20030b8:	1885f9f2 	custom	231,r2,r3,r2
 20030bc:	10000e26 	beq	r2,zero,20030f8 <collide_calc+0x22c>
				if (x21<0) sign = -1;
 20030c0:	e0bfe117 	ldw	r2,-124(fp)
 20030c4:	0007883a 	mov	r3,zero
 20030c8:	10c5f9f2 	custom	231,r2,r2,r3
 20030cc:	10000326 	beq	r2,zero,20030dc <collide_calc+0x210>
 20030d0:	00bfffc4 	movi	r2,-1
 20030d4:	e0bfe215 	stw	r2,-120(fp)
 20030d8:	00000206 	br	20030e4 <collide_calc+0x218>
				else sign=1;
 20030dc:	00800044 	movi	r2,1
 20030e0:	e0bfe215 	stw	r2,-120(fp)
				x21=fy21*sign;
 20030e4:	e0bfe217 	ldw	r2,-120(fp)
 20030e8:	1007feb2 	custom	250,r3,r2,zero
 20030ec:	e0bfe917 	ldw	r2,-92(fp)
 20030f0:	1885ff32 	custom	252,r2,r3,r2
 20030f4:	e0bfe115 	stw	r2,-124(fp)
			}
			a=y21/x21;
 20030f8:	e0ffe817 	ldw	r3,-96(fp)
 20030fc:	e0bfe117 	ldw	r2,-124(fp)
 2003100:	1885fff2 	custom	255,r2,r3,r2
 2003104:	e0bfea15 	stw	r2,-88(fp)
            dv = -2.0*(v21[0]+a*v21[1])/((1+a*a)*(1+m21));
 2003108:	e0ffec17 	ldw	r3,-80(fp)
 200310c:	e13fed17 	ldw	r4,-76(fp)
 2003110:	e0bfea17 	ldw	r2,-88(fp)
 2003114:	2085ff32 	custom	252,r2,r4,r2
 2003118:	1885ff72 	custom	253,r2,r3,r2
 200311c:	1009883a 	mov	r4,r2
 2003120:	20064940 	call	2006494 <__extendsfdf2>
 2003124:	1011883a 	mov	r8,r2
 2003128:	1813883a 	mov	r9,r3
 200312c:	000d883a 	mov	r6,zero
 2003130:	01f00034 	movhi	r7,49152
 2003134:	4009883a 	mov	r4,r8
 2003138:	480b883a 	mov	r5,r9
 200313c:	20054800 	call	2005480 <__muldf3>
 2003140:	1009883a 	mov	r4,r2
 2003144:	180b883a 	mov	r5,r3
 2003148:	2021883a 	mov	r16,r4
 200314c:	2823883a 	mov	r17,r5
 2003150:	e0ffea17 	ldw	r3,-88(fp)
 2003154:	e0bfea17 	ldw	r2,-88(fp)
 2003158:	1887ff32 	custom	252,r3,r3,r2
 200315c:	008fe034 	movhi	r2,16256
 2003160:	1887ff72 	custom	253,r3,r3,r2
 2003164:	e13fe717 	ldw	r4,-100(fp)
 2003168:	008fe034 	movhi	r2,16256
 200316c:	2085ff72 	custom	253,r2,r4,r2
 2003170:	1885ff32 	custom	252,r2,r3,r2
 2003174:	1009883a 	mov	r4,r2
 2003178:	20064940 	call	2006494 <__extendsfdf2>
 200317c:	1009883a 	mov	r4,r2
 2003180:	180b883a 	mov	r5,r3
 2003184:	200d883a 	mov	r6,r4
 2003188:	280f883a 	mov	r7,r5
 200318c:	8009883a 	mov	r4,r16
 2003190:	880b883a 	mov	r5,r17
 2003194:	20049400 	call	2004940 <__divdf3>
 2003198:	1009883a 	mov	r4,r2
 200319c:	180b883a 	mov	r5,r3
 20031a0:	2005883a 	mov	r2,r4
 20031a4:	2807883a 	mov	r3,r5
 20031a8:	1009883a 	mov	r4,r2
 20031ac:	180b883a 	mov	r5,r3
 20031b0:	20065a40 	call	20065a4 <__truncdfsf2>
 20031b4:	1007883a 	mov	r3,r2
 20031b8:	e0ffeb15 	stw	r3,-84(fp)
            velocity2[0] += dv;
 20031bc:	e0bff117 	ldw	r2,-60(fp)
 20031c0:	10c00017 	ldw	r3,0(r2)
 20031c4:	e0bfeb17 	ldw	r2,-84(fp)
 20031c8:	1887ff72 	custom	253,r3,r3,r2
 20031cc:	e0bff117 	ldw	r2,-60(fp)
 20031d0:	10c00015 	stw	r3,0(r2)
            velocity2[1] += a*dv;
 20031d4:	e0bff117 	ldw	r2,-60(fp)
 20031d8:	10800104 	addi	r2,r2,4
 20031dc:	e0fff117 	ldw	r3,-60(fp)
 20031e0:	18c00104 	addi	r3,r3,4
 20031e4:	19000017 	ldw	r4,0(r3)
 20031e8:	e17fea17 	ldw	r5,-88(fp)
 20031ec:	e0ffeb17 	ldw	r3,-84(fp)
 20031f0:	28c7ff32 	custom	252,r3,r5,r3
 20031f4:	20c7ff72 	custom	253,r3,r4,r3
 20031f8:	10c00015 	stw	r3,0(r2)

            velocity1[0] -= m21*dv;
 20031fc:	e0bff017 	ldw	r2,-64(fp)
 2003200:	10c00017 	ldw	r3,0(r2)
 2003204:	e13fe717 	ldw	r4,-100(fp)
 2003208:	e0bfeb17 	ldw	r2,-84(fp)
 200320c:	2085ff32 	custom	252,r2,r4,r2
 2003210:	1887ffb2 	custom	254,r3,r3,r2
 2003214:	e0bff017 	ldw	r2,-64(fp)
 2003218:	10c00015 	stw	r3,0(r2)
            velocity1[1] -= a*m21*dv;
 200321c:	e0bff017 	ldw	r2,-64(fp)
 2003220:	10800104 	addi	r2,r2,4
 2003224:	e0fff017 	ldw	r3,-64(fp)
 2003228:	18c00104 	addi	r3,r3,4
 200322c:	19000017 	ldw	r4,0(r3)
 2003230:	e17fea17 	ldw	r5,-88(fp)
 2003234:	e0ffe717 	ldw	r3,-100(fp)
 2003238:	28cbff32 	custom	252,r5,r5,r3
 200323c:	e0ffeb17 	ldw	r3,-84(fp)
 2003240:	28c7ff32 	custom	252,r3,r5,r3
 2003244:	20c7ffb2 	custom	254,r3,r4,r3
 2003248:	10c00015 	stw	r3,0(r2)
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 200324c:	e0bfee17 	ldw	r2,-72(fp)
 2003250:	10c00017 	ldw	r3,0(r2)
 2003254:	1809883a 	mov	r4,r3
 2003258:	20064940 	call	2006494 <__extendsfdf2>
 200325c:	e0bff215 	stw	r2,-56(fp)
 2003260:	e0fff315 	stw	r3,-52(fp)
 2003264:	e0bfee17 	ldw	r2,-72(fp)
 2003268:	10800104 	addi	r2,r2,4
 200326c:	10c00017 	ldw	r3,0(r2)
 2003270:	1809883a 	mov	r4,r3
 2003274:	20064940 	call	2006494 <__extendsfdf2>
 2003278:	e0bff415 	stw	r2,-48(fp)
 200327c:	e0fff515 	stw	r3,-44(fp)
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 2003280:	e0bfef17 	ldw	r2,-68(fp)
 2003284:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 2003288:	1809883a 	mov	r4,r3
 200328c:	20064940 	call	2006494 <__extendsfdf2>
 2003290:	1021883a 	mov	r16,r2
 2003294:	1823883a 	mov	r17,r3
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 2003298:	e0bfef17 	ldw	r2,-68(fp)
 200329c:	10800104 	addi	r2,r2,4
 20032a0:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 20032a4:	1809883a 	mov	r4,r3
 20032a8:	20064940 	call	2006494 <__extendsfdf2>
 20032ac:	1025883a 	mov	r18,r2
 20032b0:	1827883a 	mov	r19,r3
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 20032b4:	e0bff017 	ldw	r2,-64(fp)
 20032b8:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 20032bc:	1809883a 	mov	r4,r3
 20032c0:	20064940 	call	2006494 <__extendsfdf2>
 20032c4:	1029883a 	mov	r20,r2
 20032c8:	182b883a 	mov	r21,r3
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 20032cc:	e0bff017 	ldw	r2,-64(fp)
 20032d0:	10800104 	addi	r2,r2,4
 20032d4:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 20032d8:	1809883a 	mov	r4,r3
 20032dc:	20064940 	call	2006494 <__extendsfdf2>
 20032e0:	102d883a 	mov	r22,r2
 20032e4:	182f883a 	mov	r23,r3
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 20032e8:	e0bff117 	ldw	r2,-60(fp)
 20032ec:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 20032f0:	1809883a 	mov	r4,r3
 20032f4:	20064940 	call	2006494 <__extendsfdf2>
 20032f8:	e0bff615 	stw	r2,-40(fp)
 20032fc:	e0fff715 	stw	r3,-36(fp)
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
 2003300:	e0bff117 	ldw	r2,-60(fp)
 2003304:	10800104 	addi	r2,r2,4
 2003308:	10c00017 	ldw	r3,0(r2)
            velocity2[0] += dv;
            velocity2[1] += a*dv;

            velocity1[0] -= m21*dv;
            velocity1[1] -= a*m21*dv;
            DEBUG_PRINT("collision - ball 1 [ %f, %f] - ball 2 [ %f, %f] - V1 [%f, %f] - V2 [%f,%f]\n", ball1[0],ball1[1],
 200330c:	1809883a 	mov	r4,r3
 2003310:	20064940 	call	2006494 <__extendsfdf2>
 2003314:	1009883a 	mov	r4,r2
 2003318:	180b883a 	mov	r5,r3
 200331c:	d9000b15 	stw	r4,44(sp)
 2003320:	d9400c15 	stw	r5,48(sp)
 2003324:	e0bff617 	ldw	r2,-40(fp)
 2003328:	d8800915 	stw	r2,36(sp)
 200332c:	e0bff717 	ldw	r2,-36(fp)
 2003330:	d8800a15 	stw	r2,40(sp)
 2003334:	dd800715 	stw	r22,28(sp)
 2003338:	ddc00815 	stw	r23,32(sp)
 200333c:	dd000515 	stw	r20,20(sp)
 2003340:	dd400615 	stw	r21,24(sp)
 2003344:	dc800315 	stw	r18,12(sp)
 2003348:	dcc00415 	stw	r19,16(sp)
 200334c:	dc000115 	stw	r16,4(sp)
 2003350:	dc400215 	stw	r17,8(sp)
 2003354:	e0bff517 	ldw	r2,-44(fp)
 2003358:	d8800015 	stw	r2,0(sp)
 200335c:	e1fff417 	ldw	r7,-48(fp)
 2003360:	e17ff217 	ldw	r5,-56(fp)
 2003364:	e1bff317 	ldw	r6,-52(fp)
 2003368:	010080b4 	movhi	r4,514
 200336c:	213d9204 	addi	r4,r4,-2488
 2003370:	2006b800 	call	2006b80 <printf>
            					ball2[0],ball2[1],velocity1[0] , velocity1[1],velocity2[0],velocity2[1]);
		}
	}
}
 2003374:	0001883a 	nop
 2003378:	e6fff804 	addi	sp,fp,-32
 200337c:	dfc00917 	ldw	ra,36(sp)
 2003380:	df000817 	ldw	fp,32(sp)
 2003384:	ddc00717 	ldw	r23,28(sp)
 2003388:	dd800617 	ldw	r22,24(sp)
 200338c:	dd400517 	ldw	r21,20(sp)
 2003390:	dd000417 	ldw	r20,16(sp)
 2003394:	dcc00317 	ldw	r19,12(sp)
 2003398:	dc800217 	ldw	r18,8(sp)
 200339c:	dc400117 	ldw	r17,4(sp)
 20033a0:	dc000017 	ldw	r16,0(sp)
 20033a4:	dec00a04 	addi	sp,sp,40
 20033a8:	f800283a 	ret

020033ac <moveBall>:


void moveBall(float* ball, float* velocity){
 20033ac:	defffd04 	addi	sp,sp,-12
 20033b0:	df000215 	stw	fp,8(sp)
 20033b4:	df000204 	addi	fp,sp,8
 20033b8:	e13ffe15 	stw	r4,-8(fp)
 20033bc:	e17fff15 	stw	r5,-4(fp)
	ball[0] += velocity[0];
 20033c0:	e0bffe17 	ldw	r2,-8(fp)
 20033c4:	10c00017 	ldw	r3,0(r2)
 20033c8:	e13fff17 	ldw	r4,-4(fp)
 20033cc:	20800017 	ldw	r2,0(r4)
 20033d0:	1887ff72 	custom	253,r3,r3,r2
 20033d4:	e0bffe17 	ldw	r2,-8(fp)
 20033d8:	10c00015 	stw	r3,0(r2)
	ball[1] += velocity[1];
 20033dc:	e0bffe17 	ldw	r2,-8(fp)
 20033e0:	10800104 	addi	r2,r2,4
 20033e4:	e0fffe17 	ldw	r3,-8(fp)
 20033e8:	18c00104 	addi	r3,r3,4
 20033ec:	19000017 	ldw	r4,0(r3)
 20033f0:	e0ffff17 	ldw	r3,-4(fp)
 20033f4:	19400104 	addi	r5,r3,4
 20033f8:	28c00017 	ldw	r3,0(r5)
 20033fc:	20c7ff72 	custom	253,r3,r4,r3
 2003400:	10c00015 	stw	r3,0(r2)
}
 2003404:	0001883a 	nop
 2003408:	e037883a 	mov	sp,fp
 200340c:	df000017 	ldw	fp,0(sp)
 2003410:	dec00104 	addi	sp,sp,4
 2003414:	f800283a 	ret

02003418 <damping>:


void damping(float* velocity){
 2003418:	defffc04 	addi	sp,sp,-16
 200341c:	dfc00315 	stw	ra,12(sp)
 2003420:	df000215 	stw	fp,8(sp)
 2003424:	dc000115 	stw	r16,4(sp)
 2003428:	df000204 	addi	fp,sp,8
 200342c:	e13ffe15 	stw	r4,-8(fp)
	velocity[0] *= DAMPING;
 2003430:	e0bffe17 	ldw	r2,-8(fp)
 2003434:	10c00017 	ldw	r3,0(r2)
 2003438:	1809883a 	mov	r4,r3
 200343c:	20064940 	call	2006494 <__extendsfdf2>
 2003440:	1011883a 	mov	r8,r2
 2003444:	1813883a 	mov	r9,r3
 2003448:	018f5c74 	movhi	r6,15729
 200344c:	31a8f5c4 	addi	r6,r6,-23593
 2003450:	01cffc34 	movhi	r7,16368
 2003454:	39f5c284 	addi	r7,r7,-10486
 2003458:	4009883a 	mov	r4,r8
 200345c:	480b883a 	mov	r5,r9
 2003460:	20054800 	call	2005480 <__muldf3>
 2003464:	1009883a 	mov	r4,r2
 2003468:	180b883a 	mov	r5,r3
 200346c:	2005883a 	mov	r2,r4
 2003470:	2807883a 	mov	r3,r5
 2003474:	1009883a 	mov	r4,r2
 2003478:	180b883a 	mov	r5,r3
 200347c:	20065a40 	call	20065a4 <__truncdfsf2>
 2003480:	1007883a 	mov	r3,r2
 2003484:	e0bffe17 	ldw	r2,-8(fp)
 2003488:	10c00015 	stw	r3,0(r2)
	velocity[1] *= DAMPING;
 200348c:	e0bffe17 	ldw	r2,-8(fp)
 2003490:	14000104 	addi	r16,r2,4
 2003494:	e0bffe17 	ldw	r2,-8(fp)
 2003498:	10800104 	addi	r2,r2,4
 200349c:	10c00017 	ldw	r3,0(r2)
 20034a0:	1809883a 	mov	r4,r3
 20034a4:	20064940 	call	2006494 <__extendsfdf2>
 20034a8:	1011883a 	mov	r8,r2
 20034ac:	1813883a 	mov	r9,r3
 20034b0:	018f5c74 	movhi	r6,15729
 20034b4:	31a8f5c4 	addi	r6,r6,-23593
 20034b8:	01cffc34 	movhi	r7,16368
 20034bc:	39f5c284 	addi	r7,r7,-10486
 20034c0:	4009883a 	mov	r4,r8
 20034c4:	480b883a 	mov	r5,r9
 20034c8:	20054800 	call	2005480 <__muldf3>
 20034cc:	1009883a 	mov	r4,r2
 20034d0:	180b883a 	mov	r5,r3
 20034d4:	2005883a 	mov	r2,r4
 20034d8:	2807883a 	mov	r3,r5
 20034dc:	1009883a 	mov	r4,r2
 20034e0:	180b883a 	mov	r5,r3
 20034e4:	20065a40 	call	20065a4 <__truncdfsf2>
 20034e8:	1007883a 	mov	r3,r2
 20034ec:	80c00015 	stw	r3,0(r16)
}
 20034f0:	0001883a 	nop
 20034f4:	e6ffff04 	addi	sp,fp,-4
 20034f8:	dfc00217 	ldw	ra,8(sp)
 20034fc:	df000117 	ldw	fp,4(sp)
 2003500:	dc000017 	ldw	r16,0(sp)
 2003504:	dec00304 	addi	sp,sp,12
 2003508:	f800283a 	ret

0200350c <fmin>:
#else
	double fmin(x,y)
	double x;
	double y;
#endif
{
 200350c:	defffa04 	addi	sp,sp,-24
 2003510:	dfc00515 	stw	ra,20(sp)
 2003514:	df000415 	stw	fp,16(sp)
 2003518:	df000404 	addi	fp,sp,16
 200351c:	e13ffc15 	stw	r4,-16(fp)
 2003520:	e17ffd15 	stw	r5,-12(fp)
 2003524:	e1bffe15 	stw	r6,-8(fp)
 2003528:	e1ffff15 	stw	r7,-4(fp)
  if (__fpclassifyd(x) == FP_NAN)
 200352c:	e13ffc17 	ldw	r4,-16(fp)
 2003530:	e17ffd17 	ldw	r5,-12(fp)
 2003534:	20035b80 	call	20035b8 <__fpclassifyd>
 2003538:	1000031e 	bne	r2,zero,2003548 <fmin+0x3c>
    return y;
 200353c:	e0bffe17 	ldw	r2,-8(fp)
 2003540:	e0ffff17 	ldw	r3,-4(fp)
 2003544:	00001306 	br	2003594 <fmin+0x88>
  if (__fpclassifyd(y) == FP_NAN)
 2003548:	e13ffe17 	ldw	r4,-8(fp)
 200354c:	e17fff17 	ldw	r5,-4(fp)
 2003550:	20035b80 	call	20035b8 <__fpclassifyd>
 2003554:	1000031e 	bne	r2,zero,2003564 <fmin+0x58>
    return x;
 2003558:	e0bffc17 	ldw	r2,-16(fp)
 200355c:	e0fffd17 	ldw	r3,-12(fp)
 2003560:	00000c06 	br	2003594 <fmin+0x88>
  
  return x < y ? x : y;
 2003564:	e1bffe17 	ldw	r6,-8(fp)
 2003568:	e1ffff17 	ldw	r7,-4(fp)
 200356c:	e13ffc17 	ldw	r4,-16(fp)
 2003570:	e17ffd17 	ldw	r5,-12(fp)
 2003574:	200538c0 	call	200538c <__ledf2>
 2003578:	1000030e 	bge	r2,zero,2003588 <fmin+0x7c>
 200357c:	e0bffc17 	ldw	r2,-16(fp)
 2003580:	e0fffd17 	ldw	r3,-12(fp)
 2003584:	00000206 	br	2003590 <fmin+0x84>
 2003588:	e0bffe17 	ldw	r2,-8(fp)
 200358c:	e0ffff17 	ldw	r3,-4(fp)
 2003590:	0001883a 	nop
 2003594:	1009883a 	mov	r4,r2
 2003598:	180b883a 	mov	r5,r3
}
 200359c:	2005883a 	mov	r2,r4
 20035a0:	2807883a 	mov	r3,r5
 20035a4:	e037883a 	mov	sp,fp
 20035a8:	dfc00117 	ldw	ra,4(sp)
 20035ac:	df000017 	ldw	fp,0(sp)
 20035b0:	dec00204 	addi	sp,sp,8
 20035b4:	f800283a 	ret

020035b8 <__fpclassifyd>:

#include "fdlibm.h"

int
__fpclassifyd (double x)
{
 20035b8:	defff904 	addi	sp,sp,-28
 20035bc:	df000615 	stw	fp,24(sp)
 20035c0:	df000604 	addi	fp,sp,24
 20035c4:	e13ffe15 	stw	r4,-8(fp)
 20035c8:	e17fff15 	stw	r5,-4(fp)
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
 20035cc:	e0bffe17 	ldw	r2,-8(fp)
 20035d0:	e0bffc15 	stw	r2,-16(fp)
 20035d4:	e0bfff17 	ldw	r2,-4(fp)
 20035d8:	e0bffd15 	stw	r2,-12(fp)
 20035dc:	e0bffd17 	ldw	r2,-12(fp)
 20035e0:	e0bffa15 	stw	r2,-24(fp)
 20035e4:	e0bffc17 	ldw	r2,-16(fp)
 20035e8:	e0bffb15 	stw	r2,-20(fp)

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
 20035ec:	e0bffa17 	ldw	r2,-24(fp)
 20035f0:	1000021e 	bne	r2,zero,20035fc <__fpclassifyd+0x44>
 20035f4:	e0bffb17 	ldw	r2,-20(fp)
 20035f8:	10000526 	beq	r2,zero,2003610 <__fpclassifyd+0x58>
 20035fc:	e0fffa17 	ldw	r3,-24(fp)
 2003600:	00a00034 	movhi	r2,32768
 2003604:	1880041e 	bne	r3,r2,2003618 <__fpclassifyd+0x60>
      (msw == 0x80000000 && lsw == 0x00000000))
 2003608:	e0bffb17 	ldw	r2,-20(fp)
 200360c:	1000021e 	bne	r2,zero,2003618 <__fpclassifyd+0x60>
    return FP_ZERO;
 2003610:	00800084 	movi	r2,2
 2003614:	00002506 	br	20036ac <__fpclassifyd+0xf4>
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
 2003618:	e0fffa17 	ldw	r3,-24(fp)
 200361c:	00800434 	movhi	r2,16
 2003620:	18800336 	bltu	r3,r2,2003630 <__fpclassifyd+0x78>
 2003624:	e0fffa17 	ldw	r3,-24(fp)
 2003628:	009ffc34 	movhi	r2,32752
 200362c:	18800636 	bltu	r3,r2,2003648 <__fpclassifyd+0x90>
 2003630:	e0fffa17 	ldw	r3,-24(fp)
 2003634:	00a00434 	movhi	r2,32784
 2003638:	18800536 	bltu	r3,r2,2003650 <__fpclassifyd+0x98>
           (msw >= 0x80100000 && msw <= 0xffefffff))
 200363c:	e0fffa17 	ldw	r3,-24(fp)
 2003640:	00bffc34 	movhi	r2,65520
 2003644:	1880022e 	bgeu	r3,r2,2003650 <__fpclassifyd+0x98>
    return FP_NORMAL;
 2003648:	00800104 	movi	r2,4
 200364c:	00001706 	br	20036ac <__fpclassifyd+0xf4>
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
 2003650:	e0fffa17 	ldw	r3,-24(fp)
 2003654:	00800434 	movhi	r2,16
 2003658:	18800536 	bltu	r3,r2,2003670 <__fpclassifyd+0xb8>
           (msw >= 0x80000000 && msw <= 0x800fffff))
 200365c:	e0bffa17 	ldw	r2,-24(fp)
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
 2003660:	1000050e 	bge	r2,zero,2003678 <__fpclassifyd+0xc0>
           (msw >= 0x80000000 && msw <= 0x800fffff))
 2003664:	e0fffa17 	ldw	r3,-24(fp)
 2003668:	00a00434 	movhi	r2,32784
 200366c:	1880022e 	bgeu	r3,r2,2003678 <__fpclassifyd+0xc0>
    /* zero is already handled above */
    return FP_SUBNORMAL;
 2003670:	008000c4 	movi	r2,3
 2003674:	00000d06 	br	20036ac <__fpclassifyd+0xf4>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
 2003678:	e0fffa17 	ldw	r3,-24(fp)
 200367c:	009ffc34 	movhi	r2,32752
 2003680:	1880021e 	bne	r3,r2,200368c <__fpclassifyd+0xd4>
 2003684:	e0bffb17 	ldw	r2,-20(fp)
 2003688:	10000526 	beq	r2,zero,20036a0 <__fpclassifyd+0xe8>
 200368c:	e0fffa17 	ldw	r3,-24(fp)
 2003690:	00bffc34 	movhi	r2,65520
 2003694:	1880041e 	bne	r3,r2,20036a8 <__fpclassifyd+0xf0>
           (msw == 0xfff00000 && lsw == 0x00000000))
 2003698:	e0bffb17 	ldw	r2,-20(fp)
 200369c:	1000021e 	bne	r2,zero,20036a8 <__fpclassifyd+0xf0>
    return FP_INFINITE;
 20036a0:	00800044 	movi	r2,1
 20036a4:	00000106 	br	20036ac <__fpclassifyd+0xf4>
  else
    return FP_NAN;
 20036a8:	0005883a 	mov	r2,zero
}
 20036ac:	e037883a 	mov	sp,fp
 20036b0:	df000017 	ldw	fp,0(sp)
 20036b4:	dec00104 	addi	sp,sp,4
 20036b8:	f800283a 	ret

020036bc <sqrt>:
	double sqrt(double x)		/* wrapper sqrt */
#else
	double sqrt(x)			/* wrapper sqrt */
	double x;
#endif
{
 20036bc:	defff104 	addi	sp,sp,-60
 20036c0:	dfc00e15 	stw	ra,56(sp)
 20036c4:	df000d15 	stw	fp,52(sp)
 20036c8:	df000d04 	addi	fp,sp,52
 20036cc:	e13ffe15 	stw	r4,-8(fp)
 20036d0:	e17fff15 	stw	r5,-4(fp)
#ifdef _IEEE_LIBM
	return __ieee754_sqrt(x);
#else
	struct exception exc;
	double z;
	z = __ieee754_sqrt(x);
 20036d4:	e13ffe17 	ldw	r4,-8(fp)
 20036d8:	e17fff17 	ldw	r5,-4(fp)
 20036dc:	20038300 	call	2003830 <__ieee754_sqrt>
 20036e0:	e0bff315 	stw	r2,-52(fp)
 20036e4:	e0fff415 	stw	r3,-48(fp)
	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
 20036e8:	d0a00517 	ldw	r2,-32748(gp)
 20036ec:	10bfffe0 	cmpeqi	r2,r2,-1
 20036f0:	1000041e 	bne	r2,zero,2003704 <sqrt+0x48>
 20036f4:	e13ffe17 	ldw	r4,-8(fp)
 20036f8:	e17fff17 	ldw	r5,-4(fp)
 20036fc:	20035b80 	call	20035b8 <__fpclassifyd>
 2003700:	1000031e 	bne	r2,zero,2003710 <sqrt+0x54>
 2003704:	e0bff317 	ldw	r2,-52(fp)
 2003708:	e0fff417 	ldw	r3,-48(fp)
 200370c:	00003f06 	br	200380c <sqrt+0x150>
	if(x<0.0) {
 2003710:	000d883a 	mov	r6,zero
 2003714:	000f883a 	mov	r7,zero
 2003718:	e13ffe17 	ldw	r4,-8(fp)
 200371c:	e17fff17 	ldw	r5,-4(fp)
 2003720:	200538c0 	call	200538c <__ledf2>
 2003724:	1000370e 	bge	r2,zero,2003804 <sqrt+0x148>
	  exc.type = DOMAIN;
 2003728:	00800044 	movi	r2,1
 200372c:	e0bff515 	stw	r2,-44(fp)
	  exc.name = "sqrt";
 2003730:	008080b4 	movhi	r2,514
 2003734:	10bda504 	addi	r2,r2,-2412
 2003738:	e0bff615 	stw	r2,-40(fp)
	  exc.err = 0;
 200373c:	e03ffd15 	stw	zero,-12(fp)
	  exc.arg1 = exc.arg2 = x;
 2003740:	e0bffe17 	ldw	r2,-8(fp)
 2003744:	e0bff915 	stw	r2,-28(fp)
 2003748:	e0bfff17 	ldw	r2,-4(fp)
 200374c:	e0bffa15 	stw	r2,-24(fp)
 2003750:	e0bff917 	ldw	r2,-28(fp)
 2003754:	e0fffa17 	ldw	r3,-24(fp)
 2003758:	e0bff715 	stw	r2,-36(fp)
 200375c:	e0fff815 	stw	r3,-32(fp)
	  if (_LIB_VERSION == _SVID_)
 2003760:	d0a00517 	ldw	r2,-32748(gp)
 2003764:	1000031e 	bne	r2,zero,2003774 <sqrt+0xb8>
	    exc.retval = 0.0;
 2003768:	e03ffb15 	stw	zero,-20(fp)
 200376c:	e03ffc15 	stw	zero,-16(fp)
 2003770:	00000b06 	br	20037a0 <sqrt+0xe4>
          else
            exc.retval = 0.0/0.0;
 2003774:	000d883a 	mov	r6,zero
 2003778:	000f883a 	mov	r7,zero
 200377c:	0009883a 	mov	r4,zero
 2003780:	000b883a 	mov	r5,zero
 2003784:	20049400 	call	2004940 <__divdf3>
 2003788:	1009883a 	mov	r4,r2
 200378c:	180b883a 	mov	r5,r3
 2003790:	2005883a 	mov	r2,r4
 2003794:	2807883a 	mov	r3,r5
 2003798:	e0bffb15 	stw	r2,-20(fp)
 200379c:	e0fffc15 	stw	r3,-16(fp)
          if (_LIB_VERSION == _POSIX_)
 20037a0:	d0a00517 	ldw	r2,-32748(gp)
 20037a4:	10800098 	cmpnei	r2,r2,2
 20037a8:	1000051e 	bne	r2,zero,20037c0 <sqrt+0x104>
            errno = EDOM;
 20037ac:	20067b00 	call	20067b0 <__errno>
 20037b0:	1007883a 	mov	r3,r2
 20037b4:	00800844 	movi	r2,33
 20037b8:	18800015 	stw	r2,0(r3)
 20037bc:	00000806 	br	20037e0 <sqrt+0x124>
          else if (!matherr(&exc)) {
 20037c0:	e0bff504 	addi	r2,fp,-44
 20037c4:	1009883a 	mov	r4,r2
 20037c8:	2003e780 	call	2003e78 <matherr>
 20037cc:	1000041e 	bne	r2,zero,20037e0 <sqrt+0x124>
            errno = EDOM;
 20037d0:	20067b00 	call	20067b0 <__errno>
 20037d4:	1007883a 	mov	r3,r2
 20037d8:	00800844 	movi	r2,33
 20037dc:	18800015 	stw	r2,0(r3)
          }
          if (exc.err != 0)
 20037e0:	e0bffd17 	ldw	r2,-12(fp)
 20037e4:	10000426 	beq	r2,zero,20037f8 <sqrt+0x13c>
	    errno = exc.err;
 20037e8:	20067b00 	call	20067b0 <__errno>
 20037ec:	1007883a 	mov	r3,r2
 20037f0:	e0bffd17 	ldw	r2,-12(fp)
 20037f4:	18800015 	stw	r2,0(r3)
	  return exc.retval; 
 20037f8:	e0bffb17 	ldw	r2,-20(fp)
 20037fc:	e0fffc17 	ldw	r3,-16(fp)
 2003800:	00000206 	br	200380c <sqrt+0x150>
	} else
	    return z;
 2003804:	e0bff317 	ldw	r2,-52(fp)
 2003808:	e0fff417 	ldw	r3,-48(fp)
 200380c:	1009883a 	mov	r4,r2
 2003810:	180b883a 	mov	r5,r3
#endif
}
 2003814:	2005883a 	mov	r2,r4
 2003818:	2807883a 	mov	r3,r5
 200381c:	e037883a 	mov	sp,fp
 2003820:	dfc00117 	ldw	ra,4(sp)
 2003824:	df000017 	ldw	fp,0(sp)
 2003828:	dec00204 	addi	sp,sp,8
 200382c:	f800283a 	ret

02003830 <__ieee754_sqrt>:
	double __ieee754_sqrt(double x)
#else
	double __ieee754_sqrt(x)
	double x;
#endif
{
 2003830:	deffe804 	addi	sp,sp,-96
 2003834:	dfc01715 	stw	ra,92(sp)
 2003838:	df001615 	stw	fp,88(sp)
 200383c:	dc401515 	stw	r17,84(sp)
 2003840:	dc001415 	stw	r16,80(sp)
 2003844:	df001604 	addi	fp,sp,88
 2003848:	e13ffc15 	stw	r4,-16(fp)
 200384c:	e17ffd15 	stw	r5,-12(fp)
	double z;
	__int32_t sign = (int)0x80000000; 
 2003850:	00a00034 	movhi	r2,32768
 2003854:	e0bff315 	stw	r2,-52(fp)
	__uint32_t r,t1,s1,ix1,q1;
	__int32_t ix0,s0,q,m,t,i;

	EXTRACT_WORDS(ix0,ix1,x);
 2003858:	e0bffc17 	ldw	r2,-16(fp)
 200385c:	e0bff815 	stw	r2,-32(fp)
 2003860:	e0bffd17 	ldw	r2,-12(fp)
 2003864:	e0bff915 	stw	r2,-28(fp)
 2003868:	e0bff917 	ldw	r2,-28(fp)
 200386c:	e0bfee15 	stw	r2,-72(fp)
 2003870:	e0bff817 	ldw	r2,-32(fp)
 2003874:	e0bfec15 	stw	r2,-80(fp)

    /* take care of Inf and NaN */
	if((ix0&0x7ff00000)==0x7ff00000) {			
 2003878:	e0bfee17 	ldw	r2,-72(fp)
 200387c:	10dffc2c 	andhi	r3,r2,32752
 2003880:	009ffc34 	movhi	r2,32752
 2003884:	1880131e 	bne	r3,r2,20038d4 <__ieee754_sqrt+0xa4>
	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
 2003888:	e1bffc17 	ldw	r6,-16(fp)
 200388c:	e1fffd17 	ldw	r7,-12(fp)
 2003890:	e13ffc17 	ldw	r4,-16(fp)
 2003894:	e17ffd17 	ldw	r5,-12(fp)
 2003898:	20054800 	call	2005480 <__muldf3>
 200389c:	1009883a 	mov	r4,r2
 20038a0:	180b883a 	mov	r5,r3
 20038a4:	2005883a 	mov	r2,r4
 20038a8:	2807883a 	mov	r3,r5
 20038ac:	e1bffc17 	ldw	r6,-16(fp)
 20038b0:	e1fffd17 	ldw	r7,-12(fp)
 20038b4:	1009883a 	mov	r4,r2
 20038b8:	180b883a 	mov	r5,r3
 20038bc:	20040940 	call	2004094 <__adddf3>
 20038c0:	1009883a 	mov	r4,r2
 20038c4:	180b883a 	mov	r5,r3
 20038c8:	2005883a 	mov	r2,r4
 20038cc:	2807883a 	mov	r3,r5
 20038d0:	00015e06 	br	2003e4c <__ieee754_sqrt+0x61c>
					   sqrt(-inf)=sNaN */
	} 
    /* take care of zero */
	if(ix0<=0) {
 20038d4:	e0bfee17 	ldw	r2,-72(fp)
 20038d8:	00802916 	blt	zero,r2,2003980 <__ieee754_sqrt+0x150>
	    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
 20038dc:	e0bff317 	ldw	r2,-52(fp)
 20038e0:	0086303a 	nor	r3,zero,r2
 20038e4:	e0bfee17 	ldw	r2,-72(fp)
 20038e8:	1884703a 	and	r2,r3,r2
 20038ec:	1007883a 	mov	r3,r2
 20038f0:	e0bfec17 	ldw	r2,-80(fp)
 20038f4:	1884b03a 	or	r2,r3,r2
 20038f8:	1000031e 	bne	r2,zero,2003908 <__ieee754_sqrt+0xd8>
 20038fc:	e0bffc17 	ldw	r2,-16(fp)
 2003900:	e0fffd17 	ldw	r3,-12(fp)
 2003904:	00015106 	br	2003e4c <__ieee754_sqrt+0x61c>
	    else if(ix0<0)
 2003908:	e0bfee17 	ldw	r2,-72(fp)
 200390c:	10001c0e 	bge	r2,zero,2003980 <__ieee754_sqrt+0x150>
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
 2003910:	e1bffc17 	ldw	r6,-16(fp)
 2003914:	e1fffd17 	ldw	r7,-12(fp)
 2003918:	e13ffc17 	ldw	r4,-16(fp)
 200391c:	e17ffd17 	ldw	r5,-12(fp)
 2003920:	2005b980 	call	2005b98 <__subdf3>
 2003924:	1009883a 	mov	r4,r2
 2003928:	180b883a 	mov	r5,r3
 200392c:	2021883a 	mov	r16,r4
 2003930:	2823883a 	mov	r17,r5
 2003934:	e1bffc17 	ldw	r6,-16(fp)
 2003938:	e1fffd17 	ldw	r7,-12(fp)
 200393c:	e13ffc17 	ldw	r4,-16(fp)
 2003940:	e17ffd17 	ldw	r5,-12(fp)
 2003944:	2005b980 	call	2005b98 <__subdf3>
 2003948:	1009883a 	mov	r4,r2
 200394c:	180b883a 	mov	r5,r3
 2003950:	2005883a 	mov	r2,r4
 2003954:	2807883a 	mov	r3,r5
 2003958:	100d883a 	mov	r6,r2
 200395c:	180f883a 	mov	r7,r3
 2003960:	8009883a 	mov	r4,r16
 2003964:	880b883a 	mov	r5,r17
 2003968:	20049400 	call	2004940 <__divdf3>
 200396c:	1009883a 	mov	r4,r2
 2003970:	180b883a 	mov	r5,r3
 2003974:	2005883a 	mov	r2,r4
 2003978:	2807883a 	mov	r3,r5
 200397c:	00013306 	br	2003e4c <__ieee754_sqrt+0x61c>
	}
    /* normalize x */
	m = (ix0>>20);
 2003980:	e0bfee17 	ldw	r2,-72(fp)
 2003984:	1005d53a 	srai	r2,r2,20
 2003988:	e0bff115 	stw	r2,-60(fp)
	if(m==0) {				/* subnormal x */
 200398c:	e0bff117 	ldw	r2,-60(fp)
 2003990:	10002a1e 	bne	r2,zero,2003a3c <__ieee754_sqrt+0x20c>
	    while(ix0==0) {
 2003994:	00000b06 	br	20039c4 <__ieee754_sqrt+0x194>
		m -= 21;
 2003998:	e0bff117 	ldw	r2,-60(fp)
 200399c:	10bffac4 	addi	r2,r2,-21
 20039a0:	e0bff115 	stw	r2,-60(fp)
		ix0 |= (ix1>>11); ix1 <<= 21;
 20039a4:	e0bfec17 	ldw	r2,-80(fp)
 20039a8:	1006d2fa 	srli	r3,r2,11
 20039ac:	e0bfee17 	ldw	r2,-72(fp)
 20039b0:	1884b03a 	or	r2,r3,r2
 20039b4:	e0bfee15 	stw	r2,-72(fp)
 20039b8:	e0bfec17 	ldw	r2,-80(fp)
 20039bc:	1004957a 	slli	r2,r2,21
 20039c0:	e0bfec15 	stw	r2,-80(fp)
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
	}
    /* normalize x */
	m = (ix0>>20);
	if(m==0) {				/* subnormal x */
	    while(ix0==0) {
 20039c4:	e0bfee17 	ldw	r2,-72(fp)
 20039c8:	103ff326 	beq	r2,zero,2003998 <__ieee754_sqrt+0x168>
		m -= 21;
		ix0 |= (ix1>>11); ix1 <<= 21;
	    }
	    for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;
 20039cc:	e03ff215 	stw	zero,-56(fp)
 20039d0:	00000606 	br	20039ec <__ieee754_sqrt+0x1bc>
 20039d4:	e0bfee17 	ldw	r2,-72(fp)
 20039d8:	1085883a 	add	r2,r2,r2
 20039dc:	e0bfee15 	stw	r2,-72(fp)
 20039e0:	e0bff217 	ldw	r2,-56(fp)
 20039e4:	10800044 	addi	r2,r2,1
 20039e8:	e0bff215 	stw	r2,-56(fp)
 20039ec:	e0bfee17 	ldw	r2,-72(fp)
 20039f0:	1080042c 	andhi	r2,r2,16
 20039f4:	103ff726 	beq	r2,zero,20039d4 <__ieee754_sqrt+0x1a4>
	    m -= i-1;
 20039f8:	e0bff217 	ldw	r2,-56(fp)
 20039fc:	10bfffc4 	addi	r2,r2,-1
 2003a00:	e0fff117 	ldw	r3,-60(fp)
 2003a04:	1885c83a 	sub	r2,r3,r2
 2003a08:	e0bff115 	stw	r2,-60(fp)
	    ix0 |= (ix1>>(32-i));
 2003a0c:	00c00804 	movi	r3,32
 2003a10:	e0bff217 	ldw	r2,-56(fp)
 2003a14:	1885c83a 	sub	r2,r3,r2
 2003a18:	e0ffec17 	ldw	r3,-80(fp)
 2003a1c:	1886d83a 	srl	r3,r3,r2
 2003a20:	e0bfee17 	ldw	r2,-72(fp)
 2003a24:	1884b03a 	or	r2,r3,r2
 2003a28:	e0bfee15 	stw	r2,-72(fp)
	    ix1 <<= i;
 2003a2c:	e0ffec17 	ldw	r3,-80(fp)
 2003a30:	e0bff217 	ldw	r2,-56(fp)
 2003a34:	1884983a 	sll	r2,r3,r2
 2003a38:	e0bfec15 	stw	r2,-80(fp)
	}
	m -= 1023;	/* unbias exponent */
 2003a3c:	e0bff117 	ldw	r2,-60(fp)
 2003a40:	10bf0044 	addi	r2,r2,-1023
 2003a44:	e0bff115 	stw	r2,-60(fp)
	ix0 = (ix0&0x000fffff)|0x00100000;
 2003a48:	e0ffee17 	ldw	r3,-72(fp)
 2003a4c:	00800434 	movhi	r2,16
 2003a50:	10bfffc4 	addi	r2,r2,-1
 2003a54:	1884703a 	and	r2,r3,r2
 2003a58:	10800434 	orhi	r2,r2,16
 2003a5c:	e0bfee15 	stw	r2,-72(fp)
	if(m&1){	/* odd m, double x to make it even */
 2003a60:	e0bff117 	ldw	r2,-60(fp)
 2003a64:	1080004c 	andi	r2,r2,1
 2003a68:	10000d26 	beq	r2,zero,2003aa0 <__ieee754_sqrt+0x270>
	    ix0 += ix0 + ((ix1&sign)>>31);
 2003a6c:	e0fff317 	ldw	r3,-52(fp)
 2003a70:	e0bfec17 	ldw	r2,-80(fp)
 2003a74:	1884703a 	and	r2,r3,r2
 2003a78:	1006d7fa 	srli	r3,r2,31
 2003a7c:	e0bfee17 	ldw	r2,-72(fp)
 2003a80:	1887883a 	add	r3,r3,r2
 2003a84:	e0bfee17 	ldw	r2,-72(fp)
 2003a88:	1885883a 	add	r2,r3,r2
 2003a8c:	e0bfee15 	stw	r2,-72(fp)
	    ix1 += ix1;
 2003a90:	e0ffec17 	ldw	r3,-80(fp)
 2003a94:	e0bfec17 	ldw	r2,-80(fp)
 2003a98:	1885883a 	add	r2,r3,r2
 2003a9c:	e0bfec15 	stw	r2,-80(fp)
	}
	m >>= 1;	/* m = [m/2] */
 2003aa0:	e0bff117 	ldw	r2,-60(fp)
 2003aa4:	1005d07a 	srai	r2,r2,1
 2003aa8:	e0bff115 	stw	r2,-60(fp)

    /* generate sqrt(x) bit by bit */
	ix0 += ix0 + ((ix1&sign)>>31);
 2003aac:	e0fff317 	ldw	r3,-52(fp)
 2003ab0:	e0bfec17 	ldw	r2,-80(fp)
 2003ab4:	1884703a 	and	r2,r3,r2
 2003ab8:	1006d7fa 	srli	r3,r2,31
 2003abc:	e0bfee17 	ldw	r2,-72(fp)
 2003ac0:	1887883a 	add	r3,r3,r2
 2003ac4:	e0bfee17 	ldw	r2,-72(fp)
 2003ac8:	1885883a 	add	r2,r3,r2
 2003acc:	e0bfee15 	stw	r2,-72(fp)
	ix1 += ix1;
 2003ad0:	e0ffec17 	ldw	r3,-80(fp)
 2003ad4:	e0bfec17 	ldw	r2,-80(fp)
 2003ad8:	1885883a 	add	r2,r3,r2
 2003adc:	e0bfec15 	stw	r2,-80(fp)
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
 2003ae0:	e03feb15 	stw	zero,-84(fp)
 2003ae4:	e03fef15 	stw	zero,-68(fp)
 2003ae8:	e0bfef17 	ldw	r2,-68(fp)
 2003aec:	e0bfed15 	stw	r2,-76(fp)
 2003af0:	e0bfed17 	ldw	r2,-76(fp)
 2003af4:	e0bff015 	stw	r2,-64(fp)
	r = 0x00200000;		/* r = moving bit from right to left */
 2003af8:	00800834 	movhi	r2,32
 2003afc:	e0bfea15 	stw	r2,-88(fp)

	while(r!=0) {
 2003b00:	00002306 	br	2003b90 <__ieee754_sqrt+0x360>
	    t = s0+r; 
 2003b04:	e0ffef17 	ldw	r3,-68(fp)
 2003b08:	e0bfea17 	ldw	r2,-88(fp)
 2003b0c:	1885883a 	add	r2,r3,r2
 2003b10:	e0bff415 	stw	r2,-48(fp)
	    if(t<=ix0) { 
 2003b14:	e0bff417 	ldw	r2,-48(fp)
 2003b18:	e0ffee17 	ldw	r3,-72(fp)
 2003b1c:	18800c16 	blt	r3,r2,2003b50 <__ieee754_sqrt+0x320>
		s0   = t+r; 
 2003b20:	e0fff417 	ldw	r3,-48(fp)
 2003b24:	e0bfea17 	ldw	r2,-88(fp)
 2003b28:	1885883a 	add	r2,r3,r2
 2003b2c:	e0bfef15 	stw	r2,-68(fp)
		ix0 -= t; 
 2003b30:	e0ffee17 	ldw	r3,-72(fp)
 2003b34:	e0bff417 	ldw	r2,-48(fp)
 2003b38:	1885c83a 	sub	r2,r3,r2
 2003b3c:	e0bfee15 	stw	r2,-72(fp)
		q   += r; 
 2003b40:	e0fff017 	ldw	r3,-64(fp)
 2003b44:	e0bfea17 	ldw	r2,-88(fp)
 2003b48:	1885883a 	add	r2,r3,r2
 2003b4c:	e0bff015 	stw	r2,-64(fp)
	    } 
	    ix0 += ix0 + ((ix1&sign)>>31);
 2003b50:	e0fff317 	ldw	r3,-52(fp)
 2003b54:	e0bfec17 	ldw	r2,-80(fp)
 2003b58:	1884703a 	and	r2,r3,r2
 2003b5c:	1006d7fa 	srli	r3,r2,31
 2003b60:	e0bfee17 	ldw	r2,-72(fp)
 2003b64:	1887883a 	add	r3,r3,r2
 2003b68:	e0bfee17 	ldw	r2,-72(fp)
 2003b6c:	1885883a 	add	r2,r3,r2
 2003b70:	e0bfee15 	stw	r2,-72(fp)
	    ix1 += ix1;
 2003b74:	e0ffec17 	ldw	r3,-80(fp)
 2003b78:	e0bfec17 	ldw	r2,-80(fp)
 2003b7c:	1885883a 	add	r2,r3,r2
 2003b80:	e0bfec15 	stw	r2,-80(fp)
	    r>>=1;
 2003b84:	e0bfea17 	ldw	r2,-88(fp)
 2003b88:	1004d07a 	srli	r2,r2,1
 2003b8c:	e0bfea15 	stw	r2,-88(fp)
	ix0 += ix0 + ((ix1&sign)>>31);
	ix1 += ix1;
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
	r = 0x00200000;		/* r = moving bit from right to left */

	while(r!=0) {
 2003b90:	e0bfea17 	ldw	r2,-88(fp)
 2003b94:	103fdb1e 	bne	r2,zero,2003b04 <__ieee754_sqrt+0x2d4>
	    ix0 += ix0 + ((ix1&sign)>>31);
	    ix1 += ix1;
	    r>>=1;
	}

	r = sign;
 2003b98:	e0bff317 	ldw	r2,-52(fp)
 2003b9c:	e0bfea15 	stw	r2,-88(fp)
	while(r!=0) {
 2003ba0:	00004106 	br	2003ca8 <__ieee754_sqrt+0x478>
	    t1 = s1+r; 
 2003ba4:	e0ffeb17 	ldw	r3,-84(fp)
 2003ba8:	e0bfea17 	ldw	r2,-88(fp)
 2003bac:	1885883a 	add	r2,r3,r2
 2003bb0:	e0bff515 	stw	r2,-44(fp)
	    t  = s0;
 2003bb4:	e0bfef17 	ldw	r2,-68(fp)
 2003bb8:	e0bff415 	stw	r2,-48(fp)
	    if((t<ix0)||((t==ix0)&&(t1<=ix1))) { 
 2003bbc:	e0fff417 	ldw	r3,-48(fp)
 2003bc0:	e0bfee17 	ldw	r2,-72(fp)
 2003bc4:	18800616 	blt	r3,r2,2003be0 <__ieee754_sqrt+0x3b0>
 2003bc8:	e0fff417 	ldw	r3,-48(fp)
 2003bcc:	e0bfee17 	ldw	r2,-72(fp)
 2003bd0:	1880251e 	bne	r3,r2,2003c68 <__ieee754_sqrt+0x438>
 2003bd4:	e0bff517 	ldw	r2,-44(fp)
 2003bd8:	e0ffec17 	ldw	r3,-80(fp)
 2003bdc:	18802236 	bltu	r3,r2,2003c68 <__ieee754_sqrt+0x438>
		s1  = t1+r;
 2003be0:	e0fff517 	ldw	r3,-44(fp)
 2003be4:	e0bfea17 	ldw	r2,-88(fp)
 2003be8:	1885883a 	add	r2,r3,r2
 2003bec:	e0bfeb15 	stw	r2,-84(fp)
		if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;
 2003bf0:	e0fff317 	ldw	r3,-52(fp)
 2003bf4:	e0bff517 	ldw	r2,-44(fp)
 2003bf8:	1886703a 	and	r3,r3,r2
 2003bfc:	e0bff317 	ldw	r2,-52(fp)
 2003c00:	1880071e 	bne	r3,r2,2003c20 <__ieee754_sqrt+0x3f0>
 2003c04:	e0fff317 	ldw	r3,-52(fp)
 2003c08:	e0bfeb17 	ldw	r2,-84(fp)
 2003c0c:	1884703a 	and	r2,r3,r2
 2003c10:	1000031e 	bne	r2,zero,2003c20 <__ieee754_sqrt+0x3f0>
 2003c14:	e0bfef17 	ldw	r2,-68(fp)
 2003c18:	10800044 	addi	r2,r2,1
 2003c1c:	e0bfef15 	stw	r2,-68(fp)
		ix0 -= t;
 2003c20:	e0ffee17 	ldw	r3,-72(fp)
 2003c24:	e0bff417 	ldw	r2,-48(fp)
 2003c28:	1885c83a 	sub	r2,r3,r2
 2003c2c:	e0bfee15 	stw	r2,-72(fp)
		if (ix1 < t1) ix0 -= 1;
 2003c30:	e0ffec17 	ldw	r3,-80(fp)
 2003c34:	e0bff517 	ldw	r2,-44(fp)
 2003c38:	1880032e 	bgeu	r3,r2,2003c48 <__ieee754_sqrt+0x418>
 2003c3c:	e0bfee17 	ldw	r2,-72(fp)
 2003c40:	10bfffc4 	addi	r2,r2,-1
 2003c44:	e0bfee15 	stw	r2,-72(fp)
		ix1 -= t1;
 2003c48:	e0ffec17 	ldw	r3,-80(fp)
 2003c4c:	e0bff517 	ldw	r2,-44(fp)
 2003c50:	1885c83a 	sub	r2,r3,r2
 2003c54:	e0bfec15 	stw	r2,-80(fp)
		q1  += r;
 2003c58:	e0ffed17 	ldw	r3,-76(fp)
 2003c5c:	e0bfea17 	ldw	r2,-88(fp)
 2003c60:	1885883a 	add	r2,r3,r2
 2003c64:	e0bfed15 	stw	r2,-76(fp)
	    }
	    ix0 += ix0 + ((ix1&sign)>>31);
 2003c68:	e0fff317 	ldw	r3,-52(fp)
 2003c6c:	e0bfec17 	ldw	r2,-80(fp)
 2003c70:	1884703a 	and	r2,r3,r2
 2003c74:	1006d7fa 	srli	r3,r2,31
 2003c78:	e0bfee17 	ldw	r2,-72(fp)
 2003c7c:	1887883a 	add	r3,r3,r2
 2003c80:	e0bfee17 	ldw	r2,-72(fp)
 2003c84:	1885883a 	add	r2,r3,r2
 2003c88:	e0bfee15 	stw	r2,-72(fp)
	    ix1 += ix1;
 2003c8c:	e0ffec17 	ldw	r3,-80(fp)
 2003c90:	e0bfec17 	ldw	r2,-80(fp)
 2003c94:	1885883a 	add	r2,r3,r2
 2003c98:	e0bfec15 	stw	r2,-80(fp)
	    r>>=1;
 2003c9c:	e0bfea17 	ldw	r2,-88(fp)
 2003ca0:	1004d07a 	srli	r2,r2,1
 2003ca4:	e0bfea15 	stw	r2,-88(fp)
	    ix1 += ix1;
	    r>>=1;
	}

	r = sign;
	while(r!=0) {
 2003ca8:	e0bfea17 	ldw	r2,-88(fp)
 2003cac:	103fbd1e 	bne	r2,zero,2003ba4 <__ieee754_sqrt+0x374>
	    ix1 += ix1;
	    r>>=1;
	}

    /* use floating add to find out rounding direction */
	if((ix0|ix1)!=0) {
 2003cb0:	e0ffee17 	ldw	r3,-72(fp)
 2003cb4:	e0bfec17 	ldw	r2,-80(fp)
 2003cb8:	1884b03a 	or	r2,r3,r2
 2003cbc:	10004526 	beq	r2,zero,2003dd4 <__ieee754_sqrt+0x5a4>
	    z = one-tiny; /* trigger inexact flag */
 2003cc0:	0011883a 	mov	r8,zero
 2003cc4:	024ffc34 	movhi	r9,16368
 2003cc8:	00b0be74 	movhi	r2,49913
 2003ccc:	10bcd644 	addi	r2,r2,-3239
 2003cd0:	00c06974 	movhi	r3,421
 2003cd4:	18db87c4 	addi	r3,r3,28191
 2003cd8:	100d883a 	mov	r6,r2
 2003cdc:	180f883a 	mov	r7,r3
 2003ce0:	4009883a 	mov	r4,r8
 2003ce4:	480b883a 	mov	r5,r9
 2003ce8:	2005b980 	call	2005b98 <__subdf3>
 2003cec:	1009883a 	mov	r4,r2
 2003cf0:	180b883a 	mov	r5,r3
 2003cf4:	e13ff615 	stw	r4,-40(fp)
 2003cf8:	e17ff715 	stw	r5,-36(fp)
	    if (z>=one) {
 2003cfc:	0005883a 	mov	r2,zero
 2003d00:	00cffc34 	movhi	r3,16368
 2003d04:	100d883a 	mov	r6,r2
 2003d08:	180f883a 	mov	r7,r3
 2003d0c:	e13ff617 	ldw	r4,-40(fp)
 2003d10:	e17ff717 	ldw	r5,-36(fp)
 2003d14:	20052b00 	call	20052b0 <__gedf2>
 2003d18:	10002e16 	blt	r2,zero,2003dd4 <__ieee754_sqrt+0x5a4>
	        z = one+tiny;
 2003d1c:	0011883a 	mov	r8,zero
 2003d20:	024ffc34 	movhi	r9,16368
 2003d24:	00b0be74 	movhi	r2,49913
 2003d28:	10bcd644 	addi	r2,r2,-3239
 2003d2c:	00c06974 	movhi	r3,421
 2003d30:	18db87c4 	addi	r3,r3,28191
 2003d34:	100d883a 	mov	r6,r2
 2003d38:	180f883a 	mov	r7,r3
 2003d3c:	4009883a 	mov	r4,r8
 2003d40:	480b883a 	mov	r5,r9
 2003d44:	20040940 	call	2004094 <__adddf3>
 2003d48:	1009883a 	mov	r4,r2
 2003d4c:	180b883a 	mov	r5,r3
 2003d50:	e13ff615 	stw	r4,-40(fp)
 2003d54:	e17ff715 	stw	r5,-36(fp)
	        if (q1==(__uint32_t)0xffffffff) { q1=0; q += 1;}
 2003d58:	e0bfed17 	ldw	r2,-76(fp)
 2003d5c:	10bfffd8 	cmpnei	r2,r2,-1
 2003d60:	1000051e 	bne	r2,zero,2003d78 <__ieee754_sqrt+0x548>
 2003d64:	e03fed15 	stw	zero,-76(fp)
 2003d68:	e0bff017 	ldw	r2,-64(fp)
 2003d6c:	10800044 	addi	r2,r2,1
 2003d70:	e0bff015 	stw	r2,-64(fp)
 2003d74:	00001706 	br	2003dd4 <__ieee754_sqrt+0x5a4>
		else if (z>one) {
 2003d78:	0005883a 	mov	r2,zero
 2003d7c:	00cffc34 	movhi	r3,16368
 2003d80:	100d883a 	mov	r6,r2
 2003d84:	180f883a 	mov	r7,r3
 2003d88:	e13ff617 	ldw	r4,-40(fp)
 2003d8c:	e17ff717 	ldw	r5,-36(fp)
 2003d90:	20052b00 	call	20052b0 <__gedf2>
 2003d94:	00800a0e 	bge	zero,r2,2003dc0 <__ieee754_sqrt+0x590>
		    if (q1==(__uint32_t)0xfffffffe) q+=1;
 2003d98:	e0bfed17 	ldw	r2,-76(fp)
 2003d9c:	10bfff98 	cmpnei	r2,r2,-2
 2003da0:	1000031e 	bne	r2,zero,2003db0 <__ieee754_sqrt+0x580>
 2003da4:	e0bff017 	ldw	r2,-64(fp)
 2003da8:	10800044 	addi	r2,r2,1
 2003dac:	e0bff015 	stw	r2,-64(fp)
		    q1+=2; 
 2003db0:	e0bfed17 	ldw	r2,-76(fp)
 2003db4:	10800084 	addi	r2,r2,2
 2003db8:	e0bfed15 	stw	r2,-76(fp)
 2003dbc:	00000506 	br	2003dd4 <__ieee754_sqrt+0x5a4>
		} else
	            q1 += (q1&1);
 2003dc0:	e0bfed17 	ldw	r2,-76(fp)
 2003dc4:	1080004c 	andi	r2,r2,1
 2003dc8:	e0ffed17 	ldw	r3,-76(fp)
 2003dcc:	1885883a 	add	r2,r3,r2
 2003dd0:	e0bfed15 	stw	r2,-76(fp)
	    }
	}
	ix0 = (q>>1)+0x3fe00000;
 2003dd4:	e0bff017 	ldw	r2,-64(fp)
 2003dd8:	1007d07a 	srai	r3,r2,1
 2003ddc:	008ff834 	movhi	r2,16352
 2003de0:	1885883a 	add	r2,r3,r2
 2003de4:	e0bfee15 	stw	r2,-72(fp)
	ix1 =  q1>>1;
 2003de8:	e0bfed17 	ldw	r2,-76(fp)
 2003dec:	1004d07a 	srli	r2,r2,1
 2003df0:	e0bfec15 	stw	r2,-80(fp)
	if ((q&1)==1) ix1 |= sign;
 2003df4:	e0bff017 	ldw	r2,-64(fp)
 2003df8:	1080004c 	andi	r2,r2,1
 2003dfc:	10000426 	beq	r2,zero,2003e10 <__ieee754_sqrt+0x5e0>
 2003e00:	e0bff317 	ldw	r2,-52(fp)
 2003e04:	e0ffec17 	ldw	r3,-80(fp)
 2003e08:	1884b03a 	or	r2,r3,r2
 2003e0c:	e0bfec15 	stw	r2,-80(fp)
	ix0 += (m <<20);
 2003e10:	e0bff117 	ldw	r2,-60(fp)
 2003e14:	1004953a 	slli	r2,r2,20
 2003e18:	e0ffee17 	ldw	r3,-72(fp)
 2003e1c:	1885883a 	add	r2,r3,r2
 2003e20:	e0bfee15 	stw	r2,-72(fp)
	INSERT_WORDS(z,ix0,ix1);
 2003e24:	e0bfee17 	ldw	r2,-72(fp)
 2003e28:	e0bffb15 	stw	r2,-20(fp)
 2003e2c:	e0bfec17 	ldw	r2,-80(fp)
 2003e30:	e0bffa15 	stw	r2,-24(fp)
 2003e34:	e0bffa17 	ldw	r2,-24(fp)
 2003e38:	e0bff615 	stw	r2,-40(fp)
 2003e3c:	e0bffb17 	ldw	r2,-20(fp)
 2003e40:	e0bff715 	stw	r2,-36(fp)
	return z;
 2003e44:	e0bff617 	ldw	r2,-40(fp)
 2003e48:	e0fff717 	ldw	r3,-36(fp)
 2003e4c:	1009883a 	mov	r4,r2
 2003e50:	180b883a 	mov	r5,r3
}
 2003e54:	2005883a 	mov	r2,r4
 2003e58:	2807883a 	mov	r3,r5
 2003e5c:	e6fffe04 	addi	sp,fp,-8
 2003e60:	dfc00317 	ldw	ra,12(sp)
 2003e64:	df000217 	ldw	fp,8(sp)
 2003e68:	dc400117 	ldw	r17,4(sp)
 2003e6c:	dc000017 	ldw	r16,0(sp)
 2003e70:	dec00404 	addi	sp,sp,16
 2003e74:	f800283a 	ret

02003e78 <matherr>:
	int matherr(struct exception *x)
#else
	int matherr(x)
	struct exception *x;
#endif
{
 2003e78:	defffc04 	addi	sp,sp,-16
 2003e7c:	dfc00315 	stw	ra,12(sp)
 2003e80:	df000215 	stw	fp,8(sp)
 2003e84:	df000204 	addi	fp,sp,8
 2003e88:	e13fff15 	stw	r4,-4(fp)
	int n=0;
 2003e8c:	e03ffe15 	stw	zero,-8(fp)
	if(x->arg1!=x->arg1) return 0;
 2003e90:	e13fff17 	ldw	r4,-4(fp)
 2003e94:	20800217 	ldw	r2,8(r4)
 2003e98:	20c00317 	ldw	r3,12(r4)
 2003e9c:	e1bfff17 	ldw	r6,-4(fp)
 2003ea0:	31000217 	ldw	r4,8(r6)
 2003ea4:	31400317 	ldw	r5,12(r6)
 2003ea8:	200d883a 	mov	r6,r4
 2003eac:	280f883a 	mov	r7,r5
 2003eb0:	1009883a 	mov	r4,r2
 2003eb4:	180b883a 	mov	r5,r3
 2003eb8:	20052280 	call	2005228 <__eqdf2>
 2003ebc:	10000226 	beq	r2,zero,2003ec8 <matherr+0x50>
 2003ec0:	0005883a 	mov	r2,zero
 2003ec4:	00000106 	br	2003ecc <matherr+0x54>
	return n;
 2003ec8:	e0bffe17 	ldw	r2,-8(fp)
}
 2003ecc:	e037883a 	mov	sp,fp
 2003ed0:	dfc00117 	ldw	ra,4(sp)
 2003ed4:	df000017 	ldw	fp,0(sp)
 2003ed8:	dec00204 	addi	sp,sp,8
 2003edc:	f800283a 	ret

02003ee0 <__divsi3>:
 2003ee0:	20001b16 	blt	r4,zero,2003f50 <__divsi3+0x70>
 2003ee4:	000f883a 	mov	r7,zero
 2003ee8:	28001616 	blt	r5,zero,2003f44 <__divsi3+0x64>
 2003eec:	200d883a 	mov	r6,r4
 2003ef0:	29001a2e 	bgeu	r5,r4,2003f5c <__divsi3+0x7c>
 2003ef4:	00800804 	movi	r2,32
 2003ef8:	00c00044 	movi	r3,1
 2003efc:	00000106 	br	2003f04 <__divsi3+0x24>
 2003f00:	10000d26 	beq	r2,zero,2003f38 <__divsi3+0x58>
 2003f04:	294b883a 	add	r5,r5,r5
 2003f08:	10bfffc4 	addi	r2,r2,-1
 2003f0c:	18c7883a 	add	r3,r3,r3
 2003f10:	293ffb36 	bltu	r5,r4,2003f00 <__divsi3+0x20>
 2003f14:	0005883a 	mov	r2,zero
 2003f18:	18000726 	beq	r3,zero,2003f38 <__divsi3+0x58>
 2003f1c:	0005883a 	mov	r2,zero
 2003f20:	31400236 	bltu	r6,r5,2003f2c <__divsi3+0x4c>
 2003f24:	314dc83a 	sub	r6,r6,r5
 2003f28:	10c4b03a 	or	r2,r2,r3
 2003f2c:	1806d07a 	srli	r3,r3,1
 2003f30:	280ad07a 	srli	r5,r5,1
 2003f34:	183ffa1e 	bne	r3,zero,2003f20 <__divsi3+0x40>
 2003f38:	38000126 	beq	r7,zero,2003f40 <__divsi3+0x60>
 2003f3c:	0085c83a 	sub	r2,zero,r2
 2003f40:	f800283a 	ret
 2003f44:	014bc83a 	sub	r5,zero,r5
 2003f48:	39c0005c 	xori	r7,r7,1
 2003f4c:	003fe706 	br	2003eec <__divsi3+0xc>
 2003f50:	0109c83a 	sub	r4,zero,r4
 2003f54:	01c00044 	movi	r7,1
 2003f58:	003fe306 	br	2003ee8 <__divsi3+0x8>
 2003f5c:	00c00044 	movi	r3,1
 2003f60:	003fee06 	br	2003f1c <__divsi3+0x3c>

02003f64 <__modsi3>:
 2003f64:	20001716 	blt	r4,zero,2003fc4 <__modsi3+0x60>
 2003f68:	000f883a 	mov	r7,zero
 2003f6c:	2005883a 	mov	r2,r4
 2003f70:	28001216 	blt	r5,zero,2003fbc <__modsi3+0x58>
 2003f74:	2900162e 	bgeu	r5,r4,2003fd0 <__modsi3+0x6c>
 2003f78:	01800804 	movi	r6,32
 2003f7c:	00c00044 	movi	r3,1
 2003f80:	00000106 	br	2003f88 <__modsi3+0x24>
 2003f84:	30000a26 	beq	r6,zero,2003fb0 <__modsi3+0x4c>
 2003f88:	294b883a 	add	r5,r5,r5
 2003f8c:	31bfffc4 	addi	r6,r6,-1
 2003f90:	18c7883a 	add	r3,r3,r3
 2003f94:	293ffb36 	bltu	r5,r4,2003f84 <__modsi3+0x20>
 2003f98:	18000526 	beq	r3,zero,2003fb0 <__modsi3+0x4c>
 2003f9c:	1806d07a 	srli	r3,r3,1
 2003fa0:	11400136 	bltu	r2,r5,2003fa8 <__modsi3+0x44>
 2003fa4:	1145c83a 	sub	r2,r2,r5
 2003fa8:	280ad07a 	srli	r5,r5,1
 2003fac:	183ffb1e 	bne	r3,zero,2003f9c <__modsi3+0x38>
 2003fb0:	38000126 	beq	r7,zero,2003fb8 <__modsi3+0x54>
 2003fb4:	0085c83a 	sub	r2,zero,r2
 2003fb8:	f800283a 	ret
 2003fbc:	014bc83a 	sub	r5,zero,r5
 2003fc0:	003fec06 	br	2003f74 <__modsi3+0x10>
 2003fc4:	0109c83a 	sub	r4,zero,r4
 2003fc8:	01c00044 	movi	r7,1
 2003fcc:	003fe706 	br	2003f6c <__modsi3+0x8>
 2003fd0:	00c00044 	movi	r3,1
 2003fd4:	003ff106 	br	2003f9c <__modsi3+0x38>

02003fd8 <__udivsi3>:
 2003fd8:	200d883a 	mov	r6,r4
 2003fdc:	2900152e 	bgeu	r5,r4,2004034 <__udivsi3+0x5c>
 2003fe0:	28001416 	blt	r5,zero,2004034 <__udivsi3+0x5c>
 2003fe4:	00800804 	movi	r2,32
 2003fe8:	00c00044 	movi	r3,1
 2003fec:	00000206 	br	2003ff8 <__udivsi3+0x20>
 2003ff0:	10000e26 	beq	r2,zero,200402c <__udivsi3+0x54>
 2003ff4:	28000516 	blt	r5,zero,200400c <__udivsi3+0x34>
 2003ff8:	294b883a 	add	r5,r5,r5
 2003ffc:	10bfffc4 	addi	r2,r2,-1
 2004000:	18c7883a 	add	r3,r3,r3
 2004004:	293ffa36 	bltu	r5,r4,2003ff0 <__udivsi3+0x18>
 2004008:	18000826 	beq	r3,zero,200402c <__udivsi3+0x54>
 200400c:	0005883a 	mov	r2,zero
 2004010:	31400236 	bltu	r6,r5,200401c <__udivsi3+0x44>
 2004014:	314dc83a 	sub	r6,r6,r5
 2004018:	10c4b03a 	or	r2,r2,r3
 200401c:	1806d07a 	srli	r3,r3,1
 2004020:	280ad07a 	srli	r5,r5,1
 2004024:	183ffa1e 	bne	r3,zero,2004010 <__udivsi3+0x38>
 2004028:	f800283a 	ret
 200402c:	0005883a 	mov	r2,zero
 2004030:	f800283a 	ret
 2004034:	00c00044 	movi	r3,1
 2004038:	003ff406 	br	200400c <__udivsi3+0x34>

0200403c <__umodsi3>:
 200403c:	2005883a 	mov	r2,r4
 2004040:	2900122e 	bgeu	r5,r4,200408c <__umodsi3+0x50>
 2004044:	28001116 	blt	r5,zero,200408c <__umodsi3+0x50>
 2004048:	01800804 	movi	r6,32
 200404c:	00c00044 	movi	r3,1
 2004050:	00000206 	br	200405c <__umodsi3+0x20>
 2004054:	30000c26 	beq	r6,zero,2004088 <__umodsi3+0x4c>
 2004058:	28000516 	blt	r5,zero,2004070 <__umodsi3+0x34>
 200405c:	294b883a 	add	r5,r5,r5
 2004060:	31bfffc4 	addi	r6,r6,-1
 2004064:	18c7883a 	add	r3,r3,r3
 2004068:	293ffa36 	bltu	r5,r4,2004054 <__umodsi3+0x18>
 200406c:	18000626 	beq	r3,zero,2004088 <__umodsi3+0x4c>
 2004070:	1806d07a 	srli	r3,r3,1
 2004074:	11400136 	bltu	r2,r5,200407c <__umodsi3+0x40>
 2004078:	1145c83a 	sub	r2,r2,r5
 200407c:	280ad07a 	srli	r5,r5,1
 2004080:	183ffb1e 	bne	r3,zero,2004070 <__umodsi3+0x34>
 2004084:	f800283a 	ret
 2004088:	f800283a 	ret
 200408c:	00c00044 	movi	r3,1
 2004090:	003ff706 	br	2004070 <__umodsi3+0x34>

02004094 <__adddf3>:
 2004094:	02c00434 	movhi	r11,16
 2004098:	5affffc4 	addi	r11,r11,-1
 200409c:	2806d7fa 	srli	r3,r5,31
 20040a0:	2ad4703a 	and	r10,r5,r11
 20040a4:	3ad2703a 	and	r9,r7,r11
 20040a8:	3804d53a 	srli	r2,r7,20
 20040ac:	3018d77a 	srli	r12,r6,29
 20040b0:	280ad53a 	srli	r5,r5,20
 20040b4:	501490fa 	slli	r10,r10,3
 20040b8:	2010d77a 	srli	r8,r4,29
 20040bc:	481290fa 	slli	r9,r9,3
 20040c0:	380ed7fa 	srli	r7,r7,31
 20040c4:	defffb04 	addi	sp,sp,-20
 20040c8:	dc800215 	stw	r18,8(sp)
 20040cc:	dc400115 	stw	r17,4(sp)
 20040d0:	dc000015 	stw	r16,0(sp)
 20040d4:	dfc00415 	stw	ra,16(sp)
 20040d8:	dcc00315 	stw	r19,12(sp)
 20040dc:	1c803fcc 	andi	r18,r3,255
 20040e0:	2c01ffcc 	andi	r16,r5,2047
 20040e4:	5210b03a 	or	r8,r10,r8
 20040e8:	202290fa 	slli	r17,r4,3
 20040ec:	1081ffcc 	andi	r2,r2,2047
 20040f0:	4b12b03a 	or	r9,r9,r12
 20040f4:	300c90fa 	slli	r6,r6,3
 20040f8:	91c07526 	beq	r18,r7,20042d0 <__adddf3+0x23c>
 20040fc:	8087c83a 	sub	r3,r16,r2
 2004100:	00c0ab0e 	bge	zero,r3,20043b0 <__adddf3+0x31c>
 2004104:	10002a1e 	bne	r2,zero,20041b0 <__adddf3+0x11c>
 2004108:	4984b03a 	or	r2,r9,r6
 200410c:	1000961e 	bne	r2,zero,2004368 <__adddf3+0x2d4>
 2004110:	888001cc 	andi	r2,r17,7
 2004114:	10000726 	beq	r2,zero,2004134 <__adddf3+0xa0>
 2004118:	888003cc 	andi	r2,r17,15
 200411c:	00c00104 	movi	r3,4
 2004120:	10c00426 	beq	r2,r3,2004134 <__adddf3+0xa0>
 2004124:	88c7883a 	add	r3,r17,r3
 2004128:	1c63803a 	cmpltu	r17,r3,r17
 200412c:	4451883a 	add	r8,r8,r17
 2004130:	1823883a 	mov	r17,r3
 2004134:	4080202c 	andhi	r2,r8,128
 2004138:	10005926 	beq	r2,zero,20042a0 <__adddf3+0x20c>
 200413c:	84000044 	addi	r16,r16,1
 2004140:	0081ffc4 	movi	r2,2047
 2004144:	8080ba26 	beq	r16,r2,2004430 <__adddf3+0x39c>
 2004148:	00bfe034 	movhi	r2,65408
 200414c:	10bfffc4 	addi	r2,r2,-1
 2004150:	4090703a 	and	r8,r8,r2
 2004154:	4004977a 	slli	r2,r8,29
 2004158:	4010927a 	slli	r8,r8,9
 200415c:	8822d0fa 	srli	r17,r17,3
 2004160:	8401ffcc 	andi	r16,r16,2047
 2004164:	4010d33a 	srli	r8,r8,12
 2004168:	9007883a 	mov	r3,r18
 200416c:	1444b03a 	or	r2,r2,r17
 2004170:	8401ffcc 	andi	r16,r16,2047
 2004174:	8020953a 	slli	r16,r16,20
 2004178:	18c03fcc 	andi	r3,r3,255
 200417c:	01000434 	movhi	r4,16
 2004180:	213fffc4 	addi	r4,r4,-1
 2004184:	180697fa 	slli	r3,r3,31
 2004188:	4110703a 	and	r8,r8,r4
 200418c:	4410b03a 	or	r8,r8,r16
 2004190:	40c6b03a 	or	r3,r8,r3
 2004194:	dfc00417 	ldw	ra,16(sp)
 2004198:	dcc00317 	ldw	r19,12(sp)
 200419c:	dc800217 	ldw	r18,8(sp)
 20041a0:	dc400117 	ldw	r17,4(sp)
 20041a4:	dc000017 	ldw	r16,0(sp)
 20041a8:	dec00504 	addi	sp,sp,20
 20041ac:	f800283a 	ret
 20041b0:	0081ffc4 	movi	r2,2047
 20041b4:	80bfd626 	beq	r16,r2,2004110 <__adddf3+0x7c>
 20041b8:	4a402034 	orhi	r9,r9,128
 20041bc:	00800e04 	movi	r2,56
 20041c0:	10c09f16 	blt	r2,r3,2004440 <__adddf3+0x3ac>
 20041c4:	008007c4 	movi	r2,31
 20041c8:	10c0c216 	blt	r2,r3,20044d4 <__adddf3+0x440>
 20041cc:	00800804 	movi	r2,32
 20041d0:	10c5c83a 	sub	r2,r2,r3
 20041d4:	488a983a 	sll	r5,r9,r2
 20041d8:	30c8d83a 	srl	r4,r6,r3
 20041dc:	3084983a 	sll	r2,r6,r2
 20041e0:	48c6d83a 	srl	r3,r9,r3
 20041e4:	290cb03a 	or	r6,r5,r4
 20041e8:	1004c03a 	cmpne	r2,r2,zero
 20041ec:	308cb03a 	or	r6,r6,r2
 20041f0:	898dc83a 	sub	r6,r17,r6
 20041f4:	89a3803a 	cmpltu	r17,r17,r6
 20041f8:	40d1c83a 	sub	r8,r8,r3
 20041fc:	4451c83a 	sub	r8,r8,r17
 2004200:	3023883a 	mov	r17,r6
 2004204:	4080202c 	andhi	r2,r8,128
 2004208:	10002326 	beq	r2,zero,2004298 <__adddf3+0x204>
 200420c:	04c02034 	movhi	r19,128
 2004210:	9cffffc4 	addi	r19,r19,-1
 2004214:	44e6703a 	and	r19,r8,r19
 2004218:	98007626 	beq	r19,zero,20043f4 <__adddf3+0x360>
 200421c:	9809883a 	mov	r4,r19
 2004220:	200674c0 	call	200674c <__clzsi2>
 2004224:	10fffe04 	addi	r3,r2,-8
 2004228:	010007c4 	movi	r4,31
 200422c:	20c07716 	blt	r4,r3,200440c <__adddf3+0x378>
 2004230:	00800804 	movi	r2,32
 2004234:	10c5c83a 	sub	r2,r2,r3
 2004238:	8884d83a 	srl	r2,r17,r2
 200423c:	98d0983a 	sll	r8,r19,r3
 2004240:	88e2983a 	sll	r17,r17,r3
 2004244:	1204b03a 	or	r2,r2,r8
 2004248:	1c007416 	blt	r3,r16,200441c <__adddf3+0x388>
 200424c:	1c21c83a 	sub	r16,r3,r16
 2004250:	82000044 	addi	r8,r16,1
 2004254:	00c007c4 	movi	r3,31
 2004258:	1a009116 	blt	r3,r8,20044a0 <__adddf3+0x40c>
 200425c:	00c00804 	movi	r3,32
 2004260:	1a07c83a 	sub	r3,r3,r8
 2004264:	8a08d83a 	srl	r4,r17,r8
 2004268:	88e2983a 	sll	r17,r17,r3
 200426c:	10c6983a 	sll	r3,r2,r3
 2004270:	1210d83a 	srl	r8,r2,r8
 2004274:	8804c03a 	cmpne	r2,r17,zero
 2004278:	1906b03a 	or	r3,r3,r4
 200427c:	18a2b03a 	or	r17,r3,r2
 2004280:	0021883a 	mov	r16,zero
 2004284:	003fa206 	br	2004110 <__adddf3+0x7c>
 2004288:	1890b03a 	or	r8,r3,r2
 200428c:	40017d26 	beq	r8,zero,2004884 <__adddf3+0x7f0>
 2004290:	1011883a 	mov	r8,r2
 2004294:	1823883a 	mov	r17,r3
 2004298:	888001cc 	andi	r2,r17,7
 200429c:	103f9e1e 	bne	r2,zero,2004118 <__adddf3+0x84>
 20042a0:	4004977a 	slli	r2,r8,29
 20042a4:	8822d0fa 	srli	r17,r17,3
 20042a8:	4010d0fa 	srli	r8,r8,3
 20042ac:	9007883a 	mov	r3,r18
 20042b0:	1444b03a 	or	r2,r2,r17
 20042b4:	0101ffc4 	movi	r4,2047
 20042b8:	81002426 	beq	r16,r4,200434c <__adddf3+0x2b8>
 20042bc:	8120703a 	and	r16,r16,r4
 20042c0:	01000434 	movhi	r4,16
 20042c4:	213fffc4 	addi	r4,r4,-1
 20042c8:	4110703a 	and	r8,r8,r4
 20042cc:	003fa806 	br	2004170 <__adddf3+0xdc>
 20042d0:	8089c83a 	sub	r4,r16,r2
 20042d4:	01005e0e 	bge	zero,r4,2004450 <__adddf3+0x3bc>
 20042d8:	10002b26 	beq	r2,zero,2004388 <__adddf3+0x2f4>
 20042dc:	0081ffc4 	movi	r2,2047
 20042e0:	80bf8b26 	beq	r16,r2,2004110 <__adddf3+0x7c>
 20042e4:	4a402034 	orhi	r9,r9,128
 20042e8:	00800e04 	movi	r2,56
 20042ec:	1100a40e 	bge	r2,r4,2004580 <__adddf3+0x4ec>
 20042f0:	498cb03a 	or	r6,r9,r6
 20042f4:	300ac03a 	cmpne	r5,r6,zero
 20042f8:	0013883a 	mov	r9,zero
 20042fc:	2c4b883a 	add	r5,r5,r17
 2004300:	2c63803a 	cmpltu	r17,r5,r17
 2004304:	4a11883a 	add	r8,r9,r8
 2004308:	8a11883a 	add	r8,r17,r8
 200430c:	2823883a 	mov	r17,r5
 2004310:	4080202c 	andhi	r2,r8,128
 2004314:	103fe026 	beq	r2,zero,2004298 <__adddf3+0x204>
 2004318:	84000044 	addi	r16,r16,1
 200431c:	0081ffc4 	movi	r2,2047
 2004320:	8080d226 	beq	r16,r2,200466c <__adddf3+0x5d8>
 2004324:	00bfe034 	movhi	r2,65408
 2004328:	10bfffc4 	addi	r2,r2,-1
 200432c:	4090703a 	and	r8,r8,r2
 2004330:	880ad07a 	srli	r5,r17,1
 2004334:	400897fa 	slli	r4,r8,31
 2004338:	88c0004c 	andi	r3,r17,1
 200433c:	28e2b03a 	or	r17,r5,r3
 2004340:	4010d07a 	srli	r8,r8,1
 2004344:	2462b03a 	or	r17,r4,r17
 2004348:	003f7106 	br	2004110 <__adddf3+0x7c>
 200434c:	4088b03a 	or	r4,r8,r2
 2004350:	20014526 	beq	r4,zero,2004868 <__adddf3+0x7d4>
 2004354:	01000434 	movhi	r4,16
 2004358:	42000234 	orhi	r8,r8,8
 200435c:	213fffc4 	addi	r4,r4,-1
 2004360:	4110703a 	and	r8,r8,r4
 2004364:	003f8206 	br	2004170 <__adddf3+0xdc>
 2004368:	18ffffc4 	addi	r3,r3,-1
 200436c:	1800491e 	bne	r3,zero,2004494 <__adddf3+0x400>
 2004370:	898bc83a 	sub	r5,r17,r6
 2004374:	8963803a 	cmpltu	r17,r17,r5
 2004378:	4251c83a 	sub	r8,r8,r9
 200437c:	4451c83a 	sub	r8,r8,r17
 2004380:	2823883a 	mov	r17,r5
 2004384:	003f9f06 	br	2004204 <__adddf3+0x170>
 2004388:	4984b03a 	or	r2,r9,r6
 200438c:	103f6026 	beq	r2,zero,2004110 <__adddf3+0x7c>
 2004390:	213fffc4 	addi	r4,r4,-1
 2004394:	2000931e 	bne	r4,zero,20045e4 <__adddf3+0x550>
 2004398:	898d883a 	add	r6,r17,r6
 200439c:	3463803a 	cmpltu	r17,r6,r17
 20043a0:	4251883a 	add	r8,r8,r9
 20043a4:	8a11883a 	add	r8,r17,r8
 20043a8:	3023883a 	mov	r17,r6
 20043ac:	003fd806 	br	2004310 <__adddf3+0x27c>
 20043b0:	1800541e 	bne	r3,zero,2004504 <__adddf3+0x470>
 20043b4:	80800044 	addi	r2,r16,1
 20043b8:	1081ffcc 	andi	r2,r2,2047
 20043bc:	00c00044 	movi	r3,1
 20043c0:	1880a00e 	bge	r3,r2,2004644 <__adddf3+0x5b0>
 20043c4:	8989c83a 	sub	r4,r17,r6
 20043c8:	8905803a 	cmpltu	r2,r17,r4
 20043cc:	4267c83a 	sub	r19,r8,r9
 20043d0:	98a7c83a 	sub	r19,r19,r2
 20043d4:	9880202c 	andhi	r2,r19,128
 20043d8:	10006326 	beq	r2,zero,2004568 <__adddf3+0x4d4>
 20043dc:	3463c83a 	sub	r17,r6,r17
 20043e0:	4a07c83a 	sub	r3,r9,r8
 20043e4:	344d803a 	cmpltu	r6,r6,r17
 20043e8:	19a7c83a 	sub	r19,r3,r6
 20043ec:	3825883a 	mov	r18,r7
 20043f0:	983f8a1e 	bne	r19,zero,200421c <__adddf3+0x188>
 20043f4:	8809883a 	mov	r4,r17
 20043f8:	200674c0 	call	200674c <__clzsi2>
 20043fc:	10800804 	addi	r2,r2,32
 2004400:	10fffe04 	addi	r3,r2,-8
 2004404:	010007c4 	movi	r4,31
 2004408:	20ff890e 	bge	r4,r3,2004230 <__adddf3+0x19c>
 200440c:	10bff604 	addi	r2,r2,-40
 2004410:	8884983a 	sll	r2,r17,r2
 2004414:	0023883a 	mov	r17,zero
 2004418:	1c3f8c0e 	bge	r3,r16,200424c <__adddf3+0x1b8>
 200441c:	023fe034 	movhi	r8,65408
 2004420:	423fffc4 	addi	r8,r8,-1
 2004424:	80e1c83a 	sub	r16,r16,r3
 2004428:	1210703a 	and	r8,r2,r8
 200442c:	003f3806 	br	2004110 <__adddf3+0x7c>
 2004430:	9007883a 	mov	r3,r18
 2004434:	0011883a 	mov	r8,zero
 2004438:	0005883a 	mov	r2,zero
 200443c:	003f4c06 	br	2004170 <__adddf3+0xdc>
 2004440:	498cb03a 	or	r6,r9,r6
 2004444:	300cc03a 	cmpne	r6,r6,zero
 2004448:	0007883a 	mov	r3,zero
 200444c:	003f6806 	br	20041f0 <__adddf3+0x15c>
 2004450:	20009c1e 	bne	r4,zero,20046c4 <__adddf3+0x630>
 2004454:	80800044 	addi	r2,r16,1
 2004458:	1141ffcc 	andi	r5,r2,2047
 200445c:	01000044 	movi	r4,1
 2004460:	2140670e 	bge	r4,r5,2004600 <__adddf3+0x56c>
 2004464:	0101ffc4 	movi	r4,2047
 2004468:	11007f26 	beq	r2,r4,2004668 <__adddf3+0x5d4>
 200446c:	898d883a 	add	r6,r17,r6
 2004470:	4247883a 	add	r3,r8,r9
 2004474:	3451803a 	cmpltu	r8,r6,r17
 2004478:	40d1883a 	add	r8,r8,r3
 200447c:	402297fa 	slli	r17,r8,31
 2004480:	300cd07a 	srli	r6,r6,1
 2004484:	4010d07a 	srli	r8,r8,1
 2004488:	1021883a 	mov	r16,r2
 200448c:	89a2b03a 	or	r17,r17,r6
 2004490:	003f1f06 	br	2004110 <__adddf3+0x7c>
 2004494:	0081ffc4 	movi	r2,2047
 2004498:	80bf481e 	bne	r16,r2,20041bc <__adddf3+0x128>
 200449c:	003f1c06 	br	2004110 <__adddf3+0x7c>
 20044a0:	843ff844 	addi	r16,r16,-31
 20044a4:	01000804 	movi	r4,32
 20044a8:	1406d83a 	srl	r3,r2,r16
 20044ac:	41005026 	beq	r8,r4,20045f0 <__adddf3+0x55c>
 20044b0:	01001004 	movi	r4,64
 20044b4:	2211c83a 	sub	r8,r4,r8
 20044b8:	1204983a 	sll	r2,r2,r8
 20044bc:	88a2b03a 	or	r17,r17,r2
 20044c0:	8822c03a 	cmpne	r17,r17,zero
 20044c4:	1c62b03a 	or	r17,r3,r17
 20044c8:	0011883a 	mov	r8,zero
 20044cc:	0021883a 	mov	r16,zero
 20044d0:	003f7106 	br	2004298 <__adddf3+0x204>
 20044d4:	193ff804 	addi	r4,r3,-32
 20044d8:	00800804 	movi	r2,32
 20044dc:	4908d83a 	srl	r4,r9,r4
 20044e0:	18804526 	beq	r3,r2,20045f8 <__adddf3+0x564>
 20044e4:	00801004 	movi	r2,64
 20044e8:	10c5c83a 	sub	r2,r2,r3
 20044ec:	4886983a 	sll	r3,r9,r2
 20044f0:	198cb03a 	or	r6,r3,r6
 20044f4:	300cc03a 	cmpne	r6,r6,zero
 20044f8:	218cb03a 	or	r6,r4,r6
 20044fc:	0007883a 	mov	r3,zero
 2004500:	003f3b06 	br	20041f0 <__adddf3+0x15c>
 2004504:	80002a26 	beq	r16,zero,20045b0 <__adddf3+0x51c>
 2004508:	0101ffc4 	movi	r4,2047
 200450c:	11006826 	beq	r2,r4,20046b0 <__adddf3+0x61c>
 2004510:	00c7c83a 	sub	r3,zero,r3
 2004514:	42002034 	orhi	r8,r8,128
 2004518:	01000e04 	movi	r4,56
 200451c:	20c07c16 	blt	r4,r3,2004710 <__adddf3+0x67c>
 2004520:	010007c4 	movi	r4,31
 2004524:	20c0da16 	blt	r4,r3,2004890 <__adddf3+0x7fc>
 2004528:	01000804 	movi	r4,32
 200452c:	20c9c83a 	sub	r4,r4,r3
 2004530:	4114983a 	sll	r10,r8,r4
 2004534:	88cad83a 	srl	r5,r17,r3
 2004538:	8908983a 	sll	r4,r17,r4
 200453c:	40c6d83a 	srl	r3,r8,r3
 2004540:	5162b03a 	or	r17,r10,r5
 2004544:	2008c03a 	cmpne	r4,r4,zero
 2004548:	8922b03a 	or	r17,r17,r4
 200454c:	3463c83a 	sub	r17,r6,r17
 2004550:	48c7c83a 	sub	r3,r9,r3
 2004554:	344d803a 	cmpltu	r6,r6,r17
 2004558:	1991c83a 	sub	r8,r3,r6
 200455c:	1021883a 	mov	r16,r2
 2004560:	3825883a 	mov	r18,r7
 2004564:	003f2706 	br	2004204 <__adddf3+0x170>
 2004568:	24d0b03a 	or	r8,r4,r19
 200456c:	40001b1e 	bne	r8,zero,20045dc <__adddf3+0x548>
 2004570:	0005883a 	mov	r2,zero
 2004574:	0007883a 	mov	r3,zero
 2004578:	0021883a 	mov	r16,zero
 200457c:	003f4d06 	br	20042b4 <__adddf3+0x220>
 2004580:	008007c4 	movi	r2,31
 2004584:	11003c16 	blt	r2,r4,2004678 <__adddf3+0x5e4>
 2004588:	00800804 	movi	r2,32
 200458c:	1105c83a 	sub	r2,r2,r4
 2004590:	488e983a 	sll	r7,r9,r2
 2004594:	310ad83a 	srl	r5,r6,r4
 2004598:	3084983a 	sll	r2,r6,r2
 200459c:	4912d83a 	srl	r9,r9,r4
 20045a0:	394ab03a 	or	r5,r7,r5
 20045a4:	1004c03a 	cmpne	r2,r2,zero
 20045a8:	288ab03a 	or	r5,r5,r2
 20045ac:	003f5306 	br	20042fc <__adddf3+0x268>
 20045b0:	4448b03a 	or	r4,r8,r17
 20045b4:	20003e26 	beq	r4,zero,20046b0 <__adddf3+0x61c>
 20045b8:	00c6303a 	nor	r3,zero,r3
 20045bc:	18003a1e 	bne	r3,zero,20046a8 <__adddf3+0x614>
 20045c0:	3463c83a 	sub	r17,r6,r17
 20045c4:	4a07c83a 	sub	r3,r9,r8
 20045c8:	344d803a 	cmpltu	r6,r6,r17
 20045cc:	1991c83a 	sub	r8,r3,r6
 20045d0:	1021883a 	mov	r16,r2
 20045d4:	3825883a 	mov	r18,r7
 20045d8:	003f0a06 	br	2004204 <__adddf3+0x170>
 20045dc:	2023883a 	mov	r17,r4
 20045e0:	003f0d06 	br	2004218 <__adddf3+0x184>
 20045e4:	0081ffc4 	movi	r2,2047
 20045e8:	80bf3f1e 	bne	r16,r2,20042e8 <__adddf3+0x254>
 20045ec:	003ec806 	br	2004110 <__adddf3+0x7c>
 20045f0:	0005883a 	mov	r2,zero
 20045f4:	003fb106 	br	20044bc <__adddf3+0x428>
 20045f8:	0007883a 	mov	r3,zero
 20045fc:	003fbc06 	br	20044f0 <__adddf3+0x45c>
 2004600:	4444b03a 	or	r2,r8,r17
 2004604:	8000871e 	bne	r16,zero,2004824 <__adddf3+0x790>
 2004608:	1000ba26 	beq	r2,zero,20048f4 <__adddf3+0x860>
 200460c:	4984b03a 	or	r2,r9,r6
 2004610:	103ebf26 	beq	r2,zero,2004110 <__adddf3+0x7c>
 2004614:	8985883a 	add	r2,r17,r6
 2004618:	4247883a 	add	r3,r8,r9
 200461c:	1451803a 	cmpltu	r8,r2,r17
 2004620:	40d1883a 	add	r8,r8,r3
 2004624:	40c0202c 	andhi	r3,r8,128
 2004628:	1023883a 	mov	r17,r2
 200462c:	183f1a26 	beq	r3,zero,2004298 <__adddf3+0x204>
 2004630:	00bfe034 	movhi	r2,65408
 2004634:	10bfffc4 	addi	r2,r2,-1
 2004638:	2021883a 	mov	r16,r4
 200463c:	4090703a 	and	r8,r8,r2
 2004640:	003eb306 	br	2004110 <__adddf3+0x7c>
 2004644:	4444b03a 	or	r2,r8,r17
 2004648:	8000291e 	bne	r16,zero,20046f0 <__adddf3+0x65c>
 200464c:	10004b1e 	bne	r2,zero,200477c <__adddf3+0x6e8>
 2004650:	4990b03a 	or	r8,r9,r6
 2004654:	40008b26 	beq	r8,zero,2004884 <__adddf3+0x7f0>
 2004658:	4811883a 	mov	r8,r9
 200465c:	3023883a 	mov	r17,r6
 2004660:	3825883a 	mov	r18,r7
 2004664:	003eaa06 	br	2004110 <__adddf3+0x7c>
 2004668:	1021883a 	mov	r16,r2
 200466c:	0011883a 	mov	r8,zero
 2004670:	0005883a 	mov	r2,zero
 2004674:	003f0f06 	br	20042b4 <__adddf3+0x220>
 2004678:	217ff804 	addi	r5,r4,-32
 200467c:	00800804 	movi	r2,32
 2004680:	494ad83a 	srl	r5,r9,r5
 2004684:	20807d26 	beq	r4,r2,200487c <__adddf3+0x7e8>
 2004688:	00801004 	movi	r2,64
 200468c:	1109c83a 	sub	r4,r2,r4
 2004690:	4912983a 	sll	r9,r9,r4
 2004694:	498cb03a 	or	r6,r9,r6
 2004698:	300cc03a 	cmpne	r6,r6,zero
 200469c:	298ab03a 	or	r5,r5,r6
 20046a0:	0013883a 	mov	r9,zero
 20046a4:	003f1506 	br	20042fc <__adddf3+0x268>
 20046a8:	0101ffc4 	movi	r4,2047
 20046ac:	113f9a1e 	bne	r2,r4,2004518 <__adddf3+0x484>
 20046b0:	4811883a 	mov	r8,r9
 20046b4:	3023883a 	mov	r17,r6
 20046b8:	1021883a 	mov	r16,r2
 20046bc:	3825883a 	mov	r18,r7
 20046c0:	003e9306 	br	2004110 <__adddf3+0x7c>
 20046c4:	8000161e 	bne	r16,zero,2004720 <__adddf3+0x68c>
 20046c8:	444ab03a 	or	r5,r8,r17
 20046cc:	28005126 	beq	r5,zero,2004814 <__adddf3+0x780>
 20046d0:	0108303a 	nor	r4,zero,r4
 20046d4:	20004d1e 	bne	r4,zero,200480c <__adddf3+0x778>
 20046d8:	89a3883a 	add	r17,r17,r6
 20046dc:	4253883a 	add	r9,r8,r9
 20046e0:	898d803a 	cmpltu	r6,r17,r6
 20046e4:	3251883a 	add	r8,r6,r9
 20046e8:	1021883a 	mov	r16,r2
 20046ec:	003f0806 	br	2004310 <__adddf3+0x27c>
 20046f0:	1000301e 	bne	r2,zero,20047b4 <__adddf3+0x720>
 20046f4:	4984b03a 	or	r2,r9,r6
 20046f8:	10007126 	beq	r2,zero,20048c0 <__adddf3+0x82c>
 20046fc:	4811883a 	mov	r8,r9
 2004700:	3023883a 	mov	r17,r6
 2004704:	3825883a 	mov	r18,r7
 2004708:	0401ffc4 	movi	r16,2047
 200470c:	003e8006 	br	2004110 <__adddf3+0x7c>
 2004710:	4462b03a 	or	r17,r8,r17
 2004714:	8822c03a 	cmpne	r17,r17,zero
 2004718:	0007883a 	mov	r3,zero
 200471c:	003f8b06 	br	200454c <__adddf3+0x4b8>
 2004720:	0141ffc4 	movi	r5,2047
 2004724:	11403b26 	beq	r2,r5,2004814 <__adddf3+0x780>
 2004728:	0109c83a 	sub	r4,zero,r4
 200472c:	42002034 	orhi	r8,r8,128
 2004730:	01400e04 	movi	r5,56
 2004734:	29006716 	blt	r5,r4,20048d4 <__adddf3+0x840>
 2004738:	014007c4 	movi	r5,31
 200473c:	29007016 	blt	r5,r4,2004900 <__adddf3+0x86c>
 2004740:	01400804 	movi	r5,32
 2004744:	290bc83a 	sub	r5,r5,r4
 2004748:	4154983a 	sll	r10,r8,r5
 200474c:	890ed83a 	srl	r7,r17,r4
 2004750:	894a983a 	sll	r5,r17,r5
 2004754:	4108d83a 	srl	r4,r8,r4
 2004758:	51e2b03a 	or	r17,r10,r7
 200475c:	280ac03a 	cmpne	r5,r5,zero
 2004760:	8962b03a 	or	r17,r17,r5
 2004764:	89a3883a 	add	r17,r17,r6
 2004768:	2253883a 	add	r9,r4,r9
 200476c:	898d803a 	cmpltu	r6,r17,r6
 2004770:	3251883a 	add	r8,r6,r9
 2004774:	1021883a 	mov	r16,r2
 2004778:	003ee506 	br	2004310 <__adddf3+0x27c>
 200477c:	4984b03a 	or	r2,r9,r6
 2004780:	103e6326 	beq	r2,zero,2004110 <__adddf3+0x7c>
 2004784:	8987c83a 	sub	r3,r17,r6
 2004788:	88c9803a 	cmpltu	r4,r17,r3
 200478c:	4245c83a 	sub	r2,r8,r9
 2004790:	1105c83a 	sub	r2,r2,r4
 2004794:	1100202c 	andhi	r4,r2,128
 2004798:	203ebb26 	beq	r4,zero,2004288 <__adddf3+0x1f4>
 200479c:	3463c83a 	sub	r17,r6,r17
 20047a0:	4a07c83a 	sub	r3,r9,r8
 20047a4:	344d803a 	cmpltu	r6,r6,r17
 20047a8:	1991c83a 	sub	r8,r3,r6
 20047ac:	3825883a 	mov	r18,r7
 20047b0:	003e5706 	br	2004110 <__adddf3+0x7c>
 20047b4:	4984b03a 	or	r2,r9,r6
 20047b8:	10002e26 	beq	r2,zero,2004874 <__adddf3+0x7e0>
 20047bc:	4004d0fa 	srli	r2,r8,3
 20047c0:	8822d0fa 	srli	r17,r17,3
 20047c4:	4010977a 	slli	r8,r8,29
 20047c8:	10c0022c 	andhi	r3,r2,8
 20047cc:	4462b03a 	or	r17,r8,r17
 20047d0:	18000826 	beq	r3,zero,20047f4 <__adddf3+0x760>
 20047d4:	4808d0fa 	srli	r4,r9,3
 20047d8:	20c0022c 	andhi	r3,r4,8
 20047dc:	1800051e 	bne	r3,zero,20047f4 <__adddf3+0x760>
 20047e0:	300cd0fa 	srli	r6,r6,3
 20047e4:	4806977a 	slli	r3,r9,29
 20047e8:	2005883a 	mov	r2,r4
 20047ec:	3825883a 	mov	r18,r7
 20047f0:	19a2b03a 	or	r17,r3,r6
 20047f4:	8810d77a 	srli	r8,r17,29
 20047f8:	100490fa 	slli	r2,r2,3
 20047fc:	882290fa 	slli	r17,r17,3
 2004800:	0401ffc4 	movi	r16,2047
 2004804:	4090b03a 	or	r8,r8,r2
 2004808:	003e4106 	br	2004110 <__adddf3+0x7c>
 200480c:	0141ffc4 	movi	r5,2047
 2004810:	117fc71e 	bne	r2,r5,2004730 <__adddf3+0x69c>
 2004814:	4811883a 	mov	r8,r9
 2004818:	3023883a 	mov	r17,r6
 200481c:	1021883a 	mov	r16,r2
 2004820:	003e3b06 	br	2004110 <__adddf3+0x7c>
 2004824:	10002f26 	beq	r2,zero,20048e4 <__adddf3+0x850>
 2004828:	4984b03a 	or	r2,r9,r6
 200482c:	10001126 	beq	r2,zero,2004874 <__adddf3+0x7e0>
 2004830:	4004d0fa 	srli	r2,r8,3
 2004834:	8822d0fa 	srli	r17,r17,3
 2004838:	4010977a 	slli	r8,r8,29
 200483c:	10c0022c 	andhi	r3,r2,8
 2004840:	4462b03a 	or	r17,r8,r17
 2004844:	183feb26 	beq	r3,zero,20047f4 <__adddf3+0x760>
 2004848:	4808d0fa 	srli	r4,r9,3
 200484c:	20c0022c 	andhi	r3,r4,8
 2004850:	183fe81e 	bne	r3,zero,20047f4 <__adddf3+0x760>
 2004854:	300cd0fa 	srli	r6,r6,3
 2004858:	4806977a 	slli	r3,r9,29
 200485c:	2005883a 	mov	r2,r4
 2004860:	19a2b03a 	or	r17,r3,r6
 2004864:	003fe306 	br	20047f4 <__adddf3+0x760>
 2004868:	0011883a 	mov	r8,zero
 200486c:	0005883a 	mov	r2,zero
 2004870:	003e3f06 	br	2004170 <__adddf3+0xdc>
 2004874:	0401ffc4 	movi	r16,2047
 2004878:	003e2506 	br	2004110 <__adddf3+0x7c>
 200487c:	0013883a 	mov	r9,zero
 2004880:	003f8406 	br	2004694 <__adddf3+0x600>
 2004884:	0005883a 	mov	r2,zero
 2004888:	0007883a 	mov	r3,zero
 200488c:	003e8906 	br	20042b4 <__adddf3+0x220>
 2004890:	197ff804 	addi	r5,r3,-32
 2004894:	01000804 	movi	r4,32
 2004898:	414ad83a 	srl	r5,r8,r5
 200489c:	19002426 	beq	r3,r4,2004930 <__adddf3+0x89c>
 20048a0:	01001004 	movi	r4,64
 20048a4:	20c7c83a 	sub	r3,r4,r3
 20048a8:	40c6983a 	sll	r3,r8,r3
 20048ac:	1c46b03a 	or	r3,r3,r17
 20048b0:	1806c03a 	cmpne	r3,r3,zero
 20048b4:	28e2b03a 	or	r17,r5,r3
 20048b8:	0007883a 	mov	r3,zero
 20048bc:	003f2306 	br	200454c <__adddf3+0x4b8>
 20048c0:	0007883a 	mov	r3,zero
 20048c4:	5811883a 	mov	r8,r11
 20048c8:	00bfffc4 	movi	r2,-1
 20048cc:	0401ffc4 	movi	r16,2047
 20048d0:	003e7806 	br	20042b4 <__adddf3+0x220>
 20048d4:	4462b03a 	or	r17,r8,r17
 20048d8:	8822c03a 	cmpne	r17,r17,zero
 20048dc:	0009883a 	mov	r4,zero
 20048e0:	003fa006 	br	2004764 <__adddf3+0x6d0>
 20048e4:	4811883a 	mov	r8,r9
 20048e8:	3023883a 	mov	r17,r6
 20048ec:	0401ffc4 	movi	r16,2047
 20048f0:	003e0706 	br	2004110 <__adddf3+0x7c>
 20048f4:	4811883a 	mov	r8,r9
 20048f8:	3023883a 	mov	r17,r6
 20048fc:	003e0406 	br	2004110 <__adddf3+0x7c>
 2004900:	21fff804 	addi	r7,r4,-32
 2004904:	01400804 	movi	r5,32
 2004908:	41ced83a 	srl	r7,r8,r7
 200490c:	21400a26 	beq	r4,r5,2004938 <__adddf3+0x8a4>
 2004910:	01401004 	movi	r5,64
 2004914:	2909c83a 	sub	r4,r5,r4
 2004918:	4108983a 	sll	r4,r8,r4
 200491c:	2448b03a 	or	r4,r4,r17
 2004920:	2008c03a 	cmpne	r4,r4,zero
 2004924:	3922b03a 	or	r17,r7,r4
 2004928:	0009883a 	mov	r4,zero
 200492c:	003f8d06 	br	2004764 <__adddf3+0x6d0>
 2004930:	0007883a 	mov	r3,zero
 2004934:	003fdd06 	br	20048ac <__adddf3+0x818>
 2004938:	0009883a 	mov	r4,zero
 200493c:	003ff706 	br	200491c <__adddf3+0x888>

02004940 <__divdf3>:
 2004940:	defff204 	addi	sp,sp,-56
 2004944:	dd400915 	stw	r21,36(sp)
 2004948:	282ad53a 	srli	r21,r5,20
 200494c:	dd000815 	stw	r20,32(sp)
 2004950:	2828d7fa 	srli	r20,r5,31
 2004954:	dc000415 	stw	r16,16(sp)
 2004958:	04000434 	movhi	r16,16
 200495c:	df000c15 	stw	fp,48(sp)
 2004960:	843fffc4 	addi	r16,r16,-1
 2004964:	dfc00d15 	stw	ra,52(sp)
 2004968:	ddc00b15 	stw	r23,44(sp)
 200496c:	dd800a15 	stw	r22,40(sp)
 2004970:	dcc00715 	stw	r19,28(sp)
 2004974:	dc800615 	stw	r18,24(sp)
 2004978:	dc400515 	stw	r17,20(sp)
 200497c:	ad41ffcc 	andi	r21,r21,2047
 2004980:	2c20703a 	and	r16,r5,r16
 2004984:	a7003fcc 	andi	fp,r20,255
 2004988:	a8006126 	beq	r21,zero,2004b10 <__divdf3+0x1d0>
 200498c:	0081ffc4 	movi	r2,2047
 2004990:	2025883a 	mov	r18,r4
 2004994:	a8803726 	beq	r21,r2,2004a74 <__divdf3+0x134>
 2004998:	80800434 	orhi	r2,r16,16
 200499c:	100490fa 	slli	r2,r2,3
 20049a0:	2020d77a 	srli	r16,r4,29
 20049a4:	202490fa 	slli	r18,r4,3
 20049a8:	ad7f0044 	addi	r21,r21,-1023
 20049ac:	80a0b03a 	or	r16,r16,r2
 20049b0:	0027883a 	mov	r19,zero
 20049b4:	0013883a 	mov	r9,zero
 20049b8:	3804d53a 	srli	r2,r7,20
 20049bc:	382cd7fa 	srli	r22,r7,31
 20049c0:	04400434 	movhi	r17,16
 20049c4:	8c7fffc4 	addi	r17,r17,-1
 20049c8:	1081ffcc 	andi	r2,r2,2047
 20049cc:	3011883a 	mov	r8,r6
 20049d0:	3c62703a 	and	r17,r7,r17
 20049d4:	b5c03fcc 	andi	r23,r22,255
 20049d8:	10006c26 	beq	r2,zero,2004b8c <__divdf3+0x24c>
 20049dc:	00c1ffc4 	movi	r3,2047
 20049e0:	10c06426 	beq	r2,r3,2004b74 <__divdf3+0x234>
 20049e4:	88c00434 	orhi	r3,r17,16
 20049e8:	180690fa 	slli	r3,r3,3
 20049ec:	3022d77a 	srli	r17,r6,29
 20049f0:	301090fa 	slli	r8,r6,3
 20049f4:	10bf0044 	addi	r2,r2,-1023
 20049f8:	88e2b03a 	or	r17,r17,r3
 20049fc:	000f883a 	mov	r7,zero
 2004a00:	a58cf03a 	xor	r6,r20,r22
 2004a04:	3cc8b03a 	or	r4,r7,r19
 2004a08:	a8abc83a 	sub	r21,r21,r2
 2004a0c:	008003c4 	movi	r2,15
 2004a10:	3007883a 	mov	r3,r6
 2004a14:	34c03fcc 	andi	r19,r6,255
 2004a18:	11009036 	bltu	r2,r4,2004c5c <__divdf3+0x31c>
 2004a1c:	200890ba 	slli	r4,r4,2
 2004a20:	00808034 	movhi	r2,512
 2004a24:	10928d04 	addi	r2,r2,18996
 2004a28:	2089883a 	add	r4,r4,r2
 2004a2c:	20800017 	ldw	r2,0(r4)
 2004a30:	1000683a 	jmp	r2
 2004a34:	02004c5c 	xori	r8,zero,305
 2004a38:	02004aac 	andhi	r8,zero,298
 2004a3c:	02004c4c 	andi	r8,zero,305
 2004a40:	02004aa0 	cmpeqi	r8,zero,298
 2004a44:	02004c4c 	andi	r8,zero,305
 2004a48:	02004c20 	cmpeqi	r8,zero,304
 2004a4c:	02004c4c 	andi	r8,zero,305
 2004a50:	02004aa0 	cmpeqi	r8,zero,298
 2004a54:	02004aac 	andhi	r8,zero,298
 2004a58:	02004aac 	andhi	r8,zero,298
 2004a5c:	02004c20 	cmpeqi	r8,zero,304
 2004a60:	02004aa0 	cmpeqi	r8,zero,298
 2004a64:	02004a90 	cmplti	r8,zero,298
 2004a68:	02004a90 	cmplti	r8,zero,298
 2004a6c:	02004a90 	cmplti	r8,zero,298
 2004a70:	02004f40 	call	2004f4 <__alt_mem_mem_Nios_PI+0x4f4>
 2004a74:	2404b03a 	or	r2,r4,r16
 2004a78:	1000661e 	bne	r2,zero,2004c14 <__divdf3+0x2d4>
 2004a7c:	04c00204 	movi	r19,8
 2004a80:	0021883a 	mov	r16,zero
 2004a84:	0025883a 	mov	r18,zero
 2004a88:	02400084 	movi	r9,2
 2004a8c:	003fca06 	br	20049b8 <__divdf3+0x78>
 2004a90:	8023883a 	mov	r17,r16
 2004a94:	9011883a 	mov	r8,r18
 2004a98:	e02f883a 	mov	r23,fp
 2004a9c:	480f883a 	mov	r7,r9
 2004aa0:	00800084 	movi	r2,2
 2004aa4:	3881311e 	bne	r7,r2,2004f6c <__divdf3+0x62c>
 2004aa8:	b827883a 	mov	r19,r23
 2004aac:	98c0004c 	andi	r3,r19,1
 2004ab0:	0081ffc4 	movi	r2,2047
 2004ab4:	000b883a 	mov	r5,zero
 2004ab8:	0025883a 	mov	r18,zero
 2004abc:	1004953a 	slli	r2,r2,20
 2004ac0:	18c03fcc 	andi	r3,r3,255
 2004ac4:	04400434 	movhi	r17,16
 2004ac8:	8c7fffc4 	addi	r17,r17,-1
 2004acc:	180697fa 	slli	r3,r3,31
 2004ad0:	2c4a703a 	and	r5,r5,r17
 2004ad4:	288ab03a 	or	r5,r5,r2
 2004ad8:	28c6b03a 	or	r3,r5,r3
 2004adc:	9005883a 	mov	r2,r18
 2004ae0:	dfc00d17 	ldw	ra,52(sp)
 2004ae4:	df000c17 	ldw	fp,48(sp)
 2004ae8:	ddc00b17 	ldw	r23,44(sp)
 2004aec:	dd800a17 	ldw	r22,40(sp)
 2004af0:	dd400917 	ldw	r21,36(sp)
 2004af4:	dd000817 	ldw	r20,32(sp)
 2004af8:	dcc00717 	ldw	r19,28(sp)
 2004afc:	dc800617 	ldw	r18,24(sp)
 2004b00:	dc400517 	ldw	r17,20(sp)
 2004b04:	dc000417 	ldw	r16,16(sp)
 2004b08:	dec00e04 	addi	sp,sp,56
 2004b0c:	f800283a 	ret
 2004b10:	2404b03a 	or	r2,r4,r16
 2004b14:	2027883a 	mov	r19,r4
 2004b18:	10003926 	beq	r2,zero,2004c00 <__divdf3+0x2c0>
 2004b1c:	80012e26 	beq	r16,zero,2004fd8 <__divdf3+0x698>
 2004b20:	8009883a 	mov	r4,r16
 2004b24:	d9800315 	stw	r6,12(sp)
 2004b28:	d9c00215 	stw	r7,8(sp)
 2004b2c:	200674c0 	call	200674c <__clzsi2>
 2004b30:	d9800317 	ldw	r6,12(sp)
 2004b34:	d9c00217 	ldw	r7,8(sp)
 2004b38:	113ffd44 	addi	r4,r2,-11
 2004b3c:	00c00704 	movi	r3,28
 2004b40:	19012116 	blt	r3,r4,2004fc8 <__divdf3+0x688>
 2004b44:	00c00744 	movi	r3,29
 2004b48:	147ffe04 	addi	r17,r2,-8
 2004b4c:	1907c83a 	sub	r3,r3,r4
 2004b50:	8460983a 	sll	r16,r16,r17
 2004b54:	98c6d83a 	srl	r3,r19,r3
 2004b58:	9c64983a 	sll	r18,r19,r17
 2004b5c:	1c20b03a 	or	r16,r3,r16
 2004b60:	1080fcc4 	addi	r2,r2,1011
 2004b64:	00abc83a 	sub	r21,zero,r2
 2004b68:	0027883a 	mov	r19,zero
 2004b6c:	0013883a 	mov	r9,zero
 2004b70:	003f9106 	br	20049b8 <__divdf3+0x78>
 2004b74:	3446b03a 	or	r3,r6,r17
 2004b78:	18001f1e 	bne	r3,zero,2004bf8 <__divdf3+0x2b8>
 2004b7c:	0023883a 	mov	r17,zero
 2004b80:	0011883a 	mov	r8,zero
 2004b84:	01c00084 	movi	r7,2
 2004b88:	003f9d06 	br	2004a00 <__divdf3+0xc0>
 2004b8c:	3446b03a 	or	r3,r6,r17
 2004b90:	18001526 	beq	r3,zero,2004be8 <__divdf3+0x2a8>
 2004b94:	88011b26 	beq	r17,zero,2005004 <__divdf3+0x6c4>
 2004b98:	8809883a 	mov	r4,r17
 2004b9c:	d9800315 	stw	r6,12(sp)
 2004ba0:	da400115 	stw	r9,4(sp)
 2004ba4:	200674c0 	call	200674c <__clzsi2>
 2004ba8:	d9800317 	ldw	r6,12(sp)
 2004bac:	da400117 	ldw	r9,4(sp)
 2004bb0:	113ffd44 	addi	r4,r2,-11
 2004bb4:	00c00704 	movi	r3,28
 2004bb8:	19010e16 	blt	r3,r4,2004ff4 <__divdf3+0x6b4>
 2004bbc:	00c00744 	movi	r3,29
 2004bc0:	123ffe04 	addi	r8,r2,-8
 2004bc4:	1907c83a 	sub	r3,r3,r4
 2004bc8:	8a22983a 	sll	r17,r17,r8
 2004bcc:	30c6d83a 	srl	r3,r6,r3
 2004bd0:	3210983a 	sll	r8,r6,r8
 2004bd4:	1c62b03a 	or	r17,r3,r17
 2004bd8:	1080fcc4 	addi	r2,r2,1011
 2004bdc:	0085c83a 	sub	r2,zero,r2
 2004be0:	000f883a 	mov	r7,zero
 2004be4:	003f8606 	br	2004a00 <__divdf3+0xc0>
 2004be8:	0023883a 	mov	r17,zero
 2004bec:	0011883a 	mov	r8,zero
 2004bf0:	01c00044 	movi	r7,1
 2004bf4:	003f8206 	br	2004a00 <__divdf3+0xc0>
 2004bf8:	01c000c4 	movi	r7,3
 2004bfc:	003f8006 	br	2004a00 <__divdf3+0xc0>
 2004c00:	04c00104 	movi	r19,4
 2004c04:	0021883a 	mov	r16,zero
 2004c08:	0025883a 	mov	r18,zero
 2004c0c:	02400044 	movi	r9,1
 2004c10:	003f6906 	br	20049b8 <__divdf3+0x78>
 2004c14:	04c00304 	movi	r19,12
 2004c18:	024000c4 	movi	r9,3
 2004c1c:	003f6606 	br	20049b8 <__divdf3+0x78>
 2004c20:	01400434 	movhi	r5,16
 2004c24:	0007883a 	mov	r3,zero
 2004c28:	297fffc4 	addi	r5,r5,-1
 2004c2c:	04bfffc4 	movi	r18,-1
 2004c30:	0081ffc4 	movi	r2,2047
 2004c34:	003fa106 	br	2004abc <__divdf3+0x17c>
 2004c38:	00c00044 	movi	r3,1
 2004c3c:	1887c83a 	sub	r3,r3,r2
 2004c40:	01000e04 	movi	r4,56
 2004c44:	20c1210e 	bge	r4,r3,20050cc <__divdf3+0x78c>
 2004c48:	98c0004c 	andi	r3,r19,1
 2004c4c:	0005883a 	mov	r2,zero
 2004c50:	000b883a 	mov	r5,zero
 2004c54:	0025883a 	mov	r18,zero
 2004c58:	003f9806 	br	2004abc <__divdf3+0x17c>
 2004c5c:	8c00fd36 	bltu	r17,r16,2005054 <__divdf3+0x714>
 2004c60:	8440fb26 	beq	r16,r17,2005050 <__divdf3+0x710>
 2004c64:	8007883a 	mov	r3,r16
 2004c68:	ad7fffc4 	addi	r21,r21,-1
 2004c6c:	0021883a 	mov	r16,zero
 2004c70:	4004d63a 	srli	r2,r8,24
 2004c74:	8822923a 	slli	r17,r17,8
 2004c78:	1809883a 	mov	r4,r3
 2004c7c:	402c923a 	slli	r22,r8,8
 2004c80:	88b8b03a 	or	fp,r17,r2
 2004c84:	e028d43a 	srli	r20,fp,16
 2004c88:	d8c00015 	stw	r3,0(sp)
 2004c8c:	e5ffffcc 	andi	r23,fp,65535
 2004c90:	a00b883a 	mov	r5,r20
 2004c94:	2003fd80 	call	2003fd8 <__udivsi3>
 2004c98:	d8c00017 	ldw	r3,0(sp)
 2004c9c:	a00b883a 	mov	r5,r20
 2004ca0:	d8800315 	stw	r2,12(sp)
 2004ca4:	1809883a 	mov	r4,r3
 2004ca8:	200403c0 	call	200403c <__umodsi3>
 2004cac:	d9800317 	ldw	r6,12(sp)
 2004cb0:	1006943a 	slli	r3,r2,16
 2004cb4:	9004d43a 	srli	r2,r18,16
 2004cb8:	b9a3383a 	mul	r17,r23,r6
 2004cbc:	10c4b03a 	or	r2,r2,r3
 2004cc0:	1440062e 	bgeu	r2,r17,2004cdc <__divdf3+0x39c>
 2004cc4:	1705883a 	add	r2,r2,fp
 2004cc8:	30ffffc4 	addi	r3,r6,-1
 2004ccc:	1700ee36 	bltu	r2,fp,2005088 <__divdf3+0x748>
 2004cd0:	1440ed2e 	bgeu	r2,r17,2005088 <__divdf3+0x748>
 2004cd4:	31bfff84 	addi	r6,r6,-2
 2004cd8:	1705883a 	add	r2,r2,fp
 2004cdc:	1463c83a 	sub	r17,r2,r17
 2004ce0:	a00b883a 	mov	r5,r20
 2004ce4:	8809883a 	mov	r4,r17
 2004ce8:	d9800315 	stw	r6,12(sp)
 2004cec:	2003fd80 	call	2003fd8 <__udivsi3>
 2004cf0:	a00b883a 	mov	r5,r20
 2004cf4:	8809883a 	mov	r4,r17
 2004cf8:	d8800215 	stw	r2,8(sp)
 2004cfc:	200403c0 	call	200403c <__umodsi3>
 2004d00:	d9c00217 	ldw	r7,8(sp)
 2004d04:	1004943a 	slli	r2,r2,16
 2004d08:	94bfffcc 	andi	r18,r18,65535
 2004d0c:	b9d1383a 	mul	r8,r23,r7
 2004d10:	90a4b03a 	or	r18,r18,r2
 2004d14:	d9800317 	ldw	r6,12(sp)
 2004d18:	9200062e 	bgeu	r18,r8,2004d34 <__divdf3+0x3f4>
 2004d1c:	9725883a 	add	r18,r18,fp
 2004d20:	38bfffc4 	addi	r2,r7,-1
 2004d24:	9700d636 	bltu	r18,fp,2005080 <__divdf3+0x740>
 2004d28:	9200d52e 	bgeu	r18,r8,2005080 <__divdf3+0x740>
 2004d2c:	39ffff84 	addi	r7,r7,-2
 2004d30:	9725883a 	add	r18,r18,fp
 2004d34:	3004943a 	slli	r2,r6,16
 2004d38:	b012d43a 	srli	r9,r22,16
 2004d3c:	b1bfffcc 	andi	r6,r22,65535
 2004d40:	11e2b03a 	or	r17,r2,r7
 2004d44:	8806d43a 	srli	r3,r17,16
 2004d48:	893fffcc 	andi	r4,r17,65535
 2004d4c:	218b383a 	mul	r5,r4,r6
 2004d50:	30c5383a 	mul	r2,r6,r3
 2004d54:	2249383a 	mul	r4,r4,r9
 2004d58:	280ed43a 	srli	r7,r5,16
 2004d5c:	9225c83a 	sub	r18,r18,r8
 2004d60:	2089883a 	add	r4,r4,r2
 2004d64:	3909883a 	add	r4,r7,r4
 2004d68:	1a47383a 	mul	r3,r3,r9
 2004d6c:	2080022e 	bgeu	r4,r2,2004d78 <__divdf3+0x438>
 2004d70:	00800074 	movhi	r2,1
 2004d74:	1887883a 	add	r3,r3,r2
 2004d78:	2004d43a 	srli	r2,r4,16
 2004d7c:	2008943a 	slli	r4,r4,16
 2004d80:	297fffcc 	andi	r5,r5,65535
 2004d84:	10c7883a 	add	r3,r2,r3
 2004d88:	2149883a 	add	r4,r4,r5
 2004d8c:	90c0a536 	bltu	r18,r3,2005024 <__divdf3+0x6e4>
 2004d90:	90c0bf26 	beq	r18,r3,2005090 <__divdf3+0x750>
 2004d94:	90c7c83a 	sub	r3,r18,r3
 2004d98:	810fc83a 	sub	r7,r16,r4
 2004d9c:	81e5803a 	cmpltu	r18,r16,r7
 2004da0:	1ca5c83a 	sub	r18,r3,r18
 2004da4:	e480c126 	beq	fp,r18,20050ac <__divdf3+0x76c>
 2004da8:	a00b883a 	mov	r5,r20
 2004dac:	9009883a 	mov	r4,r18
 2004db0:	d9800315 	stw	r6,12(sp)
 2004db4:	d9c00215 	stw	r7,8(sp)
 2004db8:	da400115 	stw	r9,4(sp)
 2004dbc:	2003fd80 	call	2003fd8 <__udivsi3>
 2004dc0:	a00b883a 	mov	r5,r20
 2004dc4:	9009883a 	mov	r4,r18
 2004dc8:	d8800015 	stw	r2,0(sp)
 2004dcc:	200403c0 	call	200403c <__umodsi3>
 2004dd0:	d9c00217 	ldw	r7,8(sp)
 2004dd4:	da000017 	ldw	r8,0(sp)
 2004dd8:	1006943a 	slli	r3,r2,16
 2004ddc:	3804d43a 	srli	r2,r7,16
 2004de0:	ba21383a 	mul	r16,r23,r8
 2004de4:	d9800317 	ldw	r6,12(sp)
 2004de8:	10c4b03a 	or	r2,r2,r3
 2004dec:	da400117 	ldw	r9,4(sp)
 2004df0:	1400062e 	bgeu	r2,r16,2004e0c <__divdf3+0x4cc>
 2004df4:	1705883a 	add	r2,r2,fp
 2004df8:	40ffffc4 	addi	r3,r8,-1
 2004dfc:	1700ad36 	bltu	r2,fp,20050b4 <__divdf3+0x774>
 2004e00:	1400ac2e 	bgeu	r2,r16,20050b4 <__divdf3+0x774>
 2004e04:	423fff84 	addi	r8,r8,-2
 2004e08:	1705883a 	add	r2,r2,fp
 2004e0c:	1421c83a 	sub	r16,r2,r16
 2004e10:	a00b883a 	mov	r5,r20
 2004e14:	8009883a 	mov	r4,r16
 2004e18:	d9800315 	stw	r6,12(sp)
 2004e1c:	d9c00215 	stw	r7,8(sp)
 2004e20:	da000015 	stw	r8,0(sp)
 2004e24:	da400115 	stw	r9,4(sp)
 2004e28:	2003fd80 	call	2003fd8 <__udivsi3>
 2004e2c:	8009883a 	mov	r4,r16
 2004e30:	a00b883a 	mov	r5,r20
 2004e34:	1025883a 	mov	r18,r2
 2004e38:	200403c0 	call	200403c <__umodsi3>
 2004e3c:	d9c00217 	ldw	r7,8(sp)
 2004e40:	1004943a 	slli	r2,r2,16
 2004e44:	bcaf383a 	mul	r23,r23,r18
 2004e48:	393fffcc 	andi	r4,r7,65535
 2004e4c:	2088b03a 	or	r4,r4,r2
 2004e50:	d9800317 	ldw	r6,12(sp)
 2004e54:	da000017 	ldw	r8,0(sp)
 2004e58:	da400117 	ldw	r9,4(sp)
 2004e5c:	25c0062e 	bgeu	r4,r23,2004e78 <__divdf3+0x538>
 2004e60:	2709883a 	add	r4,r4,fp
 2004e64:	90bfffc4 	addi	r2,r18,-1
 2004e68:	27009436 	bltu	r4,fp,20050bc <__divdf3+0x77c>
 2004e6c:	25c0932e 	bgeu	r4,r23,20050bc <__divdf3+0x77c>
 2004e70:	94bfff84 	addi	r18,r18,-2
 2004e74:	2709883a 	add	r4,r4,fp
 2004e78:	4004943a 	slli	r2,r8,16
 2004e7c:	25efc83a 	sub	r23,r4,r23
 2004e80:	1490b03a 	or	r8,r2,r18
 2004e84:	4008d43a 	srli	r4,r8,16
 2004e88:	40ffffcc 	andi	r3,r8,65535
 2004e8c:	30c5383a 	mul	r2,r6,r3
 2004e90:	1a47383a 	mul	r3,r3,r9
 2004e94:	310d383a 	mul	r6,r6,r4
 2004e98:	100ad43a 	srli	r5,r2,16
 2004e9c:	4913383a 	mul	r9,r9,r4
 2004ea0:	1987883a 	add	r3,r3,r6
 2004ea4:	28c7883a 	add	r3,r5,r3
 2004ea8:	1980022e 	bgeu	r3,r6,2004eb4 <__divdf3+0x574>
 2004eac:	01000074 	movhi	r4,1
 2004eb0:	4913883a 	add	r9,r9,r4
 2004eb4:	1808d43a 	srli	r4,r3,16
 2004eb8:	1806943a 	slli	r3,r3,16
 2004ebc:	10bfffcc 	andi	r2,r2,65535
 2004ec0:	2253883a 	add	r9,r4,r9
 2004ec4:	1887883a 	add	r3,r3,r2
 2004ec8:	ba403836 	bltu	r23,r9,2004fac <__divdf3+0x66c>
 2004ecc:	ba403626 	beq	r23,r9,2004fa8 <__divdf3+0x668>
 2004ed0:	42000054 	ori	r8,r8,1
 2004ed4:	a880ffc4 	addi	r2,r21,1023
 2004ed8:	00bf570e 	bge	zero,r2,2004c38 <__divdf3+0x2f8>
 2004edc:	40c001cc 	andi	r3,r8,7
 2004ee0:	18000726 	beq	r3,zero,2004f00 <__divdf3+0x5c0>
 2004ee4:	40c003cc 	andi	r3,r8,15
 2004ee8:	01000104 	movi	r4,4
 2004eec:	19000426 	beq	r3,r4,2004f00 <__divdf3+0x5c0>
 2004ef0:	4107883a 	add	r3,r8,r4
 2004ef4:	1a11803a 	cmpltu	r8,r3,r8
 2004ef8:	8a23883a 	add	r17,r17,r8
 2004efc:	1811883a 	mov	r8,r3
 2004f00:	88c0402c 	andhi	r3,r17,256
 2004f04:	18000426 	beq	r3,zero,2004f18 <__divdf3+0x5d8>
 2004f08:	00ffc034 	movhi	r3,65280
 2004f0c:	18ffffc4 	addi	r3,r3,-1
 2004f10:	a8810004 	addi	r2,r21,1024
 2004f14:	88e2703a 	and	r17,r17,r3
 2004f18:	00c1ff84 	movi	r3,2046
 2004f1c:	18bee316 	blt	r3,r2,2004aac <__divdf3+0x16c>
 2004f20:	8824977a 	slli	r18,r17,29
 2004f24:	4010d0fa 	srli	r8,r8,3
 2004f28:	8822927a 	slli	r17,r17,9
 2004f2c:	1081ffcc 	andi	r2,r2,2047
 2004f30:	9224b03a 	or	r18,r18,r8
 2004f34:	880ad33a 	srli	r5,r17,12
 2004f38:	98c0004c 	andi	r3,r19,1
 2004f3c:	003edf06 	br	2004abc <__divdf3+0x17c>
 2004f40:	8080022c 	andhi	r2,r16,8
 2004f44:	10001226 	beq	r2,zero,2004f90 <__divdf3+0x650>
 2004f48:	8880022c 	andhi	r2,r17,8
 2004f4c:	1000101e 	bne	r2,zero,2004f90 <__divdf3+0x650>
 2004f50:	00800434 	movhi	r2,16
 2004f54:	89400234 	orhi	r5,r17,8
 2004f58:	10bfffc4 	addi	r2,r2,-1
 2004f5c:	b007883a 	mov	r3,r22
 2004f60:	288a703a 	and	r5,r5,r2
 2004f64:	4025883a 	mov	r18,r8
 2004f68:	003f3106 	br	2004c30 <__divdf3+0x2f0>
 2004f6c:	008000c4 	movi	r2,3
 2004f70:	3880a626 	beq	r7,r2,200520c <__divdf3+0x8cc>
 2004f74:	00800044 	movi	r2,1
 2004f78:	3880521e 	bne	r7,r2,20050c4 <__divdf3+0x784>
 2004f7c:	b807883a 	mov	r3,r23
 2004f80:	0005883a 	mov	r2,zero
 2004f84:	000b883a 	mov	r5,zero
 2004f88:	0025883a 	mov	r18,zero
 2004f8c:	003ecb06 	br	2004abc <__divdf3+0x17c>
 2004f90:	00800434 	movhi	r2,16
 2004f94:	81400234 	orhi	r5,r16,8
 2004f98:	10bfffc4 	addi	r2,r2,-1
 2004f9c:	a007883a 	mov	r3,r20
 2004fa0:	288a703a 	and	r5,r5,r2
 2004fa4:	003f2206 	br	2004c30 <__divdf3+0x2f0>
 2004fa8:	183fca26 	beq	r3,zero,2004ed4 <__divdf3+0x594>
 2004fac:	e5ef883a 	add	r23,fp,r23
 2004fb0:	40bfffc4 	addi	r2,r8,-1
 2004fb4:	bf00392e 	bgeu	r23,fp,200509c <__divdf3+0x75c>
 2004fb8:	1011883a 	mov	r8,r2
 2004fbc:	ba7fc41e 	bne	r23,r9,2004ed0 <__divdf3+0x590>
 2004fc0:	b0ffc31e 	bne	r22,r3,2004ed0 <__divdf3+0x590>
 2004fc4:	003fc306 	br	2004ed4 <__divdf3+0x594>
 2004fc8:	143ff604 	addi	r16,r2,-40
 2004fcc:	9c20983a 	sll	r16,r19,r16
 2004fd0:	0025883a 	mov	r18,zero
 2004fd4:	003ee206 	br	2004b60 <__divdf3+0x220>
 2004fd8:	d9800315 	stw	r6,12(sp)
 2004fdc:	d9c00215 	stw	r7,8(sp)
 2004fe0:	200674c0 	call	200674c <__clzsi2>
 2004fe4:	10800804 	addi	r2,r2,32
 2004fe8:	d9c00217 	ldw	r7,8(sp)
 2004fec:	d9800317 	ldw	r6,12(sp)
 2004ff0:	003ed106 	br	2004b38 <__divdf3+0x1f8>
 2004ff4:	147ff604 	addi	r17,r2,-40
 2004ff8:	3462983a 	sll	r17,r6,r17
 2004ffc:	0011883a 	mov	r8,zero
 2005000:	003ef506 	br	2004bd8 <__divdf3+0x298>
 2005004:	3009883a 	mov	r4,r6
 2005008:	d9800315 	stw	r6,12(sp)
 200500c:	da400115 	stw	r9,4(sp)
 2005010:	200674c0 	call	200674c <__clzsi2>
 2005014:	10800804 	addi	r2,r2,32
 2005018:	da400117 	ldw	r9,4(sp)
 200501c:	d9800317 	ldw	r6,12(sp)
 2005020:	003ee306 	br	2004bb0 <__divdf3+0x270>
 2005024:	85a1883a 	add	r16,r16,r22
 2005028:	8585803a 	cmpltu	r2,r16,r22
 200502c:	1705883a 	add	r2,r2,fp
 2005030:	14a5883a 	add	r18,r2,r18
 2005034:	88bfffc4 	addi	r2,r17,-1
 2005038:	e4800c2e 	bgeu	fp,r18,200506c <__divdf3+0x72c>
 200503c:	90c03e36 	bltu	r18,r3,2005138 <__divdf3+0x7f8>
 2005040:	1c806926 	beq	r3,r18,20051e8 <__divdf3+0x8a8>
 2005044:	90c7c83a 	sub	r3,r18,r3
 2005048:	1023883a 	mov	r17,r2
 200504c:	003f5206 	br	2004d98 <__divdf3+0x458>
 2005050:	923f0436 	bltu	r18,r8,2004c64 <__divdf3+0x324>
 2005054:	800897fa 	slli	r4,r16,31
 2005058:	9004d07a 	srli	r2,r18,1
 200505c:	8006d07a 	srli	r3,r16,1
 2005060:	902097fa 	slli	r16,r18,31
 2005064:	20a4b03a 	or	r18,r4,r2
 2005068:	003f0106 	br	2004c70 <__divdf3+0x330>
 200506c:	e4bff51e 	bne	fp,r18,2005044 <__divdf3+0x704>
 2005070:	85bff22e 	bgeu	r16,r22,200503c <__divdf3+0x6fc>
 2005074:	e0c7c83a 	sub	r3,fp,r3
 2005078:	1023883a 	mov	r17,r2
 200507c:	003f4606 	br	2004d98 <__divdf3+0x458>
 2005080:	100f883a 	mov	r7,r2
 2005084:	003f2b06 	br	2004d34 <__divdf3+0x3f4>
 2005088:	180d883a 	mov	r6,r3
 200508c:	003f1306 	br	2004cdc <__divdf3+0x39c>
 2005090:	813fe436 	bltu	r16,r4,2005024 <__divdf3+0x6e4>
 2005094:	0007883a 	mov	r3,zero
 2005098:	003f3f06 	br	2004d98 <__divdf3+0x458>
 200509c:	ba402c36 	bltu	r23,r9,2005150 <__divdf3+0x810>
 20050a0:	4dc05426 	beq	r9,r23,20051f4 <__divdf3+0x8b4>
 20050a4:	1011883a 	mov	r8,r2
 20050a8:	003f8906 	br	2004ed0 <__divdf3+0x590>
 20050ac:	023fffc4 	movi	r8,-1
 20050b0:	003f8806 	br	2004ed4 <__divdf3+0x594>
 20050b4:	1811883a 	mov	r8,r3
 20050b8:	003f5406 	br	2004e0c <__divdf3+0x4cc>
 20050bc:	1025883a 	mov	r18,r2
 20050c0:	003f6d06 	br	2004e78 <__divdf3+0x538>
 20050c4:	b827883a 	mov	r19,r23
 20050c8:	003f8206 	br	2004ed4 <__divdf3+0x594>
 20050cc:	010007c4 	movi	r4,31
 20050d0:	20c02616 	blt	r4,r3,200516c <__divdf3+0x82c>
 20050d4:	00800804 	movi	r2,32
 20050d8:	10c5c83a 	sub	r2,r2,r3
 20050dc:	888a983a 	sll	r5,r17,r2
 20050e0:	40c8d83a 	srl	r4,r8,r3
 20050e4:	4084983a 	sll	r2,r8,r2
 20050e8:	88e2d83a 	srl	r17,r17,r3
 20050ec:	2906b03a 	or	r3,r5,r4
 20050f0:	1004c03a 	cmpne	r2,r2,zero
 20050f4:	1886b03a 	or	r3,r3,r2
 20050f8:	188001cc 	andi	r2,r3,7
 20050fc:	10000726 	beq	r2,zero,200511c <__divdf3+0x7dc>
 2005100:	188003cc 	andi	r2,r3,15
 2005104:	01000104 	movi	r4,4
 2005108:	11000426 	beq	r2,r4,200511c <__divdf3+0x7dc>
 200510c:	1805883a 	mov	r2,r3
 2005110:	10c00104 	addi	r3,r2,4
 2005114:	1885803a 	cmpltu	r2,r3,r2
 2005118:	88a3883a 	add	r17,r17,r2
 200511c:	8880202c 	andhi	r2,r17,128
 2005120:	10002726 	beq	r2,zero,20051c0 <__divdf3+0x880>
 2005124:	98c0004c 	andi	r3,r19,1
 2005128:	00800044 	movi	r2,1
 200512c:	000b883a 	mov	r5,zero
 2005130:	0025883a 	mov	r18,zero
 2005134:	003e6106 	br	2004abc <__divdf3+0x17c>
 2005138:	85a1883a 	add	r16,r16,r22
 200513c:	8585803a 	cmpltu	r2,r16,r22
 2005140:	1705883a 	add	r2,r2,fp
 2005144:	14a5883a 	add	r18,r2,r18
 2005148:	8c7fff84 	addi	r17,r17,-2
 200514c:	003f1106 	br	2004d94 <__divdf3+0x454>
 2005150:	b589883a 	add	r4,r22,r22
 2005154:	25ad803a 	cmpltu	r22,r4,r22
 2005158:	b739883a 	add	fp,r22,fp
 200515c:	40bfff84 	addi	r2,r8,-2
 2005160:	bf2f883a 	add	r23,r23,fp
 2005164:	202d883a 	mov	r22,r4
 2005168:	003f9306 	br	2004fb8 <__divdf3+0x678>
 200516c:	013ff844 	movi	r4,-31
 2005170:	2085c83a 	sub	r2,r4,r2
 2005174:	8888d83a 	srl	r4,r17,r2
 2005178:	00800804 	movi	r2,32
 200517c:	18802126 	beq	r3,r2,2005204 <__divdf3+0x8c4>
 2005180:	00801004 	movi	r2,64
 2005184:	10c5c83a 	sub	r2,r2,r3
 2005188:	8884983a 	sll	r2,r17,r2
 200518c:	1204b03a 	or	r2,r2,r8
 2005190:	1004c03a 	cmpne	r2,r2,zero
 2005194:	2084b03a 	or	r2,r4,r2
 2005198:	144001cc 	andi	r17,r2,7
 200519c:	88000d1e 	bne	r17,zero,20051d4 <__divdf3+0x894>
 20051a0:	000b883a 	mov	r5,zero
 20051a4:	1024d0fa 	srli	r18,r2,3
 20051a8:	98c0004c 	andi	r3,r19,1
 20051ac:	0005883a 	mov	r2,zero
 20051b0:	9464b03a 	or	r18,r18,r17
 20051b4:	003e4106 	br	2004abc <__divdf3+0x17c>
 20051b8:	1007883a 	mov	r3,r2
 20051bc:	0023883a 	mov	r17,zero
 20051c0:	880a927a 	slli	r5,r17,9
 20051c4:	1805883a 	mov	r2,r3
 20051c8:	8822977a 	slli	r17,r17,29
 20051cc:	280ad33a 	srli	r5,r5,12
 20051d0:	003ff406 	br	20051a4 <__divdf3+0x864>
 20051d4:	10c003cc 	andi	r3,r2,15
 20051d8:	01000104 	movi	r4,4
 20051dc:	193ff626 	beq	r3,r4,20051b8 <__divdf3+0x878>
 20051e0:	0023883a 	mov	r17,zero
 20051e4:	003fca06 	br	2005110 <__divdf3+0x7d0>
 20051e8:	813fd336 	bltu	r16,r4,2005138 <__divdf3+0x7f8>
 20051ec:	1023883a 	mov	r17,r2
 20051f0:	003fa806 	br	2005094 <__divdf3+0x754>
 20051f4:	b0ffd636 	bltu	r22,r3,2005150 <__divdf3+0x810>
 20051f8:	1011883a 	mov	r8,r2
 20051fc:	b0ff341e 	bne	r22,r3,2004ed0 <__divdf3+0x590>
 2005200:	003f3406 	br	2004ed4 <__divdf3+0x594>
 2005204:	0005883a 	mov	r2,zero
 2005208:	003fe006 	br	200518c <__divdf3+0x84c>
 200520c:	00800434 	movhi	r2,16
 2005210:	89400234 	orhi	r5,r17,8
 2005214:	10bfffc4 	addi	r2,r2,-1
 2005218:	b807883a 	mov	r3,r23
 200521c:	288a703a 	and	r5,r5,r2
 2005220:	4025883a 	mov	r18,r8
 2005224:	003e8206 	br	2004c30 <__divdf3+0x2f0>

02005228 <__eqdf2>:
 2005228:	2804d53a 	srli	r2,r5,20
 200522c:	3806d53a 	srli	r3,r7,20
 2005230:	02000434 	movhi	r8,16
 2005234:	423fffc4 	addi	r8,r8,-1
 2005238:	1081ffcc 	andi	r2,r2,2047
 200523c:	0281ffc4 	movi	r10,2047
 2005240:	2a12703a 	and	r9,r5,r8
 2005244:	18c1ffcc 	andi	r3,r3,2047
 2005248:	3a10703a 	and	r8,r7,r8
 200524c:	280ad7fa 	srli	r5,r5,31
 2005250:	380ed7fa 	srli	r7,r7,31
 2005254:	12801026 	beq	r2,r10,2005298 <__eqdf2+0x70>
 2005258:	0281ffc4 	movi	r10,2047
 200525c:	1a800a26 	beq	r3,r10,2005288 <__eqdf2+0x60>
 2005260:	10c00226 	beq	r2,r3,200526c <__eqdf2+0x44>
 2005264:	00800044 	movi	r2,1
 2005268:	f800283a 	ret
 200526c:	4a3ffd1e 	bne	r9,r8,2005264 <__eqdf2+0x3c>
 2005270:	21bffc1e 	bne	r4,r6,2005264 <__eqdf2+0x3c>
 2005274:	29c00c26 	beq	r5,r7,20052a8 <__eqdf2+0x80>
 2005278:	103ffa1e 	bne	r2,zero,2005264 <__eqdf2+0x3c>
 200527c:	2244b03a 	or	r2,r4,r9
 2005280:	1004c03a 	cmpne	r2,r2,zero
 2005284:	f800283a 	ret
 2005288:	3214b03a 	or	r10,r6,r8
 200528c:	503ff426 	beq	r10,zero,2005260 <__eqdf2+0x38>
 2005290:	00800044 	movi	r2,1
 2005294:	f800283a 	ret
 2005298:	2254b03a 	or	r10,r4,r9
 200529c:	503fee26 	beq	r10,zero,2005258 <__eqdf2+0x30>
 20052a0:	00800044 	movi	r2,1
 20052a4:	f800283a 	ret
 20052a8:	0005883a 	mov	r2,zero
 20052ac:	f800283a 	ret

020052b0 <__gedf2>:
 20052b0:	2804d53a 	srli	r2,r5,20
 20052b4:	3806d53a 	srli	r3,r7,20
 20052b8:	02000434 	movhi	r8,16
 20052bc:	423fffc4 	addi	r8,r8,-1
 20052c0:	1081ffcc 	andi	r2,r2,2047
 20052c4:	0241ffc4 	movi	r9,2047
 20052c8:	2a14703a 	and	r10,r5,r8
 20052cc:	18c1ffcc 	andi	r3,r3,2047
 20052d0:	3a10703a 	and	r8,r7,r8
 20052d4:	280ad7fa 	srli	r5,r5,31
 20052d8:	380ed7fa 	srli	r7,r7,31
 20052dc:	12401d26 	beq	r2,r9,2005354 <__gedf2+0xa4>
 20052e0:	0241ffc4 	movi	r9,2047
 20052e4:	1a401226 	beq	r3,r9,2005330 <__gedf2+0x80>
 20052e8:	1000081e 	bne	r2,zero,200530c <__gedf2+0x5c>
 20052ec:	2296b03a 	or	r11,r4,r10
 20052f0:	5813003a 	cmpeq	r9,r11,zero
 20052f4:	1800091e 	bne	r3,zero,200531c <__gedf2+0x6c>
 20052f8:	3218b03a 	or	r12,r6,r8
 20052fc:	6000071e 	bne	r12,zero,200531c <__gedf2+0x6c>
 2005300:	0005883a 	mov	r2,zero
 2005304:	5800101e 	bne	r11,zero,2005348 <__gedf2+0x98>
 2005308:	f800283a 	ret
 200530c:	18000c1e 	bne	r3,zero,2005340 <__gedf2+0x90>
 2005310:	3212b03a 	or	r9,r6,r8
 2005314:	48000c26 	beq	r9,zero,2005348 <__gedf2+0x98>
 2005318:	0013883a 	mov	r9,zero
 200531c:	39c03fcc 	andi	r7,r7,255
 2005320:	48000826 	beq	r9,zero,2005344 <__gedf2+0x94>
 2005324:	38000926 	beq	r7,zero,200534c <__gedf2+0x9c>
 2005328:	00800044 	movi	r2,1
 200532c:	f800283a 	ret
 2005330:	3212b03a 	or	r9,r6,r8
 2005334:	483fec26 	beq	r9,zero,20052e8 <__gedf2+0x38>
 2005338:	00bfff84 	movi	r2,-2
 200533c:	f800283a 	ret
 2005340:	39c03fcc 	andi	r7,r7,255
 2005344:	29c00626 	beq	r5,r7,2005360 <__gedf2+0xb0>
 2005348:	283ff726 	beq	r5,zero,2005328 <__gedf2+0x78>
 200534c:	00bfffc4 	movi	r2,-1
 2005350:	f800283a 	ret
 2005354:	2292b03a 	or	r9,r4,r10
 2005358:	483fe126 	beq	r9,zero,20052e0 <__gedf2+0x30>
 200535c:	003ff606 	br	2005338 <__gedf2+0x88>
 2005360:	18bff916 	blt	r3,r2,2005348 <__gedf2+0x98>
 2005364:	10c00316 	blt	r2,r3,2005374 <__gedf2+0xc4>
 2005368:	42bff736 	bltu	r8,r10,2005348 <__gedf2+0x98>
 200536c:	52000326 	beq	r10,r8,200537c <__gedf2+0xcc>
 2005370:	5200042e 	bgeu	r10,r8,2005384 <__gedf2+0xd4>
 2005374:	283fec1e 	bne	r5,zero,2005328 <__gedf2+0x78>
 2005378:	003ff406 	br	200534c <__gedf2+0x9c>
 200537c:	313ff236 	bltu	r6,r4,2005348 <__gedf2+0x98>
 2005380:	21bffc36 	bltu	r4,r6,2005374 <__gedf2+0xc4>
 2005384:	0005883a 	mov	r2,zero
 2005388:	f800283a 	ret

0200538c <__ledf2>:
 200538c:	2804d53a 	srli	r2,r5,20
 2005390:	3810d53a 	srli	r8,r7,20
 2005394:	00c00434 	movhi	r3,16
 2005398:	18ffffc4 	addi	r3,r3,-1
 200539c:	1081ffcc 	andi	r2,r2,2047
 20053a0:	0241ffc4 	movi	r9,2047
 20053a4:	28d4703a 	and	r10,r5,r3
 20053a8:	4201ffcc 	andi	r8,r8,2047
 20053ac:	38c6703a 	and	r3,r7,r3
 20053b0:	280ad7fa 	srli	r5,r5,31
 20053b4:	380ed7fa 	srli	r7,r7,31
 20053b8:	12401f26 	beq	r2,r9,2005438 <__ledf2+0xac>
 20053bc:	0241ffc4 	movi	r9,2047
 20053c0:	42401426 	beq	r8,r9,2005414 <__ledf2+0x88>
 20053c4:	1000091e 	bne	r2,zero,20053ec <__ledf2+0x60>
 20053c8:	2296b03a 	or	r11,r4,r10
 20053cc:	5813003a 	cmpeq	r9,r11,zero
 20053d0:	29403fcc 	andi	r5,r5,255
 20053d4:	40000a1e 	bne	r8,zero,2005400 <__ledf2+0x74>
 20053d8:	30d8b03a 	or	r12,r6,r3
 20053dc:	6000081e 	bne	r12,zero,2005400 <__ledf2+0x74>
 20053e0:	0005883a 	mov	r2,zero
 20053e4:	5800111e 	bne	r11,zero,200542c <__ledf2+0xa0>
 20053e8:	f800283a 	ret
 20053ec:	29403fcc 	andi	r5,r5,255
 20053f0:	40000c1e 	bne	r8,zero,2005424 <__ledf2+0x98>
 20053f4:	30d2b03a 	or	r9,r6,r3
 20053f8:	48000c26 	beq	r9,zero,200542c <__ledf2+0xa0>
 20053fc:	0013883a 	mov	r9,zero
 2005400:	39c03fcc 	andi	r7,r7,255
 2005404:	48000826 	beq	r9,zero,2005428 <__ledf2+0x9c>
 2005408:	38001126 	beq	r7,zero,2005450 <__ledf2+0xc4>
 200540c:	00800044 	movi	r2,1
 2005410:	f800283a 	ret
 2005414:	30d2b03a 	or	r9,r6,r3
 2005418:	483fea26 	beq	r9,zero,20053c4 <__ledf2+0x38>
 200541c:	00800084 	movi	r2,2
 2005420:	f800283a 	ret
 2005424:	39c03fcc 	andi	r7,r7,255
 2005428:	39400726 	beq	r7,r5,2005448 <__ledf2+0xbc>
 200542c:	2800081e 	bne	r5,zero,2005450 <__ledf2+0xc4>
 2005430:	00800044 	movi	r2,1
 2005434:	f800283a 	ret
 2005438:	2292b03a 	or	r9,r4,r10
 200543c:	483fdf26 	beq	r9,zero,20053bc <__ledf2+0x30>
 2005440:	00800084 	movi	r2,2
 2005444:	f800283a 	ret
 2005448:	4080030e 	bge	r8,r2,2005458 <__ledf2+0xcc>
 200544c:	383fef26 	beq	r7,zero,200540c <__ledf2+0x80>
 2005450:	00bfffc4 	movi	r2,-1
 2005454:	f800283a 	ret
 2005458:	123feb16 	blt	r2,r8,2005408 <__ledf2+0x7c>
 200545c:	1abff336 	bltu	r3,r10,200542c <__ledf2+0xa0>
 2005460:	50c00326 	beq	r10,r3,2005470 <__ledf2+0xe4>
 2005464:	50c0042e 	bgeu	r10,r3,2005478 <__ledf2+0xec>
 2005468:	283fe81e 	bne	r5,zero,200540c <__ledf2+0x80>
 200546c:	003ff806 	br	2005450 <__ledf2+0xc4>
 2005470:	313fee36 	bltu	r6,r4,200542c <__ledf2+0xa0>
 2005474:	21bffc36 	bltu	r4,r6,2005468 <__ledf2+0xdc>
 2005478:	0005883a 	mov	r2,zero
 200547c:	f800283a 	ret

02005480 <__muldf3>:
 2005480:	defff304 	addi	sp,sp,-52
 2005484:	2804d53a 	srli	r2,r5,20
 2005488:	dd800915 	stw	r22,36(sp)
 200548c:	282cd7fa 	srli	r22,r5,31
 2005490:	dc000315 	stw	r16,12(sp)
 2005494:	04000434 	movhi	r16,16
 2005498:	dd400815 	stw	r21,32(sp)
 200549c:	dc800515 	stw	r18,20(sp)
 20054a0:	843fffc4 	addi	r16,r16,-1
 20054a4:	dfc00c15 	stw	ra,48(sp)
 20054a8:	df000b15 	stw	fp,44(sp)
 20054ac:	ddc00a15 	stw	r23,40(sp)
 20054b0:	dd000715 	stw	r20,28(sp)
 20054b4:	dcc00615 	stw	r19,24(sp)
 20054b8:	dc400415 	stw	r17,16(sp)
 20054bc:	1481ffcc 	andi	r18,r2,2047
 20054c0:	2c20703a 	and	r16,r5,r16
 20054c4:	b02b883a 	mov	r21,r22
 20054c8:	b2403fcc 	andi	r9,r22,255
 20054cc:	90006026 	beq	r18,zero,2005650 <__muldf3+0x1d0>
 20054d0:	0081ffc4 	movi	r2,2047
 20054d4:	2029883a 	mov	r20,r4
 20054d8:	90803626 	beq	r18,r2,20055b4 <__muldf3+0x134>
 20054dc:	80800434 	orhi	r2,r16,16
 20054e0:	100490fa 	slli	r2,r2,3
 20054e4:	2020d77a 	srli	r16,r4,29
 20054e8:	202890fa 	slli	r20,r4,3
 20054ec:	94bf0044 	addi	r18,r18,-1023
 20054f0:	80a0b03a 	or	r16,r16,r2
 20054f4:	0027883a 	mov	r19,zero
 20054f8:	0039883a 	mov	fp,zero
 20054fc:	3804d53a 	srli	r2,r7,20
 2005500:	382ed7fa 	srli	r23,r7,31
 2005504:	04400434 	movhi	r17,16
 2005508:	8c7fffc4 	addi	r17,r17,-1
 200550c:	1081ffcc 	andi	r2,r2,2047
 2005510:	3011883a 	mov	r8,r6
 2005514:	3c62703a 	and	r17,r7,r17
 2005518:	ba803fcc 	andi	r10,r23,255
 200551c:	10006d26 	beq	r2,zero,20056d4 <__muldf3+0x254>
 2005520:	00c1ffc4 	movi	r3,2047
 2005524:	10c06526 	beq	r2,r3,20056bc <__muldf3+0x23c>
 2005528:	88c00434 	orhi	r3,r17,16
 200552c:	180690fa 	slli	r3,r3,3
 2005530:	3022d77a 	srli	r17,r6,29
 2005534:	301090fa 	slli	r8,r6,3
 2005538:	10bf0044 	addi	r2,r2,-1023
 200553c:	88e2b03a 	or	r17,r17,r3
 2005540:	000b883a 	mov	r5,zero
 2005544:	9085883a 	add	r2,r18,r2
 2005548:	2cc8b03a 	or	r4,r5,r19
 200554c:	00c003c4 	movi	r3,15
 2005550:	bdacf03a 	xor	r22,r23,r22
 2005554:	12c00044 	addi	r11,r2,1
 2005558:	19009936 	bltu	r3,r4,20057c0 <__muldf3+0x340>
 200555c:	200890ba 	slli	r4,r4,2
 2005560:	00c08034 	movhi	r3,512
 2005564:	18d55d04 	addi	r3,r3,21876
 2005568:	20c9883a 	add	r4,r4,r3
 200556c:	20c00017 	ldw	r3,0(r4)
 2005570:	1800683a 	jmp	r3
 2005574:	020057c0 	call	20057c <__alt_mem_mem_Nios_PI+0x57c>
 2005578:	020055d4 	movui	r8,343
 200557c:	020055d4 	movui	r8,343
 2005580:	020055d0 	cmplti	r8,zero,343
 2005584:	0200579c 	xori	r8,zero,350
 2005588:	0200579c 	xori	r8,zero,350
 200558c:	02005784 	movi	r8,350
 2005590:	020055d0 	cmplti	r8,zero,343
 2005594:	0200579c 	xori	r8,zero,350
 2005598:	02005784 	movi	r8,350
 200559c:	0200579c 	xori	r8,zero,350
 20055a0:	020055d0 	cmplti	r8,zero,343
 20055a4:	020057ac 	andhi	r8,zero,350
 20055a8:	020057ac 	andhi	r8,zero,350
 20055ac:	020057ac 	andhi	r8,zero,350
 20055b0:	020059c8 	cmpgei	r8,zero,359
 20055b4:	2404b03a 	or	r2,r4,r16
 20055b8:	10006f1e 	bne	r2,zero,2005778 <__muldf3+0x2f8>
 20055bc:	04c00204 	movi	r19,8
 20055c0:	0021883a 	mov	r16,zero
 20055c4:	0029883a 	mov	r20,zero
 20055c8:	07000084 	movi	fp,2
 20055cc:	003fcb06 	br	20054fc <__muldf3+0x7c>
 20055d0:	502d883a 	mov	r22,r10
 20055d4:	00800084 	movi	r2,2
 20055d8:	28805726 	beq	r5,r2,2005738 <__muldf3+0x2b8>
 20055dc:	008000c4 	movi	r2,3
 20055e0:	28816626 	beq	r5,r2,2005b7c <__muldf3+0x6fc>
 20055e4:	00800044 	movi	r2,1
 20055e8:	2881411e 	bne	r5,r2,2005af0 <__muldf3+0x670>
 20055ec:	b02b883a 	mov	r21,r22
 20055f0:	0005883a 	mov	r2,zero
 20055f4:	000b883a 	mov	r5,zero
 20055f8:	0029883a 	mov	r20,zero
 20055fc:	1004953a 	slli	r2,r2,20
 2005600:	a8c03fcc 	andi	r3,r21,255
 2005604:	04400434 	movhi	r17,16
 2005608:	8c7fffc4 	addi	r17,r17,-1
 200560c:	180697fa 	slli	r3,r3,31
 2005610:	2c4a703a 	and	r5,r5,r17
 2005614:	288ab03a 	or	r5,r5,r2
 2005618:	28c6b03a 	or	r3,r5,r3
 200561c:	a005883a 	mov	r2,r20
 2005620:	dfc00c17 	ldw	ra,48(sp)
 2005624:	df000b17 	ldw	fp,44(sp)
 2005628:	ddc00a17 	ldw	r23,40(sp)
 200562c:	dd800917 	ldw	r22,36(sp)
 2005630:	dd400817 	ldw	r21,32(sp)
 2005634:	dd000717 	ldw	r20,28(sp)
 2005638:	dcc00617 	ldw	r19,24(sp)
 200563c:	dc800517 	ldw	r18,20(sp)
 2005640:	dc400417 	ldw	r17,16(sp)
 2005644:	dc000317 	ldw	r16,12(sp)
 2005648:	dec00d04 	addi	sp,sp,52
 200564c:	f800283a 	ret
 2005650:	2404b03a 	or	r2,r4,r16
 2005654:	2027883a 	mov	r19,r4
 2005658:	10004226 	beq	r2,zero,2005764 <__muldf3+0x2e4>
 200565c:	8000fc26 	beq	r16,zero,2005a50 <__muldf3+0x5d0>
 2005660:	8009883a 	mov	r4,r16
 2005664:	d9800215 	stw	r6,8(sp)
 2005668:	d9c00015 	stw	r7,0(sp)
 200566c:	da400115 	stw	r9,4(sp)
 2005670:	200674c0 	call	200674c <__clzsi2>
 2005674:	d9800217 	ldw	r6,8(sp)
 2005678:	d9c00017 	ldw	r7,0(sp)
 200567c:	da400117 	ldw	r9,4(sp)
 2005680:	113ffd44 	addi	r4,r2,-11
 2005684:	00c00704 	movi	r3,28
 2005688:	1900ed16 	blt	r3,r4,2005a40 <__muldf3+0x5c0>
 200568c:	00c00744 	movi	r3,29
 2005690:	147ffe04 	addi	r17,r2,-8
 2005694:	1907c83a 	sub	r3,r3,r4
 2005698:	8460983a 	sll	r16,r16,r17
 200569c:	98c6d83a 	srl	r3,r19,r3
 20056a0:	9c68983a 	sll	r20,r19,r17
 20056a4:	1c20b03a 	or	r16,r3,r16
 20056a8:	1080fcc4 	addi	r2,r2,1011
 20056ac:	00a5c83a 	sub	r18,zero,r2
 20056b0:	0027883a 	mov	r19,zero
 20056b4:	0039883a 	mov	fp,zero
 20056b8:	003f9006 	br	20054fc <__muldf3+0x7c>
 20056bc:	3446b03a 	or	r3,r6,r17
 20056c0:	1800261e 	bne	r3,zero,200575c <__muldf3+0x2dc>
 20056c4:	0023883a 	mov	r17,zero
 20056c8:	0011883a 	mov	r8,zero
 20056cc:	01400084 	movi	r5,2
 20056d0:	003f9c06 	br	2005544 <__muldf3+0xc4>
 20056d4:	3446b03a 	or	r3,r6,r17
 20056d8:	18001c26 	beq	r3,zero,200574c <__muldf3+0x2cc>
 20056dc:	8800ce26 	beq	r17,zero,2005a18 <__muldf3+0x598>
 20056e0:	8809883a 	mov	r4,r17
 20056e4:	d9800215 	stw	r6,8(sp)
 20056e8:	da400115 	stw	r9,4(sp)
 20056ec:	da800015 	stw	r10,0(sp)
 20056f0:	200674c0 	call	200674c <__clzsi2>
 20056f4:	d9800217 	ldw	r6,8(sp)
 20056f8:	da400117 	ldw	r9,4(sp)
 20056fc:	da800017 	ldw	r10,0(sp)
 2005700:	113ffd44 	addi	r4,r2,-11
 2005704:	00c00704 	movi	r3,28
 2005708:	1900bf16 	blt	r3,r4,2005a08 <__muldf3+0x588>
 200570c:	00c00744 	movi	r3,29
 2005710:	123ffe04 	addi	r8,r2,-8
 2005714:	1907c83a 	sub	r3,r3,r4
 2005718:	8a22983a 	sll	r17,r17,r8
 200571c:	30c6d83a 	srl	r3,r6,r3
 2005720:	3210983a 	sll	r8,r6,r8
 2005724:	1c62b03a 	or	r17,r3,r17
 2005728:	1080fcc4 	addi	r2,r2,1011
 200572c:	0085c83a 	sub	r2,zero,r2
 2005730:	000b883a 	mov	r5,zero
 2005734:	003f8306 	br	2005544 <__muldf3+0xc4>
 2005738:	b02b883a 	mov	r21,r22
 200573c:	0081ffc4 	movi	r2,2047
 2005740:	000b883a 	mov	r5,zero
 2005744:	0029883a 	mov	r20,zero
 2005748:	003fac06 	br	20055fc <__muldf3+0x17c>
 200574c:	0023883a 	mov	r17,zero
 2005750:	0011883a 	mov	r8,zero
 2005754:	01400044 	movi	r5,1
 2005758:	003f7a06 	br	2005544 <__muldf3+0xc4>
 200575c:	014000c4 	movi	r5,3
 2005760:	003f7806 	br	2005544 <__muldf3+0xc4>
 2005764:	04c00104 	movi	r19,4
 2005768:	0021883a 	mov	r16,zero
 200576c:	0029883a 	mov	r20,zero
 2005770:	07000044 	movi	fp,1
 2005774:	003f6106 	br	20054fc <__muldf3+0x7c>
 2005778:	04c00304 	movi	r19,12
 200577c:	070000c4 	movi	fp,3
 2005780:	003f5e06 	br	20054fc <__muldf3+0x7c>
 2005784:	01400434 	movhi	r5,16
 2005788:	002b883a 	mov	r21,zero
 200578c:	297fffc4 	addi	r5,r5,-1
 2005790:	053fffc4 	movi	r20,-1
 2005794:	0081ffc4 	movi	r2,2047
 2005798:	003f9806 	br	20055fc <__muldf3+0x17c>
 200579c:	8023883a 	mov	r17,r16
 20057a0:	a011883a 	mov	r8,r20
 20057a4:	e00b883a 	mov	r5,fp
 20057a8:	003f8a06 	br	20055d4 <__muldf3+0x154>
 20057ac:	8023883a 	mov	r17,r16
 20057b0:	a011883a 	mov	r8,r20
 20057b4:	482d883a 	mov	r22,r9
 20057b8:	e00b883a 	mov	r5,fp
 20057bc:	003f8506 	br	20055d4 <__muldf3+0x154>
 20057c0:	a00ad43a 	srli	r5,r20,16
 20057c4:	401ad43a 	srli	r13,r8,16
 20057c8:	a53fffcc 	andi	r20,r20,65535
 20057cc:	423fffcc 	andi	r8,r8,65535
 20057d0:	4519383a 	mul	r12,r8,r20
 20057d4:	4147383a 	mul	r3,r8,r5
 20057d8:	6d09383a 	mul	r4,r13,r20
 20057dc:	600cd43a 	srli	r6,r12,16
 20057e0:	2b5d383a 	mul	r14,r5,r13
 20057e4:	20c9883a 	add	r4,r4,r3
 20057e8:	310d883a 	add	r6,r6,r4
 20057ec:	30c0022e 	bgeu	r6,r3,20057f8 <__muldf3+0x378>
 20057f0:	00c00074 	movhi	r3,1
 20057f4:	70dd883a 	add	r14,r14,r3
 20057f8:	8826d43a 	srli	r19,r17,16
 20057fc:	8bffffcc 	andi	r15,r17,65535
 2005800:	7d23383a 	mul	r17,r15,r20
 2005804:	7949383a 	mul	r4,r15,r5
 2005808:	9d29383a 	mul	r20,r19,r20
 200580c:	8814d43a 	srli	r10,r17,16
 2005810:	3012943a 	slli	r9,r6,16
 2005814:	a129883a 	add	r20,r20,r4
 2005818:	633fffcc 	andi	r12,r12,65535
 200581c:	5515883a 	add	r10,r10,r20
 2005820:	3006d43a 	srli	r3,r6,16
 2005824:	4b13883a 	add	r9,r9,r12
 2005828:	2ccb383a 	mul	r5,r5,r19
 200582c:	5100022e 	bgeu	r10,r4,2005838 <__muldf3+0x3b8>
 2005830:	01000074 	movhi	r4,1
 2005834:	290b883a 	add	r5,r5,r4
 2005838:	802ad43a 	srli	r21,r16,16
 200583c:	843fffcc 	andi	r16,r16,65535
 2005840:	440d383a 	mul	r6,r8,r16
 2005844:	4565383a 	mul	r18,r8,r21
 2005848:	8349383a 	mul	r4,r16,r13
 200584c:	500e943a 	slli	r7,r10,16
 2005850:	3010d43a 	srli	r8,r6,16
 2005854:	5028d43a 	srli	r20,r10,16
 2005858:	2489883a 	add	r4,r4,r18
 200585c:	8abfffcc 	andi	r10,r17,65535
 2005860:	3a95883a 	add	r10,r7,r10
 2005864:	4119883a 	add	r12,r8,r4
 2005868:	a169883a 	add	r20,r20,r5
 200586c:	1a87883a 	add	r3,r3,r10
 2005870:	6d5b383a 	mul	r13,r13,r21
 2005874:	6480022e 	bgeu	r12,r18,2005880 <__muldf3+0x400>
 2005878:	01000074 	movhi	r4,1
 200587c:	691b883a 	add	r13,r13,r4
 2005880:	7c25383a 	mul	r18,r15,r16
 2005884:	7d4b383a 	mul	r5,r15,r21
 2005888:	84cf383a 	mul	r7,r16,r19
 200588c:	901ed43a 	srli	r15,r18,16
 2005890:	6008d43a 	srli	r4,r12,16
 2005894:	6010943a 	slli	r8,r12,16
 2005898:	394f883a 	add	r7,r7,r5
 200589c:	333fffcc 	andi	r12,r6,65535
 20058a0:	79df883a 	add	r15,r15,r7
 20058a4:	235b883a 	add	r13,r4,r13
 20058a8:	9d63383a 	mul	r17,r19,r21
 20058ac:	4309883a 	add	r4,r8,r12
 20058b0:	7940022e 	bgeu	r15,r5,20058bc <__muldf3+0x43c>
 20058b4:	01400074 	movhi	r5,1
 20058b8:	8963883a 	add	r17,r17,r5
 20058bc:	780a943a 	slli	r5,r15,16
 20058c0:	91bfffcc 	andi	r6,r18,65535
 20058c4:	70c7883a 	add	r3,r14,r3
 20058c8:	298d883a 	add	r6,r5,r6
 20058cc:	1a8f803a 	cmpltu	r7,r3,r10
 20058d0:	350b883a 	add	r5,r6,r20
 20058d4:	20c7883a 	add	r3,r4,r3
 20058d8:	3955883a 	add	r10,r7,r5
 20058dc:	1909803a 	cmpltu	r4,r3,r4
 20058e0:	6a91883a 	add	r8,r13,r10
 20058e4:	780cd43a 	srli	r6,r15,16
 20058e8:	2219883a 	add	r12,r4,r8
 20058ec:	2d0b803a 	cmpltu	r5,r5,r20
 20058f0:	51cf803a 	cmpltu	r7,r10,r7
 20058f4:	29ceb03a 	or	r7,r5,r7
 20058f8:	4351803a 	cmpltu	r8,r8,r13
 20058fc:	610b803a 	cmpltu	r5,r12,r4
 2005900:	4148b03a 	or	r4,r8,r5
 2005904:	398f883a 	add	r7,r7,r6
 2005908:	3909883a 	add	r4,r7,r4
 200590c:	1810927a 	slli	r8,r3,9
 2005910:	2449883a 	add	r4,r4,r17
 2005914:	2008927a 	slli	r4,r4,9
 2005918:	6022d5fa 	srli	r17,r12,23
 200591c:	1806d5fa 	srli	r3,r3,23
 2005920:	4252b03a 	or	r9,r8,r9
 2005924:	600a927a 	slli	r5,r12,9
 2005928:	4810c03a 	cmpne	r8,r9,zero
 200592c:	2462b03a 	or	r17,r4,r17
 2005930:	40c6b03a 	or	r3,r8,r3
 2005934:	8900402c 	andhi	r4,r17,256
 2005938:	1950b03a 	or	r8,r3,r5
 200593c:	20000726 	beq	r4,zero,200595c <__muldf3+0x4dc>
 2005940:	4006d07a 	srli	r3,r8,1
 2005944:	880497fa 	slli	r2,r17,31
 2005948:	4200004c 	andi	r8,r8,1
 200594c:	8822d07a 	srli	r17,r17,1
 2005950:	1a10b03a 	or	r8,r3,r8
 2005954:	1210b03a 	or	r8,r2,r8
 2005958:	5805883a 	mov	r2,r11
 200595c:	1140ffc4 	addi	r5,r2,1023
 2005960:	0140440e 	bge	zero,r5,2005a74 <__muldf3+0x5f4>
 2005964:	40c001cc 	andi	r3,r8,7
 2005968:	18000726 	beq	r3,zero,2005988 <__muldf3+0x508>
 200596c:	40c003cc 	andi	r3,r8,15
 2005970:	01000104 	movi	r4,4
 2005974:	19000426 	beq	r3,r4,2005988 <__muldf3+0x508>
 2005978:	4107883a 	add	r3,r8,r4
 200597c:	1a11803a 	cmpltu	r8,r3,r8
 2005980:	8a23883a 	add	r17,r17,r8
 2005984:	1811883a 	mov	r8,r3
 2005988:	88c0402c 	andhi	r3,r17,256
 200598c:	18000426 	beq	r3,zero,20059a0 <__muldf3+0x520>
 2005990:	11410004 	addi	r5,r2,1024
 2005994:	00bfc034 	movhi	r2,65280
 2005998:	10bfffc4 	addi	r2,r2,-1
 200599c:	88a2703a 	and	r17,r17,r2
 20059a0:	0081ff84 	movi	r2,2046
 20059a4:	117f6416 	blt	r2,r5,2005738 <__muldf3+0x2b8>
 20059a8:	8828977a 	slli	r20,r17,29
 20059ac:	4010d0fa 	srli	r8,r8,3
 20059b0:	8822927a 	slli	r17,r17,9
 20059b4:	2881ffcc 	andi	r2,r5,2047
 20059b8:	a228b03a 	or	r20,r20,r8
 20059bc:	880ad33a 	srli	r5,r17,12
 20059c0:	b02b883a 	mov	r21,r22
 20059c4:	003f0d06 	br	20055fc <__muldf3+0x17c>
 20059c8:	8080022c 	andhi	r2,r16,8
 20059cc:	10000926 	beq	r2,zero,20059f4 <__muldf3+0x574>
 20059d0:	8880022c 	andhi	r2,r17,8
 20059d4:	1000071e 	bne	r2,zero,20059f4 <__muldf3+0x574>
 20059d8:	00800434 	movhi	r2,16
 20059dc:	89400234 	orhi	r5,r17,8
 20059e0:	10bfffc4 	addi	r2,r2,-1
 20059e4:	b82b883a 	mov	r21,r23
 20059e8:	288a703a 	and	r5,r5,r2
 20059ec:	4029883a 	mov	r20,r8
 20059f0:	003f6806 	br	2005794 <__muldf3+0x314>
 20059f4:	00800434 	movhi	r2,16
 20059f8:	81400234 	orhi	r5,r16,8
 20059fc:	10bfffc4 	addi	r2,r2,-1
 2005a00:	288a703a 	and	r5,r5,r2
 2005a04:	003f6306 	br	2005794 <__muldf3+0x314>
 2005a08:	147ff604 	addi	r17,r2,-40
 2005a0c:	3462983a 	sll	r17,r6,r17
 2005a10:	0011883a 	mov	r8,zero
 2005a14:	003f4406 	br	2005728 <__muldf3+0x2a8>
 2005a18:	3009883a 	mov	r4,r6
 2005a1c:	d9800215 	stw	r6,8(sp)
 2005a20:	da400115 	stw	r9,4(sp)
 2005a24:	da800015 	stw	r10,0(sp)
 2005a28:	200674c0 	call	200674c <__clzsi2>
 2005a2c:	10800804 	addi	r2,r2,32
 2005a30:	da800017 	ldw	r10,0(sp)
 2005a34:	da400117 	ldw	r9,4(sp)
 2005a38:	d9800217 	ldw	r6,8(sp)
 2005a3c:	003f3006 	br	2005700 <__muldf3+0x280>
 2005a40:	143ff604 	addi	r16,r2,-40
 2005a44:	9c20983a 	sll	r16,r19,r16
 2005a48:	0029883a 	mov	r20,zero
 2005a4c:	003f1606 	br	20056a8 <__muldf3+0x228>
 2005a50:	d9800215 	stw	r6,8(sp)
 2005a54:	d9c00015 	stw	r7,0(sp)
 2005a58:	da400115 	stw	r9,4(sp)
 2005a5c:	200674c0 	call	200674c <__clzsi2>
 2005a60:	10800804 	addi	r2,r2,32
 2005a64:	da400117 	ldw	r9,4(sp)
 2005a68:	d9c00017 	ldw	r7,0(sp)
 2005a6c:	d9800217 	ldw	r6,8(sp)
 2005a70:	003f0306 	br	2005680 <__muldf3+0x200>
 2005a74:	00c00044 	movi	r3,1
 2005a78:	1947c83a 	sub	r3,r3,r5
 2005a7c:	00800e04 	movi	r2,56
 2005a80:	10feda16 	blt	r2,r3,20055ec <__muldf3+0x16c>
 2005a84:	008007c4 	movi	r2,31
 2005a88:	10c01b16 	blt	r2,r3,2005af8 <__muldf3+0x678>
 2005a8c:	00800804 	movi	r2,32
 2005a90:	10c5c83a 	sub	r2,r2,r3
 2005a94:	888a983a 	sll	r5,r17,r2
 2005a98:	40c8d83a 	srl	r4,r8,r3
 2005a9c:	4084983a 	sll	r2,r8,r2
 2005aa0:	88e2d83a 	srl	r17,r17,r3
 2005aa4:	2906b03a 	or	r3,r5,r4
 2005aa8:	1004c03a 	cmpne	r2,r2,zero
 2005aac:	1886b03a 	or	r3,r3,r2
 2005ab0:	188001cc 	andi	r2,r3,7
 2005ab4:	10000726 	beq	r2,zero,2005ad4 <__muldf3+0x654>
 2005ab8:	188003cc 	andi	r2,r3,15
 2005abc:	01000104 	movi	r4,4
 2005ac0:	11000426 	beq	r2,r4,2005ad4 <__muldf3+0x654>
 2005ac4:	1805883a 	mov	r2,r3
 2005ac8:	10c00104 	addi	r3,r2,4
 2005acc:	1885803a 	cmpltu	r2,r3,r2
 2005ad0:	88a3883a 	add	r17,r17,r2
 2005ad4:	8880202c 	andhi	r2,r17,128
 2005ad8:	10001c26 	beq	r2,zero,2005b4c <__muldf3+0x6cc>
 2005adc:	b02b883a 	mov	r21,r22
 2005ae0:	00800044 	movi	r2,1
 2005ae4:	000b883a 	mov	r5,zero
 2005ae8:	0029883a 	mov	r20,zero
 2005aec:	003ec306 	br	20055fc <__muldf3+0x17c>
 2005af0:	5805883a 	mov	r2,r11
 2005af4:	003f9906 	br	200595c <__muldf3+0x4dc>
 2005af8:	00bff844 	movi	r2,-31
 2005afc:	1145c83a 	sub	r2,r2,r5
 2005b00:	8888d83a 	srl	r4,r17,r2
 2005b04:	00800804 	movi	r2,32
 2005b08:	18801a26 	beq	r3,r2,2005b74 <__muldf3+0x6f4>
 2005b0c:	00801004 	movi	r2,64
 2005b10:	10c5c83a 	sub	r2,r2,r3
 2005b14:	8884983a 	sll	r2,r17,r2
 2005b18:	1204b03a 	or	r2,r2,r8
 2005b1c:	1004c03a 	cmpne	r2,r2,zero
 2005b20:	2084b03a 	or	r2,r4,r2
 2005b24:	144001cc 	andi	r17,r2,7
 2005b28:	88000d1e 	bne	r17,zero,2005b60 <__muldf3+0x6e0>
 2005b2c:	000b883a 	mov	r5,zero
 2005b30:	1028d0fa 	srli	r20,r2,3
 2005b34:	b02b883a 	mov	r21,r22
 2005b38:	0005883a 	mov	r2,zero
 2005b3c:	a468b03a 	or	r20,r20,r17
 2005b40:	003eae06 	br	20055fc <__muldf3+0x17c>
 2005b44:	1007883a 	mov	r3,r2
 2005b48:	0023883a 	mov	r17,zero
 2005b4c:	880a927a 	slli	r5,r17,9
 2005b50:	1805883a 	mov	r2,r3
 2005b54:	8822977a 	slli	r17,r17,29
 2005b58:	280ad33a 	srli	r5,r5,12
 2005b5c:	003ff406 	br	2005b30 <__muldf3+0x6b0>
 2005b60:	10c003cc 	andi	r3,r2,15
 2005b64:	01000104 	movi	r4,4
 2005b68:	193ff626 	beq	r3,r4,2005b44 <__muldf3+0x6c4>
 2005b6c:	0023883a 	mov	r17,zero
 2005b70:	003fd506 	br	2005ac8 <__muldf3+0x648>
 2005b74:	0005883a 	mov	r2,zero
 2005b78:	003fe706 	br	2005b18 <__muldf3+0x698>
 2005b7c:	00800434 	movhi	r2,16
 2005b80:	89400234 	orhi	r5,r17,8
 2005b84:	10bfffc4 	addi	r2,r2,-1
 2005b88:	b02b883a 	mov	r21,r22
 2005b8c:	288a703a 	and	r5,r5,r2
 2005b90:	4029883a 	mov	r20,r8
 2005b94:	003eff06 	br	2005794 <__muldf3+0x314>

02005b98 <__subdf3>:
 2005b98:	02000434 	movhi	r8,16
 2005b9c:	423fffc4 	addi	r8,r8,-1
 2005ba0:	defffb04 	addi	sp,sp,-20
 2005ba4:	2a14703a 	and	r10,r5,r8
 2005ba8:	3812d53a 	srli	r9,r7,20
 2005bac:	3a10703a 	and	r8,r7,r8
 2005bb0:	2006d77a 	srli	r3,r4,29
 2005bb4:	3004d77a 	srli	r2,r6,29
 2005bb8:	dc000015 	stw	r16,0(sp)
 2005bbc:	501490fa 	slli	r10,r10,3
 2005bc0:	2820d53a 	srli	r16,r5,20
 2005bc4:	401090fa 	slli	r8,r8,3
 2005bc8:	dc800215 	stw	r18,8(sp)
 2005bcc:	dc400115 	stw	r17,4(sp)
 2005bd0:	dfc00415 	stw	ra,16(sp)
 2005bd4:	202290fa 	slli	r17,r4,3
 2005bd8:	dcc00315 	stw	r19,12(sp)
 2005bdc:	4a41ffcc 	andi	r9,r9,2047
 2005be0:	0101ffc4 	movi	r4,2047
 2005be4:	2824d7fa 	srli	r18,r5,31
 2005be8:	8401ffcc 	andi	r16,r16,2047
 2005bec:	50c6b03a 	or	r3,r10,r3
 2005bf0:	380ed7fa 	srli	r7,r7,31
 2005bf4:	408ab03a 	or	r5,r8,r2
 2005bf8:	300c90fa 	slli	r6,r6,3
 2005bfc:	49009626 	beq	r9,r4,2005e58 <__subdf3+0x2c0>
 2005c00:	39c0005c 	xori	r7,r7,1
 2005c04:	8245c83a 	sub	r2,r16,r9
 2005c08:	3c807426 	beq	r7,r18,2005ddc <__subdf3+0x244>
 2005c0c:	0080af0e 	bge	zero,r2,2005ecc <__subdf3+0x334>
 2005c10:	48002a1e 	bne	r9,zero,2005cbc <__subdf3+0x124>
 2005c14:	2988b03a 	or	r4,r5,r6
 2005c18:	20009a1e 	bne	r4,zero,2005e84 <__subdf3+0x2ec>
 2005c1c:	888001cc 	andi	r2,r17,7
 2005c20:	10000726 	beq	r2,zero,2005c40 <__subdf3+0xa8>
 2005c24:	888003cc 	andi	r2,r17,15
 2005c28:	01000104 	movi	r4,4
 2005c2c:	11000426 	beq	r2,r4,2005c40 <__subdf3+0xa8>
 2005c30:	890b883a 	add	r5,r17,r4
 2005c34:	2c63803a 	cmpltu	r17,r5,r17
 2005c38:	1c47883a 	add	r3,r3,r17
 2005c3c:	2823883a 	mov	r17,r5
 2005c40:	1880202c 	andhi	r2,r3,128
 2005c44:	10005926 	beq	r2,zero,2005dac <__subdf3+0x214>
 2005c48:	84000044 	addi	r16,r16,1
 2005c4c:	0081ffc4 	movi	r2,2047
 2005c50:	8080be26 	beq	r16,r2,2005f4c <__subdf3+0x3b4>
 2005c54:	017fe034 	movhi	r5,65408
 2005c58:	297fffc4 	addi	r5,r5,-1
 2005c5c:	1946703a 	and	r3,r3,r5
 2005c60:	1804977a 	slli	r2,r3,29
 2005c64:	1806927a 	slli	r3,r3,9
 2005c68:	8822d0fa 	srli	r17,r17,3
 2005c6c:	8401ffcc 	andi	r16,r16,2047
 2005c70:	180ad33a 	srli	r5,r3,12
 2005c74:	9100004c 	andi	r4,r18,1
 2005c78:	1444b03a 	or	r2,r2,r17
 2005c7c:	80c1ffcc 	andi	r3,r16,2047
 2005c80:	1820953a 	slli	r16,r3,20
 2005c84:	20c03fcc 	andi	r3,r4,255
 2005c88:	180897fa 	slli	r4,r3,31
 2005c8c:	00c00434 	movhi	r3,16
 2005c90:	18ffffc4 	addi	r3,r3,-1
 2005c94:	28c6703a 	and	r3,r5,r3
 2005c98:	1c06b03a 	or	r3,r3,r16
 2005c9c:	1906b03a 	or	r3,r3,r4
 2005ca0:	dfc00417 	ldw	ra,16(sp)
 2005ca4:	dcc00317 	ldw	r19,12(sp)
 2005ca8:	dc800217 	ldw	r18,8(sp)
 2005cac:	dc400117 	ldw	r17,4(sp)
 2005cb0:	dc000017 	ldw	r16,0(sp)
 2005cb4:	dec00504 	addi	sp,sp,20
 2005cb8:	f800283a 	ret
 2005cbc:	0101ffc4 	movi	r4,2047
 2005cc0:	813fd626 	beq	r16,r4,2005c1c <__subdf3+0x84>
 2005cc4:	29402034 	orhi	r5,r5,128
 2005cc8:	01000e04 	movi	r4,56
 2005ccc:	2080a316 	blt	r4,r2,2005f5c <__subdf3+0x3c4>
 2005cd0:	010007c4 	movi	r4,31
 2005cd4:	2080c616 	blt	r4,r2,2005ff0 <__subdf3+0x458>
 2005cd8:	01000804 	movi	r4,32
 2005cdc:	2089c83a 	sub	r4,r4,r2
 2005ce0:	2910983a 	sll	r8,r5,r4
 2005ce4:	308ed83a 	srl	r7,r6,r2
 2005ce8:	3108983a 	sll	r4,r6,r4
 2005cec:	2884d83a 	srl	r2,r5,r2
 2005cf0:	41ccb03a 	or	r6,r8,r7
 2005cf4:	2008c03a 	cmpne	r4,r4,zero
 2005cf8:	310cb03a 	or	r6,r6,r4
 2005cfc:	898dc83a 	sub	r6,r17,r6
 2005d00:	89a3803a 	cmpltu	r17,r17,r6
 2005d04:	1887c83a 	sub	r3,r3,r2
 2005d08:	1c47c83a 	sub	r3,r3,r17
 2005d0c:	3023883a 	mov	r17,r6
 2005d10:	1880202c 	andhi	r2,r3,128
 2005d14:	10002326 	beq	r2,zero,2005da4 <__subdf3+0x20c>
 2005d18:	04c02034 	movhi	r19,128
 2005d1c:	9cffffc4 	addi	r19,r19,-1
 2005d20:	1ce6703a 	and	r19,r3,r19
 2005d24:	98007a26 	beq	r19,zero,2005f10 <__subdf3+0x378>
 2005d28:	9809883a 	mov	r4,r19
 2005d2c:	200674c0 	call	200674c <__clzsi2>
 2005d30:	113ffe04 	addi	r4,r2,-8
 2005d34:	00c007c4 	movi	r3,31
 2005d38:	19007b16 	blt	r3,r4,2005f28 <__subdf3+0x390>
 2005d3c:	00800804 	movi	r2,32
 2005d40:	1105c83a 	sub	r2,r2,r4
 2005d44:	8884d83a 	srl	r2,r17,r2
 2005d48:	9906983a 	sll	r3,r19,r4
 2005d4c:	8922983a 	sll	r17,r17,r4
 2005d50:	10c4b03a 	or	r2,r2,r3
 2005d54:	24007816 	blt	r4,r16,2005f38 <__subdf3+0x3a0>
 2005d58:	2421c83a 	sub	r16,r4,r16
 2005d5c:	80c00044 	addi	r3,r16,1
 2005d60:	010007c4 	movi	r4,31
 2005d64:	20c09516 	blt	r4,r3,2005fbc <__subdf3+0x424>
 2005d68:	01400804 	movi	r5,32
 2005d6c:	28cbc83a 	sub	r5,r5,r3
 2005d70:	88c8d83a 	srl	r4,r17,r3
 2005d74:	8962983a 	sll	r17,r17,r5
 2005d78:	114a983a 	sll	r5,r2,r5
 2005d7c:	10c6d83a 	srl	r3,r2,r3
 2005d80:	8804c03a 	cmpne	r2,r17,zero
 2005d84:	290ab03a 	or	r5,r5,r4
 2005d88:	28a2b03a 	or	r17,r5,r2
 2005d8c:	0021883a 	mov	r16,zero
 2005d90:	003fa206 	br	2005c1c <__subdf3+0x84>
 2005d94:	2090b03a 	or	r8,r4,r2
 2005d98:	40018e26 	beq	r8,zero,20063d4 <__subdf3+0x83c>
 2005d9c:	1007883a 	mov	r3,r2
 2005da0:	2023883a 	mov	r17,r4
 2005da4:	888001cc 	andi	r2,r17,7
 2005da8:	103f9e1e 	bne	r2,zero,2005c24 <__subdf3+0x8c>
 2005dac:	1804977a 	slli	r2,r3,29
 2005db0:	8822d0fa 	srli	r17,r17,3
 2005db4:	1810d0fa 	srli	r8,r3,3
 2005db8:	9100004c 	andi	r4,r18,1
 2005dbc:	1444b03a 	or	r2,r2,r17
 2005dc0:	00c1ffc4 	movi	r3,2047
 2005dc4:	80c02826 	beq	r16,r3,2005e68 <__subdf3+0x2d0>
 2005dc8:	01400434 	movhi	r5,16
 2005dcc:	297fffc4 	addi	r5,r5,-1
 2005dd0:	80e0703a 	and	r16,r16,r3
 2005dd4:	414a703a 	and	r5,r8,r5
 2005dd8:	003fa806 	br	2005c7c <__subdf3+0xe4>
 2005ddc:	0080630e 	bge	zero,r2,2005f6c <__subdf3+0x3d4>
 2005de0:	48003026 	beq	r9,zero,2005ea4 <__subdf3+0x30c>
 2005de4:	0101ffc4 	movi	r4,2047
 2005de8:	813f8c26 	beq	r16,r4,2005c1c <__subdf3+0x84>
 2005dec:	29402034 	orhi	r5,r5,128
 2005df0:	01000e04 	movi	r4,56
 2005df4:	2080a90e 	bge	r4,r2,200609c <__subdf3+0x504>
 2005df8:	298cb03a 	or	r6,r5,r6
 2005dfc:	3012c03a 	cmpne	r9,r6,zero
 2005e00:	0005883a 	mov	r2,zero
 2005e04:	4c53883a 	add	r9,r9,r17
 2005e08:	4c63803a 	cmpltu	r17,r9,r17
 2005e0c:	10c7883a 	add	r3,r2,r3
 2005e10:	88c7883a 	add	r3,r17,r3
 2005e14:	4823883a 	mov	r17,r9
 2005e18:	1880202c 	andhi	r2,r3,128
 2005e1c:	1000d026 	beq	r2,zero,2006160 <__subdf3+0x5c8>
 2005e20:	84000044 	addi	r16,r16,1
 2005e24:	0081ffc4 	movi	r2,2047
 2005e28:	8080fe26 	beq	r16,r2,2006224 <__subdf3+0x68c>
 2005e2c:	00bfe034 	movhi	r2,65408
 2005e30:	10bfffc4 	addi	r2,r2,-1
 2005e34:	1886703a 	and	r3,r3,r2
 2005e38:	880ad07a 	srli	r5,r17,1
 2005e3c:	180497fa 	slli	r2,r3,31
 2005e40:	8900004c 	andi	r4,r17,1
 2005e44:	2922b03a 	or	r17,r5,r4
 2005e48:	1806d07a 	srli	r3,r3,1
 2005e4c:	1462b03a 	or	r17,r2,r17
 2005e50:	3825883a 	mov	r18,r7
 2005e54:	003f7106 	br	2005c1c <__subdf3+0x84>
 2005e58:	2984b03a 	or	r2,r5,r6
 2005e5c:	103f6826 	beq	r2,zero,2005c00 <__subdf3+0x68>
 2005e60:	39c03fcc 	andi	r7,r7,255
 2005e64:	003f6706 	br	2005c04 <__subdf3+0x6c>
 2005e68:	4086b03a 	or	r3,r8,r2
 2005e6c:	18015226 	beq	r3,zero,20063b8 <__subdf3+0x820>
 2005e70:	00c00434 	movhi	r3,16
 2005e74:	41400234 	orhi	r5,r8,8
 2005e78:	18ffffc4 	addi	r3,r3,-1
 2005e7c:	28ca703a 	and	r5,r5,r3
 2005e80:	003f7e06 	br	2005c7c <__subdf3+0xe4>
 2005e84:	10bfffc4 	addi	r2,r2,-1
 2005e88:	1000491e 	bne	r2,zero,2005fb0 <__subdf3+0x418>
 2005e8c:	898fc83a 	sub	r7,r17,r6
 2005e90:	89e3803a 	cmpltu	r17,r17,r7
 2005e94:	1947c83a 	sub	r3,r3,r5
 2005e98:	1c47c83a 	sub	r3,r3,r17
 2005e9c:	3823883a 	mov	r17,r7
 2005ea0:	003f9b06 	br	2005d10 <__subdf3+0x178>
 2005ea4:	2988b03a 	or	r4,r5,r6
 2005ea8:	203f5c26 	beq	r4,zero,2005c1c <__subdf3+0x84>
 2005eac:	10bfffc4 	addi	r2,r2,-1
 2005eb0:	1000931e 	bne	r2,zero,2006100 <__subdf3+0x568>
 2005eb4:	898d883a 	add	r6,r17,r6
 2005eb8:	3463803a 	cmpltu	r17,r6,r17
 2005ebc:	1947883a 	add	r3,r3,r5
 2005ec0:	88c7883a 	add	r3,r17,r3
 2005ec4:	3023883a 	mov	r17,r6
 2005ec8:	003fd306 	br	2005e18 <__subdf3+0x280>
 2005ecc:	1000541e 	bne	r2,zero,2006020 <__subdf3+0x488>
 2005ed0:	80800044 	addi	r2,r16,1
 2005ed4:	1081ffcc 	andi	r2,r2,2047
 2005ed8:	01000044 	movi	r4,1
 2005edc:	2080a20e 	bge	r4,r2,2006168 <__subdf3+0x5d0>
 2005ee0:	8989c83a 	sub	r4,r17,r6
 2005ee4:	8905803a 	cmpltu	r2,r17,r4
 2005ee8:	1967c83a 	sub	r19,r3,r5
 2005eec:	98a7c83a 	sub	r19,r19,r2
 2005ef0:	9880202c 	andhi	r2,r19,128
 2005ef4:	10006326 	beq	r2,zero,2006084 <__subdf3+0x4ec>
 2005ef8:	3463c83a 	sub	r17,r6,r17
 2005efc:	28c7c83a 	sub	r3,r5,r3
 2005f00:	344d803a 	cmpltu	r6,r6,r17
 2005f04:	19a7c83a 	sub	r19,r3,r6
 2005f08:	3825883a 	mov	r18,r7
 2005f0c:	983f861e 	bne	r19,zero,2005d28 <__subdf3+0x190>
 2005f10:	8809883a 	mov	r4,r17
 2005f14:	200674c0 	call	200674c <__clzsi2>
 2005f18:	10800804 	addi	r2,r2,32
 2005f1c:	113ffe04 	addi	r4,r2,-8
 2005f20:	00c007c4 	movi	r3,31
 2005f24:	193f850e 	bge	r3,r4,2005d3c <__subdf3+0x1a4>
 2005f28:	10bff604 	addi	r2,r2,-40
 2005f2c:	8884983a 	sll	r2,r17,r2
 2005f30:	0023883a 	mov	r17,zero
 2005f34:	243f880e 	bge	r4,r16,2005d58 <__subdf3+0x1c0>
 2005f38:	00ffe034 	movhi	r3,65408
 2005f3c:	18ffffc4 	addi	r3,r3,-1
 2005f40:	8121c83a 	sub	r16,r16,r4
 2005f44:	10c6703a 	and	r3,r2,r3
 2005f48:	003f3406 	br	2005c1c <__subdf3+0x84>
 2005f4c:	9100004c 	andi	r4,r18,1
 2005f50:	000b883a 	mov	r5,zero
 2005f54:	0005883a 	mov	r2,zero
 2005f58:	003f4806 	br	2005c7c <__subdf3+0xe4>
 2005f5c:	298cb03a 	or	r6,r5,r6
 2005f60:	300cc03a 	cmpne	r6,r6,zero
 2005f64:	0005883a 	mov	r2,zero
 2005f68:	003f6406 	br	2005cfc <__subdf3+0x164>
 2005f6c:	10009a1e 	bne	r2,zero,20061d8 <__subdf3+0x640>
 2005f70:	82400044 	addi	r9,r16,1
 2005f74:	4881ffcc 	andi	r2,r9,2047
 2005f78:	02800044 	movi	r10,1
 2005f7c:	5080670e 	bge	r10,r2,200611c <__subdf3+0x584>
 2005f80:	0081ffc4 	movi	r2,2047
 2005f84:	4880af26 	beq	r9,r2,2006244 <__subdf3+0x6ac>
 2005f88:	898d883a 	add	r6,r17,r6
 2005f8c:	1945883a 	add	r2,r3,r5
 2005f90:	3447803a 	cmpltu	r3,r6,r17
 2005f94:	1887883a 	add	r3,r3,r2
 2005f98:	182297fa 	slli	r17,r3,31
 2005f9c:	300cd07a 	srli	r6,r6,1
 2005fa0:	1806d07a 	srli	r3,r3,1
 2005fa4:	4821883a 	mov	r16,r9
 2005fa8:	89a2b03a 	or	r17,r17,r6
 2005fac:	003f1b06 	br	2005c1c <__subdf3+0x84>
 2005fb0:	0101ffc4 	movi	r4,2047
 2005fb4:	813f441e 	bne	r16,r4,2005cc8 <__subdf3+0x130>
 2005fb8:	003f1806 	br	2005c1c <__subdf3+0x84>
 2005fbc:	843ff844 	addi	r16,r16,-31
 2005fc0:	01400804 	movi	r5,32
 2005fc4:	1408d83a 	srl	r4,r2,r16
 2005fc8:	19405026 	beq	r3,r5,200610c <__subdf3+0x574>
 2005fcc:	01401004 	movi	r5,64
 2005fd0:	28c7c83a 	sub	r3,r5,r3
 2005fd4:	10c4983a 	sll	r2,r2,r3
 2005fd8:	88a2b03a 	or	r17,r17,r2
 2005fdc:	8822c03a 	cmpne	r17,r17,zero
 2005fe0:	2462b03a 	or	r17,r4,r17
 2005fe4:	0007883a 	mov	r3,zero
 2005fe8:	0021883a 	mov	r16,zero
 2005fec:	003f6d06 	br	2005da4 <__subdf3+0x20c>
 2005ff0:	11fff804 	addi	r7,r2,-32
 2005ff4:	01000804 	movi	r4,32
 2005ff8:	29ced83a 	srl	r7,r5,r7
 2005ffc:	11004526 	beq	r2,r4,2006114 <__subdf3+0x57c>
 2006000:	01001004 	movi	r4,64
 2006004:	2089c83a 	sub	r4,r4,r2
 2006008:	2904983a 	sll	r2,r5,r4
 200600c:	118cb03a 	or	r6,r2,r6
 2006010:	300cc03a 	cmpne	r6,r6,zero
 2006014:	398cb03a 	or	r6,r7,r6
 2006018:	0005883a 	mov	r2,zero
 200601c:	003f3706 	br	2005cfc <__subdf3+0x164>
 2006020:	80002a26 	beq	r16,zero,20060cc <__subdf3+0x534>
 2006024:	0101ffc4 	movi	r4,2047
 2006028:	49006626 	beq	r9,r4,20061c4 <__subdf3+0x62c>
 200602c:	0085c83a 	sub	r2,zero,r2
 2006030:	18c02034 	orhi	r3,r3,128
 2006034:	01000e04 	movi	r4,56
 2006038:	20807e16 	blt	r4,r2,2006234 <__subdf3+0x69c>
 200603c:	010007c4 	movi	r4,31
 2006040:	2080e716 	blt	r4,r2,20063e0 <__subdf3+0x848>
 2006044:	01000804 	movi	r4,32
 2006048:	2089c83a 	sub	r4,r4,r2
 200604c:	1914983a 	sll	r10,r3,r4
 2006050:	8890d83a 	srl	r8,r17,r2
 2006054:	8908983a 	sll	r4,r17,r4
 2006058:	1884d83a 	srl	r2,r3,r2
 200605c:	5222b03a 	or	r17,r10,r8
 2006060:	2006c03a 	cmpne	r3,r4,zero
 2006064:	88e2b03a 	or	r17,r17,r3
 2006068:	3463c83a 	sub	r17,r6,r17
 200606c:	2885c83a 	sub	r2,r5,r2
 2006070:	344d803a 	cmpltu	r6,r6,r17
 2006074:	1187c83a 	sub	r3,r2,r6
 2006078:	4821883a 	mov	r16,r9
 200607c:	3825883a 	mov	r18,r7
 2006080:	003f2306 	br	2005d10 <__subdf3+0x178>
 2006084:	24d0b03a 	or	r8,r4,r19
 2006088:	40001b1e 	bne	r8,zero,20060f8 <__subdf3+0x560>
 200608c:	0005883a 	mov	r2,zero
 2006090:	0009883a 	mov	r4,zero
 2006094:	0021883a 	mov	r16,zero
 2006098:	003f4906 	br	2005dc0 <__subdf3+0x228>
 200609c:	010007c4 	movi	r4,31
 20060a0:	20803a16 	blt	r4,r2,200618c <__subdf3+0x5f4>
 20060a4:	01000804 	movi	r4,32
 20060a8:	2089c83a 	sub	r4,r4,r2
 20060ac:	2912983a 	sll	r9,r5,r4
 20060b0:	3090d83a 	srl	r8,r6,r2
 20060b4:	3108983a 	sll	r4,r6,r4
 20060b8:	2884d83a 	srl	r2,r5,r2
 20060bc:	4a12b03a 	or	r9,r9,r8
 20060c0:	2008c03a 	cmpne	r4,r4,zero
 20060c4:	4912b03a 	or	r9,r9,r4
 20060c8:	003f4e06 	br	2005e04 <__subdf3+0x26c>
 20060cc:	1c48b03a 	or	r4,r3,r17
 20060d0:	20003c26 	beq	r4,zero,20061c4 <__subdf3+0x62c>
 20060d4:	0084303a 	nor	r2,zero,r2
 20060d8:	1000381e 	bne	r2,zero,20061bc <__subdf3+0x624>
 20060dc:	3463c83a 	sub	r17,r6,r17
 20060e0:	28c5c83a 	sub	r2,r5,r3
 20060e4:	344d803a 	cmpltu	r6,r6,r17
 20060e8:	1187c83a 	sub	r3,r2,r6
 20060ec:	4821883a 	mov	r16,r9
 20060f0:	3825883a 	mov	r18,r7
 20060f4:	003f0606 	br	2005d10 <__subdf3+0x178>
 20060f8:	2023883a 	mov	r17,r4
 20060fc:	003f0906 	br	2005d24 <__subdf3+0x18c>
 2006100:	0101ffc4 	movi	r4,2047
 2006104:	813f3a1e 	bne	r16,r4,2005df0 <__subdf3+0x258>
 2006108:	003ec406 	br	2005c1c <__subdf3+0x84>
 200610c:	0005883a 	mov	r2,zero
 2006110:	003fb106 	br	2005fd8 <__subdf3+0x440>
 2006114:	0005883a 	mov	r2,zero
 2006118:	003fbc06 	br	200600c <__subdf3+0x474>
 200611c:	1c44b03a 	or	r2,r3,r17
 2006120:	80008e1e 	bne	r16,zero,200635c <__subdf3+0x7c4>
 2006124:	1000c826 	beq	r2,zero,2006448 <__subdf3+0x8b0>
 2006128:	2984b03a 	or	r2,r5,r6
 200612c:	103ebb26 	beq	r2,zero,2005c1c <__subdf3+0x84>
 2006130:	8989883a 	add	r4,r17,r6
 2006134:	1945883a 	add	r2,r3,r5
 2006138:	2447803a 	cmpltu	r3,r4,r17
 200613c:	1887883a 	add	r3,r3,r2
 2006140:	1880202c 	andhi	r2,r3,128
 2006144:	2023883a 	mov	r17,r4
 2006148:	103f1626 	beq	r2,zero,2005da4 <__subdf3+0x20c>
 200614c:	00bfe034 	movhi	r2,65408
 2006150:	10bfffc4 	addi	r2,r2,-1
 2006154:	5021883a 	mov	r16,r10
 2006158:	1886703a 	and	r3,r3,r2
 200615c:	003eaf06 	br	2005c1c <__subdf3+0x84>
 2006160:	3825883a 	mov	r18,r7
 2006164:	003f0f06 	br	2005da4 <__subdf3+0x20c>
 2006168:	1c44b03a 	or	r2,r3,r17
 200616c:	8000251e 	bne	r16,zero,2006204 <__subdf3+0x66c>
 2006170:	1000661e 	bne	r2,zero,200630c <__subdf3+0x774>
 2006174:	2990b03a 	or	r8,r5,r6
 2006178:	40009626 	beq	r8,zero,20063d4 <__subdf3+0x83c>
 200617c:	2807883a 	mov	r3,r5
 2006180:	3023883a 	mov	r17,r6
 2006184:	3825883a 	mov	r18,r7
 2006188:	003ea406 	br	2005c1c <__subdf3+0x84>
 200618c:	127ff804 	addi	r9,r2,-32
 2006190:	01000804 	movi	r4,32
 2006194:	2a52d83a 	srl	r9,r5,r9
 2006198:	11008c26 	beq	r2,r4,20063cc <__subdf3+0x834>
 200619c:	01001004 	movi	r4,64
 20061a0:	2085c83a 	sub	r2,r4,r2
 20061a4:	2884983a 	sll	r2,r5,r2
 20061a8:	118cb03a 	or	r6,r2,r6
 20061ac:	300cc03a 	cmpne	r6,r6,zero
 20061b0:	4992b03a 	or	r9,r9,r6
 20061b4:	0005883a 	mov	r2,zero
 20061b8:	003f1206 	br	2005e04 <__subdf3+0x26c>
 20061bc:	0101ffc4 	movi	r4,2047
 20061c0:	493f9c1e 	bne	r9,r4,2006034 <__subdf3+0x49c>
 20061c4:	2807883a 	mov	r3,r5
 20061c8:	3023883a 	mov	r17,r6
 20061cc:	4821883a 	mov	r16,r9
 20061d0:	3825883a 	mov	r18,r7
 20061d4:	003e9106 	br	2005c1c <__subdf3+0x84>
 20061d8:	80001f1e 	bne	r16,zero,2006258 <__subdf3+0x6c0>
 20061dc:	1c48b03a 	or	r4,r3,r17
 20061e0:	20005a26 	beq	r4,zero,200634c <__subdf3+0x7b4>
 20061e4:	0084303a 	nor	r2,zero,r2
 20061e8:	1000561e 	bne	r2,zero,2006344 <__subdf3+0x7ac>
 20061ec:	89a3883a 	add	r17,r17,r6
 20061f0:	1945883a 	add	r2,r3,r5
 20061f4:	898d803a 	cmpltu	r6,r17,r6
 20061f8:	3087883a 	add	r3,r6,r2
 20061fc:	4821883a 	mov	r16,r9
 2006200:	003f0506 	br	2005e18 <__subdf3+0x280>
 2006204:	10002b1e 	bne	r2,zero,20062b4 <__subdf3+0x71c>
 2006208:	2984b03a 	or	r2,r5,r6
 200620c:	10008026 	beq	r2,zero,2006410 <__subdf3+0x878>
 2006210:	2807883a 	mov	r3,r5
 2006214:	3023883a 	mov	r17,r6
 2006218:	3825883a 	mov	r18,r7
 200621c:	0401ffc4 	movi	r16,2047
 2006220:	003e7e06 	br	2005c1c <__subdf3+0x84>
 2006224:	3809883a 	mov	r4,r7
 2006228:	0011883a 	mov	r8,zero
 200622c:	0005883a 	mov	r2,zero
 2006230:	003ee306 	br	2005dc0 <__subdf3+0x228>
 2006234:	1c62b03a 	or	r17,r3,r17
 2006238:	8822c03a 	cmpne	r17,r17,zero
 200623c:	0005883a 	mov	r2,zero
 2006240:	003f8906 	br	2006068 <__subdf3+0x4d0>
 2006244:	3809883a 	mov	r4,r7
 2006248:	4821883a 	mov	r16,r9
 200624c:	0011883a 	mov	r8,zero
 2006250:	0005883a 	mov	r2,zero
 2006254:	003eda06 	br	2005dc0 <__subdf3+0x228>
 2006258:	0101ffc4 	movi	r4,2047
 200625c:	49003b26 	beq	r9,r4,200634c <__subdf3+0x7b4>
 2006260:	0085c83a 	sub	r2,zero,r2
 2006264:	18c02034 	orhi	r3,r3,128
 2006268:	01000e04 	movi	r4,56
 200626c:	20806e16 	blt	r4,r2,2006428 <__subdf3+0x890>
 2006270:	010007c4 	movi	r4,31
 2006274:	20807716 	blt	r4,r2,2006454 <__subdf3+0x8bc>
 2006278:	01000804 	movi	r4,32
 200627c:	2089c83a 	sub	r4,r4,r2
 2006280:	1914983a 	sll	r10,r3,r4
 2006284:	8890d83a 	srl	r8,r17,r2
 2006288:	8908983a 	sll	r4,r17,r4
 200628c:	1884d83a 	srl	r2,r3,r2
 2006290:	5222b03a 	or	r17,r10,r8
 2006294:	2006c03a 	cmpne	r3,r4,zero
 2006298:	88e2b03a 	or	r17,r17,r3
 200629c:	89a3883a 	add	r17,r17,r6
 20062a0:	1145883a 	add	r2,r2,r5
 20062a4:	898d803a 	cmpltu	r6,r17,r6
 20062a8:	3087883a 	add	r3,r6,r2
 20062ac:	4821883a 	mov	r16,r9
 20062b0:	003ed906 	br	2005e18 <__subdf3+0x280>
 20062b4:	2984b03a 	or	r2,r5,r6
 20062b8:	10004226 	beq	r2,zero,20063c4 <__subdf3+0x82c>
 20062bc:	1808d0fa 	srli	r4,r3,3
 20062c0:	8822d0fa 	srli	r17,r17,3
 20062c4:	1806977a 	slli	r3,r3,29
 20062c8:	2080022c 	andhi	r2,r4,8
 20062cc:	1c62b03a 	or	r17,r3,r17
 20062d0:	10000826 	beq	r2,zero,20062f4 <__subdf3+0x75c>
 20062d4:	2812d0fa 	srli	r9,r5,3
 20062d8:	4880022c 	andhi	r2,r9,8
 20062dc:	1000051e 	bne	r2,zero,20062f4 <__subdf3+0x75c>
 20062e0:	300cd0fa 	srli	r6,r6,3
 20062e4:	2804977a 	slli	r2,r5,29
 20062e8:	4809883a 	mov	r4,r9
 20062ec:	3825883a 	mov	r18,r7
 20062f0:	11a2b03a 	or	r17,r2,r6
 20062f4:	8806d77a 	srli	r3,r17,29
 20062f8:	200890fa 	slli	r4,r4,3
 20062fc:	882290fa 	slli	r17,r17,3
 2006300:	0401ffc4 	movi	r16,2047
 2006304:	1906b03a 	or	r3,r3,r4
 2006308:	003e4406 	br	2005c1c <__subdf3+0x84>
 200630c:	2984b03a 	or	r2,r5,r6
 2006310:	103e4226 	beq	r2,zero,2005c1c <__subdf3+0x84>
 2006314:	8989c83a 	sub	r4,r17,r6
 2006318:	8911803a 	cmpltu	r8,r17,r4
 200631c:	1945c83a 	sub	r2,r3,r5
 2006320:	1205c83a 	sub	r2,r2,r8
 2006324:	1200202c 	andhi	r8,r2,128
 2006328:	403e9a26 	beq	r8,zero,2005d94 <__subdf3+0x1fc>
 200632c:	3463c83a 	sub	r17,r6,r17
 2006330:	28c5c83a 	sub	r2,r5,r3
 2006334:	344d803a 	cmpltu	r6,r6,r17
 2006338:	1187c83a 	sub	r3,r2,r6
 200633c:	3825883a 	mov	r18,r7
 2006340:	003e3606 	br	2005c1c <__subdf3+0x84>
 2006344:	0101ffc4 	movi	r4,2047
 2006348:	493fc71e 	bne	r9,r4,2006268 <__subdf3+0x6d0>
 200634c:	2807883a 	mov	r3,r5
 2006350:	3023883a 	mov	r17,r6
 2006354:	4821883a 	mov	r16,r9
 2006358:	003e3006 	br	2005c1c <__subdf3+0x84>
 200635c:	10003626 	beq	r2,zero,2006438 <__subdf3+0x8a0>
 2006360:	2984b03a 	or	r2,r5,r6
 2006364:	10001726 	beq	r2,zero,20063c4 <__subdf3+0x82c>
 2006368:	1808d0fa 	srli	r4,r3,3
 200636c:	8822d0fa 	srli	r17,r17,3
 2006370:	1806977a 	slli	r3,r3,29
 2006374:	2080022c 	andhi	r2,r4,8
 2006378:	1c62b03a 	or	r17,r3,r17
 200637c:	10000726 	beq	r2,zero,200639c <__subdf3+0x804>
 2006380:	2812d0fa 	srli	r9,r5,3
 2006384:	4880022c 	andhi	r2,r9,8
 2006388:	1000041e 	bne	r2,zero,200639c <__subdf3+0x804>
 200638c:	300cd0fa 	srli	r6,r6,3
 2006390:	2804977a 	slli	r2,r5,29
 2006394:	4809883a 	mov	r4,r9
 2006398:	11a2b03a 	or	r17,r2,r6
 200639c:	8806d77a 	srli	r3,r17,29
 20063a0:	200890fa 	slli	r4,r4,3
 20063a4:	882290fa 	slli	r17,r17,3
 20063a8:	3825883a 	mov	r18,r7
 20063ac:	1906b03a 	or	r3,r3,r4
 20063b0:	0401ffc4 	movi	r16,2047
 20063b4:	003e1906 	br	2005c1c <__subdf3+0x84>
 20063b8:	000b883a 	mov	r5,zero
 20063bc:	0005883a 	mov	r2,zero
 20063c0:	003e2e06 	br	2005c7c <__subdf3+0xe4>
 20063c4:	0401ffc4 	movi	r16,2047
 20063c8:	003e1406 	br	2005c1c <__subdf3+0x84>
 20063cc:	0005883a 	mov	r2,zero
 20063d0:	003f7506 	br	20061a8 <__subdf3+0x610>
 20063d4:	0005883a 	mov	r2,zero
 20063d8:	0009883a 	mov	r4,zero
 20063dc:	003e7806 	br	2005dc0 <__subdf3+0x228>
 20063e0:	123ff804 	addi	r8,r2,-32
 20063e4:	01000804 	movi	r4,32
 20063e8:	1a10d83a 	srl	r8,r3,r8
 20063ec:	11002526 	beq	r2,r4,2006484 <__subdf3+0x8ec>
 20063f0:	01001004 	movi	r4,64
 20063f4:	2085c83a 	sub	r2,r4,r2
 20063f8:	1884983a 	sll	r2,r3,r2
 20063fc:	1444b03a 	or	r2,r2,r17
 2006400:	1004c03a 	cmpne	r2,r2,zero
 2006404:	40a2b03a 	or	r17,r8,r2
 2006408:	0005883a 	mov	r2,zero
 200640c:	003f1606 	br	2006068 <__subdf3+0x4d0>
 2006410:	02000434 	movhi	r8,16
 2006414:	0009883a 	mov	r4,zero
 2006418:	423fffc4 	addi	r8,r8,-1
 200641c:	00bfffc4 	movi	r2,-1
 2006420:	0401ffc4 	movi	r16,2047
 2006424:	003e6606 	br	2005dc0 <__subdf3+0x228>
 2006428:	1c62b03a 	or	r17,r3,r17
 200642c:	8822c03a 	cmpne	r17,r17,zero
 2006430:	0005883a 	mov	r2,zero
 2006434:	003f9906 	br	200629c <__subdf3+0x704>
 2006438:	2807883a 	mov	r3,r5
 200643c:	3023883a 	mov	r17,r6
 2006440:	0401ffc4 	movi	r16,2047
 2006444:	003df506 	br	2005c1c <__subdf3+0x84>
 2006448:	2807883a 	mov	r3,r5
 200644c:	3023883a 	mov	r17,r6
 2006450:	003df206 	br	2005c1c <__subdf3+0x84>
 2006454:	123ff804 	addi	r8,r2,-32
 2006458:	01000804 	movi	r4,32
 200645c:	1a10d83a 	srl	r8,r3,r8
 2006460:	11000a26 	beq	r2,r4,200648c <__subdf3+0x8f4>
 2006464:	01001004 	movi	r4,64
 2006468:	2085c83a 	sub	r2,r4,r2
 200646c:	1884983a 	sll	r2,r3,r2
 2006470:	1444b03a 	or	r2,r2,r17
 2006474:	1004c03a 	cmpne	r2,r2,zero
 2006478:	40a2b03a 	or	r17,r8,r2
 200647c:	0005883a 	mov	r2,zero
 2006480:	003f8606 	br	200629c <__subdf3+0x704>
 2006484:	0005883a 	mov	r2,zero
 2006488:	003fdc06 	br	20063fc <__subdf3+0x864>
 200648c:	0005883a 	mov	r2,zero
 2006490:	003ff706 	br	2006470 <__subdf3+0x8d8>

02006494 <__extendsfdf2>:
 2006494:	200ad5fa 	srli	r5,r4,23
 2006498:	defffd04 	addi	sp,sp,-12
 200649c:	dc400115 	stw	r17,4(sp)
 20064a0:	29403fcc 	andi	r5,r5,255
 20064a4:	29800044 	addi	r6,r5,1
 20064a8:	04402034 	movhi	r17,128
 20064ac:	dc000015 	stw	r16,0(sp)
 20064b0:	8c7fffc4 	addi	r17,r17,-1
 20064b4:	dfc00215 	stw	ra,8(sp)
 20064b8:	31803fcc 	andi	r6,r6,255
 20064bc:	00800044 	movi	r2,1
 20064c0:	8922703a 	and	r17,r17,r4
 20064c4:	2020d7fa 	srli	r16,r4,31
 20064c8:	1180110e 	bge	r2,r6,2006510 <__extendsfdf2+0x7c>
 20064cc:	880cd0fa 	srli	r6,r17,3
 20064d0:	8822977a 	slli	r17,r17,29
 20064d4:	2940e004 	addi	r5,r5,896
 20064d8:	2941ffcc 	andi	r5,r5,2047
 20064dc:	2804953a 	slli	r2,r5,20
 20064e0:	01400434 	movhi	r5,16
 20064e4:	800697fa 	slli	r3,r16,31
 20064e8:	297fffc4 	addi	r5,r5,-1
 20064ec:	314a703a 	and	r5,r6,r5
 20064f0:	288ab03a 	or	r5,r5,r2
 20064f4:	28c6b03a 	or	r3,r5,r3
 20064f8:	8805883a 	mov	r2,r17
 20064fc:	dfc00217 	ldw	ra,8(sp)
 2006500:	dc400117 	ldw	r17,4(sp)
 2006504:	dc000017 	ldw	r16,0(sp)
 2006508:	dec00304 	addi	sp,sp,12
 200650c:	f800283a 	ret
 2006510:	2800111e 	bne	r5,zero,2006558 <__extendsfdf2+0xc4>
 2006514:	88001c26 	beq	r17,zero,2006588 <__extendsfdf2+0xf4>
 2006518:	8809883a 	mov	r4,r17
 200651c:	200674c0 	call	200674c <__clzsi2>
 2006520:	00c00284 	movi	r3,10
 2006524:	18801b16 	blt	r3,r2,2006594 <__extendsfdf2+0x100>
 2006528:	018002c4 	movi	r6,11
 200652c:	308dc83a 	sub	r6,r6,r2
 2006530:	11000544 	addi	r4,r2,21
 2006534:	8986d83a 	srl	r3,r17,r6
 2006538:	8922983a 	sll	r17,r17,r4
 200653c:	0180e244 	movi	r6,905
 2006540:	01400434 	movhi	r5,16
 2006544:	3085c83a 	sub	r2,r6,r2
 2006548:	297fffc4 	addi	r5,r5,-1
 200654c:	194c703a 	and	r6,r3,r5
 2006550:	1141ffcc 	andi	r5,r2,2047
 2006554:	003fe006 	br	20064d8 <__extendsfdf2+0x44>
 2006558:	88000826 	beq	r17,zero,200657c <__extendsfdf2+0xe8>
 200655c:	880cd0fa 	srli	r6,r17,3
 2006560:	00800434 	movhi	r2,16
 2006564:	10bfffc4 	addi	r2,r2,-1
 2006568:	31800234 	orhi	r6,r6,8
 200656c:	8822977a 	slli	r17,r17,29
 2006570:	308c703a 	and	r6,r6,r2
 2006574:	0141ffc4 	movi	r5,2047
 2006578:	003fd706 	br	20064d8 <__extendsfdf2+0x44>
 200657c:	0141ffc4 	movi	r5,2047
 2006580:	000d883a 	mov	r6,zero
 2006584:	003fd406 	br	20064d8 <__extendsfdf2+0x44>
 2006588:	000b883a 	mov	r5,zero
 200658c:	000d883a 	mov	r6,zero
 2006590:	003fd106 	br	20064d8 <__extendsfdf2+0x44>
 2006594:	11bffd44 	addi	r6,r2,-11
 2006598:	8986983a 	sll	r3,r17,r6
 200659c:	0023883a 	mov	r17,zero
 20065a0:	003fe606 	br	200653c <__extendsfdf2+0xa8>

020065a4 <__truncdfsf2>:
 20065a4:	2810d53a 	srli	r8,r5,20
 20065a8:	01c00434 	movhi	r7,16
 20065ac:	39ffffc4 	addi	r7,r7,-1
 20065b0:	29ce703a 	and	r7,r5,r7
 20065b4:	4201ffcc 	andi	r8,r8,2047
 20065b8:	380e90fa 	slli	r7,r7,3
 20065bc:	200cd77a 	srli	r6,r4,29
 20065c0:	42400044 	addi	r9,r8,1
 20065c4:	4a41ffcc 	andi	r9,r9,2047
 20065c8:	00c00044 	movi	r3,1
 20065cc:	280ad7fa 	srli	r5,r5,31
 20065d0:	31ceb03a 	or	r7,r6,r7
 20065d4:	200490fa 	slli	r2,r4,3
 20065d8:	1a40230e 	bge	r3,r9,2006668 <__truncdfsf2+0xc4>
 20065dc:	40ff2004 	addi	r3,r8,-896
 20065e0:	01803f84 	movi	r6,254
 20065e4:	30c01516 	blt	r6,r3,200663c <__truncdfsf2+0x98>
 20065e8:	00c0380e 	bge	zero,r3,20066cc <__truncdfsf2+0x128>
 20065ec:	200c91ba 	slli	r6,r4,6
 20065f0:	380e90fa 	slli	r7,r7,3
 20065f4:	1004d77a 	srli	r2,r2,29
 20065f8:	300cc03a 	cmpne	r6,r6,zero
 20065fc:	31ccb03a 	or	r6,r6,r7
 2006600:	308cb03a 	or	r6,r6,r2
 2006604:	308001cc 	andi	r2,r6,7
 2006608:	10000426 	beq	r2,zero,200661c <__truncdfsf2+0x78>
 200660c:	308003cc 	andi	r2,r6,15
 2006610:	01000104 	movi	r4,4
 2006614:	11000126 	beq	r2,r4,200661c <__truncdfsf2+0x78>
 2006618:	31800104 	addi	r6,r6,4
 200661c:	3081002c 	andhi	r2,r6,1024
 2006620:	10001626 	beq	r2,zero,200667c <__truncdfsf2+0xd8>
 2006624:	18c00044 	addi	r3,r3,1
 2006628:	00803fc4 	movi	r2,255
 200662c:	18800326 	beq	r3,r2,200663c <__truncdfsf2+0x98>
 2006630:	300c91ba 	slli	r6,r6,6
 2006634:	300cd27a 	srli	r6,r6,9
 2006638:	00000206 	br	2006644 <__truncdfsf2+0xa0>
 200663c:	00ffffc4 	movi	r3,-1
 2006640:	000d883a 	mov	r6,zero
 2006644:	18c03fcc 	andi	r3,r3,255
 2006648:	180895fa 	slli	r4,r3,23
 200664c:	00c02034 	movhi	r3,128
 2006650:	280a97fa 	slli	r5,r5,31
 2006654:	18ffffc4 	addi	r3,r3,-1
 2006658:	30c6703a 	and	r3,r6,r3
 200665c:	1906b03a 	or	r3,r3,r4
 2006660:	1944b03a 	or	r2,r3,r5
 2006664:	f800283a 	ret
 2006668:	40000b1e 	bne	r8,zero,2006698 <__truncdfsf2+0xf4>
 200666c:	388cb03a 	or	r6,r7,r2
 2006670:	0007883a 	mov	r3,zero
 2006674:	30000426 	beq	r6,zero,2006688 <__truncdfsf2+0xe4>
 2006678:	01800144 	movi	r6,5
 200667c:	00803fc4 	movi	r2,255
 2006680:	300cd0fa 	srli	r6,r6,3
 2006684:	18800a26 	beq	r3,r2,20066b0 <__truncdfsf2+0x10c>
 2006688:	00802034 	movhi	r2,128
 200668c:	10bfffc4 	addi	r2,r2,-1
 2006690:	308c703a 	and	r6,r6,r2
 2006694:	003feb06 	br	2006644 <__truncdfsf2+0xa0>
 2006698:	3888b03a 	or	r4,r7,r2
 200669c:	203fe726 	beq	r4,zero,200663c <__truncdfsf2+0x98>
 20066a0:	380c90fa 	slli	r6,r7,3
 20066a4:	00c03fc4 	movi	r3,255
 20066a8:	31808034 	orhi	r6,r6,512
 20066ac:	003fd506 	br	2006604 <__truncdfsf2+0x60>
 20066b0:	303fe226 	beq	r6,zero,200663c <__truncdfsf2+0x98>
 20066b4:	00802034 	movhi	r2,128
 20066b8:	31801034 	orhi	r6,r6,64
 20066bc:	10bfffc4 	addi	r2,r2,-1
 20066c0:	00ffffc4 	movi	r3,-1
 20066c4:	308c703a 	and	r6,r6,r2
 20066c8:	003fde06 	br	2006644 <__truncdfsf2+0xa0>
 20066cc:	013ffa44 	movi	r4,-23
 20066d0:	19000e16 	blt	r3,r4,200670c <__truncdfsf2+0x168>
 20066d4:	01000784 	movi	r4,30
 20066d8:	20c9c83a 	sub	r4,r4,r3
 20066dc:	018007c4 	movi	r6,31
 20066e0:	39c02034 	orhi	r7,r7,128
 20066e4:	31000b16 	blt	r6,r4,2006714 <__truncdfsf2+0x170>
 20066e8:	423f2084 	addi	r8,r8,-894
 20066ec:	120c983a 	sll	r6,r2,r8
 20066f0:	3a0e983a 	sll	r7,r7,r8
 20066f4:	1104d83a 	srl	r2,r2,r4
 20066f8:	300cc03a 	cmpne	r6,r6,zero
 20066fc:	31ceb03a 	or	r7,r6,r7
 2006700:	388cb03a 	or	r6,r7,r2
 2006704:	0007883a 	mov	r3,zero
 2006708:	003fbe06 	br	2006604 <__truncdfsf2+0x60>
 200670c:	0007883a 	mov	r3,zero
 2006710:	003fd906 	br	2006678 <__truncdfsf2+0xd4>
 2006714:	01bfff84 	movi	r6,-2
 2006718:	30cdc83a 	sub	r6,r6,r3
 200671c:	00c00804 	movi	r3,32
 2006720:	398cd83a 	srl	r6,r7,r6
 2006724:	20c00726 	beq	r4,r3,2006744 <__truncdfsf2+0x1a0>
 2006728:	423f2884 	addi	r8,r8,-862
 200672c:	3a0e983a 	sll	r7,r7,r8
 2006730:	3884b03a 	or	r2,r7,r2
 2006734:	1004c03a 	cmpne	r2,r2,zero
 2006738:	118cb03a 	or	r6,r2,r6
 200673c:	0007883a 	mov	r3,zero
 2006740:	003fb006 	br	2006604 <__truncdfsf2+0x60>
 2006744:	000f883a 	mov	r7,zero
 2006748:	003ff906 	br	2006730 <__truncdfsf2+0x18c>

0200674c <__clzsi2>:
 200674c:	00bfffd4 	movui	r2,65535
 2006750:	11000536 	bltu	r2,r4,2006768 <__clzsi2+0x1c>
 2006754:	00803fc4 	movi	r2,255
 2006758:	11000f36 	bltu	r2,r4,2006798 <__clzsi2+0x4c>
 200675c:	00800804 	movi	r2,32
 2006760:	0007883a 	mov	r3,zero
 2006764:	00000506 	br	200677c <__clzsi2+0x30>
 2006768:	00804034 	movhi	r2,256
 200676c:	10bfffc4 	addi	r2,r2,-1
 2006770:	11000c2e 	bgeu	r2,r4,20067a4 <__clzsi2+0x58>
 2006774:	00800204 	movi	r2,8
 2006778:	00c00604 	movi	r3,24
 200677c:	20c8d83a 	srl	r4,r4,r3
 2006780:	00c080b4 	movhi	r3,514
 2006784:	18fda644 	addi	r3,r3,-2407
 2006788:	1909883a 	add	r4,r3,r4
 200678c:	20c00003 	ldbu	r3,0(r4)
 2006790:	10c5c83a 	sub	r2,r2,r3
 2006794:	f800283a 	ret
 2006798:	00800604 	movi	r2,24
 200679c:	00c00204 	movi	r3,8
 20067a0:	003ff606 	br	200677c <__clzsi2+0x30>
 20067a4:	00800404 	movi	r2,16
 20067a8:	1007883a 	mov	r3,r2
 20067ac:	003ff306 	br	200677c <__clzsi2+0x30>

020067b0 <__errno>:

#ifndef _REENT_ONLY

int *
__errno ()
{
 20067b0:	deffff04 	addi	sp,sp,-4
 20067b4:	df000015 	stw	fp,0(sp)
 20067b8:	d839883a 	mov	fp,sp
  return &_REENT->_errno;
 20067bc:	d0a00617 	ldw	r2,-32744(gp)
}
 20067c0:	e037883a 	mov	sp,fp
 20067c4:	df000017 	ldw	fp,0(sp)
 20067c8:	dec00104 	addi	sp,sp,4
 20067cc:	f800283a 	ret

020067d0 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
 20067d0:	defff804 	addi	sp,sp,-32
 20067d4:	df000715 	stw	fp,28(sp)
 20067d8:	df000704 	addi	fp,sp,28
 20067dc:	e13ffd15 	stw	r4,-12(fp)
 20067e0:	e17ffe15 	stw	r5,-8(fp)
 20067e4:	e1bfff15 	stw	r6,-4(fp)
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
 20067e8:	e0bffd17 	ldw	r2,-12(fp)
 20067ec:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src0;
 20067f0:	e0bffe17 	ldw	r2,-8(fp)
 20067f4:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
 20067f8:	e0bfff17 	ldw	r2,-4(fp)
 20067fc:	10800430 	cmpltui	r2,r2,16
 2006800:	10004c1e 	bne	r2,zero,2006934 <memcpy+0x164>
 2006804:	e0fffa17 	ldw	r3,-24(fp)
 2006808:	e0bff917 	ldw	r2,-28(fp)
 200680c:	1884b03a 	or	r2,r3,r2
 2006810:	108000cc 	andi	r2,r2,3
 2006814:	1000471e 	bne	r2,zero,2006934 <memcpy+0x164>
    {
      aligned_dst = (long*)dst;
 2006818:	e0bff917 	ldw	r2,-28(fp)
 200681c:	e0bffb15 	stw	r2,-20(fp)
      aligned_src = (long*)src;
 2006820:	e0bffa17 	ldw	r2,-24(fp)
 2006824:	e0bffc15 	stw	r2,-16(fp)

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 2006828:	00002306 	br	20068b8 <memcpy+0xe8>
        {
          *aligned_dst++ = *aligned_src++;
 200682c:	e0bffb17 	ldw	r2,-20(fp)
 2006830:	10c00104 	addi	r3,r2,4
 2006834:	e0fffb15 	stw	r3,-20(fp)
 2006838:	e0fffc17 	ldw	r3,-16(fp)
 200683c:	19000104 	addi	r4,r3,4
 2006840:	e13ffc15 	stw	r4,-16(fp)
 2006844:	18c00017 	ldw	r3,0(r3)
 2006848:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 200684c:	e0bffb17 	ldw	r2,-20(fp)
 2006850:	10c00104 	addi	r3,r2,4
 2006854:	e0fffb15 	stw	r3,-20(fp)
 2006858:	e0fffc17 	ldw	r3,-16(fp)
 200685c:	19000104 	addi	r4,r3,4
 2006860:	e13ffc15 	stw	r4,-16(fp)
 2006864:	18c00017 	ldw	r3,0(r3)
 2006868:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 200686c:	e0bffb17 	ldw	r2,-20(fp)
 2006870:	10c00104 	addi	r3,r2,4
 2006874:	e0fffb15 	stw	r3,-20(fp)
 2006878:	e0fffc17 	ldw	r3,-16(fp)
 200687c:	19000104 	addi	r4,r3,4
 2006880:	e13ffc15 	stw	r4,-16(fp)
 2006884:	18c00017 	ldw	r3,0(r3)
 2006888:	10c00015 	stw	r3,0(r2)
          *aligned_dst++ = *aligned_src++;
 200688c:	e0bffb17 	ldw	r2,-20(fp)
 2006890:	10c00104 	addi	r3,r2,4
 2006894:	e0fffb15 	stw	r3,-20(fp)
 2006898:	e0fffc17 	ldw	r3,-16(fp)
 200689c:	19000104 	addi	r4,r3,4
 20068a0:	e13ffc15 	stw	r4,-16(fp)
 20068a4:	18c00017 	ldw	r3,0(r3)
 20068a8:	10c00015 	stw	r3,0(r2)
          len0 -= BIGBLOCKSIZE;
 20068ac:	e0bfff17 	ldw	r2,-4(fp)
 20068b0:	10bffc04 	addi	r2,r2,-16
 20068b4:	e0bfff15 	stw	r2,-4(fp)
    {
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      while (len0 >= BIGBLOCKSIZE)
 20068b8:	e0bfff17 	ldw	r2,-4(fp)
 20068bc:	10800428 	cmpgeui	r2,r2,16
 20068c0:	103fda1e 	bne	r2,zero,200682c <memcpy+0x5c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 20068c4:	00000b06 	br	20068f4 <memcpy+0x124>
        {
          *aligned_dst++ = *aligned_src++;
 20068c8:	e0bffb17 	ldw	r2,-20(fp)
 20068cc:	10c00104 	addi	r3,r2,4
 20068d0:	e0fffb15 	stw	r3,-20(fp)
 20068d4:	e0fffc17 	ldw	r3,-16(fp)
 20068d8:	19000104 	addi	r4,r3,4
 20068dc:	e13ffc15 	stw	r4,-16(fp)
 20068e0:	18c00017 	ldw	r3,0(r3)
 20068e4:	10c00015 	stw	r3,0(r2)
          len0 -= LITTLEBLOCKSIZE;
 20068e8:	e0bfff17 	ldw	r2,-4(fp)
 20068ec:	10bfff04 	addi	r2,r2,-4
 20068f0:	e0bfff15 	stw	r2,-4(fp)
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
 20068f4:	e0bfff17 	ldw	r2,-4(fp)
 20068f8:	10800128 	cmpgeui	r2,r2,4
 20068fc:	103ff21e 	bne	r2,zero,20068c8 <memcpy+0xf8>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
 2006900:	e0bffb17 	ldw	r2,-20(fp)
 2006904:	e0bff915 	stw	r2,-28(fp)
      src = (char*)aligned_src;
 2006908:	e0bffc17 	ldw	r2,-16(fp)
 200690c:	e0bffa15 	stw	r2,-24(fp)
    }

  while (len0--)
 2006910:	00000806 	br	2006934 <memcpy+0x164>
    *dst++ = *src++;
 2006914:	e0bff917 	ldw	r2,-28(fp)
 2006918:	10c00044 	addi	r3,r2,1
 200691c:	e0fff915 	stw	r3,-28(fp)
 2006920:	e0fffa17 	ldw	r3,-24(fp)
 2006924:	19000044 	addi	r4,r3,1
 2006928:	e13ffa15 	stw	r4,-24(fp)
 200692c:	18c00003 	ldbu	r3,0(r3)
 2006930:	10c00005 	stb	r3,0(r2)
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (len0--)
 2006934:	e0bfff17 	ldw	r2,-4(fp)
 2006938:	10ffffc4 	addi	r3,r2,-1
 200693c:	e0ffff15 	stw	r3,-4(fp)
 2006940:	103ff41e 	bne	r2,zero,2006914 <memcpy+0x144>
    *dst++ = *src++;

  return dst0;
 2006944:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 2006948:	e037883a 	mov	sp,fp
 200694c:	df000017 	ldw	fp,0(sp)
 2006950:	dec00104 	addi	sp,sp,4
 2006954:	f800283a 	ret

02006958 <memset>:
__inhibit_loop_to_libcall
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
 2006958:	defff704 	addi	sp,sp,-36
 200695c:	df000815 	stw	fp,32(sp)
 2006960:	df000804 	addi	fp,sp,32
 2006964:	e13ffd15 	stw	r4,-12(fp)
 2006968:	e17ffe15 	stw	r5,-8(fp)
 200696c:	e1bfff15 	stw	r6,-4(fp)
  char *s = (char *) m;
 2006970:	e0bffd17 	ldw	r2,-12(fp)
 2006974:	e0bff815 	stw	r2,-32(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
 2006978:	e0bffe17 	ldw	r2,-8(fp)
 200697c:	10803fcc 	andi	r2,r2,255
 2006980:	e0bffc15 	stw	r2,-16(fp)
				   unsigned variable.  */

  while (UNALIGNED (s))
 2006984:	00000c06 	br	20069b8 <memset+0x60>
    {
      if (n--)
 2006988:	e0bfff17 	ldw	r2,-4(fp)
 200698c:	10ffffc4 	addi	r3,r2,-1
 2006990:	e0ffff15 	stw	r3,-4(fp)
 2006994:	10000626 	beq	r2,zero,20069b0 <memset+0x58>
        *s++ = (char) c;
 2006998:	e0bff817 	ldw	r2,-32(fp)
 200699c:	10c00044 	addi	r3,r2,1
 20069a0:	e0fff815 	stw	r3,-32(fp)
 20069a4:	e0fffe17 	ldw	r3,-8(fp)
 20069a8:	10c00005 	stb	r3,0(r2)
 20069ac:	00000206 	br	20069b8 <memset+0x60>
      else
        return m;
 20069b0:	e0bffd17 	ldw	r2,-12(fp)
 20069b4:	00005506 	br	2006b0c <memset+0x1b4>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
 20069b8:	e0bff817 	ldw	r2,-32(fp)
 20069bc:	108000cc 	andi	r2,r2,3
 20069c0:	103ff11e 	bne	r2,zero,2006988 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
 20069c4:	e0bfff17 	ldw	r2,-4(fp)
 20069c8:	10800130 	cmpltui	r2,r2,4
 20069cc:	10004a1e 	bne	r2,zero,2006af8 <memset+0x1a0>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
 20069d0:	e0bff817 	ldw	r2,-32(fp)
 20069d4:	e0bffb15 	stw	r2,-20(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
 20069d8:	e0bffc17 	ldw	r2,-16(fp)
 20069dc:	1006923a 	slli	r3,r2,8
 20069e0:	e0bffc17 	ldw	r2,-16(fp)
 20069e4:	1884b03a 	or	r2,r3,r2
 20069e8:	e0bffa15 	stw	r2,-24(fp)
      buffer |= (buffer << 16);
 20069ec:	e0bffa17 	ldw	r2,-24(fp)
 20069f0:	1004943a 	slli	r2,r2,16
 20069f4:	e0fffa17 	ldw	r3,-24(fp)
 20069f8:	1884b03a 	or	r2,r3,r2
 20069fc:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 2006a00:	00800804 	movi	r2,32
 2006a04:	e0bff915 	stw	r2,-28(fp)
 2006a08:	00000906 	br	2006a30 <memset+0xd8>
        buffer = (buffer << i) | buffer;
 2006a0c:	e0fffa17 	ldw	r3,-24(fp)
 2006a10:	e0bff917 	ldw	r2,-28(fp)
 2006a14:	1884983a 	sll	r2,r3,r2
 2006a18:	e0fffa17 	ldw	r3,-24(fp)
 2006a1c:	1884b03a 	or	r2,r3,r2
 2006a20:	e0bffa15 	stw	r2,-24(fp)

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 2006a24:	e0bff917 	ldw	r2,-28(fp)
 2006a28:	1085883a 	add	r2,r2,r2
 2006a2c:	e0bff915 	stw	r2,-28(fp)
 2006a30:	e0bff917 	ldw	r2,-28(fp)
 2006a34:	10800830 	cmpltui	r2,r2,32
 2006a38:	103ff41e 	bne	r2,zero,2006a0c <memset+0xb4>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 2006a3c:	00001706 	br	2006a9c <memset+0x144>
        {
          *aligned_addr++ = buffer;
 2006a40:	e0bffb17 	ldw	r2,-20(fp)
 2006a44:	10c00104 	addi	r3,r2,4
 2006a48:	e0fffb15 	stw	r3,-20(fp)
 2006a4c:	e0fffa17 	ldw	r3,-24(fp)
 2006a50:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 2006a54:	e0bffb17 	ldw	r2,-20(fp)
 2006a58:	10c00104 	addi	r3,r2,4
 2006a5c:	e0fffb15 	stw	r3,-20(fp)
 2006a60:	e0fffa17 	ldw	r3,-24(fp)
 2006a64:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 2006a68:	e0bffb17 	ldw	r2,-20(fp)
 2006a6c:	10c00104 	addi	r3,r2,4
 2006a70:	e0fffb15 	stw	r3,-20(fp)
 2006a74:	e0fffa17 	ldw	r3,-24(fp)
 2006a78:	10c00015 	stw	r3,0(r2)
          *aligned_addr++ = buffer;
 2006a7c:	e0bffb17 	ldw	r2,-20(fp)
 2006a80:	10c00104 	addi	r3,r2,4
 2006a84:	e0fffb15 	stw	r3,-20(fp)
 2006a88:	e0fffa17 	ldw	r3,-24(fp)
 2006a8c:	10c00015 	stw	r3,0(r2)
          n -= 4*LBLOCKSIZE;
 2006a90:	e0bfff17 	ldw	r2,-4(fp)
 2006a94:	10bffc04 	addi	r2,r2,-16
 2006a98:	e0bfff15 	stw	r2,-4(fp)
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
 2006a9c:	e0bfff17 	ldw	r2,-4(fp)
 2006aa0:	10800428 	cmpgeui	r2,r2,16
 2006aa4:	103fe61e 	bne	r2,zero,2006a40 <memset+0xe8>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 2006aa8:	00000806 	br	2006acc <memset+0x174>
        {
          *aligned_addr++ = buffer;
 2006aac:	e0bffb17 	ldw	r2,-20(fp)
 2006ab0:	10c00104 	addi	r3,r2,4
 2006ab4:	e0fffb15 	stw	r3,-20(fp)
 2006ab8:	e0fffa17 	ldw	r3,-24(fp)
 2006abc:	10c00015 	stw	r3,0(r2)
          n -= LBLOCKSIZE;
 2006ac0:	e0bfff17 	ldw	r2,-4(fp)
 2006ac4:	10bfff04 	addi	r2,r2,-4
 2006ac8:	e0bfff15 	stw	r2,-4(fp)
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
 2006acc:	e0bfff17 	ldw	r2,-4(fp)
 2006ad0:	10800128 	cmpgeui	r2,r2,4
 2006ad4:	103ff51e 	bne	r2,zero,2006aac <memset+0x154>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
 2006ad8:	e0bffb17 	ldw	r2,-20(fp)
 2006adc:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 2006ae0:	00000506 	br	2006af8 <memset+0x1a0>
    *s++ = (char) c;
 2006ae4:	e0bff817 	ldw	r2,-32(fp)
 2006ae8:	10c00044 	addi	r3,r2,1
 2006aec:	e0fff815 	stw	r3,-32(fp)
 2006af0:	e0fffe17 	ldw	r3,-8(fp)
 2006af4:	10c00005 	stb	r3,0(r2)
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 2006af8:	e0bfff17 	ldw	r2,-4(fp)
 2006afc:	10ffffc4 	addi	r3,r2,-1
 2006b00:	e0ffff15 	stw	r3,-4(fp)
 2006b04:	103ff71e 	bne	r2,zero,2006ae4 <memset+0x18c>
    *s++ = (char) c;

  return m;
 2006b08:	e0bffd17 	ldw	r2,-12(fp)
}
 2006b0c:	e037883a 	mov	sp,fp
 2006b10:	df000017 	ldw	fp,0(sp)
 2006b14:	dec00104 	addi	sp,sp,4
 2006b18:	f800283a 	ret

02006b1c <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *__restrict fmt _DOTS)
{
 2006b1c:	defff804 	addi	sp,sp,-32
 2006b20:	dfc00515 	stw	ra,20(sp)
 2006b24:	df000415 	stw	fp,16(sp)
 2006b28:	df000404 	addi	fp,sp,16
 2006b2c:	e13ffe15 	stw	r4,-8(fp)
 2006b30:	e17fff15 	stw	r5,-4(fp)
 2006b34:	e1800215 	stw	r6,8(fp)
 2006b38:	e1c00315 	stw	r7,12(fp)
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (ptr));						/* AlteraSpecific */
  va_start (ap, fmt);
 2006b3c:	e0800204 	addi	r2,fp,8
 2006b40:	e0bffd15 	stw	r2,-12(fp)
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16.0*/	/* AlteraSpecific */
/*ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.16  */	/* AlteraSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/*1.18.0*/	/* AlteraSpecific */
/*ret =   _vfprintf_r          (ptr, _stdout_r (ptr), fmt, ap);	*/	/* try1 */	/* AlteraSpecific */
  ret = ___vfprintf_internal_r (ptr, _stdout_r (ptr), fmt, ap);		/* try2 */	/* AlteraSpecific */
 2006b44:	e0bffe17 	ldw	r2,-8(fp)
 2006b48:	10800217 	ldw	r2,8(r2)
 2006b4c:	e0fffd17 	ldw	r3,-12(fp)
 2006b50:	180f883a 	mov	r7,r3
 2006b54:	e1bfff17 	ldw	r6,-4(fp)
 2006b58:	100b883a 	mov	r5,r2
 2006b5c:	e13ffe17 	ldw	r4,-8(fp)
 2006b60:	2006f6c0 	call	2006f6c <___vfprintf_internal_r>
 2006b64:	e0bffc15 	stw	r2,-16(fp)
  va_end (ap);
  return ret;
 2006b68:	e0bffc17 	ldw	r2,-16(fp)
}
 2006b6c:	e037883a 	mov	sp,fp
 2006b70:	dfc00117 	ldw	ra,4(sp)
 2006b74:	df000017 	ldw	fp,0(sp)
 2006b78:	dec00404 	addi	sp,sp,16
 2006b7c:	f800283a 	ret

02006b80 <printf>:
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *__restrict fmt _DOTS)
{
 2006b80:	defff704 	addi	sp,sp,-36
 2006b84:	dfc00515 	stw	ra,20(sp)
 2006b88:	df000415 	stw	fp,16(sp)
 2006b8c:	df000404 	addi	fp,sp,16
 2006b90:	e13fff15 	stw	r4,-4(fp)
 2006b94:	e1400215 	stw	r5,8(fp)
 2006b98:	e1800315 	stw	r6,12(fp)
 2006b9c:	e1c00415 	stw	r7,16(fp)
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
 2006ba0:	d0a00617 	ldw	r2,-32744(gp)
 2006ba4:	e0bffc15 	stw	r2,-16(fp)

  _REENT_SMALL_CHECK_INIT (ptr);
  _FILE_INIT_DEV_WRITE (_stdout_r (_REENT));					/* AlteraSpecific. Mirror changes here in iprintf.c */
  va_start (ap, fmt);
 2006ba8:	e0800204 	addi	r2,fp,8
 2006bac:	e0bffe15 	stw	r2,-8(fp)
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.16.0*/	/* AlteraSpecific */
/*ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);	*/ /*1.16  */	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap);	*/ /*1.18.0*/	/* AlteraSpecific */
/*ret =  _vfprintf_r        (ptr, _stdout_r    (ptr), fmt, ap); */ /* try1 */	/* AlteraSpecific */
  ret = __vfprintf_internal (     _stdout_r (_REENT), fmt, ap);    /* try2 */	/* AlteraSpecific */
 2006bb0:	d0a00617 	ldw	r2,-32744(gp)
 2006bb4:	10800217 	ldw	r2,8(r2)
 2006bb8:	e0fffe17 	ldw	r3,-8(fp)
 2006bbc:	180d883a 	mov	r6,r3
 2006bc0:	e17fff17 	ldw	r5,-4(fp)
 2006bc4:	1009883a 	mov	r4,r2
 2006bc8:	2006f1c0 	call	2006f1c <__vfprintf_internal>
 2006bcc:	e0bffd15 	stw	r2,-12(fp)
  va_end (ap);
  return ret;
 2006bd0:	e0bffd17 	ldw	r2,-12(fp)
}
 2006bd4:	e037883a 	mov	sp,fp
 2006bd8:	dfc00117 	ldw	ra,4(sp)
 2006bdc:	df000017 	ldw	fp,0(sp)
 2006be0:	dec00504 	addi	sp,sp,20
 2006be4:	f800283a 	ret

02006be8 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
 2006be8:	defff104 	addi	sp,sp,-60
 2006bec:	dfc00e15 	stw	ra,56(sp)
 2006bf0:	df000d15 	stw	fp,52(sp)
 2006bf4:	df000d04 	addi	fp,sp,52
 2006bf8:	e13ffe15 	stw	r4,-8(fp)
 2006bfc:	e17fff15 	stw	r5,-4(fp)
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
 2006c00:	e13fff17 	ldw	r4,-4(fp)
 2006c04:	2006d380 	call	2006d38 <strlen>
 2006c08:	e0bff315 	stw	r2,-52(fp)
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
 2006c0c:	e0bfff17 	ldw	r2,-4(fp)
 2006c10:	e0bffa15 	stw	r2,-24(fp)
  iov[0].iov_len = c;
 2006c14:	e0bff317 	ldw	r2,-52(fp)
 2006c18:	e0bffb15 	stw	r2,-20(fp)
  iov[1].iov_base = "\n";
 2006c1c:	008080b4 	movhi	r2,514
 2006c20:	10bde804 	addi	r2,r2,-2144
 2006c24:	e0bffc15 	stw	r2,-16(fp)
  iov[1].iov_len = 1;
 2006c28:	00800044 	movi	r2,1
 2006c2c:	e0bffd15 	stw	r2,-12(fp)
  uio.uio_resid = c + 1;
 2006c30:	e0bff317 	ldw	r2,-52(fp)
 2006c34:	10800044 	addi	r2,r2,1
 2006c38:	e0bff915 	stw	r2,-28(fp)
  uio.uio_iov = &iov[0];
 2006c3c:	e0bffa04 	addi	r2,fp,-24
 2006c40:	e0bff715 	stw	r2,-36(fp)
  uio.uio_iovcnt = 2;
 2006c44:	00800084 	movi	r2,2
 2006c48:	e0bff815 	stw	r2,-32(fp)

  CHECK_STD_INIT (ptr);
 2006c4c:	e0bffe17 	ldw	r2,-8(fp)
 2006c50:	e0bff415 	stw	r2,-48(fp)
 2006c54:	e0bff417 	ldw	r2,-48(fp)
 2006c58:	10000526 	beq	r2,zero,2006c70 <_puts_r+0x88>
 2006c5c:	e0bff417 	ldw	r2,-48(fp)
 2006c60:	10800e17 	ldw	r2,56(r2)
 2006c64:	1000021e 	bne	r2,zero,2006c70 <_puts_r+0x88>
 2006c68:	e13ff417 	ldw	r4,-48(fp)
 2006c6c:	200bbd80 	call	200bbd8 <__sinit>
  fp = _stdout_r (ptr);
 2006c70:	e0bffe17 	ldw	r2,-8(fp)
 2006c74:	10800217 	ldw	r2,8(r2)
 2006c78:	e0bff515 	stw	r2,-44(fp)
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
 2006c7c:	e0bff517 	ldw	r2,-44(fp)
 2006c80:	1080030b 	ldhu	r2,12(r2)
 2006c84:	10bfffcc 	andi	r2,r2,65535
 2006c88:	1088000c 	andi	r2,r2,8192
 2006c8c:	10000c1e 	bne	r2,zero,2006cc0 <_puts_r+0xd8>
 2006c90:	e0bff517 	ldw	r2,-44(fp)
 2006c94:	1080030b 	ldhu	r2,12(r2)
 2006c98:	10880014 	ori	r2,r2,8192
 2006c9c:	1007883a 	mov	r3,r2
 2006ca0:	e0bff517 	ldw	r2,-44(fp)
 2006ca4:	10c0030d 	sth	r3,12(r2)
 2006ca8:	e0bff517 	ldw	r2,-44(fp)
 2006cac:	10c01917 	ldw	r3,100(r2)
 2006cb0:	00b7ffc4 	movi	r2,-8193
 2006cb4:	1886703a 	and	r3,r3,r2
 2006cb8:	e0bff517 	ldw	r2,-44(fp)
 2006cbc:	10c01915 	stw	r3,100(r2)
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
 2006cc0:	e0bff704 	addi	r2,fp,-36
 2006cc4:	100d883a 	mov	r6,r2
 2006cc8:	e17ff517 	ldw	r5,-44(fp)
 2006ccc:	e13ffe17 	ldw	r4,-8(fp)
 2006cd0:	200c5240 	call	200c524 <__sfvwrite_r>
 2006cd4:	10000226 	beq	r2,zero,2006ce0 <_puts_r+0xf8>
 2006cd8:	00bfffc4 	movi	r2,-1
 2006cdc:	00000106 	br	2006ce4 <_puts_r+0xfc>
 2006ce0:	00800284 	movi	r2,10
 2006ce4:	e0bff615 	stw	r2,-40(fp)
  _newlib_flockfile_end (fp);
  return result;
 2006ce8:	e0bff617 	ldw	r2,-40(fp)

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
 2006cec:	e037883a 	mov	sp,fp
 2006cf0:	dfc00117 	ldw	ra,4(sp)
 2006cf4:	df000017 	ldw	fp,0(sp)
 2006cf8:	dec00204 	addi	sp,sp,8
 2006cfc:	f800283a 	ret

02006d00 <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
 2006d00:	defffd04 	addi	sp,sp,-12
 2006d04:	dfc00215 	stw	ra,8(sp)
 2006d08:	df000115 	stw	fp,4(sp)
 2006d0c:	df000104 	addi	fp,sp,4
 2006d10:	e13fff15 	stw	r4,-4(fp)
  return _puts_r (_REENT, s);
 2006d14:	d0a00617 	ldw	r2,-32744(gp)
 2006d18:	e17fff17 	ldw	r5,-4(fp)
 2006d1c:	1009883a 	mov	r4,r2
 2006d20:	2006be80 	call	2006be8 <_puts_r>
}
 2006d24:	e037883a 	mov	sp,fp
 2006d28:	dfc00117 	ldw	ra,4(sp)
 2006d2c:	df000017 	ldw	fp,0(sp)
 2006d30:	dec00204 	addi	sp,sp,8
 2006d34:	f800283a 	ret

02006d38 <strlen>:
#endif

size_t
_DEFUN (strlen, (str),
	_CONST char *str)
{
 2006d38:	defffc04 	addi	sp,sp,-16
 2006d3c:	df000315 	stw	fp,12(sp)
 2006d40:	df000304 	addi	fp,sp,12
 2006d44:	e13fff15 	stw	r4,-4(fp)
  _CONST char *start = str;
 2006d48:	e0bfff17 	ldw	r2,-4(fp)
 2006d4c:	e0bffe15 	stw	r2,-8(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 2006d50:	00000d06 	br	2006d88 <strlen+0x50>
    {
      if (!*str)
 2006d54:	e0bfff17 	ldw	r2,-4(fp)
 2006d58:	10800003 	ldbu	r2,0(r2)
 2006d5c:	10803fcc 	andi	r2,r2,255
 2006d60:	1080201c 	xori	r2,r2,128
 2006d64:	10bfe004 	addi	r2,r2,-128
 2006d68:	1000041e 	bne	r2,zero,2006d7c <strlen+0x44>
	return str - start;
 2006d6c:	e0ffff17 	ldw	r3,-4(fp)
 2006d70:	e0bffe17 	ldw	r2,-8(fp)
 2006d74:	1885c83a 	sub	r2,r3,r2
 2006d78:	00002806 	br	2006e1c <strlen+0xe4>
      str++;
 2006d7c:	e0bfff17 	ldw	r2,-4(fp)
 2006d80:	10800044 	addi	r2,r2,1
 2006d84:	e0bfff15 	stw	r2,-4(fp)

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *aligned_addr;

  /* Align the pointer, so we can search a word at a time.  */
  while (UNALIGNED (str))
 2006d88:	e0bfff17 	ldw	r2,-4(fp)
 2006d8c:	108000cc 	andi	r2,r2,3
 2006d90:	103ff01e 	bne	r2,zero,2006d54 <strlen+0x1c>
      str++;
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
 2006d94:	e0bfff17 	ldw	r2,-4(fp)
 2006d98:	e0bffd15 	stw	r2,-12(fp)
  while (!DETECTNULL (*aligned_addr))
 2006d9c:	00000306 	br	2006dac <strlen+0x74>
    aligned_addr++;
 2006da0:	e0bffd17 	ldw	r2,-12(fp)
 2006da4:	10800104 	addi	r2,r2,4
 2006da8:	e0bffd15 	stw	r2,-12(fp)
    }

  /* If the string is word-aligned, we can check for the presence of
     a null in each word-sized block.  */
  aligned_addr = (unsigned long *)str;
  while (!DETECTNULL (*aligned_addr))
 2006dac:	e0bffd17 	ldw	r2,-12(fp)
 2006db0:	10c00017 	ldw	r3,0(r2)
 2006db4:	00bfbff4 	movhi	r2,65279
 2006db8:	10bfbfc4 	addi	r2,r2,-257
 2006dbc:	1887883a 	add	r3,r3,r2
 2006dc0:	e0bffd17 	ldw	r2,-12(fp)
 2006dc4:	10800017 	ldw	r2,0(r2)
 2006dc8:	0084303a 	nor	r2,zero,r2
 2006dcc:	1886703a 	and	r3,r3,r2
 2006dd0:	00a02074 	movhi	r2,32897
 2006dd4:	10a02004 	addi	r2,r2,-32640
 2006dd8:	1884703a 	and	r2,r3,r2
 2006ddc:	103ff026 	beq	r2,zero,2006da0 <strlen+0x68>
    aligned_addr++;

  /* Once a null is detected, we check each byte in that block for a
     precise position of the null.  */
  str = (char *) aligned_addr;
 2006de0:	e0bffd17 	ldw	r2,-12(fp)
 2006de4:	e0bfff15 	stw	r2,-4(fp)

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 2006de8:	00000306 	br	2006df8 <strlen+0xc0>
    str++;
 2006dec:	e0bfff17 	ldw	r2,-4(fp)
 2006df0:	10800044 	addi	r2,r2,1
 2006df4:	e0bfff15 	stw	r2,-4(fp)
     precise position of the null.  */
  str = (char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*str)
 2006df8:	e0bfff17 	ldw	r2,-4(fp)
 2006dfc:	10800003 	ldbu	r2,0(r2)
 2006e00:	10803fcc 	andi	r2,r2,255
 2006e04:	1080201c 	xori	r2,r2,128
 2006e08:	10bfe004 	addi	r2,r2,-128
 2006e0c:	103ff71e 	bne	r2,zero,2006dec <strlen+0xb4>
    str++;
  return str - start;
 2006e10:	e0ffff17 	ldw	r3,-4(fp)
 2006e14:	e0bffe17 	ldw	r2,-8(fp)
 2006e18:	1885c83a 	sub	r2,r3,r2
}
 2006e1c:	e037883a 	mov	sp,fp
 2006e20:	df000017 	ldw	fp,0(sp)
 2006e24:	dec00104 	addi	sp,sp,4
 2006e28:	f800283a 	ret

02006e2c <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
 2006e2c:	defedf04 	addi	sp,sp,-1156
 2006e30:	dfc12015 	stw	ra,1152(sp)
 2006e34:	df011f15 	stw	fp,1148(sp)
 2006e38:	dc011e15 	stw	r16,1144(sp)
 2006e3c:	df011f04 	addi	fp,sp,1148
 2006e40:	e13ffc15 	stw	r4,-16(fp)
 2006e44:	2821883a 	mov	r16,r5
 2006e48:	e1bffd15 	stw	r6,-12(fp)
 2006e4c:	e1fffe15 	stw	r7,-8(fp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
 2006e50:	80c0030b 	ldhu	r3,12(r16)
 2006e54:	00bfff44 	movi	r2,-3
 2006e58:	1884703a 	and	r2,r3,r2
 2006e5c:	e0bee50d 	sth	r2,-1132(fp)
	fake._flags2 = fp->_flags2;
 2006e60:	80801917 	ldw	r2,100(r16)
 2006e64:	e0befb15 	stw	r2,-1044(fp)
	fake._file = fp->_file;
 2006e68:	8080038b 	ldhu	r2,14(r16)
 2006e6c:	e0bee58d 	sth	r2,-1130(fp)
	fake._cookie = fp->_cookie;
 2006e70:	80800717 	ldw	r2,28(r16)
 2006e74:	e0bee915 	stw	r2,-1116(fp)
	fake._write = fp->_write;
 2006e78:	80800917 	ldw	r2,36(r16)
 2006e7c:	e0beeb15 	stw	r2,-1108(fp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
 2006e80:	e0befc04 	addi	r2,fp,-1040
 2006e84:	e0bee215 	stw	r2,-1144(fp)
 2006e88:	e0bee217 	ldw	r2,-1144(fp)
 2006e8c:	e0bee615 	stw	r2,-1128(fp)
	fake._bf._size = fake._w = sizeof (buf);
 2006e90:	00810004 	movi	r2,1024
 2006e94:	e0bee415 	stw	r2,-1136(fp)
 2006e98:	e0bee417 	ldw	r2,-1136(fp)
 2006e9c:	e0bee715 	stw	r2,-1124(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 2006ea0:	e03ee815 	stw	zero,-1120(fp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 2006ea4:	e0bee204 	addi	r2,fp,-1144
 2006ea8:	e1fffe17 	ldw	r7,-8(fp)
 2006eac:	e1bffd17 	ldw	r6,-12(fp)
 2006eb0:	100b883a 	mov	r5,r2
 2006eb4:	e13ffc17 	ldw	r4,-16(fp)
 2006eb8:	2006f6c0 	call	2006f6c <___vfprintf_internal_r>
 2006ebc:	e0bee115 	stw	r2,-1148(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 2006ec0:	e0bee117 	ldw	r2,-1148(fp)
 2006ec4:	10000716 	blt	r2,zero,2006ee4 <__sbprintf+0xb8>
 2006ec8:	e0bee204 	addi	r2,fp,-1144
 2006ecc:	100b883a 	mov	r5,r2
 2006ed0:	e13ffc17 	ldw	r4,-16(fp)
 2006ed4:	200b7580 	call	200b758 <_fflush_r>
 2006ed8:	10000226 	beq	r2,zero,2006ee4 <__sbprintf+0xb8>
		ret = EOF;
 2006edc:	00bfffc4 	movi	r2,-1
 2006ee0:	e0bee115 	stw	r2,-1148(fp)
	if (fake._flags & __SERR)
 2006ee4:	e0bee50b 	ldhu	r2,-1132(fp)
 2006ee8:	10bfffcc 	andi	r2,r2,65535
 2006eec:	1080100c 	andi	r2,r2,64
 2006ef0:	10000326 	beq	r2,zero,2006f00 <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 2006ef4:	8080030b 	ldhu	r2,12(r16)
 2006ef8:	10801014 	ori	r2,r2,64
 2006efc:	8080030d 	sth	r2,12(r16)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
 2006f00:	e0bee117 	ldw	r2,-1148(fp)
}
 2006f04:	e6ffff04 	addi	sp,fp,-4
 2006f08:	dfc00217 	ldw	ra,8(sp)
 2006f0c:	df000117 	ldw	fp,4(sp)
 2006f10:	dc000017 	ldw	r16,0(sp)
 2006f14:	dec00304 	addi	sp,sp,12
 2006f18:	f800283a 	ret

02006f1c <__vfprintf_internal>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
 2006f1c:	defffa04 	addi	sp,sp,-24
 2006f20:	dfc00515 	stw	ra,20(sp)
 2006f24:	df000415 	stw	fp,16(sp)
 2006f28:	df000404 	addi	fp,sp,16
 2006f2c:	e13ffd15 	stw	r4,-12(fp)
 2006f30:	e17ffe15 	stw	r5,-8(fp)
 2006f34:	e1bfff15 	stw	r6,-4(fp)
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 2006f38:	d0a00617 	ldw	r2,-32744(gp)
 2006f3c:	e1ffff17 	ldw	r7,-4(fp)
 2006f40:	e1bffe17 	ldw	r6,-8(fp)
 2006f44:	e17ffd17 	ldw	r5,-12(fp)
 2006f48:	1009883a 	mov	r4,r2
 2006f4c:	2006f6c0 	call	2006f6c <___vfprintf_internal_r>
 2006f50:	e0bffc15 	stw	r2,-16(fp)
  return result;
 2006f54:	e0bffc17 	ldw	r2,-16(fp)
}
 2006f58:	e037883a 	mov	sp,fp
 2006f5c:	dfc00117 	ldw	ra,4(sp)
 2006f60:	df000017 	ldw	fp,0(sp)
 2006f64:	dec00204 	addi	sp,sp,8
 2006f68:	f800283a 	ret

02006f6c <___vfprintf_internal_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
 2006f6c:	deffa404 	addi	sp,sp,-368
 2006f70:	dfc05b15 	stw	ra,364(sp)
 2006f74:	df005a15 	stw	fp,360(sp)
 2006f78:	ddc05915 	stw	r23,356(sp)
 2006f7c:	dd805815 	stw	r22,352(sp)
 2006f80:	dd405715 	stw	r21,348(sp)
 2006f84:	dd005615 	stw	r20,344(sp)
 2006f88:	dcc05515 	stw	r19,340(sp)
 2006f8c:	dc805415 	stw	r18,336(sp)
 2006f90:	dc405315 	stw	r17,332(sp)
 2006f94:	dc005215 	stw	r16,328(sp)
 2006f98:	df005a04 	addi	fp,sp,360
 2006f9c:	e13fe615 	stw	r4,-104(fp)
 2006fa0:	e17fe715 	stw	r5,-100(fp)
 2006fa4:	e1bfe815 	stw	r6,-96(fp)
 2006fa8:	e1ffe915 	stw	r7,-92(fp)
	char *thousands_sep = NULL;
	size_t thsnd_len = 0;
	const char *grouping = NULL;
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
 2006fac:	e13fe617 	ldw	r4,-104(fp)
 2006fb0:	200cdc00 	call	200cdc0 <_localeconv_r>
 2006fb4:	10800017 	ldw	r2,0(r2)
 2006fb8:	e0bfbb15 	stw	r2,-276(fp)
	size_t decp_len = strlen (decimal_point);
 2006fbc:	e13fbb17 	ldw	r4,-276(fp)
 2006fc0:	2006d380 	call	2006d38 <strlen>
 2006fc4:	e0bfbc15 	stw	r2,-272(fp)
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
 2006fc8:	e03fc215 	stw	zero,-248(fp)
 2006fcc:	e03fc315 	stw	zero,-244(fp)
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
 2006fd0:	e03faf15 	stw	zero,-324(fp)
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
 2006fd4:	e03fc715 	stw	zero,-228(fp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
 2006fd8:	e03fb715 	stw	zero,-292(fp)
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 2006fdc:	e03fb815 	stw	zero,-288(fp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
 2006fe0:	e0bfe617 	ldw	r2,-104(fp)
 2006fe4:	e0bfbd15 	stw	r2,-268(fp)
 2006fe8:	e0bfbd17 	ldw	r2,-268(fp)
 2006fec:	10000526 	beq	r2,zero,2007004 <___vfprintf_internal_r+0x98>
 2006ff0:	e0bfbd17 	ldw	r2,-268(fp)
 2006ff4:	10800e17 	ldw	r2,56(r2)
 2006ff8:	1000021e 	bne	r2,zero,2007004 <___vfprintf_internal_r+0x98>
 2006ffc:	e13fbd17 	ldw	r4,-268(fp)
 2007000:	200bbd80 	call	200bbd8 <__sinit>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
 2007004:	e0bfe717 	ldw	r2,-100(fp)
 2007008:	1080030b 	ldhu	r2,12(r2)
 200700c:	10bfffcc 	andi	r2,r2,65535
 2007010:	1088000c 	andi	r2,r2,8192
 2007014:	10000c1e 	bne	r2,zero,2007048 <___vfprintf_internal_r+0xdc>
 2007018:	e0bfe717 	ldw	r2,-100(fp)
 200701c:	1080030b 	ldhu	r2,12(r2)
 2007020:	10880014 	ori	r2,r2,8192
 2007024:	1007883a 	mov	r3,r2
 2007028:	e0bfe717 	ldw	r2,-100(fp)
 200702c:	10c0030d 	sth	r3,12(r2)
 2007030:	e0bfe717 	ldw	r2,-100(fp)
 2007034:	10c01917 	ldw	r3,100(r2)
 2007038:	00b7ffc4 	movi	r2,-8193
 200703c:	1886703a 	and	r3,r3,r2
 2007040:	e0bfe717 	ldw	r2,-100(fp)
 2007044:	10c01915 	stw	r3,100(r2)

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
 2007048:	e0bfe717 	ldw	r2,-100(fp)
 200704c:	1080030b 	ldhu	r2,12(r2)
 2007050:	10bfffcc 	andi	r2,r2,65535
 2007054:	1080020c 	andi	r2,r2,8
 2007058:	10000326 	beq	r2,zero,2007068 <___vfprintf_internal_r+0xfc>
 200705c:	e0bfe717 	ldw	r2,-100(fp)
 2007060:	10800417 	ldw	r2,16(r2)
 2007064:	1000061e 	bne	r2,zero,2007080 <___vfprintf_internal_r+0x114>
 2007068:	e17fe717 	ldw	r5,-100(fp)
 200706c:	e13fe617 	ldw	r4,-104(fp)
 2007070:	20093880 	call	2009388 <__swsetup_r>
 2007074:	10000226 	beq	r2,zero,2007080 <___vfprintf_internal_r+0x114>
		_newlib_flockfile_exit (fp);
		return (EOF);
 2007078:	00bfffc4 	movi	r2,-1
 200707c:	0007e206 	br	2009008 <___vfprintf_internal_r+0x209c>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 2007080:	e0bfe717 	ldw	r2,-100(fp)
 2007084:	1080030b 	ldhu	r2,12(r2)
 2007088:	10bfffcc 	andi	r2,r2,65535
 200708c:	1080068c 	andi	r2,r2,26
 2007090:	10800298 	cmpnei	r2,r2,10
 2007094:	10000c1e 	bne	r2,zero,20070c8 <___vfprintf_internal_r+0x15c>
	    fp->_file >= 0) {
 2007098:	e0bfe717 	ldw	r2,-100(fp)
 200709c:	1080038b 	ldhu	r2,14(r2)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 20070a0:	10bfffcc 	andi	r2,r2,65535
 20070a4:	10a0001c 	xori	r2,r2,32768
 20070a8:	10a00004 	addi	r2,r2,-32768
 20070ac:	10000616 	blt	r2,zero,20070c8 <___vfprintf_internal_r+0x15c>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
 20070b0:	e1ffe917 	ldw	r7,-92(fp)
 20070b4:	e1bfe817 	ldw	r6,-96(fp)
 20070b8:	e17fe717 	ldw	r5,-100(fp)
 20070bc:	e13fe617 	ldw	r4,-104(fp)
 20070c0:	2006e2c0 	call	2006e2c <__sbprintf>
 20070c4:	0007d006 	br	2009008 <___vfprintf_internal_r+0x209c>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
 20070c8:	e57fe817 	ldw	r21,-96(fp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
 20070cc:	e47fcb04 	addi	r17,fp,-212
 20070d0:	e47fc815 	stw	r17,-224(fp)
	uio.uio_resid = 0;
 20070d4:	e03fca15 	stw	zero,-216(fp)
	uio.uio_iovcnt = 0;
 20070d8:	e03fc915 	stw	zero,-220(fp)
#endif
	ret = 0;
 20070dc:	e03fac15 	stw	zero,-336(fp)

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
 20070e0:	a825883a 	mov	r18,r21
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 20070e4:	00000106 	br	20070ec <___vfprintf_internal_r+0x180>
                    fmt += 1;
 20070e8:	ad400044 	addi	r21,r21,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 20070ec:	a8800003 	ldbu	r2,0(r21)
 20070f0:	10803fcc 	andi	r2,r2,255
 20070f4:	1080201c 	xori	r2,r2,128
 20070f8:	10bfe004 	addi	r2,r2,-128
 20070fc:	10000626 	beq	r2,zero,2007118 <___vfprintf_internal_r+0x1ac>
 2007100:	a8800003 	ldbu	r2,0(r21)
 2007104:	10803fcc 	andi	r2,r2,255
 2007108:	1080201c 	xori	r2,r2,128
 200710c:	10bfe004 	addi	r2,r2,-128
 2007110:	10800958 	cmpnei	r2,r2,37
 2007114:	103ff41e 	bne	r2,zero,20070e8 <___vfprintf_internal_r+0x17c>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
 2007118:	a807883a 	mov	r3,r21
 200711c:	9005883a 	mov	r2,r18
 2007120:	18a1c83a 	sub	r16,r3,r2
 2007124:	80001826 	beq	r16,zero,2007188 <___vfprintf_internal_r+0x21c>
			PRINT (cp, m);
 2007128:	8c800015 	stw	r18,0(r17)
 200712c:	8005883a 	mov	r2,r16
 2007130:	88800115 	stw	r2,4(r17)
 2007134:	e0bfca17 	ldw	r2,-216(fp)
 2007138:	8007883a 	mov	r3,r16
 200713c:	10c5883a 	add	r2,r2,r3
 2007140:	e0bfca15 	stw	r2,-216(fp)
 2007144:	8c400204 	addi	r17,r17,8
 2007148:	e0bfc917 	ldw	r2,-220(fp)
 200714c:	10800044 	addi	r2,r2,1
 2007150:	e0bfc915 	stw	r2,-220(fp)
 2007154:	e0bfc917 	ldw	r2,-220(fp)
 2007158:	10800210 	cmplti	r2,r2,8
 200715c:	1000071e 	bne	r2,zero,200717c <___vfprintf_internal_r+0x210>
 2007160:	e0bfc804 	addi	r2,fp,-224
 2007164:	100d883a 	mov	r6,r2
 2007168:	e17fe717 	ldw	r5,-100(fp)
 200716c:	e13fe617 	ldw	r4,-104(fp)
 2007170:	2010df40 	call	2010df4 <__sprint_r>
 2007174:	10074d1e 	bne	r2,zero,2008eac <___vfprintf_internal_r+0x1f40>
 2007178:	e47fcb04 	addi	r17,fp,-212
			ret += m;
 200717c:	e0bfac17 	ldw	r2,-336(fp)
 2007180:	1405883a 	add	r2,r2,r16
 2007184:	e0bfac15 	stw	r2,-336(fp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
 2007188:	a8800003 	ldbu	r2,0(r21)
 200718c:	10803fcc 	andi	r2,r2,255
 2007190:	1080201c 	xori	r2,r2,128
 2007194:	10bfe004 	addi	r2,r2,-128
 2007198:	10073626 	beq	r2,zero,2008e74 <___vfprintf_internal_r+0x1f08>
                    goto done;
#endif
		fmt_anchor = fmt;
 200719c:	e57fbe15 	stw	r21,-264(fp)
		fmt++;		/* skip over '%' */
 20071a0:	ad400044 	addi	r21,r21,1

		flags = 0;
 20071a4:	0027883a 	mov	r19,zero
		dprec = 0;
 20071a8:	e03fb415 	stw	zero,-304(fp)
		width = 0;
 20071ac:	e03fad15 	stw	zero,-332(fp)
		prec = -1;
 20071b0:	00bfffc4 	movi	r2,-1
 20071b4:	e0bfae15 	stw	r2,-328(fp)
		sign = '\0';
 20071b8:	e03fc105 	stb	zero,-252(fp)
#ifdef FLOATING_POINT
		lead = 0;
 20071bc:	e03fb015 	stw	zero,-320(fp)
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
 20071c0:	a805883a 	mov	r2,r21
 20071c4:	15400044 	addi	r21,r2,1
 20071c8:	10800003 	ldbu	r2,0(r2)
 20071cc:	15003fcc 	andi	r20,r2,255
 20071d0:	a500201c 	xori	r20,r20,128
 20071d4:	a53fe004 	addi	r20,r20,-128
reswitch:	switch (ch) {
 20071d8:	a0bff804 	addi	r2,r20,-32
 20071dc:	10c01668 	cmpgeui	r3,r2,89
 20071e0:	1803491e 	bne	r3,zero,2007f08 <___vfprintf_internal_r+0xf9c>
 20071e4:	100690ba 	slli	r3,r2,2
 20071e8:	00808034 	movhi	r2,512
 20071ec:	109c7f04 	addi	r2,r2,29180
 20071f0:	1885883a 	add	r2,r3,r2
 20071f4:	10800017 	ldw	r2,0(r2)
 20071f8:	1000683a 	jmp	r2
 20071fc:	02007360 	cmpeqi	r8,zero,461
 2007200:	02007f08 	cmpgei	r8,zero,508
 2007204:	02007f08 	cmpgei	r8,zero,508
 2007208:	02007380 	call	200738 <__alt_mem_mem_Nios_PI+0x738>
 200720c:	02007f08 	cmpgei	r8,zero,508
 2007210:	02007f08 	cmpgei	r8,zero,508
 2007214:	02007f08 	cmpgei	r8,zero,508
 2007218:	02007f08 	cmpgei	r8,zero,508
 200721c:	02007f08 	cmpgei	r8,zero,508
 2007220:	02007f08 	cmpgei	r8,zero,508
 2007224:	02007388 	cmpgei	r8,zero,462
 2007228:	020073bc 	xorhi	r8,zero,462
 200722c:	02007f08 	cmpgei	r8,zero,508
 2007230:	020073b4 	movhi	r8,462
 2007234:	020073c8 	cmpgei	r8,zero,463
 2007238:	02007f08 	cmpgei	r8,zero,508
 200723c:	0200745c 	xori	r8,zero,465
 2007240:	02007464 	muli	r8,zero,465
 2007244:	02007464 	muli	r8,zero,465
 2007248:	02007464 	muli	r8,zero,465
 200724c:	02007464 	muli	r8,zero,465
 2007250:	02007464 	muli	r8,zero,465
 2007254:	02007464 	muli	r8,zero,465
 2007258:	02007464 	muli	r8,zero,465
 200725c:	02007464 	muli	r8,zero,465
 2007260:	02007464 	muli	r8,zero,465
 2007264:	02007f08 	cmpgei	r8,zero,508
 2007268:	02007f08 	cmpgei	r8,zero,508
 200726c:	02007f08 	cmpgei	r8,zero,508
 2007270:	02007f08 	cmpgei	r8,zero,508
 2007274:	02007f08 	cmpgei	r8,zero,508
 2007278:	02007f08 	cmpgei	r8,zero,508
 200727c:	02007f08 	cmpgei	r8,zero,508
 2007280:	02007f08 	cmpgei	r8,zero,508
 2007284:	02007f08 	cmpgei	r8,zero,508
 2007288:	02007f08 	cmpgei	r8,zero,508
 200728c:	0200750c 	andi	r8,zero,468
 2007290:	0200760c 	andi	r8,zero,472
 2007294:	02007f08 	cmpgei	r8,zero,508
 2007298:	0200760c 	andi	r8,zero,472
 200729c:	02007f08 	cmpgei	r8,zero,508
 20072a0:	02007f08 	cmpgei	r8,zero,508
 20072a4:	02007f08 	cmpgei	r8,zero,508
 20072a8:	02007f08 	cmpgei	r8,zero,508
 20072ac:	020074a0 	cmpeqi	r8,zero,466
 20072b0:	02007f08 	cmpgei	r8,zero,508
 20072b4:	02007f08 	cmpgei	r8,zero,508
 20072b8:	020079a8 	cmpgeui	r8,zero,486
 20072bc:	02007f08 	cmpgei	r8,zero,508
 20072c0:	02007f08 	cmpgei	r8,zero,508
 20072c4:	02007f08 	cmpgei	r8,zero,508
 20072c8:	02007f08 	cmpgei	r8,zero,508
 20072cc:	02007f08 	cmpgei	r8,zero,508
 20072d0:	02007b24 	muli	r8,zero,492
 20072d4:	02007f08 	cmpgei	r8,zero,508
 20072d8:	02007f08 	cmpgei	r8,zero,508
 20072dc:	02007be4 	muli	r8,zero,495
 20072e0:	02007f08 	cmpgei	r8,zero,508
 20072e4:	02007f08 	cmpgei	r8,zero,508
 20072e8:	02007f08 	cmpgei	r8,zero,508
 20072ec:	02007f08 	cmpgei	r8,zero,508
 20072f0:	02007f08 	cmpgei	r8,zero,508
 20072f4:	02007f08 	cmpgei	r8,zero,508
 20072f8:	02007f08 	cmpgei	r8,zero,508
 20072fc:	02007f08 	cmpgei	r8,zero,508
 2007300:	02007f08 	cmpgei	r8,zero,508
 2007304:	02007f08 	cmpgei	r8,zero,508
 2007308:	020074e4 	muli	r8,zero,467
 200730c:	02007510 	cmplti	r8,zero,468
 2007310:	0200760c 	andi	r8,zero,472
 2007314:	0200760c 	andi	r8,zero,472
 2007318:	0200760c 	andi	r8,zero,472
 200731c:	020074a8 	cmpgeui	r8,zero,466
 2007320:	02007510 	cmplti	r8,zero,468
 2007324:	02007f08 	cmpgei	r8,zero,508
 2007328:	02007f08 	cmpgei	r8,zero,508
 200732c:	020074b0 	cmpltui	r8,zero,466
 2007330:	02007f08 	cmpgei	r8,zero,508
 2007334:	02007908 	cmpgei	r8,zero,484
 2007338:	020079ac 	andhi	r8,zero,486
 200733c:	02007a4c 	andi	r8,zero,489
 2007340:	020074dc 	xori	r8,zero,467
 2007344:	02007f08 	cmpgei	r8,zero,508
 2007348:	02007a94 	movui	r8,490
 200734c:	02007f08 	cmpgei	r8,zero,508
 2007350:	02007b28 	cmpgeui	r8,zero,492
 2007354:	02007f08 	cmpgei	r8,zero,508
 2007358:	02007f08 	cmpgei	r8,zero,508
 200735c:	02007bf4 	movhi	r8,495
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
 2007360:	e0bfc103 	ldbu	r2,-252(fp)
 2007364:	10803fcc 	andi	r2,r2,255
 2007368:	1080201c 	xori	r2,r2,128
 200736c:	10bfe004 	addi	r2,r2,-128
 2007370:	103f931e 	bne	r2,zero,20071c0 <___vfprintf_internal_r+0x254>
				sign = ' ';
 2007374:	00800804 	movi	r2,32
 2007378:	e0bfc105 	stb	r2,-252(fp)
			goto rflag;
 200737c:	003f9006 	br	20071c0 <___vfprintf_internal_r+0x254>
		case '#':
			flags |= ALT;
 2007380:	9cc00054 	ori	r19,r19,1
			goto rflag;
 2007384:	003f8e06 	br	20071c0 <___vfprintf_internal_r+0x254>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
 2007388:	e0bfe917 	ldw	r2,-92(fp)
 200738c:	10c00104 	addi	r3,r2,4
 2007390:	e0ffe915 	stw	r3,-92(fp)
 2007394:	10800017 	ldw	r2,0(r2)
 2007398:	e0bfad15 	stw	r2,-332(fp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
 200739c:	e0bfad17 	ldw	r2,-332(fp)
 20073a0:	10000116 	blt	r2,zero,20073a8 <___vfprintf_internal_r+0x43c>
				goto rflag;
 20073a4:	003f8606 	br	20071c0 <___vfprintf_internal_r+0x254>
			width = -width;
 20073a8:	e0bfad17 	ldw	r2,-332(fp)
 20073ac:	0085c83a 	sub	r2,zero,r2
 20073b0:	e0bfad15 	stw	r2,-332(fp)
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
 20073b4:	9cc00114 	ori	r19,r19,4
			goto rflag;
 20073b8:	003f8106 	br	20071c0 <___vfprintf_internal_r+0x254>
		case '+':
			sign = '+';
 20073bc:	00800ac4 	movi	r2,43
 20073c0:	e0bfc105 	stb	r2,-252(fp)
			goto rflag;
 20073c4:	003f7e06 	br	20071c0 <___vfprintf_internal_r+0x254>
		case '.':
			if ((ch = *fmt++) == '*') {
 20073c8:	a805883a 	mov	r2,r21
 20073cc:	15400044 	addi	r21,r2,1
 20073d0:	10800003 	ldbu	r2,0(r2)
 20073d4:	15003fcc 	andi	r20,r2,255
 20073d8:	a500201c 	xori	r20,r20,128
 20073dc:	a53fe004 	addi	r20,r20,-128
 20073e0:	a0800a98 	cmpnei	r2,r20,42
 20073e4:	10000a1e 	bne	r2,zero,2007410 <___vfprintf_internal_r+0x4a4>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
 20073e8:	e0bfe917 	ldw	r2,-92(fp)
 20073ec:	10c00104 	addi	r3,r2,4
 20073f0:	e0ffe915 	stw	r3,-92(fp)
 20073f4:	10800017 	ldw	r2,0(r2)
 20073f8:	e0bfae15 	stw	r2,-328(fp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
 20073fc:	e0bfae17 	ldw	r2,-328(fp)
 2007400:	103f6f0e 	bge	r2,zero,20071c0 <___vfprintf_internal_r+0x254>
					prec = -1;
 2007404:	00bfffc4 	movi	r2,-1
 2007408:	e0bfae15 	stw	r2,-328(fp)
				goto rflag;
 200740c:	003f6c06 	br	20071c0 <___vfprintf_internal_r+0x254>
			}
			n = 0;
 2007410:	0021883a 	mov	r16,zero
			while (is_digit (ch)) {
 2007414:	00000906 	br	200743c <___vfprintf_internal_r+0x4d0>
				n = 10 * n + to_digit (ch);
 2007418:	80c002a4 	muli	r3,r16,10
 200741c:	a0bff404 	addi	r2,r20,-48
 2007420:	18a1883a 	add	r16,r3,r2
				ch = *fmt++;
 2007424:	a805883a 	mov	r2,r21
 2007428:	15400044 	addi	r21,r2,1
 200742c:	10800003 	ldbu	r2,0(r2)
 2007430:	15003fcc 	andi	r20,r2,255
 2007434:	a500201c 	xori	r20,r20,128
 2007438:	a53fe004 	addi	r20,r20,-128
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
 200743c:	a0bff404 	addi	r2,r20,-48
 2007440:	108002b0 	cmpltui	r2,r2,10
 2007444:	103ff41e 	bne	r2,zero,2007418 <___vfprintf_internal_r+0x4ac>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
 2007448:	8005883a 	mov	r2,r16
 200744c:	1000010e 	bge	r2,zero,2007454 <___vfprintf_internal_r+0x4e8>
 2007450:	00bfffc4 	movi	r2,-1
 2007454:	e0bfae15 	stw	r2,-328(fp)
			goto reswitch;
 2007458:	003f5f06 	br	20071d8 <___vfprintf_internal_r+0x26c>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
 200745c:	9cc02014 	ori	r19,r19,128
			goto rflag;
 2007460:	003f5706 	br	20071c0 <___vfprintf_internal_r+0x254>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
 2007464:	0021883a 	mov	r16,zero
			do {
				n = 10 * n + to_digit (ch);
 2007468:	80c002a4 	muli	r3,r16,10
 200746c:	a0bff404 	addi	r2,r20,-48
 2007470:	18a1883a 	add	r16,r3,r2
				ch = *fmt++;
 2007474:	a805883a 	mov	r2,r21
 2007478:	15400044 	addi	r21,r2,1
 200747c:	10800003 	ldbu	r2,0(r2)
 2007480:	15003fcc 	andi	r20,r2,255
 2007484:	a500201c 	xori	r20,r20,128
 2007488:	a53fe004 	addi	r20,r20,-128
			} while (is_digit (ch));
 200748c:	a0bff404 	addi	r2,r20,-48
 2007490:	108002b0 	cmpltui	r2,r2,10
 2007494:	103ff41e 	bne	r2,zero,2007468 <___vfprintf_internal_r+0x4fc>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
 2007498:	e43fad15 	stw	r16,-332(fp)
			goto reswitch;
 200749c:	003f4e06 	br	20071d8 <___vfprintf_internal_r+0x26c>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
 20074a0:	9cc00214 	ori	r19,r19,8
			goto rflag;
 20074a4:	003f4606 	br	20071c0 <___vfprintf_internal_r+0x254>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
 20074a8:	9cc01014 	ori	r19,r19,64
			goto rflag;
 20074ac:	003f4406 	br	20071c0 <___vfprintf_internal_r+0x254>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
 20074b0:	a8800003 	ldbu	r2,0(r21)
 20074b4:	10803fcc 	andi	r2,r2,255
 20074b8:	1080201c 	xori	r2,r2,128
 20074bc:	10bfe004 	addi	r2,r2,-128
 20074c0:	10801b18 	cmpnei	r2,r2,108
 20074c4:	1000031e 	bne	r2,zero,20074d4 <___vfprintf_internal_r+0x568>
				fmt++;
 20074c8:	ad400044 	addi	r21,r21,1
				flags |= QUADINT;
 20074cc:	9cc00814 	ori	r19,r19,32
 20074d0:	003f3b06 	br	20071c0 <___vfprintf_internal_r+0x254>
			} else
#endif
				flags |= LONGINT;
 20074d4:	9cc00414 	ori	r19,r19,16
			goto rflag;
 20074d8:	003f3906 	br	20071c0 <___vfprintf_internal_r+0x254>
		case 'q': /* extension */
			flags |= QUADINT;
 20074dc:	9cc00814 	ori	r19,r19,32
			goto rflag;
 20074e0:	003f3706 	br	20071c0 <___vfprintf_internal_r+0x254>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
 20074e4:	e4bfdb04 	addi	r18,fp,-148
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
 20074e8:	e0bfe917 	ldw	r2,-92(fp)
 20074ec:	10c00104 	addi	r3,r2,4
 20074f0:	e0ffe915 	stw	r3,-92(fp)
 20074f4:	10800017 	ldw	r2,0(r2)
 20074f8:	90800005 	stb	r2,0(r18)
				size = 1;
 20074fc:	00800044 	movi	r2,1
 2007500:	e0bfb615 	stw	r2,-296(fp)
			}
			sign = '\0';
 2007504:	e03fc105 	stb	zero,-252(fp)
			break;
 2007508:	00028806 	br	2007f2c <___vfprintf_internal_r+0xfc0>
		case 'D':  /* extension */
			flags |= LONGINT;
 200750c:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
 2007510:	9880080c 	andi	r2,r19,32
 2007514:	10000826 	beq	r2,zero,2007538 <___vfprintf_internal_r+0x5cc>
 2007518:	e13fe917 	ldw	r4,-92(fp)
 200751c:	20800204 	addi	r2,r4,8
 2007520:	e0bfe915 	stw	r2,-92(fp)
 2007524:	20800017 	ldw	r2,0(r4)
 2007528:	20c00117 	ldw	r3,4(r4)
 200752c:	e0bfea15 	stw	r2,-88(fp)
 2007530:	e0ffeb15 	stw	r3,-84(fp)
 2007534:	00001e06 	br	20075b0 <___vfprintf_internal_r+0x644>
 2007538:	9880040c 	andi	r2,r19,16
 200753c:	10000826 	beq	r2,zero,2007560 <___vfprintf_internal_r+0x5f4>
 2007540:	e0bfe917 	ldw	r2,-92(fp)
 2007544:	10c00104 	addi	r3,r2,4
 2007548:	e0ffe915 	stw	r3,-92(fp)
 200754c:	10800017 	ldw	r2,0(r2)
 2007550:	e0bfea15 	stw	r2,-88(fp)
 2007554:	1005d7fa 	srai	r2,r2,31
 2007558:	e0bfeb15 	stw	r2,-84(fp)
 200755c:	00001406 	br	20075b0 <___vfprintf_internal_r+0x644>
 2007560:	9880100c 	andi	r2,r19,64
 2007564:	10000b26 	beq	r2,zero,2007594 <___vfprintf_internal_r+0x628>
 2007568:	e0bfe917 	ldw	r2,-92(fp)
 200756c:	10c00104 	addi	r3,r2,4
 2007570:	e0ffe915 	stw	r3,-92(fp)
 2007574:	10800017 	ldw	r2,0(r2)
 2007578:	10bfffcc 	andi	r2,r2,65535
 200757c:	10a0001c 	xori	r2,r2,32768
 2007580:	10a00004 	addi	r2,r2,-32768
 2007584:	e0bfea15 	stw	r2,-88(fp)
 2007588:	1005d7fa 	srai	r2,r2,31
 200758c:	e0bfeb15 	stw	r2,-84(fp)
 2007590:	00000706 	br	20075b0 <___vfprintf_internal_r+0x644>
 2007594:	e0bfe917 	ldw	r2,-92(fp)
 2007598:	10c00104 	addi	r3,r2,4
 200759c:	e0ffe915 	stw	r3,-92(fp)
 20075a0:	10800017 	ldw	r2,0(r2)
 20075a4:	e0bfea15 	stw	r2,-88(fp)
 20075a8:	1005d7fa 	srai	r2,r2,31
 20075ac:	e0bfeb15 	stw	r2,-84(fp)
 20075b0:	e0bfea17 	ldw	r2,-88(fp)
 20075b4:	e0bfb115 	stw	r2,-316(fp)
 20075b8:	e0ffeb17 	ldw	r3,-84(fp)
 20075bc:	e0ffb215 	stw	r3,-312(fp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
 20075c0:	e0bfb117 	ldw	r2,-316(fp)
 20075c4:	e0ffb217 	ldw	r3,-312(fp)
 20075c8:	18000d0e 	bge	r3,zero,2007600 <___vfprintf_internal_r+0x694>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
 20075cc:	000f883a 	mov	r7,zero
 20075d0:	0011883a 	mov	r8,zero
 20075d4:	e13fb117 	ldw	r4,-316(fp)
 20075d8:	e17fb217 	ldw	r5,-312(fp)
 20075dc:	3905c83a 	sub	r2,r7,r4
 20075e0:	388d803a 	cmpltu	r6,r7,r2
 20075e4:	4147c83a 	sub	r3,r8,r5
 20075e8:	1989c83a 	sub	r4,r3,r6
 20075ec:	2007883a 	mov	r3,r4
 20075f0:	e0bfb115 	stw	r2,-316(fp)
 20075f4:	e0ffb215 	stw	r3,-312(fp)
				sign = '-';
 20075f8:	00800b44 	movi	r2,45
 20075fc:	e0bfc105 	stb	r2,-252(fp)
			}
			base = DEC;
 2007600:	00800044 	movi	r2,1
 2007604:	e0bfb305 	stb	r2,-308(fp)
			goto number;
 2007608:	0001b706 	br	2007ce8 <___vfprintf_internal_r+0xd7c>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
 200760c:	9880020c 	andi	r2,r19,8
 2007610:	10000826 	beq	r2,zero,2007634 <___vfprintf_internal_r+0x6c8>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
 2007614:	e13fe917 	ldw	r4,-92(fp)
 2007618:	20800204 	addi	r2,r4,8
 200761c:	e0bfe915 	stw	r2,-92(fp)
 2007620:	20800017 	ldw	r2,0(r4)
 2007624:	20c00117 	ldw	r3,4(r4)
 2007628:	e0bfc215 	stw	r2,-248(fp)
 200762c:	e0ffc315 	stw	r3,-244(fp)
 2007630:	00000706 	br	2007650 <___vfprintf_internal_r+0x6e4>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
 2007634:	e13fe917 	ldw	r4,-92(fp)
 2007638:	20800204 	addi	r2,r4,8
 200763c:	e0bfe915 	stw	r2,-92(fp)
 2007640:	20800017 	ldw	r2,0(r4)
 2007644:	20c00117 	ldw	r3,4(r4)
 2007648:	e0bfc215 	stw	r2,-248(fp)
 200764c:	e0ffc315 	stw	r3,-244(fp)

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
 2007650:	e0bfc217 	ldw	r2,-248(fp)
 2007654:	e0ffc317 	ldw	r3,-244(fp)
 2007658:	1009883a 	mov	r4,r2
 200765c:	180b883a 	mov	r5,r3
 2007660:	20035b80 	call	20035b8 <__fpclassifyd>
 2007664:	10800058 	cmpnei	r2,r2,1
 2007668:	1000161e 	bne	r2,zero,20076c4 <___vfprintf_internal_r+0x758>
				if (_fpvalue < 0)
 200766c:	e0bfc217 	ldw	r2,-248(fp)
 2007670:	e0ffc317 	ldw	r3,-244(fp)
 2007674:	000d883a 	mov	r6,zero
 2007678:	000f883a 	mov	r7,zero
 200767c:	1009883a 	mov	r4,r2
 2007680:	180b883a 	mov	r5,r3
 2007684:	200538c0 	call	200538c <__ledf2>
 2007688:	1000020e 	bge	r2,zero,2007694 <___vfprintf_internal_r+0x728>
					sign = '-';
 200768c:	00800b44 	movi	r2,45
 2007690:	e0bfc105 	stb	r2,-252(fp)
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 2007694:	a0801208 	cmpgei	r2,r20,72
 2007698:	1000031e 	bne	r2,zero,20076a8 <___vfprintf_internal_r+0x73c>
					cp = "INF";
 200769c:	048080b4 	movhi	r18,514
 20076a0:	94bde904 	addi	r18,r18,-2140
 20076a4:	00000206 	br	20076b0 <___vfprintf_internal_r+0x744>
				else
					cp = "inf";
 20076a8:	048080b4 	movhi	r18,514
 20076ac:	94bdea04 	addi	r18,r18,-2136
				size = 3;
 20076b0:	008000c4 	movi	r2,3
 20076b4:	e0bfb615 	stw	r2,-296(fp)
				flags &= ~ZEROPAD;
 20076b8:	00bfdfc4 	movi	r2,-129
 20076bc:	98a6703a 	and	r19,r19,r2
				break;
 20076c0:	00021a06 	br	2007f2c <___vfprintf_internal_r+0xfc0>
			}
			if (isnan (_fpvalue)) {
 20076c4:	e0bfc217 	ldw	r2,-248(fp)
 20076c8:	e0ffc317 	ldw	r3,-244(fp)
 20076cc:	1009883a 	mov	r4,r2
 20076d0:	180b883a 	mov	r5,r3
 20076d4:	20035b80 	call	20035b8 <__fpclassifyd>
 20076d8:	10000c1e 	bne	r2,zero,200770c <___vfprintf_internal_r+0x7a0>
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
 20076dc:	a0801208 	cmpgei	r2,r20,72
 20076e0:	1000031e 	bne	r2,zero,20076f0 <___vfprintf_internal_r+0x784>
					cp = "NAN";
 20076e4:	048080b4 	movhi	r18,514
 20076e8:	94bdeb04 	addi	r18,r18,-2132
 20076ec:	00000206 	br	20076f8 <___vfprintf_internal_r+0x78c>
				else
					cp = "nan";
 20076f0:	048080b4 	movhi	r18,514
 20076f4:	94bdec04 	addi	r18,r18,-2128
				size = 3;
 20076f8:	008000c4 	movi	r2,3
 20076fc:	e0bfb615 	stw	r2,-296(fp)
				flags &= ~ZEROPAD;
 2007700:	00bfdfc4 	movi	r2,-129
 2007704:	98a6703a 	and	r19,r19,r2
				break;
 2007708:	00020806 	br	2007f2c <___vfprintf_internal_r+0xfc0>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
 200770c:	e0bfae17 	ldw	r2,-328(fp)
 2007710:	10bfffd8 	cmpnei	r2,r2,-1
 2007714:	1000031e 	bne	r2,zero,2007724 <___vfprintf_internal_r+0x7b8>
				prec = DEFPREC;
 2007718:	00800184 	movi	r2,6
 200771c:	e0bfae15 	stw	r2,-328(fp)
 2007720:	00000806 	br	2007744 <___vfprintf_internal_r+0x7d8>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
 2007724:	a08019e0 	cmpeqi	r2,r20,103
 2007728:	1000021e 	bne	r2,zero,2007734 <___vfprintf_internal_r+0x7c8>
 200772c:	a08011d8 	cmpnei	r2,r20,71
 2007730:	1000041e 	bne	r2,zero,2007744 <___vfprintf_internal_r+0x7d8>
 2007734:	e0bfae17 	ldw	r2,-328(fp)
 2007738:	1000021e 	bne	r2,zero,2007744 <___vfprintf_internal_r+0x7d8>
				prec = 1;
 200773c:	00800044 	movi	r2,1
 2007740:	e0bfae15 	stw	r2,-328(fp)
			}

			flags |= FPT;
 2007744:	9cc04014 	ori	r19,r19,256

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
 2007748:	e0bfc217 	ldw	r2,-248(fp)
 200774c:	e0ffc317 	ldw	r3,-244(fp)
 2007750:	dc800515 	stw	r18,20(sp)
 2007754:	e13fc704 	addi	r4,fp,-228
 2007758:	d9000415 	stw	r4,16(sp)
 200775c:	dd000315 	stw	r20,12(sp)
 2007760:	e13fc404 	addi	r4,fp,-240
 2007764:	d9000215 	stw	r4,8(sp)
 2007768:	e13fc144 	addi	r4,fp,-251
 200776c:	d9000115 	stw	r4,4(sp)
 2007770:	dcc00015 	stw	r19,0(sp)
 2007774:	e1ffae17 	ldw	r7,-328(fp)
 2007778:	100b883a 	mov	r5,r2
 200777c:	180d883a 	mov	r6,r3
 2007780:	e13fe617 	ldw	r4,-104(fp)
 2007784:	200903c0 	call	200903c <cvt>
 2007788:	1025883a 	mov	r18,r2
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
 200778c:	a08019e0 	cmpeqi	r2,r20,103
 2007790:	1000021e 	bne	r2,zero,200779c <___vfprintf_internal_r+0x830>
 2007794:	a08011d8 	cmpnei	r2,r20,71
 2007798:	1000091e 	bne	r2,zero,20077c0 <___vfprintf_internal_r+0x854>
				if (expt <= -4 || expt > prec)
 200779c:	e0bfc417 	ldw	r2,-240(fp)
 20077a0:	10bfff50 	cmplti	r2,r2,-3
 20077a4:	1000031e 	bne	r2,zero,20077b4 <___vfprintf_internal_r+0x848>
 20077a8:	e0bfc417 	ldw	r2,-240(fp)
 20077ac:	e0ffae17 	ldw	r3,-328(fp)
 20077b0:	1880020e 	bge	r3,r2,20077bc <___vfprintf_internal_r+0x850>
					ch -= 2; /* 'e' or 'E' */
 20077b4:	a53fff84 	addi	r20,r20,-2
 20077b8:	00000106 	br	20077c0 <___vfprintf_internal_r+0x854>
				else
					ch = 'g';
 20077bc:	050019c4 	movi	r20,103
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
				ch = 'f';
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
 20077c0:	a0801988 	cmpgei	r2,r20,102
 20077c4:	1000171e 	bne	r2,zero,2007824 <___vfprintf_internal_r+0x8b8>
				--expt;
 20077c8:	e0bfc417 	ldw	r2,-240(fp)
 20077cc:	10bfffc4 	addi	r2,r2,-1
 20077d0:	e0bfc415 	stw	r2,-240(fp)
				expsize = exponent (expstr, expt, ch);
 20077d4:	e0bfc417 	ldw	r2,-240(fp)
 20077d8:	e0ffc504 	addi	r3,fp,-236
 20077dc:	a00d883a 	mov	r6,r20
 20077e0:	100b883a 	mov	r5,r2
 20077e4:	1809883a 	mov	r4,r3
 20077e8:	20092480 	call	2009248 <exponent>
 20077ec:	e0bfaf15 	stw	r2,-324(fp)
				size = expsize + ndig;
 20077f0:	e0bfc717 	ldw	r2,-228(fp)
 20077f4:	e0ffaf17 	ldw	r3,-324(fp)
 20077f8:	1885883a 	add	r2,r3,r2
 20077fc:	e0bfb615 	stw	r2,-296(fp)
				if (ndig > 1 || flags & ALT)
 2007800:	e0bfc717 	ldw	r2,-228(fp)
 2007804:	10800088 	cmpgei	r2,r2,2
 2007808:	1000021e 	bne	r2,zero,2007814 <___vfprintf_internal_r+0x8a8>
 200780c:	9880004c 	andi	r2,r19,1
 2007810:	10003526 	beq	r2,zero,20078e8 <___vfprintf_internal_r+0x97c>
					++size;
 2007814:	e0bfb617 	ldw	r2,-296(fp)
 2007818:	10800044 	addi	r2,r2,1
 200781c:	e0bfb615 	stw	r2,-296(fp)
 2007820:	00003106 	br	20078e8 <___vfprintf_internal_r+0x97c>
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
 2007824:	a0801998 	cmpnei	r2,r20,102
 2007828:	1000181e 	bne	r2,zero,200788c <___vfprintf_internal_r+0x920>
					if (expt > 0) {
 200782c:	e0bfc417 	ldw	r2,-240(fp)
 2007830:	00800c0e 	bge	zero,r2,2007864 <___vfprintf_internal_r+0x8f8>
						size = expt;
 2007834:	e0bfc417 	ldw	r2,-240(fp)
 2007838:	e0bfb615 	stw	r2,-296(fp)
						if (prec || flags & ALT)
 200783c:	e0bfae17 	ldw	r2,-328(fp)
 2007840:	1000021e 	bne	r2,zero,200784c <___vfprintf_internal_r+0x8e0>
 2007844:	9880004c 	andi	r2,r19,1
 2007848:	10002526 	beq	r2,zero,20078e0 <___vfprintf_internal_r+0x974>
							size += prec + 1;
 200784c:	e0bfae17 	ldw	r2,-328(fp)
 2007850:	10800044 	addi	r2,r2,1
 2007854:	e0ffb617 	ldw	r3,-296(fp)
 2007858:	1885883a 	add	r2,r3,r2
 200785c:	e0bfb615 	stw	r2,-296(fp)
 2007860:	00001f06 	br	20078e0 <___vfprintf_internal_r+0x974>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
 2007864:	e0bfae17 	ldw	r2,-328(fp)
 2007868:	1000021e 	bne	r2,zero,2007874 <___vfprintf_internal_r+0x908>
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
 200786c:	9880004c 	andi	r2,r19,1
 2007870:	10000326 	beq	r2,zero,2007880 <___vfprintf_internal_r+0x914>
							  ? prec + 2
							  : 1;
 2007874:	e0bfae17 	ldw	r2,-328(fp)
 2007878:	10800084 	addi	r2,r2,2
 200787c:	00000106 	br	2007884 <___vfprintf_internal_r+0x918>
 2007880:	00800044 	movi	r2,1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
 2007884:	e0bfb615 	stw	r2,-296(fp)
 2007888:	00001506 	br	20078e0 <___vfprintf_internal_r+0x974>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
 200788c:	e0ffc417 	ldw	r3,-240(fp)
 2007890:	e0bfc717 	ldw	r2,-228(fp)
 2007894:	18800816 	blt	r3,r2,20078b8 <___vfprintf_internal_r+0x94c>
					size = expt;
 2007898:	e0bfc417 	ldw	r2,-240(fp)
 200789c:	e0bfb615 	stw	r2,-296(fp)
					if (flags & ALT)
 20078a0:	9880004c 	andi	r2,r19,1
 20078a4:	10000e26 	beq	r2,zero,20078e0 <___vfprintf_internal_r+0x974>
						++size;
 20078a8:	e0bfb617 	ldw	r2,-296(fp)
 20078ac:	10800044 	addi	r2,r2,1
 20078b0:	e0bfb615 	stw	r2,-296(fp)
 20078b4:	00000a06 	br	20078e0 <___vfprintf_internal_r+0x974>
				} else
					size = ndig + (expt > 0 ?
 20078b8:	e0bfc417 	ldw	r2,-240(fp)
						1 : 2 - expt);
 20078bc:	00800416 	blt	zero,r2,20078d0 <___vfprintf_internal_r+0x964>
 20078c0:	e0bfc417 	ldw	r2,-240(fp)
 20078c4:	00c00084 	movi	r3,2
 20078c8:	1885c83a 	sub	r2,r3,r2
 20078cc:	00000106 	br	20078d4 <___vfprintf_internal_r+0x968>
 20078d0:	00800044 	movi	r2,1
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
 20078d4:	e0ffc717 	ldw	r3,-228(fp)
 20078d8:	10c5883a 	add	r2,r2,r3
 20078dc:	e0bfb615 	stw	r2,-296(fp)
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
				} else
# endif
					lead = expt;
 20078e0:	e0bfc417 	ldw	r2,-240(fp)
 20078e4:	e0bfb015 	stw	r2,-320(fp)
			}

			if (softsign)
 20078e8:	e0bfc143 	ldbu	r2,-251(fp)
 20078ec:	10803fcc 	andi	r2,r2,255
 20078f0:	1080201c 	xori	r2,r2,128
 20078f4:	10bfe004 	addi	r2,r2,-128
 20078f8:	10018b26 	beq	r2,zero,2007f28 <___vfprintf_internal_r+0xfbc>
				sign = '-';
 20078fc:	00800b44 	movi	r2,45
 2007900:	e0bfc105 	stb	r2,-252(fp)
			break;
 2007904:	00018806 	br	2007f28 <___vfprintf_internal_r+0xfbc>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
 2007908:	9880080c 	andi	r2,r19,32
 200790c:	10000d26 	beq	r2,zero,2007944 <___vfprintf_internal_r+0x9d8>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 2007910:	e0bfe917 	ldw	r2,-92(fp)
 2007914:	10c00104 	addi	r3,r2,4
 2007918:	e0ffe915 	stw	r3,-92(fp)
 200791c:	10800017 	ldw	r2,0(r2)
 2007920:	e0ffac17 	ldw	r3,-336(fp)
 2007924:	e0fff015 	stw	r3,-64(fp)
 2007928:	1807d7fa 	srai	r3,r3,31
 200792c:	e0fff115 	stw	r3,-60(fp)
 2007930:	e0fff017 	ldw	r3,-64(fp)
 2007934:	10c00015 	stw	r3,0(r2)
 2007938:	e0fff117 	ldw	r3,-60(fp)
 200793c:	10c00115 	stw	r3,4(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2007940:	00054b06 	br	2008e70 <___vfprintf_internal_r+0x1f04>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
 2007944:	9880040c 	andi	r2,r19,16
 2007948:	10000726 	beq	r2,zero,2007968 <___vfprintf_internal_r+0x9fc>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 200794c:	e0bfe917 	ldw	r2,-92(fp)
 2007950:	10c00104 	addi	r3,r2,4
 2007954:	e0ffe915 	stw	r3,-92(fp)
 2007958:	10800017 	ldw	r2,0(r2)
 200795c:	e0ffac17 	ldw	r3,-336(fp)
 2007960:	10c00015 	stw	r3,0(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2007964:	00054206 	br	2008e70 <___vfprintf_internal_r+0x1f04>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
 2007968:	9880100c 	andi	r2,r19,64
 200796c:	10000726 	beq	r2,zero,200798c <___vfprintf_internal_r+0xa20>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 2007970:	e0bfe917 	ldw	r2,-92(fp)
 2007974:	10c00104 	addi	r3,r2,4
 2007978:	e0ffe915 	stw	r3,-92(fp)
 200797c:	10800017 	ldw	r2,0(r2)
 2007980:	e0ffac17 	ldw	r3,-336(fp)
 2007984:	10c0000d 	sth	r3,0(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2007988:	00053906 	br	2008e70 <___vfprintf_internal_r+0x1f04>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
 200798c:	e0bfe917 	ldw	r2,-92(fp)
 2007990:	10c00104 	addi	r3,r2,4
 2007994:	e0ffe915 	stw	r3,-92(fp)
 2007998:	10800017 	ldw	r2,0(r2)
 200799c:	e0ffac17 	ldw	r3,-336(fp)
 20079a0:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 20079a4:	00053206 	br	2008e70 <___vfprintf_internal_r+0x1f04>
		case 'O': /* extension */
			flags |= LONGINT;
 20079a8:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
 20079ac:	9880080c 	andi	r2,r19,32
 20079b0:	10000626 	beq	r2,zero,20079cc <___vfprintf_internal_r+0xa60>
 20079b4:	e0bfe917 	ldw	r2,-92(fp)
 20079b8:	10c00204 	addi	r3,r2,8
 20079bc:	e0ffe915 	stw	r3,-92(fp)
 20079c0:	15800017 	ldw	r22,0(r2)
 20079c4:	15c00117 	ldw	r23,4(r2)
 20079c8:	00001c06 	br	2007a3c <___vfprintf_internal_r+0xad0>
 20079cc:	9880040c 	andi	r2,r19,16
 20079d0:	10000726 	beq	r2,zero,20079f0 <___vfprintf_internal_r+0xa84>
 20079d4:	e0bfe917 	ldw	r2,-92(fp)
 20079d8:	10c00104 	addi	r3,r2,4
 20079dc:	e0ffe915 	stw	r3,-92(fp)
 20079e0:	10800017 	ldw	r2,0(r2)
 20079e4:	102d883a 	mov	r22,r2
 20079e8:	002f883a 	mov	r23,zero
 20079ec:	00001306 	br	2007a3c <___vfprintf_internal_r+0xad0>
 20079f0:	9880100c 	andi	r2,r19,64
 20079f4:	10000b26 	beq	r2,zero,2007a24 <___vfprintf_internal_r+0xab8>
 20079f8:	e0bfe917 	ldw	r2,-92(fp)
 20079fc:	10c00104 	addi	r3,r2,4
 2007a00:	e0ffe915 	stw	r3,-92(fp)
 2007a04:	10800017 	ldw	r2,0(r2)
 2007a08:	e0bff215 	stw	r2,-56(fp)
 2007a0c:	e03ff315 	stw	zero,-52(fp)
 2007a10:	e0bff217 	ldw	r2,-56(fp)
 2007a14:	15bfffcc 	andi	r22,r2,65535
 2007a18:	e0fff317 	ldw	r3,-52(fp)
 2007a1c:	182e703a 	and	r23,r3,zero
 2007a20:	00000606 	br	2007a3c <___vfprintf_internal_r+0xad0>
 2007a24:	e0bfe917 	ldw	r2,-92(fp)
 2007a28:	10c00104 	addi	r3,r2,4
 2007a2c:	e0ffe915 	stw	r3,-92(fp)
 2007a30:	10800017 	ldw	r2,0(r2)
 2007a34:	102d883a 	mov	r22,r2
 2007a38:	002f883a 	mov	r23,zero
 2007a3c:	e5bfb115 	stw	r22,-316(fp)
 2007a40:	e5ffb215 	stw	r23,-312(fp)
			base = OCT;
 2007a44:	e03fb305 	stb	zero,-308(fp)
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			goto nosign;
 2007a48:	0000a606 	br	2007ce4 <___vfprintf_internal_r+0xd78>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 2007a4c:	e0bfe917 	ldw	r2,-92(fp)
 2007a50:	10c00104 	addi	r3,r2,4
 2007a54:	e0ffe915 	stw	r3,-92(fp)
 2007a58:	10800017 	ldw	r2,0(r2)
 2007a5c:	e0bfb115 	stw	r2,-316(fp)
 2007a60:	e03fb215 	stw	zero,-312(fp)
			base = HEX;
 2007a64:	00800084 	movi	r2,2
 2007a68:	e0bfb305 	stb	r2,-308(fp)
			xdigs = "0123456789abcdef";
 2007a6c:	008080b4 	movhi	r2,514
 2007a70:	10bded04 	addi	r2,r2,-2124
 2007a74:	e0bfb715 	stw	r2,-292(fp)
			flags |= HEXPREFIX;
 2007a78:	9cc00094 	ori	r19,r19,2
			ox[0] = '0';
 2007a7c:	00800c04 	movi	r2,48
 2007a80:	e0bfe505 	stb	r2,-108(fp)
			ox[1] = ch = 'x';
 2007a84:	05001e04 	movi	r20,120
 2007a88:	00801e04 	movi	r2,120
 2007a8c:	e0bfe545 	stb	r2,-107(fp)
			goto nosign;
 2007a90:	00009406 	br	2007ce4 <___vfprintf_internal_r+0xd78>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
 2007a94:	e0bfe917 	ldw	r2,-92(fp)
 2007a98:	10c00104 	addi	r3,r2,4
 2007a9c:	e0ffe915 	stw	r3,-92(fp)
 2007aa0:	14800017 	ldw	r18,0(r2)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
 2007aa4:	e03fc105 	stb	zero,-252(fp)
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
 2007aa8:	9000081e 	bne	r18,zero,2007acc <___vfprintf_internal_r+0xb60>
				cp = "(null)";
 2007aac:	048080b4 	movhi	r18,514
 2007ab0:	94bdf204 	addi	r18,r18,-2104
				size = ((unsigned) prec > 6U) ? 6 : prec;
 2007ab4:	e0bfae17 	ldw	r2,-328(fp)
 2007ab8:	10c001f0 	cmpltui	r3,r2,7
 2007abc:	1800011e 	bne	r3,zero,2007ac4 <___vfprintf_internal_r+0xb58>
 2007ac0:	00800184 	movi	r2,6
 2007ac4:	e0bfb615 	stw	r2,-296(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 2007ac8:	00011806 	br	2007f2c <___vfprintf_internal_r+0xfc0>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
 2007acc:	e0bfae17 	ldw	r2,-328(fp)
 2007ad0:	10001016 	blt	r2,zero,2007b14 <___vfprintf_internal_r+0xba8>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
 2007ad4:	e0bfae17 	ldw	r2,-328(fp)
 2007ad8:	100d883a 	mov	r6,r2
 2007adc:	000b883a 	mov	r5,zero
 2007ae0:	9009883a 	mov	r4,r18
 2007ae4:	200dfb40 	call	200dfb4 <memchr>
 2007ae8:	e0bfbf15 	stw	r2,-260(fp)

				if (p != NULL)
 2007aec:	e0bfbf17 	ldw	r2,-260(fp)
 2007af0:	10000526 	beq	r2,zero,2007b08 <___vfprintf_internal_r+0xb9c>
					size = p - cp;
 2007af4:	e0bfbf17 	ldw	r2,-260(fp)
 2007af8:	9007883a 	mov	r3,r18
 2007afc:	10c5c83a 	sub	r2,r2,r3
 2007b00:	e0bfb615 	stw	r2,-296(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 2007b04:	00010906 	br	2007f2c <___vfprintf_internal_r+0xfc0>
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
					size = p - cp;
				else
					size = prec;
 2007b08:	e0bfae17 	ldw	r2,-328(fp)
 2007b0c:	e0bfb615 	stw	r2,-296(fp)
			} else
				size = strlen (cp);

			break;
 2007b10:	00010606 	br	2007f2c <___vfprintf_internal_r+0xfc0>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
 2007b14:	9009883a 	mov	r4,r18
 2007b18:	2006d380 	call	2006d38 <strlen>
 2007b1c:	e0bfb615 	stw	r2,-296(fp)

			break;
 2007b20:	00010206 	br	2007f2c <___vfprintf_internal_r+0xfc0>
		case 'U': /* extension */
			flags |= LONGINT;
 2007b24:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
 2007b28:	9880080c 	andi	r2,r19,32
 2007b2c:	10000826 	beq	r2,zero,2007b50 <___vfprintf_internal_r+0xbe4>
 2007b30:	e0bfe917 	ldw	r2,-92(fp)
 2007b34:	10c00204 	addi	r3,r2,8
 2007b38:	e0ffe915 	stw	r3,-92(fp)
 2007b3c:	10c00017 	ldw	r3,0(r2)
 2007b40:	e0ffec15 	stw	r3,-80(fp)
 2007b44:	10c00117 	ldw	r3,4(r2)
 2007b48:	e0ffed15 	stw	r3,-76(fp)
 2007b4c:	00001e06 	br	2007bc8 <___vfprintf_internal_r+0xc5c>
 2007b50:	9880040c 	andi	r2,r19,16
 2007b54:	10000726 	beq	r2,zero,2007b74 <___vfprintf_internal_r+0xc08>
 2007b58:	e0bfe917 	ldw	r2,-92(fp)
 2007b5c:	10c00104 	addi	r3,r2,4
 2007b60:	e0ffe915 	stw	r3,-92(fp)
 2007b64:	10800017 	ldw	r2,0(r2)
 2007b68:	e0bfec15 	stw	r2,-80(fp)
 2007b6c:	e03fed15 	stw	zero,-76(fp)
 2007b70:	00001506 	br	2007bc8 <___vfprintf_internal_r+0xc5c>
 2007b74:	9880100c 	andi	r2,r19,64
 2007b78:	10000d26 	beq	r2,zero,2007bb0 <___vfprintf_internal_r+0xc44>
 2007b7c:	e0bfe917 	ldw	r2,-92(fp)
 2007b80:	10c00104 	addi	r3,r2,4
 2007b84:	e0ffe915 	stw	r3,-92(fp)
 2007b88:	10800017 	ldw	r2,0(r2)
 2007b8c:	e0bff415 	stw	r2,-48(fp)
 2007b90:	e03ff515 	stw	zero,-44(fp)
 2007b94:	e0bff417 	ldw	r2,-48(fp)
 2007b98:	10bfffcc 	andi	r2,r2,65535
 2007b9c:	e0bfec15 	stw	r2,-80(fp)
 2007ba0:	e0fff517 	ldw	r3,-44(fp)
 2007ba4:	1806703a 	and	r3,r3,zero
 2007ba8:	e0ffed15 	stw	r3,-76(fp)
 2007bac:	00000606 	br	2007bc8 <___vfprintf_internal_r+0xc5c>
 2007bb0:	e0bfe917 	ldw	r2,-92(fp)
 2007bb4:	10c00104 	addi	r3,r2,4
 2007bb8:	e0ffe915 	stw	r3,-92(fp)
 2007bbc:	10800017 	ldw	r2,0(r2)
 2007bc0:	e0bfec15 	stw	r2,-80(fp)
 2007bc4:	e03fed15 	stw	zero,-76(fp)
 2007bc8:	e0bfec17 	ldw	r2,-80(fp)
 2007bcc:	e0bfb115 	stw	r2,-316(fp)
 2007bd0:	e0ffed17 	ldw	r3,-76(fp)
 2007bd4:	e0ffb215 	stw	r3,-312(fp)
			base = DEC;
 2007bd8:	00800044 	movi	r2,1
 2007bdc:	e0bfb305 	stb	r2,-308(fp)
			goto nosign;
 2007be0:	00004006 	br	2007ce4 <___vfprintf_internal_r+0xd78>
		case 'X':
			xdigs = "0123456789ABCDEF";
 2007be4:	008080b4 	movhi	r2,514
 2007be8:	10bdf404 	addi	r2,r2,-2096
 2007bec:	e0bfb715 	stw	r2,-292(fp)
			goto hex;
 2007bf0:	00000306 	br	2007c00 <___vfprintf_internal_r+0xc94>
		case 'x':
			xdigs = "0123456789abcdef";
 2007bf4:	008080b4 	movhi	r2,514
 2007bf8:	10bded04 	addi	r2,r2,-2124
 2007bfc:	e0bfb715 	stw	r2,-292(fp)
hex:			_uquad = UARG ();
 2007c00:	9880080c 	andi	r2,r19,32
 2007c04:	10000826 	beq	r2,zero,2007c28 <___vfprintf_internal_r+0xcbc>
 2007c08:	e0bfe917 	ldw	r2,-92(fp)
 2007c0c:	10c00204 	addi	r3,r2,8
 2007c10:	e0ffe915 	stw	r3,-92(fp)
 2007c14:	10c00017 	ldw	r3,0(r2)
 2007c18:	e0ffee15 	stw	r3,-72(fp)
 2007c1c:	10c00117 	ldw	r3,4(r2)
 2007c20:	e0ffef15 	stw	r3,-68(fp)
 2007c24:	00001e06 	br	2007ca0 <___vfprintf_internal_r+0xd34>
 2007c28:	9880040c 	andi	r2,r19,16
 2007c2c:	10000726 	beq	r2,zero,2007c4c <___vfprintf_internal_r+0xce0>
 2007c30:	e0bfe917 	ldw	r2,-92(fp)
 2007c34:	10c00104 	addi	r3,r2,4
 2007c38:	e0ffe915 	stw	r3,-92(fp)
 2007c3c:	10800017 	ldw	r2,0(r2)
 2007c40:	e0bfee15 	stw	r2,-72(fp)
 2007c44:	e03fef15 	stw	zero,-68(fp)
 2007c48:	00001506 	br	2007ca0 <___vfprintf_internal_r+0xd34>
 2007c4c:	9880100c 	andi	r2,r19,64
 2007c50:	10000d26 	beq	r2,zero,2007c88 <___vfprintf_internal_r+0xd1c>
 2007c54:	e0bfe917 	ldw	r2,-92(fp)
 2007c58:	10c00104 	addi	r3,r2,4
 2007c5c:	e0ffe915 	stw	r3,-92(fp)
 2007c60:	10800017 	ldw	r2,0(r2)
 2007c64:	e0bff615 	stw	r2,-40(fp)
 2007c68:	e03ff715 	stw	zero,-36(fp)
 2007c6c:	e0bff617 	ldw	r2,-40(fp)
 2007c70:	10bfffcc 	andi	r2,r2,65535
 2007c74:	e0bfee15 	stw	r2,-72(fp)
 2007c78:	e0fff717 	ldw	r3,-36(fp)
 2007c7c:	1806703a 	and	r3,r3,zero
 2007c80:	e0ffef15 	stw	r3,-68(fp)
 2007c84:	00000606 	br	2007ca0 <___vfprintf_internal_r+0xd34>
 2007c88:	e0bfe917 	ldw	r2,-92(fp)
 2007c8c:	10c00104 	addi	r3,r2,4
 2007c90:	e0ffe915 	stw	r3,-92(fp)
 2007c94:	10800017 	ldw	r2,0(r2)
 2007c98:	e0bfee15 	stw	r2,-72(fp)
 2007c9c:	e03fef15 	stw	zero,-68(fp)
 2007ca0:	e0bfee17 	ldw	r2,-72(fp)
 2007ca4:	e0bfb115 	stw	r2,-316(fp)
 2007ca8:	e0ffef17 	ldw	r3,-68(fp)
 2007cac:	e0ffb215 	stw	r3,-312(fp)
			base = HEX;
 2007cb0:	00800084 	movi	r2,2
 2007cb4:	e0bfb305 	stb	r2,-308(fp)
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
 2007cb8:	9880004c 	andi	r2,r19,1
 2007cbc:	10000926 	beq	r2,zero,2007ce4 <___vfprintf_internal_r+0xd78>
 2007cc0:	e0bfb117 	ldw	r2,-316(fp)
 2007cc4:	e0ffb217 	ldw	r3,-312(fp)
 2007cc8:	10c4b03a 	or	r2,r2,r3
 2007ccc:	10000526 	beq	r2,zero,2007ce4 <___vfprintf_internal_r+0xd78>
				ox[0] = '0';
 2007cd0:	00800c04 	movi	r2,48
 2007cd4:	e0bfe505 	stb	r2,-108(fp)
				ox[1] = ch;
 2007cd8:	a005883a 	mov	r2,r20
 2007cdc:	e0bfe545 	stb	r2,-107(fp)
				flags |= HEXPREFIX;
 2007ce0:	9cc00094 	ori	r19,r19,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
 2007ce4:	e03fc105 	stb	zero,-252(fp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
 2007ce8:	e0bfae17 	ldw	r2,-328(fp)
 2007cec:	e0bfb415 	stw	r2,-304(fp)
 2007cf0:	e0bfb417 	ldw	r2,-304(fp)
 2007cf4:	10000216 	blt	r2,zero,2007d00 <___vfprintf_internal_r+0xd94>
				flags &= ~ZEROPAD;
 2007cf8:	00bfdfc4 	movi	r2,-129
 2007cfc:	98a6703a 	and	r19,r19,r2
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
 2007d00:	e4bfdb04 	addi	r18,fp,-148
 2007d04:	94800a04 	addi	r18,r18,40
			if (_uquad != 0 || prec != 0) {
 2007d08:	e0bfb117 	ldw	r2,-316(fp)
 2007d0c:	e0ffb217 	ldw	r3,-312(fp)
 2007d10:	10c4b03a 	or	r2,r2,r3
 2007d14:	1000021e 	bne	r2,zero,2007d20 <___vfprintf_internal_r+0xdb4>
 2007d18:	e0bfae17 	ldw	r2,-328(fp)
 2007d1c:	10006c26 	beq	r2,zero,2007ed0 <___vfprintf_internal_r+0xf64>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
 2007d20:	e0bfb303 	ldbu	r2,-308(fp)
 2007d24:	10c00060 	cmpeqi	r3,r2,1
 2007d28:	1800211e 	bne	r3,zero,2007db0 <___vfprintf_internal_r+0xe44>
 2007d2c:	10c000a0 	cmpeqi	r3,r2,2
 2007d30:	1800491e 	bne	r3,zero,2007e58 <___vfprintf_internal_r+0xeec>
 2007d34:	10005d1e 	bne	r2,zero,2007eac <___vfprintf_internal_r+0xf40>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
 2007d38:	94bfffc4 	addi	r18,r18,-1
 2007d3c:	e0bfb117 	ldw	r2,-316(fp)
 2007d40:	108001cc 	andi	r2,r2,7
 2007d44:	10800c04 	addi	r2,r2,48
 2007d48:	90800005 	stb	r2,0(r18)
						_uquad >>= 3;
 2007d4c:	e0bfb217 	ldw	r2,-312(fp)
 2007d50:	1004977a 	slli	r2,r2,29
 2007d54:	e0ffb117 	ldw	r3,-316(fp)
 2007d58:	1806d0fa 	srli	r3,r3,3
 2007d5c:	1884b03a 	or	r2,r3,r2
 2007d60:	e0bfb115 	stw	r2,-316(fp)
 2007d64:	e0bfb217 	ldw	r2,-312(fp)
 2007d68:	1004d0fa 	srli	r2,r2,3
 2007d6c:	e0bfb215 	stw	r2,-312(fp)
					} while (_uquad);
 2007d70:	e0bfb117 	ldw	r2,-316(fp)
 2007d74:	e0ffb217 	ldw	r3,-312(fp)
 2007d78:	10c4b03a 	or	r2,r2,r3
 2007d7c:	103fee1e 	bne	r2,zero,2007d38 <___vfprintf_internal_r+0xdcc>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
 2007d80:	9880004c 	andi	r2,r19,1
 2007d84:	10005026 	beq	r2,zero,2007ec8 <___vfprintf_internal_r+0xf5c>
 2007d88:	90800003 	ldbu	r2,0(r18)
 2007d8c:	10803fcc 	andi	r2,r2,255
 2007d90:	1080201c 	xori	r2,r2,128
 2007d94:	10bfe004 	addi	r2,r2,-128
 2007d98:	10800c20 	cmpeqi	r2,r2,48
 2007d9c:	10004a1e 	bne	r2,zero,2007ec8 <___vfprintf_internal_r+0xf5c>
						*--cp = '0';
 2007da0:	94bfffc4 	addi	r18,r18,-1
 2007da4:	00800c04 	movi	r2,48
 2007da8:	90800005 	stb	r2,0(r18)
					break;
 2007dac:	00004606 	br	2007ec8 <___vfprintf_internal_r+0xf5c>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
 2007db0:	e0bfb217 	ldw	r2,-312(fp)
 2007db4:	10000a1e 	bne	r2,zero,2007de0 <___vfprintf_internal_r+0xe74>
 2007db8:	e0bfb217 	ldw	r2,-312(fp)
 2007dbc:	1000031e 	bne	r2,zero,2007dcc <___vfprintf_internal_r+0xe60>
 2007dc0:	e0bfb117 	ldw	r2,-316(fp)
 2007dc4:	108002a8 	cmpgeui	r2,r2,10
 2007dc8:	1000051e 	bne	r2,zero,2007de0 <___vfprintf_internal_r+0xe74>
						*--cp = to_char(_uquad);
 2007dcc:	94bfffc4 	addi	r18,r18,-1
 2007dd0:	e0bfb117 	ldw	r2,-316(fp)
 2007dd4:	10800c04 	addi	r2,r2,48
 2007dd8:	90800005 	stb	r2,0(r18)
						break;
 2007ddc:	00003b06 	br	2007ecc <___vfprintf_internal_r+0xf60>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
 2007de0:	94bfffc4 	addi	r18,r18,-1
 2007de4:	e0bfb117 	ldw	r2,-316(fp)
 2007de8:	e0ffb217 	ldw	r3,-312(fp)
 2007dec:	01800284 	movi	r6,10
 2007df0:	000f883a 	mov	r7,zero
 2007df4:	1009883a 	mov	r4,r2
 2007df8:	180b883a 	mov	r5,r3
 2007dfc:	20135000 	call	2013500 <__umoddi3>
 2007e00:	1009883a 	mov	r4,r2
 2007e04:	180b883a 	mov	r5,r3
 2007e08:	2005883a 	mov	r2,r4
 2007e0c:	2807883a 	mov	r3,r5
 2007e10:	10800c04 	addi	r2,r2,48
 2007e14:	90800005 	stb	r2,0(r18)
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
 2007e18:	e0bfb117 	ldw	r2,-316(fp)
 2007e1c:	e0ffb217 	ldw	r3,-312(fp)
 2007e20:	01800284 	movi	r6,10
 2007e24:	000f883a 	mov	r7,zero
 2007e28:	1009883a 	mov	r4,r2
 2007e2c:	180b883a 	mov	r5,r3
 2007e30:	2012f880 	call	2012f88 <__udivdi3>
 2007e34:	1009883a 	mov	r4,r2
 2007e38:	180b883a 	mov	r5,r3
 2007e3c:	e13fb115 	stw	r4,-316(fp)
 2007e40:	e17fb215 	stw	r5,-312(fp)
					} while (_uquad != 0);
 2007e44:	e0bfb117 	ldw	r2,-316(fp)
 2007e48:	e0ffb217 	ldw	r3,-312(fp)
 2007e4c:	10c4b03a 	or	r2,r2,r3
 2007e50:	103fe31e 	bne	r2,zero,2007de0 <___vfprintf_internal_r+0xe74>
					break;
 2007e54:	00001d06 	br	2007ecc <___vfprintf_internal_r+0xf60>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
 2007e58:	94bfffc4 	addi	r18,r18,-1
 2007e5c:	e0bfb117 	ldw	r2,-316(fp)
 2007e60:	108003cc 	andi	r2,r2,15
 2007e64:	e0ffb717 	ldw	r3,-292(fp)
 2007e68:	1885883a 	add	r2,r3,r2
 2007e6c:	10800003 	ldbu	r2,0(r2)
 2007e70:	90800005 	stb	r2,0(r18)
						_uquad >>= 4;
 2007e74:	e0bfb217 	ldw	r2,-312(fp)
 2007e78:	1004973a 	slli	r2,r2,28
 2007e7c:	e0ffb117 	ldw	r3,-316(fp)
 2007e80:	1806d13a 	srli	r3,r3,4
 2007e84:	1884b03a 	or	r2,r3,r2
 2007e88:	e0bfb115 	stw	r2,-316(fp)
 2007e8c:	e0bfb217 	ldw	r2,-312(fp)
 2007e90:	1004d13a 	srli	r2,r2,4
 2007e94:	e0bfb215 	stw	r2,-312(fp)
					} while (_uquad);
 2007e98:	e0bfb117 	ldw	r2,-316(fp)
 2007e9c:	e0ffb217 	ldw	r3,-312(fp)
 2007ea0:	10c4b03a 	or	r2,r2,r3
 2007ea4:	103fec1e 	bne	r2,zero,2007e58 <___vfprintf_internal_r+0xeec>
					break;
 2007ea8:	00000806 	br	2007ecc <___vfprintf_internal_r+0xf60>

				default:
					cp = "bug in vfprintf: bad base";
 2007eac:	048080b4 	movhi	r18,514
 2007eb0:	94bdf904 	addi	r18,r18,-2076
					size = strlen (cp);
 2007eb4:	9009883a 	mov	r4,r18
 2007eb8:	2006d380 	call	2006d38 <strlen>
 2007ebc:	e0bfb615 	stw	r2,-296(fp)
					goto skipsize;
 2007ec0:	0001883a 	nop
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
 2007ec4:	00001906 	br	2007f2c <___vfprintf_internal_r+0xfc0>
						_uquad >>= 3;
					} while (_uquad);
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
						*--cp = '0';
					break;
 2007ec8:	0001883a 	nop
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
 2007ecc:	00000706 	br	2007eec <___vfprintf_internal_r+0xf80>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
 2007ed0:	e0bfb303 	ldbu	r2,-308(fp)
 2007ed4:	1000051e 	bne	r2,zero,2007eec <___vfprintf_internal_r+0xf80>
 2007ed8:	9880004c 	andi	r2,r19,1
 2007edc:	10000326 	beq	r2,zero,2007eec <___vfprintf_internal_r+0xf80>
                         *--cp = '0';
 2007ee0:	94bfffc4 	addi	r18,r18,-1
 2007ee4:	00800c04 	movi	r2,48
 2007ee8:	90800005 	stb	r2,0(r18)

			size = buf + BUF - cp;
 2007eec:	e0bfdb04 	addi	r2,fp,-148
 2007ef0:	10800a04 	addi	r2,r2,40
 2007ef4:	1007883a 	mov	r3,r2
 2007ef8:	9005883a 	mov	r2,r18
 2007efc:	1885c83a 	sub	r2,r3,r2
 2007f00:	e0bfb615 	stw	r2,-296(fp)
		skipsize:
			break;
 2007f04:	00000906 	br	2007f2c <___vfprintf_internal_r+0xfc0>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
 2007f08:	a003dc26 	beq	r20,zero,2008e7c <___vfprintf_internal_r+0x1f10>
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
 2007f0c:	e4bfdb04 	addi	r18,fp,-148
			*cp = ch;
 2007f10:	a005883a 	mov	r2,r20
 2007f14:	90800005 	stb	r2,0(r18)
			size = 1;
 2007f18:	00800044 	movi	r2,1
 2007f1c:	e0bfb615 	stw	r2,-296(fp)
			sign = '\0';
 2007f20:	e03fc105 	stb	zero,-252(fp)
			break;
 2007f24:	00000106 	br	2007f2c <___vfprintf_internal_r+0xfc0>
					lead = expt;
			}

			if (softsign)
				sign = '-';
			break;
 2007f28:	0001883a 	nop
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
 2007f2c:	e0ffb417 	ldw	r3,-304(fp)
 2007f30:	e0bfb617 	ldw	r2,-296(fp)
 2007f34:	10c0010e 	bge	r2,r3,2007f3c <___vfprintf_internal_r+0xfd0>
 2007f38:	1805883a 	mov	r2,r3
 2007f3c:	e0bfb515 	stw	r2,-300(fp)
		if (sign)
 2007f40:	e0bfc103 	ldbu	r2,-252(fp)
 2007f44:	10803fcc 	andi	r2,r2,255
 2007f48:	1080201c 	xori	r2,r2,128
 2007f4c:	10bfe004 	addi	r2,r2,-128
 2007f50:	10000326 	beq	r2,zero,2007f60 <___vfprintf_internal_r+0xff4>
			realsz++;
 2007f54:	e0bfb517 	ldw	r2,-300(fp)
 2007f58:	10800044 	addi	r2,r2,1
 2007f5c:	e0bfb515 	stw	r2,-300(fp)
		if (flags & HEXPREFIX)
 2007f60:	9880008c 	andi	r2,r19,2
 2007f64:	10000326 	beq	r2,zero,2007f74 <___vfprintf_internal_r+0x1008>
			realsz+= 2;
 2007f68:	e0bfb517 	ldw	r2,-300(fp)
 2007f6c:	10800084 	addi	r2,r2,2
 2007f70:	e0bfb515 	stw	r2,-300(fp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 2007f74:	9880210c 	andi	r2,r19,132
 2007f78:	1000351e 	bne	r2,zero,2008050 <___vfprintf_internal_r+0x10e4>
			PAD (width - realsz, blanks);
 2007f7c:	e0ffad17 	ldw	r3,-332(fp)
 2007f80:	e0bfb517 	ldw	r2,-300(fp)
 2007f84:	18a1c83a 	sub	r16,r3,r2
 2007f88:	0400310e 	bge	zero,r16,2008050 <___vfprintf_internal_r+0x10e4>
 2007f8c:	00001706 	br	2007fec <___vfprintf_internal_r+0x1080>
 2007f90:	008080b4 	movhi	r2,514
 2007f94:	10be0084 	addi	r2,r2,-2046
 2007f98:	88800015 	stw	r2,0(r17)
 2007f9c:	00800404 	movi	r2,16
 2007fa0:	88800115 	stw	r2,4(r17)
 2007fa4:	e0bfca17 	ldw	r2,-216(fp)
 2007fa8:	10800404 	addi	r2,r2,16
 2007fac:	e0bfca15 	stw	r2,-216(fp)
 2007fb0:	8c400204 	addi	r17,r17,8
 2007fb4:	e0bfc917 	ldw	r2,-220(fp)
 2007fb8:	10800044 	addi	r2,r2,1
 2007fbc:	e0bfc915 	stw	r2,-220(fp)
 2007fc0:	e0bfc917 	ldw	r2,-220(fp)
 2007fc4:	10800210 	cmplti	r2,r2,8
 2007fc8:	1000071e 	bne	r2,zero,2007fe8 <___vfprintf_internal_r+0x107c>
 2007fcc:	e0bfc804 	addi	r2,fp,-224
 2007fd0:	100d883a 	mov	r6,r2
 2007fd4:	e17fe717 	ldw	r5,-100(fp)
 2007fd8:	e13fe617 	ldw	r4,-104(fp)
 2007fdc:	2010df40 	call	2010df4 <__sprint_r>
 2007fe0:	1003b41e 	bne	r2,zero,2008eb4 <___vfprintf_internal_r+0x1f48>
 2007fe4:	e47fcb04 	addi	r17,fp,-212
 2007fe8:	843ffc04 	addi	r16,r16,-16
 2007fec:	80800448 	cmpgei	r2,r16,17
 2007ff0:	103fe71e 	bne	r2,zero,2007f90 <___vfprintf_internal_r+0x1024>
 2007ff4:	008080b4 	movhi	r2,514
 2007ff8:	10be0084 	addi	r2,r2,-2046
 2007ffc:	88800015 	stw	r2,0(r17)
 2008000:	8005883a 	mov	r2,r16
 2008004:	88800115 	stw	r2,4(r17)
 2008008:	e0bfca17 	ldw	r2,-216(fp)
 200800c:	8007883a 	mov	r3,r16
 2008010:	10c5883a 	add	r2,r2,r3
 2008014:	e0bfca15 	stw	r2,-216(fp)
 2008018:	8c400204 	addi	r17,r17,8
 200801c:	e0bfc917 	ldw	r2,-220(fp)
 2008020:	10800044 	addi	r2,r2,1
 2008024:	e0bfc915 	stw	r2,-220(fp)
 2008028:	e0bfc917 	ldw	r2,-220(fp)
 200802c:	10800210 	cmplti	r2,r2,8
 2008030:	1000071e 	bne	r2,zero,2008050 <___vfprintf_internal_r+0x10e4>
 2008034:	e0bfc804 	addi	r2,fp,-224
 2008038:	100d883a 	mov	r6,r2
 200803c:	e17fe717 	ldw	r5,-100(fp)
 2008040:	e13fe617 	ldw	r4,-104(fp)
 2008044:	2010df40 	call	2010df4 <__sprint_r>
 2008048:	10039c1e 	bne	r2,zero,2008ebc <___vfprintf_internal_r+0x1f50>
 200804c:	e47fcb04 	addi	r17,fp,-212

		/* prefix */
		if (sign)
 2008050:	e0bfc103 	ldbu	r2,-252(fp)
 2008054:	10803fcc 	andi	r2,r2,255
 2008058:	1080201c 	xori	r2,r2,128
 200805c:	10bfe004 	addi	r2,r2,-128
 2008060:	10001526 	beq	r2,zero,20080b8 <___vfprintf_internal_r+0x114c>
			PRINT (&sign, 1);
 2008064:	e0bfc104 	addi	r2,fp,-252
 2008068:	88800015 	stw	r2,0(r17)
 200806c:	00800044 	movi	r2,1
 2008070:	88800115 	stw	r2,4(r17)
 2008074:	e0bfca17 	ldw	r2,-216(fp)
 2008078:	10800044 	addi	r2,r2,1
 200807c:	e0bfca15 	stw	r2,-216(fp)
 2008080:	8c400204 	addi	r17,r17,8
 2008084:	e0bfc917 	ldw	r2,-220(fp)
 2008088:	10800044 	addi	r2,r2,1
 200808c:	e0bfc915 	stw	r2,-220(fp)
 2008090:	e0bfc917 	ldw	r2,-220(fp)
 2008094:	10800210 	cmplti	r2,r2,8
 2008098:	1000071e 	bne	r2,zero,20080b8 <___vfprintf_internal_r+0x114c>
 200809c:	e0bfc804 	addi	r2,fp,-224
 20080a0:	100d883a 	mov	r6,r2
 20080a4:	e17fe717 	ldw	r5,-100(fp)
 20080a8:	e13fe617 	ldw	r4,-104(fp)
 20080ac:	2010df40 	call	2010df4 <__sprint_r>
 20080b0:	1003841e 	bne	r2,zero,2008ec4 <___vfprintf_internal_r+0x1f58>
 20080b4:	e47fcb04 	addi	r17,fp,-212
		if (flags & HEXPREFIX)
 20080b8:	9880008c 	andi	r2,r19,2
 20080bc:	10001526 	beq	r2,zero,2008114 <___vfprintf_internal_r+0x11a8>
			PRINT (ox, 2);
 20080c0:	e0bfe504 	addi	r2,fp,-108
 20080c4:	88800015 	stw	r2,0(r17)
 20080c8:	00800084 	movi	r2,2
 20080cc:	88800115 	stw	r2,4(r17)
 20080d0:	e0bfca17 	ldw	r2,-216(fp)
 20080d4:	10800084 	addi	r2,r2,2
 20080d8:	e0bfca15 	stw	r2,-216(fp)
 20080dc:	8c400204 	addi	r17,r17,8
 20080e0:	e0bfc917 	ldw	r2,-220(fp)
 20080e4:	10800044 	addi	r2,r2,1
 20080e8:	e0bfc915 	stw	r2,-220(fp)
 20080ec:	e0bfc917 	ldw	r2,-220(fp)
 20080f0:	10800210 	cmplti	r2,r2,8
 20080f4:	1000071e 	bne	r2,zero,2008114 <___vfprintf_internal_r+0x11a8>
 20080f8:	e0bfc804 	addi	r2,fp,-224
 20080fc:	100d883a 	mov	r6,r2
 2008100:	e17fe717 	ldw	r5,-100(fp)
 2008104:	e13fe617 	ldw	r4,-104(fp)
 2008108:	2010df40 	call	2010df4 <__sprint_r>
 200810c:	10036f1e 	bne	r2,zero,2008ecc <___vfprintf_internal_r+0x1f60>
 2008110:	e47fcb04 	addi	r17,fp,-212

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 2008114:	9880210c 	andi	r2,r19,132
 2008118:	10802018 	cmpnei	r2,r2,128
 200811c:	1000351e 	bne	r2,zero,20081f4 <___vfprintf_internal_r+0x1288>
			PAD (width - realsz, zeroes);
 2008120:	e0ffad17 	ldw	r3,-332(fp)
 2008124:	e0bfb517 	ldw	r2,-300(fp)
 2008128:	18a1c83a 	sub	r16,r3,r2
 200812c:	0400310e 	bge	zero,r16,20081f4 <___vfprintf_internal_r+0x1288>
 2008130:	00001706 	br	2008190 <___vfprintf_internal_r+0x1224>
 2008134:	008080b4 	movhi	r2,514
 2008138:	10be0484 	addi	r2,r2,-2030
 200813c:	88800015 	stw	r2,0(r17)
 2008140:	00800404 	movi	r2,16
 2008144:	88800115 	stw	r2,4(r17)
 2008148:	e0bfca17 	ldw	r2,-216(fp)
 200814c:	10800404 	addi	r2,r2,16
 2008150:	e0bfca15 	stw	r2,-216(fp)
 2008154:	8c400204 	addi	r17,r17,8
 2008158:	e0bfc917 	ldw	r2,-220(fp)
 200815c:	10800044 	addi	r2,r2,1
 2008160:	e0bfc915 	stw	r2,-220(fp)
 2008164:	e0bfc917 	ldw	r2,-220(fp)
 2008168:	10800210 	cmplti	r2,r2,8
 200816c:	1000071e 	bne	r2,zero,200818c <___vfprintf_internal_r+0x1220>
 2008170:	e0bfc804 	addi	r2,fp,-224
 2008174:	100d883a 	mov	r6,r2
 2008178:	e17fe717 	ldw	r5,-100(fp)
 200817c:	e13fe617 	ldw	r4,-104(fp)
 2008180:	2010df40 	call	2010df4 <__sprint_r>
 2008184:	1003531e 	bne	r2,zero,2008ed4 <___vfprintf_internal_r+0x1f68>
 2008188:	e47fcb04 	addi	r17,fp,-212
 200818c:	843ffc04 	addi	r16,r16,-16
 2008190:	80800448 	cmpgei	r2,r16,17
 2008194:	103fe71e 	bne	r2,zero,2008134 <___vfprintf_internal_r+0x11c8>
 2008198:	008080b4 	movhi	r2,514
 200819c:	10be0484 	addi	r2,r2,-2030
 20081a0:	88800015 	stw	r2,0(r17)
 20081a4:	8005883a 	mov	r2,r16
 20081a8:	88800115 	stw	r2,4(r17)
 20081ac:	e0bfca17 	ldw	r2,-216(fp)
 20081b0:	8007883a 	mov	r3,r16
 20081b4:	10c5883a 	add	r2,r2,r3
 20081b8:	e0bfca15 	stw	r2,-216(fp)
 20081bc:	8c400204 	addi	r17,r17,8
 20081c0:	e0bfc917 	ldw	r2,-220(fp)
 20081c4:	10800044 	addi	r2,r2,1
 20081c8:	e0bfc915 	stw	r2,-220(fp)
 20081cc:	e0bfc917 	ldw	r2,-220(fp)
 20081d0:	10800210 	cmplti	r2,r2,8
 20081d4:	1000071e 	bne	r2,zero,20081f4 <___vfprintf_internal_r+0x1288>
 20081d8:	e0bfc804 	addi	r2,fp,-224
 20081dc:	100d883a 	mov	r6,r2
 20081e0:	e17fe717 	ldw	r5,-100(fp)
 20081e4:	e13fe617 	ldw	r4,-104(fp)
 20081e8:	2010df40 	call	2010df4 <__sprint_r>
 20081ec:	10033b1e 	bne	r2,zero,2008edc <___vfprintf_internal_r+0x1f70>
 20081f0:	e47fcb04 	addi	r17,fp,-212

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 20081f4:	e0ffb417 	ldw	r3,-304(fp)
 20081f8:	e0bfb617 	ldw	r2,-296(fp)
 20081fc:	18a1c83a 	sub	r16,r3,r2
 2008200:	0400310e 	bge	zero,r16,20082c8 <___vfprintf_internal_r+0x135c>
 2008204:	00001706 	br	2008264 <___vfprintf_internal_r+0x12f8>
 2008208:	008080b4 	movhi	r2,514
 200820c:	10be0484 	addi	r2,r2,-2030
 2008210:	88800015 	stw	r2,0(r17)
 2008214:	00800404 	movi	r2,16
 2008218:	88800115 	stw	r2,4(r17)
 200821c:	e0bfca17 	ldw	r2,-216(fp)
 2008220:	10800404 	addi	r2,r2,16
 2008224:	e0bfca15 	stw	r2,-216(fp)
 2008228:	8c400204 	addi	r17,r17,8
 200822c:	e0bfc917 	ldw	r2,-220(fp)
 2008230:	10800044 	addi	r2,r2,1
 2008234:	e0bfc915 	stw	r2,-220(fp)
 2008238:	e0bfc917 	ldw	r2,-220(fp)
 200823c:	10800210 	cmplti	r2,r2,8
 2008240:	1000071e 	bne	r2,zero,2008260 <___vfprintf_internal_r+0x12f4>
 2008244:	e0bfc804 	addi	r2,fp,-224
 2008248:	100d883a 	mov	r6,r2
 200824c:	e17fe717 	ldw	r5,-100(fp)
 2008250:	e13fe617 	ldw	r4,-104(fp)
 2008254:	2010df40 	call	2010df4 <__sprint_r>
 2008258:	1003221e 	bne	r2,zero,2008ee4 <___vfprintf_internal_r+0x1f78>
 200825c:	e47fcb04 	addi	r17,fp,-212
 2008260:	843ffc04 	addi	r16,r16,-16
 2008264:	80800448 	cmpgei	r2,r16,17
 2008268:	103fe71e 	bne	r2,zero,2008208 <___vfprintf_internal_r+0x129c>
 200826c:	008080b4 	movhi	r2,514
 2008270:	10be0484 	addi	r2,r2,-2030
 2008274:	88800015 	stw	r2,0(r17)
 2008278:	8005883a 	mov	r2,r16
 200827c:	88800115 	stw	r2,4(r17)
 2008280:	e0bfca17 	ldw	r2,-216(fp)
 2008284:	8007883a 	mov	r3,r16
 2008288:	10c5883a 	add	r2,r2,r3
 200828c:	e0bfca15 	stw	r2,-216(fp)
 2008290:	8c400204 	addi	r17,r17,8
 2008294:	e0bfc917 	ldw	r2,-220(fp)
 2008298:	10800044 	addi	r2,r2,1
 200829c:	e0bfc915 	stw	r2,-220(fp)
 20082a0:	e0bfc917 	ldw	r2,-220(fp)
 20082a4:	10800210 	cmplti	r2,r2,8
 20082a8:	1000071e 	bne	r2,zero,20082c8 <___vfprintf_internal_r+0x135c>
 20082ac:	e0bfc804 	addi	r2,fp,-224
 20082b0:	100d883a 	mov	r6,r2
 20082b4:	e17fe717 	ldw	r5,-100(fp)
 20082b8:	e13fe617 	ldw	r4,-104(fp)
 20082bc:	2010df40 	call	2010df4 <__sprint_r>
 20082c0:	10030a1e 	bne	r2,zero,2008eec <___vfprintf_internal_r+0x1f80>
 20082c4:	e47fcb04 	addi	r17,fp,-212

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
 20082c8:	9880400c 	andi	r2,r19,256
 20082cc:	1000161e 	bne	r2,zero,2008328 <___vfprintf_internal_r+0x13bc>
			PRINT (cp, size);
 20082d0:	8c800015 	stw	r18,0(r17)
 20082d4:	e0bfb617 	ldw	r2,-296(fp)
 20082d8:	88800115 	stw	r2,4(r17)
 20082dc:	e0ffca17 	ldw	r3,-216(fp)
 20082e0:	e0bfb617 	ldw	r2,-296(fp)
 20082e4:	1885883a 	add	r2,r3,r2
 20082e8:	e0bfca15 	stw	r2,-216(fp)
 20082ec:	8c400204 	addi	r17,r17,8
 20082f0:	e0bfc917 	ldw	r2,-220(fp)
 20082f4:	10800044 	addi	r2,r2,1
 20082f8:	e0bfc915 	stw	r2,-220(fp)
 20082fc:	e0bfc917 	ldw	r2,-220(fp)
 2008300:	10800210 	cmplti	r2,r2,8
 2008304:	10028c1e 	bne	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
 2008308:	e0bfc804 	addi	r2,fp,-224
 200830c:	100d883a 	mov	r6,r2
 2008310:	e17fe717 	ldw	r5,-100(fp)
 2008314:	e13fe617 	ldw	r4,-104(fp)
 2008318:	2010df40 	call	2010df4 <__sprint_r>
 200831c:	1002f51e 	bne	r2,zero,2008ef4 <___vfprintf_internal_r+0x1f88>
 2008320:	e47fcb04 	addi	r17,fp,-212
 2008324:	00028406 	br	2008d38 <___vfprintf_internal_r+0x1dcc>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
 2008328:	a0801990 	cmplti	r2,r20,102
 200832c:	1001d11e 	bne	r2,zero,2008a74 <___vfprintf_internal_r+0x1b08>
				if (_fpvalue == 0) {
 2008330:	e0bfc217 	ldw	r2,-248(fp)
 2008334:	e0ffc317 	ldw	r3,-244(fp)
 2008338:	000d883a 	mov	r6,zero
 200833c:	000f883a 	mov	r7,zero
 2008340:	1009883a 	mov	r4,r2
 2008344:	180b883a 	mov	r5,r3
 2008348:	20052280 	call	2005228 <__eqdf2>
 200834c:	1000661e 	bne	r2,zero,20084e8 <___vfprintf_internal_r+0x157c>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
 2008350:	008080b4 	movhi	r2,514
 2008354:	10be0004 	addi	r2,r2,-2048
 2008358:	88800015 	stw	r2,0(r17)
 200835c:	00800044 	movi	r2,1
 2008360:	88800115 	stw	r2,4(r17)
 2008364:	e0bfca17 	ldw	r2,-216(fp)
 2008368:	10800044 	addi	r2,r2,1
 200836c:	e0bfca15 	stw	r2,-216(fp)
 2008370:	8c400204 	addi	r17,r17,8
 2008374:	e0bfc917 	ldw	r2,-220(fp)
 2008378:	10800044 	addi	r2,r2,1
 200837c:	e0bfc915 	stw	r2,-220(fp)
 2008380:	e0bfc917 	ldw	r2,-220(fp)
 2008384:	10800210 	cmplti	r2,r2,8
 2008388:	1000071e 	bne	r2,zero,20083a8 <___vfprintf_internal_r+0x143c>
 200838c:	e0bfc804 	addi	r2,fp,-224
 2008390:	100d883a 	mov	r6,r2
 2008394:	e17fe717 	ldw	r5,-100(fp)
 2008398:	e13fe617 	ldw	r4,-104(fp)
 200839c:	2010df40 	call	2010df4 <__sprint_r>
 20083a0:	1002d61e 	bne	r2,zero,2008efc <___vfprintf_internal_r+0x1f90>
 20083a4:	e47fcb04 	addi	r17,fp,-212
					if (expt < ndig || flags & ALT) {
 20083a8:	e0ffc417 	ldw	r3,-240(fp)
 20083ac:	e0bfc717 	ldw	r2,-228(fp)
 20083b0:	18800216 	blt	r3,r2,20083bc <___vfprintf_internal_r+0x1450>
 20083b4:	9880004c 	andi	r2,r19,1
 20083b8:	10025f26 	beq	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
						PRINT (decimal_point, decp_len);
 20083bc:	e0bfbb17 	ldw	r2,-276(fp)
 20083c0:	88800015 	stw	r2,0(r17)
 20083c4:	e0bfbc17 	ldw	r2,-272(fp)
 20083c8:	88800115 	stw	r2,4(r17)
 20083cc:	e0ffca17 	ldw	r3,-216(fp)
 20083d0:	e0bfbc17 	ldw	r2,-272(fp)
 20083d4:	1885883a 	add	r2,r3,r2
 20083d8:	e0bfca15 	stw	r2,-216(fp)
 20083dc:	8c400204 	addi	r17,r17,8
 20083e0:	e0bfc917 	ldw	r2,-220(fp)
 20083e4:	10800044 	addi	r2,r2,1
 20083e8:	e0bfc915 	stw	r2,-220(fp)
 20083ec:	e0bfc917 	ldw	r2,-220(fp)
 20083f0:	10800210 	cmplti	r2,r2,8
 20083f4:	1000071e 	bne	r2,zero,2008414 <___vfprintf_internal_r+0x14a8>
 20083f8:	e0bfc804 	addi	r2,fp,-224
 20083fc:	100d883a 	mov	r6,r2
 2008400:	e17fe717 	ldw	r5,-100(fp)
 2008404:	e13fe617 	ldw	r4,-104(fp)
 2008408:	2010df40 	call	2010df4 <__sprint_r>
 200840c:	1002bd1e 	bne	r2,zero,2008f04 <___vfprintf_internal_r+0x1f98>
 2008410:	e47fcb04 	addi	r17,fp,-212
						PAD (ndig - 1, zeroes);
 2008414:	e0bfc717 	ldw	r2,-228(fp)
 2008418:	143fffc4 	addi	r16,r2,-1
 200841c:	0402460e 	bge	zero,r16,2008d38 <___vfprintf_internal_r+0x1dcc>
 2008420:	00001706 	br	2008480 <___vfprintf_internal_r+0x1514>
 2008424:	008080b4 	movhi	r2,514
 2008428:	10be0484 	addi	r2,r2,-2030
 200842c:	88800015 	stw	r2,0(r17)
 2008430:	00800404 	movi	r2,16
 2008434:	88800115 	stw	r2,4(r17)
 2008438:	e0bfca17 	ldw	r2,-216(fp)
 200843c:	10800404 	addi	r2,r2,16
 2008440:	e0bfca15 	stw	r2,-216(fp)
 2008444:	8c400204 	addi	r17,r17,8
 2008448:	e0bfc917 	ldw	r2,-220(fp)
 200844c:	10800044 	addi	r2,r2,1
 2008450:	e0bfc915 	stw	r2,-220(fp)
 2008454:	e0bfc917 	ldw	r2,-220(fp)
 2008458:	10800210 	cmplti	r2,r2,8
 200845c:	1000071e 	bne	r2,zero,200847c <___vfprintf_internal_r+0x1510>
 2008460:	e0bfc804 	addi	r2,fp,-224
 2008464:	100d883a 	mov	r6,r2
 2008468:	e17fe717 	ldw	r5,-100(fp)
 200846c:	e13fe617 	ldw	r4,-104(fp)
 2008470:	2010df40 	call	2010df4 <__sprint_r>
 2008474:	1002a51e 	bne	r2,zero,2008f0c <___vfprintf_internal_r+0x1fa0>
 2008478:	e47fcb04 	addi	r17,fp,-212
 200847c:	843ffc04 	addi	r16,r16,-16
 2008480:	80800448 	cmpgei	r2,r16,17
 2008484:	103fe71e 	bne	r2,zero,2008424 <___vfprintf_internal_r+0x14b8>
 2008488:	008080b4 	movhi	r2,514
 200848c:	10be0484 	addi	r2,r2,-2030
 2008490:	88800015 	stw	r2,0(r17)
 2008494:	8005883a 	mov	r2,r16
 2008498:	88800115 	stw	r2,4(r17)
 200849c:	e0bfca17 	ldw	r2,-216(fp)
 20084a0:	8007883a 	mov	r3,r16
 20084a4:	10c5883a 	add	r2,r2,r3
 20084a8:	e0bfca15 	stw	r2,-216(fp)
 20084ac:	8c400204 	addi	r17,r17,8
 20084b0:	e0bfc917 	ldw	r2,-220(fp)
 20084b4:	10800044 	addi	r2,r2,1
 20084b8:	e0bfc915 	stw	r2,-220(fp)
 20084bc:	e0bfc917 	ldw	r2,-220(fp)
 20084c0:	10800210 	cmplti	r2,r2,8
 20084c4:	10021c1e 	bne	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
 20084c8:	e0bfc804 	addi	r2,fp,-224
 20084cc:	100d883a 	mov	r6,r2
 20084d0:	e17fe717 	ldw	r5,-100(fp)
 20084d4:	e13fe617 	ldw	r4,-104(fp)
 20084d8:	2010df40 	call	2010df4 <__sprint_r>
 20084dc:	10028d1e 	bne	r2,zero,2008f14 <___vfprintf_internal_r+0x1fa8>
 20084e0:	e47fcb04 	addi	r17,fp,-212
 20084e4:	00021406 	br	2008d38 <___vfprintf_internal_r+0x1dcc>
					}
				} else if (expt <= 0) {
 20084e8:	e0bfc417 	ldw	r2,-240(fp)
 20084ec:	00807c16 	blt	zero,r2,20086e0 <___vfprintf_internal_r+0x1774>
					PRINT ("0", 1);
 20084f0:	008080b4 	movhi	r2,514
 20084f4:	10be0004 	addi	r2,r2,-2048
 20084f8:	88800015 	stw	r2,0(r17)
 20084fc:	00800044 	movi	r2,1
 2008500:	88800115 	stw	r2,4(r17)
 2008504:	e0bfca17 	ldw	r2,-216(fp)
 2008508:	10800044 	addi	r2,r2,1
 200850c:	e0bfca15 	stw	r2,-216(fp)
 2008510:	8c400204 	addi	r17,r17,8
 2008514:	e0bfc917 	ldw	r2,-220(fp)
 2008518:	10800044 	addi	r2,r2,1
 200851c:	e0bfc915 	stw	r2,-220(fp)
 2008520:	e0bfc917 	ldw	r2,-220(fp)
 2008524:	10800210 	cmplti	r2,r2,8
 2008528:	1000071e 	bne	r2,zero,2008548 <___vfprintf_internal_r+0x15dc>
 200852c:	e0bfc804 	addi	r2,fp,-224
 2008530:	100d883a 	mov	r6,r2
 2008534:	e17fe717 	ldw	r5,-100(fp)
 2008538:	e13fe617 	ldw	r4,-104(fp)
 200853c:	2010df40 	call	2010df4 <__sprint_r>
 2008540:	1002761e 	bne	r2,zero,2008f1c <___vfprintf_internal_r+0x1fb0>
 2008544:	e47fcb04 	addi	r17,fp,-212
					if (expt || ndig || flags & ALT) {
 2008548:	e0bfc417 	ldw	r2,-240(fp)
 200854c:	1000041e 	bne	r2,zero,2008560 <___vfprintf_internal_r+0x15f4>
 2008550:	e0bfc717 	ldw	r2,-228(fp)
 2008554:	1000021e 	bne	r2,zero,2008560 <___vfprintf_internal_r+0x15f4>
 2008558:	9880004c 	andi	r2,r19,1
 200855c:	1001f626 	beq	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
						PRINT (decimal_point, decp_len);
 2008560:	e0bfbb17 	ldw	r2,-276(fp)
 2008564:	88800015 	stw	r2,0(r17)
 2008568:	e0bfbc17 	ldw	r2,-272(fp)
 200856c:	88800115 	stw	r2,4(r17)
 2008570:	e0ffca17 	ldw	r3,-216(fp)
 2008574:	e0bfbc17 	ldw	r2,-272(fp)
 2008578:	1885883a 	add	r2,r3,r2
 200857c:	e0bfca15 	stw	r2,-216(fp)
 2008580:	8c400204 	addi	r17,r17,8
 2008584:	e0bfc917 	ldw	r2,-220(fp)
 2008588:	10800044 	addi	r2,r2,1
 200858c:	e0bfc915 	stw	r2,-220(fp)
 2008590:	e0bfc917 	ldw	r2,-220(fp)
 2008594:	10800210 	cmplti	r2,r2,8
 2008598:	1000071e 	bne	r2,zero,20085b8 <___vfprintf_internal_r+0x164c>
 200859c:	e0bfc804 	addi	r2,fp,-224
 20085a0:	100d883a 	mov	r6,r2
 20085a4:	e17fe717 	ldw	r5,-100(fp)
 20085a8:	e13fe617 	ldw	r4,-104(fp)
 20085ac:	2010df40 	call	2010df4 <__sprint_r>
 20085b0:	10025c1e 	bne	r2,zero,2008f24 <___vfprintf_internal_r+0x1fb8>
 20085b4:	e47fcb04 	addi	r17,fp,-212
						PAD (-expt, zeroes);
 20085b8:	e0bfc417 	ldw	r2,-240(fp)
 20085bc:	00a1c83a 	sub	r16,zero,r2
 20085c0:	0400310e 	bge	zero,r16,2008688 <___vfprintf_internal_r+0x171c>
 20085c4:	00001706 	br	2008624 <___vfprintf_internal_r+0x16b8>
 20085c8:	008080b4 	movhi	r2,514
 20085cc:	10be0484 	addi	r2,r2,-2030
 20085d0:	88800015 	stw	r2,0(r17)
 20085d4:	00800404 	movi	r2,16
 20085d8:	88800115 	stw	r2,4(r17)
 20085dc:	e0bfca17 	ldw	r2,-216(fp)
 20085e0:	10800404 	addi	r2,r2,16
 20085e4:	e0bfca15 	stw	r2,-216(fp)
 20085e8:	8c400204 	addi	r17,r17,8
 20085ec:	e0bfc917 	ldw	r2,-220(fp)
 20085f0:	10800044 	addi	r2,r2,1
 20085f4:	e0bfc915 	stw	r2,-220(fp)
 20085f8:	e0bfc917 	ldw	r2,-220(fp)
 20085fc:	10800210 	cmplti	r2,r2,8
 2008600:	1000071e 	bne	r2,zero,2008620 <___vfprintf_internal_r+0x16b4>
 2008604:	e0bfc804 	addi	r2,fp,-224
 2008608:	100d883a 	mov	r6,r2
 200860c:	e17fe717 	ldw	r5,-100(fp)
 2008610:	e13fe617 	ldw	r4,-104(fp)
 2008614:	2010df40 	call	2010df4 <__sprint_r>
 2008618:	1002441e 	bne	r2,zero,2008f2c <___vfprintf_internal_r+0x1fc0>
 200861c:	e47fcb04 	addi	r17,fp,-212
 2008620:	843ffc04 	addi	r16,r16,-16
 2008624:	80800448 	cmpgei	r2,r16,17
 2008628:	103fe71e 	bne	r2,zero,20085c8 <___vfprintf_internal_r+0x165c>
 200862c:	008080b4 	movhi	r2,514
 2008630:	10be0484 	addi	r2,r2,-2030
 2008634:	88800015 	stw	r2,0(r17)
 2008638:	8005883a 	mov	r2,r16
 200863c:	88800115 	stw	r2,4(r17)
 2008640:	e0bfca17 	ldw	r2,-216(fp)
 2008644:	8007883a 	mov	r3,r16
 2008648:	10c5883a 	add	r2,r2,r3
 200864c:	e0bfca15 	stw	r2,-216(fp)
 2008650:	8c400204 	addi	r17,r17,8
 2008654:	e0bfc917 	ldw	r2,-220(fp)
 2008658:	10800044 	addi	r2,r2,1
 200865c:	e0bfc915 	stw	r2,-220(fp)
 2008660:	e0bfc917 	ldw	r2,-220(fp)
 2008664:	10800210 	cmplti	r2,r2,8
 2008668:	1000071e 	bne	r2,zero,2008688 <___vfprintf_internal_r+0x171c>
 200866c:	e0bfc804 	addi	r2,fp,-224
 2008670:	100d883a 	mov	r6,r2
 2008674:	e17fe717 	ldw	r5,-100(fp)
 2008678:	e13fe617 	ldw	r4,-104(fp)
 200867c:	2010df40 	call	2010df4 <__sprint_r>
 2008680:	10022c1e 	bne	r2,zero,2008f34 <___vfprintf_internal_r+0x1fc8>
 2008684:	e47fcb04 	addi	r17,fp,-212
						PRINT (cp, ndig);
 2008688:	8c800015 	stw	r18,0(r17)
 200868c:	e0bfc717 	ldw	r2,-228(fp)
 2008690:	88800115 	stw	r2,4(r17)
 2008694:	e0bfca17 	ldw	r2,-216(fp)
 2008698:	e0ffc717 	ldw	r3,-228(fp)
 200869c:	10c5883a 	add	r2,r2,r3
 20086a0:	e0bfca15 	stw	r2,-216(fp)
 20086a4:	8c400204 	addi	r17,r17,8
 20086a8:	e0bfc917 	ldw	r2,-220(fp)
 20086ac:	10800044 	addi	r2,r2,1
 20086b0:	e0bfc915 	stw	r2,-220(fp)
 20086b4:	e0bfc917 	ldw	r2,-220(fp)
 20086b8:	10800210 	cmplti	r2,r2,8
 20086bc:	10019e1e 	bne	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
 20086c0:	e0bfc804 	addi	r2,fp,-224
 20086c4:	100d883a 	mov	r6,r2
 20086c8:	e17fe717 	ldw	r5,-100(fp)
 20086cc:	e13fe617 	ldw	r4,-104(fp)
 20086d0:	2010df40 	call	2010df4 <__sprint_r>
 20086d4:	1002191e 	bne	r2,zero,2008f3c <___vfprintf_internal_r+0x1fd0>
 20086d8:	e47fcb04 	addi	r17,fp,-212
 20086dc:	00019606 	br	2008d38 <___vfprintf_internal_r+0x1dcc>
					}
				} else {
					char *convbuf = cp;
 20086e0:	e4bfc015 	stw	r18,-256(fp)
					PRINTANDPAD(cp, convbuf + ndig,
 20086e4:	e0bfc717 	ldw	r2,-228(fp)
 20086e8:	1007883a 	mov	r3,r2
 20086ec:	e0bfc017 	ldw	r2,-256(fp)
 20086f0:	10c5883a 	add	r2,r2,r3
 20086f4:	1007883a 	mov	r3,r2
 20086f8:	9005883a 	mov	r2,r18
 20086fc:	1885c83a 	sub	r2,r3,r2
 2008700:	e0bfb915 	stw	r2,-284(fp)
 2008704:	e0bfb917 	ldw	r2,-284(fp)
 2008708:	e0ffb017 	ldw	r3,-320(fp)
 200870c:	1880020e 	bge	r3,r2,2008718 <___vfprintf_internal_r+0x17ac>
 2008710:	e0bfb017 	ldw	r2,-320(fp)
 2008714:	e0bfb915 	stw	r2,-284(fp)
 2008718:	e0bfb917 	ldw	r2,-284(fp)
 200871c:	0080150e 	bge	zero,r2,2008774 <___vfprintf_internal_r+0x1808>
 2008720:	8c800015 	stw	r18,0(r17)
 2008724:	e0bfb917 	ldw	r2,-284(fp)
 2008728:	88800115 	stw	r2,4(r17)
 200872c:	e0ffca17 	ldw	r3,-216(fp)
 2008730:	e0bfb917 	ldw	r2,-284(fp)
 2008734:	1885883a 	add	r2,r3,r2
 2008738:	e0bfca15 	stw	r2,-216(fp)
 200873c:	8c400204 	addi	r17,r17,8
 2008740:	e0bfc917 	ldw	r2,-220(fp)
 2008744:	10800044 	addi	r2,r2,1
 2008748:	e0bfc915 	stw	r2,-220(fp)
 200874c:	e0bfc917 	ldw	r2,-220(fp)
 2008750:	10800210 	cmplti	r2,r2,8
 2008754:	1000071e 	bne	r2,zero,2008774 <___vfprintf_internal_r+0x1808>
 2008758:	e0bfc804 	addi	r2,fp,-224
 200875c:	100d883a 	mov	r6,r2
 2008760:	e17fe717 	ldw	r5,-100(fp)
 2008764:	e13fe617 	ldw	r4,-104(fp)
 2008768:	2010df40 	call	2010df4 <__sprint_r>
 200876c:	1001f51e 	bne	r2,zero,2008f44 <___vfprintf_internal_r+0x1fd8>
 2008770:	e47fcb04 	addi	r17,fp,-212
 2008774:	e0bfb917 	ldw	r2,-284(fp)
 2008778:	1000010e 	bge	r2,zero,2008780 <___vfprintf_internal_r+0x1814>
 200877c:	0005883a 	mov	r2,zero
 2008780:	e0ffb017 	ldw	r3,-320(fp)
 2008784:	1885c83a 	sub	r2,r3,r2
 2008788:	e0bfb915 	stw	r2,-284(fp)
 200878c:	e0bfb917 	ldw	r2,-284(fp)
 2008790:	0080340e 	bge	zero,r2,2008864 <___vfprintf_internal_r+0x18f8>
 2008794:	00001906 	br	20087fc <___vfprintf_internal_r+0x1890>
 2008798:	008080b4 	movhi	r2,514
 200879c:	10be0484 	addi	r2,r2,-2030
 20087a0:	88800015 	stw	r2,0(r17)
 20087a4:	00800404 	movi	r2,16
 20087a8:	88800115 	stw	r2,4(r17)
 20087ac:	e0bfca17 	ldw	r2,-216(fp)
 20087b0:	10800404 	addi	r2,r2,16
 20087b4:	e0bfca15 	stw	r2,-216(fp)
 20087b8:	8c400204 	addi	r17,r17,8
 20087bc:	e0bfc917 	ldw	r2,-220(fp)
 20087c0:	10800044 	addi	r2,r2,1
 20087c4:	e0bfc915 	stw	r2,-220(fp)
 20087c8:	e0bfc917 	ldw	r2,-220(fp)
 20087cc:	10800210 	cmplti	r2,r2,8
 20087d0:	1000071e 	bne	r2,zero,20087f0 <___vfprintf_internal_r+0x1884>
 20087d4:	e0bfc804 	addi	r2,fp,-224
 20087d8:	100d883a 	mov	r6,r2
 20087dc:	e17fe717 	ldw	r5,-100(fp)
 20087e0:	e13fe617 	ldw	r4,-104(fp)
 20087e4:	2010df40 	call	2010df4 <__sprint_r>
 20087e8:	1001d81e 	bne	r2,zero,2008f4c <___vfprintf_internal_r+0x1fe0>
 20087ec:	e47fcb04 	addi	r17,fp,-212
 20087f0:	e0bfb917 	ldw	r2,-284(fp)
 20087f4:	10bffc04 	addi	r2,r2,-16
 20087f8:	e0bfb915 	stw	r2,-284(fp)
 20087fc:	e0bfb917 	ldw	r2,-284(fp)
 2008800:	10800448 	cmpgei	r2,r2,17
 2008804:	103fe41e 	bne	r2,zero,2008798 <___vfprintf_internal_r+0x182c>
 2008808:	008080b4 	movhi	r2,514
 200880c:	10be0484 	addi	r2,r2,-2030
 2008810:	88800015 	stw	r2,0(r17)
 2008814:	e0bfb917 	ldw	r2,-284(fp)
 2008818:	88800115 	stw	r2,4(r17)
 200881c:	e0ffca17 	ldw	r3,-216(fp)
 2008820:	e0bfb917 	ldw	r2,-284(fp)
 2008824:	1885883a 	add	r2,r3,r2
 2008828:	e0bfca15 	stw	r2,-216(fp)
 200882c:	8c400204 	addi	r17,r17,8
 2008830:	e0bfc917 	ldw	r2,-220(fp)
 2008834:	10800044 	addi	r2,r2,1
 2008838:	e0bfc915 	stw	r2,-220(fp)
 200883c:	e0bfc917 	ldw	r2,-220(fp)
 2008840:	10800210 	cmplti	r2,r2,8
 2008844:	1000071e 	bne	r2,zero,2008864 <___vfprintf_internal_r+0x18f8>
 2008848:	e0bfc804 	addi	r2,fp,-224
 200884c:	100d883a 	mov	r6,r2
 2008850:	e17fe717 	ldw	r5,-100(fp)
 2008854:	e13fe617 	ldw	r4,-104(fp)
 2008858:	2010df40 	call	2010df4 <__sprint_r>
 200885c:	1001bd1e 	bne	r2,zero,2008f54 <___vfprintf_internal_r+0x1fe8>
 2008860:	e47fcb04 	addi	r17,fp,-212
						    lead, zeroes);
					cp += lead;
 2008864:	e0bfb017 	ldw	r2,-320(fp)
 2008868:	90a5883a 	add	r18,r18,r2
					    }
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
 200886c:	e0ffc417 	ldw	r3,-240(fp)
 2008870:	e0bfc717 	ldw	r2,-228(fp)
 2008874:	18800216 	blt	r3,r2,2008880 <___vfprintf_internal_r+0x1914>
 2008878:	9880004c 	andi	r2,r19,1
 200887c:	10001626 	beq	r2,zero,20088d8 <___vfprintf_internal_r+0x196c>
					    PRINT (decimal_point, decp_len);
 2008880:	e0bfbb17 	ldw	r2,-276(fp)
 2008884:	88800015 	stw	r2,0(r17)
 2008888:	e0bfbc17 	ldw	r2,-272(fp)
 200888c:	88800115 	stw	r2,4(r17)
 2008890:	e0ffca17 	ldw	r3,-216(fp)
 2008894:	e0bfbc17 	ldw	r2,-272(fp)
 2008898:	1885883a 	add	r2,r3,r2
 200889c:	e0bfca15 	stw	r2,-216(fp)
 20088a0:	8c400204 	addi	r17,r17,8
 20088a4:	e0bfc917 	ldw	r2,-220(fp)
 20088a8:	10800044 	addi	r2,r2,1
 20088ac:	e0bfc915 	stw	r2,-220(fp)
 20088b0:	e0bfc917 	ldw	r2,-220(fp)
 20088b4:	10800210 	cmplti	r2,r2,8
 20088b8:	1000071e 	bne	r2,zero,20088d8 <___vfprintf_internal_r+0x196c>
 20088bc:	e0bfc804 	addi	r2,fp,-224
 20088c0:	100d883a 	mov	r6,r2
 20088c4:	e17fe717 	ldw	r5,-100(fp)
 20088c8:	e13fe617 	ldw	r4,-104(fp)
 20088cc:	2010df40 	call	2010df4 <__sprint_r>
 20088d0:	1001a21e 	bne	r2,zero,2008f5c <___vfprintf_internal_r+0x1ff0>
 20088d4:	e47fcb04 	addi	r17,fp,-212
					PRINTANDPAD (cp, convbuf + ndig,
 20088d8:	e0bfc717 	ldw	r2,-228(fp)
 20088dc:	1007883a 	mov	r3,r2
 20088e0:	e0bfc017 	ldw	r2,-256(fp)
 20088e4:	10c5883a 	add	r2,r2,r3
 20088e8:	1007883a 	mov	r3,r2
 20088ec:	9005883a 	mov	r2,r18
 20088f0:	1885c83a 	sub	r2,r3,r2
 20088f4:	e0bfba15 	stw	r2,-280(fp)
 20088f8:	e0ffc717 	ldw	r3,-228(fp)
 20088fc:	e0bfc417 	ldw	r2,-240(fp)
 2008900:	1887c83a 	sub	r3,r3,r2
 2008904:	e0bfba17 	ldw	r2,-280(fp)
 2008908:	1880040e 	bge	r3,r2,200891c <___vfprintf_internal_r+0x19b0>
 200890c:	e0ffc717 	ldw	r3,-228(fp)
 2008910:	e0bfc417 	ldw	r2,-240(fp)
 2008914:	1885c83a 	sub	r2,r3,r2
 2008918:	e0bfba15 	stw	r2,-280(fp)
 200891c:	e0bfba17 	ldw	r2,-280(fp)
 2008920:	0080150e 	bge	zero,r2,2008978 <___vfprintf_internal_r+0x1a0c>
 2008924:	8c800015 	stw	r18,0(r17)
 2008928:	e0bfba17 	ldw	r2,-280(fp)
 200892c:	88800115 	stw	r2,4(r17)
 2008930:	e0ffca17 	ldw	r3,-216(fp)
 2008934:	e0bfba17 	ldw	r2,-280(fp)
 2008938:	1885883a 	add	r2,r3,r2
 200893c:	e0bfca15 	stw	r2,-216(fp)
 2008940:	8c400204 	addi	r17,r17,8
 2008944:	e0bfc917 	ldw	r2,-220(fp)
 2008948:	10800044 	addi	r2,r2,1
 200894c:	e0bfc915 	stw	r2,-220(fp)
 2008950:	e0bfc917 	ldw	r2,-220(fp)
 2008954:	10800210 	cmplti	r2,r2,8
 2008958:	1000071e 	bne	r2,zero,2008978 <___vfprintf_internal_r+0x1a0c>
 200895c:	e0bfc804 	addi	r2,fp,-224
 2008960:	100d883a 	mov	r6,r2
 2008964:	e17fe717 	ldw	r5,-100(fp)
 2008968:	e13fe617 	ldw	r4,-104(fp)
 200896c:	2010df40 	call	2010df4 <__sprint_r>
 2008970:	10017c1e 	bne	r2,zero,2008f64 <___vfprintf_internal_r+0x1ff8>
 2008974:	e47fcb04 	addi	r17,fp,-212
 2008978:	e0ffc717 	ldw	r3,-228(fp)
 200897c:	e0bfc417 	ldw	r2,-240(fp)
 2008980:	1887c83a 	sub	r3,r3,r2
 2008984:	e0bfba17 	ldw	r2,-280(fp)
 2008988:	1000010e 	bge	r2,zero,2008990 <___vfprintf_internal_r+0x1a24>
 200898c:	0005883a 	mov	r2,zero
 2008990:	1885c83a 	sub	r2,r3,r2
 2008994:	e0bfba15 	stw	r2,-280(fp)
 2008998:	e0bfba17 	ldw	r2,-280(fp)
 200899c:	0080e60e 	bge	zero,r2,2008d38 <___vfprintf_internal_r+0x1dcc>
 20089a0:	00001906 	br	2008a08 <___vfprintf_internal_r+0x1a9c>
 20089a4:	008080b4 	movhi	r2,514
 20089a8:	10be0484 	addi	r2,r2,-2030
 20089ac:	88800015 	stw	r2,0(r17)
 20089b0:	00800404 	movi	r2,16
 20089b4:	88800115 	stw	r2,4(r17)
 20089b8:	e0bfca17 	ldw	r2,-216(fp)
 20089bc:	10800404 	addi	r2,r2,16
 20089c0:	e0bfca15 	stw	r2,-216(fp)
 20089c4:	8c400204 	addi	r17,r17,8
 20089c8:	e0bfc917 	ldw	r2,-220(fp)
 20089cc:	10800044 	addi	r2,r2,1
 20089d0:	e0bfc915 	stw	r2,-220(fp)
 20089d4:	e0bfc917 	ldw	r2,-220(fp)
 20089d8:	10800210 	cmplti	r2,r2,8
 20089dc:	1000071e 	bne	r2,zero,20089fc <___vfprintf_internal_r+0x1a90>
 20089e0:	e0bfc804 	addi	r2,fp,-224
 20089e4:	100d883a 	mov	r6,r2
 20089e8:	e17fe717 	ldw	r5,-100(fp)
 20089ec:	e13fe617 	ldw	r4,-104(fp)
 20089f0:	2010df40 	call	2010df4 <__sprint_r>
 20089f4:	10015d1e 	bne	r2,zero,2008f6c <___vfprintf_internal_r+0x2000>
 20089f8:	e47fcb04 	addi	r17,fp,-212
 20089fc:	e0bfba17 	ldw	r2,-280(fp)
 2008a00:	10bffc04 	addi	r2,r2,-16
 2008a04:	e0bfba15 	stw	r2,-280(fp)
 2008a08:	e0bfba17 	ldw	r2,-280(fp)
 2008a0c:	10800448 	cmpgei	r2,r2,17
 2008a10:	103fe41e 	bne	r2,zero,20089a4 <___vfprintf_internal_r+0x1a38>
 2008a14:	008080b4 	movhi	r2,514
 2008a18:	10be0484 	addi	r2,r2,-2030
 2008a1c:	88800015 	stw	r2,0(r17)
 2008a20:	e0bfba17 	ldw	r2,-280(fp)
 2008a24:	88800115 	stw	r2,4(r17)
 2008a28:	e0ffca17 	ldw	r3,-216(fp)
 2008a2c:	e0bfba17 	ldw	r2,-280(fp)
 2008a30:	1885883a 	add	r2,r3,r2
 2008a34:	e0bfca15 	stw	r2,-216(fp)
 2008a38:	8c400204 	addi	r17,r17,8
 2008a3c:	e0bfc917 	ldw	r2,-220(fp)
 2008a40:	10800044 	addi	r2,r2,1
 2008a44:	e0bfc915 	stw	r2,-220(fp)
 2008a48:	e0bfc917 	ldw	r2,-220(fp)
 2008a4c:	10800210 	cmplti	r2,r2,8
 2008a50:	1000b91e 	bne	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
 2008a54:	e0bfc804 	addi	r2,fp,-224
 2008a58:	100d883a 	mov	r6,r2
 2008a5c:	e17fe717 	ldw	r5,-100(fp)
 2008a60:	e13fe617 	ldw	r4,-104(fp)
 2008a64:	2010df40 	call	2010df4 <__sprint_r>
 2008a68:	1001421e 	bne	r2,zero,2008f74 <___vfprintf_internal_r+0x2008>
 2008a6c:	e47fcb04 	addi	r17,fp,-212
 2008a70:	0000b106 	br	2008d38 <___vfprintf_internal_r+0x1dcc>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
 2008a74:	e0bfc717 	ldw	r2,-228(fp)
 2008a78:	10800088 	cmpgei	r2,r2,2
 2008a7c:	1000021e 	bne	r2,zero,2008a88 <___vfprintf_internal_r+0x1b1c>
 2008a80:	9880004c 	andi	r2,r19,1
 2008a84:	10008026 	beq	r2,zero,2008c88 <___vfprintf_internal_r+0x1d1c>
					PRINT (cp, 1);
 2008a88:	8c800015 	stw	r18,0(r17)
 2008a8c:	00800044 	movi	r2,1
 2008a90:	88800115 	stw	r2,4(r17)
 2008a94:	e0bfca17 	ldw	r2,-216(fp)
 2008a98:	10800044 	addi	r2,r2,1
 2008a9c:	e0bfca15 	stw	r2,-216(fp)
 2008aa0:	8c400204 	addi	r17,r17,8
 2008aa4:	e0bfc917 	ldw	r2,-220(fp)
 2008aa8:	10800044 	addi	r2,r2,1
 2008aac:	e0bfc915 	stw	r2,-220(fp)
 2008ab0:	e0bfc917 	ldw	r2,-220(fp)
 2008ab4:	10800210 	cmplti	r2,r2,8
 2008ab8:	1000071e 	bne	r2,zero,2008ad8 <___vfprintf_internal_r+0x1b6c>
 2008abc:	e0bfc804 	addi	r2,fp,-224
 2008ac0:	100d883a 	mov	r6,r2
 2008ac4:	e17fe717 	ldw	r5,-100(fp)
 2008ac8:	e13fe617 	ldw	r4,-104(fp)
 2008acc:	2010df40 	call	2010df4 <__sprint_r>
 2008ad0:	10012a1e 	bne	r2,zero,2008f7c <___vfprintf_internal_r+0x2010>
 2008ad4:	e47fcb04 	addi	r17,fp,-212
					cp++;
 2008ad8:	94800044 	addi	r18,r18,1
					PRINT (decimal_point, decp_len);
 2008adc:	e0bfbb17 	ldw	r2,-276(fp)
 2008ae0:	88800015 	stw	r2,0(r17)
 2008ae4:	e0bfbc17 	ldw	r2,-272(fp)
 2008ae8:	88800115 	stw	r2,4(r17)
 2008aec:	e0ffca17 	ldw	r3,-216(fp)
 2008af0:	e0bfbc17 	ldw	r2,-272(fp)
 2008af4:	1885883a 	add	r2,r3,r2
 2008af8:	e0bfca15 	stw	r2,-216(fp)
 2008afc:	8c400204 	addi	r17,r17,8
 2008b00:	e0bfc917 	ldw	r2,-220(fp)
 2008b04:	10800044 	addi	r2,r2,1
 2008b08:	e0bfc915 	stw	r2,-220(fp)
 2008b0c:	e0bfc917 	ldw	r2,-220(fp)
 2008b10:	10800210 	cmplti	r2,r2,8
 2008b14:	1000071e 	bne	r2,zero,2008b34 <___vfprintf_internal_r+0x1bc8>
 2008b18:	e0bfc804 	addi	r2,fp,-224
 2008b1c:	100d883a 	mov	r6,r2
 2008b20:	e17fe717 	ldw	r5,-100(fp)
 2008b24:	e13fe617 	ldw	r4,-104(fp)
 2008b28:	2010df40 	call	2010df4 <__sprint_r>
 2008b2c:	1001151e 	bne	r2,zero,2008f84 <___vfprintf_internal_r+0x2018>
 2008b30:	e47fcb04 	addi	r17,fp,-212
					if (_fpvalue) {
 2008b34:	e0bfc217 	ldw	r2,-248(fp)
 2008b38:	e0ffc317 	ldw	r3,-244(fp)
 2008b3c:	000d883a 	mov	r6,zero
 2008b40:	000f883a 	mov	r7,zero
 2008b44:	1009883a 	mov	r4,r2
 2008b48:	180b883a 	mov	r5,r3
 2008b4c:	20052280 	call	2005228 <__eqdf2>
 2008b50:	10001826 	beq	r2,zero,2008bb4 <___vfprintf_internal_r+0x1c48>
						PRINT (cp, ndig - 1);
 2008b54:	8c800015 	stw	r18,0(r17)
 2008b58:	e0bfc717 	ldw	r2,-228(fp)
 2008b5c:	10bfffc4 	addi	r2,r2,-1
 2008b60:	88800115 	stw	r2,4(r17)
 2008b64:	e0bfca17 	ldw	r2,-216(fp)
 2008b68:	e0ffc717 	ldw	r3,-228(fp)
 2008b6c:	10c5883a 	add	r2,r2,r3
 2008b70:	10bfffc4 	addi	r2,r2,-1
 2008b74:	e0bfca15 	stw	r2,-216(fp)
 2008b78:	8c400204 	addi	r17,r17,8
 2008b7c:	e0bfc917 	ldw	r2,-220(fp)
 2008b80:	10800044 	addi	r2,r2,1
 2008b84:	e0bfc915 	stw	r2,-220(fp)
 2008b88:	e0bfc917 	ldw	r2,-220(fp)
 2008b8c:	10800210 	cmplti	r2,r2,8
 2008b90:	1000521e 	bne	r2,zero,2008cdc <___vfprintf_internal_r+0x1d70>
 2008b94:	e0bfc804 	addi	r2,fp,-224
 2008b98:	100d883a 	mov	r6,r2
 2008b9c:	e17fe717 	ldw	r5,-100(fp)
 2008ba0:	e13fe617 	ldw	r4,-104(fp)
 2008ba4:	2010df40 	call	2010df4 <__sprint_r>
 2008ba8:	1000f81e 	bne	r2,zero,2008f8c <___vfprintf_internal_r+0x2020>
 2008bac:	e47fcb04 	addi	r17,fp,-212
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
 2008bb0:	00004a06 	br	2008cdc <___vfprintf_internal_r+0x1d70>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
 2008bb4:	e0bfc717 	ldw	r2,-228(fp)
 2008bb8:	143fffc4 	addi	r16,r2,-1
 2008bbc:	0400470e 	bge	zero,r16,2008cdc <___vfprintf_internal_r+0x1d70>
 2008bc0:	00001706 	br	2008c20 <___vfprintf_internal_r+0x1cb4>
 2008bc4:	008080b4 	movhi	r2,514
 2008bc8:	10be0484 	addi	r2,r2,-2030
 2008bcc:	88800015 	stw	r2,0(r17)
 2008bd0:	00800404 	movi	r2,16
 2008bd4:	88800115 	stw	r2,4(r17)
 2008bd8:	e0bfca17 	ldw	r2,-216(fp)
 2008bdc:	10800404 	addi	r2,r2,16
 2008be0:	e0bfca15 	stw	r2,-216(fp)
 2008be4:	8c400204 	addi	r17,r17,8
 2008be8:	e0bfc917 	ldw	r2,-220(fp)
 2008bec:	10800044 	addi	r2,r2,1
 2008bf0:	e0bfc915 	stw	r2,-220(fp)
 2008bf4:	e0bfc917 	ldw	r2,-220(fp)
 2008bf8:	10800210 	cmplti	r2,r2,8
 2008bfc:	1000071e 	bne	r2,zero,2008c1c <___vfprintf_internal_r+0x1cb0>
 2008c00:	e0bfc804 	addi	r2,fp,-224
 2008c04:	100d883a 	mov	r6,r2
 2008c08:	e17fe717 	ldw	r5,-100(fp)
 2008c0c:	e13fe617 	ldw	r4,-104(fp)
 2008c10:	2010df40 	call	2010df4 <__sprint_r>
 2008c14:	1000df1e 	bne	r2,zero,2008f94 <___vfprintf_internal_r+0x2028>
 2008c18:	e47fcb04 	addi	r17,fp,-212
 2008c1c:	843ffc04 	addi	r16,r16,-16
 2008c20:	80800448 	cmpgei	r2,r16,17
 2008c24:	103fe71e 	bne	r2,zero,2008bc4 <___vfprintf_internal_r+0x1c58>
 2008c28:	008080b4 	movhi	r2,514
 2008c2c:	10be0484 	addi	r2,r2,-2030
 2008c30:	88800015 	stw	r2,0(r17)
 2008c34:	8005883a 	mov	r2,r16
 2008c38:	88800115 	stw	r2,4(r17)
 2008c3c:	e0bfca17 	ldw	r2,-216(fp)
 2008c40:	8007883a 	mov	r3,r16
 2008c44:	10c5883a 	add	r2,r2,r3
 2008c48:	e0bfca15 	stw	r2,-216(fp)
 2008c4c:	8c400204 	addi	r17,r17,8
 2008c50:	e0bfc917 	ldw	r2,-220(fp)
 2008c54:	10800044 	addi	r2,r2,1
 2008c58:	e0bfc915 	stw	r2,-220(fp)
 2008c5c:	e0bfc917 	ldw	r2,-220(fp)
 2008c60:	10800210 	cmplti	r2,r2,8
 2008c64:	10001d1e 	bne	r2,zero,2008cdc <___vfprintf_internal_r+0x1d70>
 2008c68:	e0bfc804 	addi	r2,fp,-224
 2008c6c:	100d883a 	mov	r6,r2
 2008c70:	e17fe717 	ldw	r5,-100(fp)
 2008c74:	e13fe617 	ldw	r4,-104(fp)
 2008c78:	2010df40 	call	2010df4 <__sprint_r>
 2008c7c:	1000c71e 	bne	r2,zero,2008f9c <___vfprintf_internal_r+0x2030>
 2008c80:	e47fcb04 	addi	r17,fp,-212
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
 2008c84:	00001506 	br	2008cdc <___vfprintf_internal_r+0x1d70>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
 2008c88:	8c800015 	stw	r18,0(r17)
 2008c8c:	00800044 	movi	r2,1
 2008c90:	88800115 	stw	r2,4(r17)
 2008c94:	e0bfca17 	ldw	r2,-216(fp)
 2008c98:	10800044 	addi	r2,r2,1
 2008c9c:	e0bfca15 	stw	r2,-216(fp)
 2008ca0:	8c400204 	addi	r17,r17,8
 2008ca4:	e0bfc917 	ldw	r2,-220(fp)
 2008ca8:	10800044 	addi	r2,r2,1
 2008cac:	e0bfc915 	stw	r2,-220(fp)
 2008cb0:	e0bfc917 	ldw	r2,-220(fp)
 2008cb4:	10800210 	cmplti	r2,r2,8
 2008cb8:	1000091e 	bne	r2,zero,2008ce0 <___vfprintf_internal_r+0x1d74>
 2008cbc:	e0bfc804 	addi	r2,fp,-224
 2008cc0:	100d883a 	mov	r6,r2
 2008cc4:	e17fe717 	ldw	r5,-100(fp)
 2008cc8:	e13fe617 	ldw	r4,-104(fp)
 2008ccc:	2010df40 	call	2010df4 <__sprint_r>
 2008cd0:	1000b41e 	bne	r2,zero,2008fa4 <___vfprintf_internal_r+0x2038>
 2008cd4:	e47fcb04 	addi	r17,fp,-212
 2008cd8:	00000106 	br	2008ce0 <___vfprintf_internal_r+0x1d74>
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
 2008cdc:	0001883a 	nop
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
				PRINT (expstr, expsize);
 2008ce0:	e0bfc504 	addi	r2,fp,-236
 2008ce4:	88800015 	stw	r2,0(r17)
 2008ce8:	e0bfaf17 	ldw	r2,-324(fp)
 2008cec:	88800115 	stw	r2,4(r17)
 2008cf0:	e0ffca17 	ldw	r3,-216(fp)
 2008cf4:	e0bfaf17 	ldw	r2,-324(fp)
 2008cf8:	1885883a 	add	r2,r3,r2
 2008cfc:	e0bfca15 	stw	r2,-216(fp)
 2008d00:	8c400204 	addi	r17,r17,8
 2008d04:	e0bfc917 	ldw	r2,-220(fp)
 2008d08:	10800044 	addi	r2,r2,1
 2008d0c:	e0bfc915 	stw	r2,-220(fp)
 2008d10:	e0bfc917 	ldw	r2,-220(fp)
 2008d14:	10800210 	cmplti	r2,r2,8
 2008d18:	1000071e 	bne	r2,zero,2008d38 <___vfprintf_internal_r+0x1dcc>
 2008d1c:	e0bfc804 	addi	r2,fp,-224
 2008d20:	100d883a 	mov	r6,r2
 2008d24:	e17fe717 	ldw	r5,-100(fp)
 2008d28:	e13fe617 	ldw	r4,-104(fp)
 2008d2c:	2010df40 	call	2010df4 <__sprint_r>
 2008d30:	10009e1e 	bne	r2,zero,2008fac <___vfprintf_internal_r+0x2040>
 2008d34:	e47fcb04 	addi	r17,fp,-212
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
 2008d38:	9880010c 	andi	r2,r19,4
 2008d3c:	10003526 	beq	r2,zero,2008e14 <___vfprintf_internal_r+0x1ea8>
			PAD (width - realsz, blanks);
 2008d40:	e0ffad17 	ldw	r3,-332(fp)
 2008d44:	e0bfb517 	ldw	r2,-300(fp)
 2008d48:	18a1c83a 	sub	r16,r3,r2
 2008d4c:	0400310e 	bge	zero,r16,2008e14 <___vfprintf_internal_r+0x1ea8>
 2008d50:	00001706 	br	2008db0 <___vfprintf_internal_r+0x1e44>
 2008d54:	008080b4 	movhi	r2,514
 2008d58:	10be0084 	addi	r2,r2,-2046
 2008d5c:	88800015 	stw	r2,0(r17)
 2008d60:	00800404 	movi	r2,16
 2008d64:	88800115 	stw	r2,4(r17)
 2008d68:	e0bfca17 	ldw	r2,-216(fp)
 2008d6c:	10800404 	addi	r2,r2,16
 2008d70:	e0bfca15 	stw	r2,-216(fp)
 2008d74:	8c400204 	addi	r17,r17,8
 2008d78:	e0bfc917 	ldw	r2,-220(fp)
 2008d7c:	10800044 	addi	r2,r2,1
 2008d80:	e0bfc915 	stw	r2,-220(fp)
 2008d84:	e0bfc917 	ldw	r2,-220(fp)
 2008d88:	10800210 	cmplti	r2,r2,8
 2008d8c:	1000071e 	bne	r2,zero,2008dac <___vfprintf_internal_r+0x1e40>
 2008d90:	e0bfc804 	addi	r2,fp,-224
 2008d94:	100d883a 	mov	r6,r2
 2008d98:	e17fe717 	ldw	r5,-100(fp)
 2008d9c:	e13fe617 	ldw	r4,-104(fp)
 2008da0:	2010df40 	call	2010df4 <__sprint_r>
 2008da4:	1000831e 	bne	r2,zero,2008fb4 <___vfprintf_internal_r+0x2048>
 2008da8:	e47fcb04 	addi	r17,fp,-212
 2008dac:	843ffc04 	addi	r16,r16,-16
 2008db0:	80800448 	cmpgei	r2,r16,17
 2008db4:	103fe71e 	bne	r2,zero,2008d54 <___vfprintf_internal_r+0x1de8>
 2008db8:	008080b4 	movhi	r2,514
 2008dbc:	10be0084 	addi	r2,r2,-2046
 2008dc0:	88800015 	stw	r2,0(r17)
 2008dc4:	8005883a 	mov	r2,r16
 2008dc8:	88800115 	stw	r2,4(r17)
 2008dcc:	e0bfca17 	ldw	r2,-216(fp)
 2008dd0:	8007883a 	mov	r3,r16
 2008dd4:	10c5883a 	add	r2,r2,r3
 2008dd8:	e0bfca15 	stw	r2,-216(fp)
 2008ddc:	8c400204 	addi	r17,r17,8
 2008de0:	e0bfc917 	ldw	r2,-220(fp)
 2008de4:	10800044 	addi	r2,r2,1
 2008de8:	e0bfc915 	stw	r2,-220(fp)
 2008dec:	e0bfc917 	ldw	r2,-220(fp)
 2008df0:	10800210 	cmplti	r2,r2,8
 2008df4:	1000071e 	bne	r2,zero,2008e14 <___vfprintf_internal_r+0x1ea8>
 2008df8:	e0bfc804 	addi	r2,fp,-224
 2008dfc:	100d883a 	mov	r6,r2
 2008e00:	e17fe717 	ldw	r5,-100(fp)
 2008e04:	e13fe617 	ldw	r4,-104(fp)
 2008e08:	2010df40 	call	2010df4 <__sprint_r>
 2008e0c:	10006b1e 	bne	r2,zero,2008fbc <___vfprintf_internal_r+0x2050>
 2008e10:	e47fcb04 	addi	r17,fp,-212

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
 2008e14:	e0ffad17 	ldw	r3,-332(fp)
 2008e18:	e0bfb517 	ldw	r2,-300(fp)
 2008e1c:	10c0010e 	bge	r2,r3,2008e24 <___vfprintf_internal_r+0x1eb8>
 2008e20:	1805883a 	mov	r2,r3
 2008e24:	e0ffac17 	ldw	r3,-336(fp)
 2008e28:	1885883a 	add	r2,r3,r2
 2008e2c:	e0bfac15 	stw	r2,-336(fp)

		FLUSH ();	/* copy out the I/O vectors */
 2008e30:	e0bfca17 	ldw	r2,-216(fp)
 2008e34:	10000626 	beq	r2,zero,2008e50 <___vfprintf_internal_r+0x1ee4>
 2008e38:	e0bfc804 	addi	r2,fp,-224
 2008e3c:	100d883a 	mov	r6,r2
 2008e40:	e17fe717 	ldw	r5,-100(fp)
 2008e44:	e13fe617 	ldw	r4,-104(fp)
 2008e48:	2010df40 	call	2010df4 <__sprint_r>
 2008e4c:	10005d1e 	bne	r2,zero,2008fc4 <___vfprintf_internal_r+0x2058>
 2008e50:	e03fc915 	stw	zero,-220(fp)
 2008e54:	e47fcb04 	addi	r17,fp,-212

                if (malloc_buf != NULL) {
 2008e58:	e0bfb817 	ldw	r2,-288(fp)
 2008e5c:	1038a026 	beq	r2,zero,20070e0 <___vfprintf_internal_r+0x174>
			_free_r (data, malloc_buf);
 2008e60:	e17fb817 	ldw	r5,-288(fp)
 2008e64:	e13fe617 	ldw	r4,-104(fp)
 2008e68:	200bdf80 	call	200bdf8 <_free_r>
			malloc_buf = NULL;
 2008e6c:	e03fb815 	stw	zero,-288(fp)
		}
	}
 2008e70:	00389b06 	br	20070e0 <___vfprintf_internal_r+0x174>
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
                    goto done;
 2008e74:	0001883a 	nop
 2008e78:	00000106 	br	2008e80 <___vfprintf_internal_r+0x1f14>
			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
 2008e7c:	0001883a 	nop
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
 2008e80:	e0bfca17 	ldw	r2,-216(fp)
 2008e84:	10000626 	beq	r2,zero,2008ea0 <___vfprintf_internal_r+0x1f34>
 2008e88:	e0bfc804 	addi	r2,fp,-224
 2008e8c:	100d883a 	mov	r6,r2
 2008e90:	e17fe717 	ldw	r5,-100(fp)
 2008e94:	e13fe617 	ldw	r4,-104(fp)
 2008e98:	2010df40 	call	2010df4 <__sprint_r>
 2008e9c:	10004b1e 	bne	r2,zero,2008fcc <___vfprintf_internal_r+0x2060>
 2008ea0:	e03fc915 	stw	zero,-220(fp)
 2008ea4:	e47fcb04 	addi	r17,fp,-212
 2008ea8:	00004906 	br	2008fd0 <___vfprintf_internal_r+0x2064>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
 2008eac:	0001883a 	nop
 2008eb0:	00004706 	br	2008fd0 <___vfprintf_internal_r+0x2064>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
 2008eb4:	0001883a 	nop
 2008eb8:	00004506 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008ebc:	0001883a 	nop
 2008ec0:	00004306 	br	2008fd0 <___vfprintf_internal_r+0x2064>

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
 2008ec4:	0001883a 	nop
 2008ec8:	00004106 	br	2008fd0 <___vfprintf_internal_r+0x2064>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
 2008ecc:	0001883a 	nop
 2008ed0:	00003f06 	br	2008fd0 <___vfprintf_internal_r+0x2064>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
 2008ed4:	0001883a 	nop
 2008ed8:	00003d06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008edc:	0001883a 	nop
 2008ee0:	00003b06 	br	2008fd0 <___vfprintf_internal_r+0x2064>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 2008ee4:	0001883a 	nop
 2008ee8:	00003906 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008eec:	0001883a 	nop
 2008ef0:	00003706 	br	2008fd0 <___vfprintf_internal_r+0x2064>

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
			PRINT (cp, size);
 2008ef4:	0001883a 	nop
 2008ef8:	00003506 	br	2008fd0 <___vfprintf_internal_r+0x2064>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
				if (_fpvalue == 0) {
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
 2008efc:	0001883a 	nop
 2008f00:	00003306 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					if (expt < ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
 2008f04:	0001883a 	nop
 2008f08:	00003106 	br	2008fd0 <___vfprintf_internal_r+0x2064>
						PAD (ndig - 1, zeroes);
 2008f0c:	0001883a 	nop
 2008f10:	00002f06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f14:	0001883a 	nop
 2008f18:	00002d06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					}
				} else if (expt <= 0) {
					PRINT ("0", 1);
 2008f1c:	0001883a 	nop
 2008f20:	00002b06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					if (expt || ndig || flags & ALT) {
						PRINT (decimal_point, decp_len);
 2008f24:	0001883a 	nop
 2008f28:	00002906 	br	2008fd0 <___vfprintf_internal_r+0x2064>
						PAD (-expt, zeroes);
 2008f2c:	0001883a 	nop
 2008f30:	00002706 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f34:	0001883a 	nop
 2008f38:	00002506 	br	2008fd0 <___vfprintf_internal_r+0x2064>
						PRINT (cp, ndig);
 2008f3c:	0001883a 	nop
 2008f40:	00002306 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					}
				} else {
					char *convbuf = cp;
					PRINTANDPAD(cp, convbuf + ndig,
 2008f44:	0001883a 	nop
 2008f48:	00002106 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f4c:	0001883a 	nop
 2008f50:	00001f06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f54:	0001883a 	nop
 2008f58:	00001d06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					    if (cp > convbuf + ndig)
						cp = convbuf + ndig;
					}
#endif
					if (expt < ndig || flags & ALT)
					    PRINT (decimal_point, decp_len);
 2008f5c:	0001883a 	nop
 2008f60:	00001b06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					PRINTANDPAD (cp, convbuf + ndig,
 2008f64:	0001883a 	nop
 2008f68:	00001906 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f6c:	0001883a 	nop
 2008f70:	00001706 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f74:	0001883a 	nop
 2008f78:	00001506 	br	2008fd0 <___vfprintf_internal_r+0x2064>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
 2008f7c:	0001883a 	nop
 2008f80:	00001306 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					cp++;
					PRINT (decimal_point, decp_len);
 2008f84:	0001883a 	nop
 2008f88:	00001106 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					if (_fpvalue) {
						PRINT (cp, ndig - 1);
 2008f8c:	0001883a 	nop
 2008f90:	00000f06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
 2008f94:	0001883a 	nop
 2008f98:	00000d06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008f9c:	0001883a 	nop
 2008fa0:	00000b06 	br	2008fd0 <___vfprintf_internal_r+0x2064>
				} else	/* XeYYY */
					PRINT (cp, 1);
 2008fa4:	0001883a 	nop
 2008fa8:	00000906 	br	2008fd0 <___vfprintf_internal_r+0x2064>
				PRINT (expstr, expsize);
 2008fac:	0001883a 	nop
 2008fb0:	00000706 	br	2008fd0 <___vfprintf_internal_r+0x2064>
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
 2008fb4:	0001883a 	nop
 2008fb8:	00000506 	br	2008fd0 <___vfprintf_internal_r+0x2064>
 2008fbc:	0001883a 	nop
 2008fc0:	00000306 	br	2008fd0 <___vfprintf_internal_r+0x2064>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
 2008fc4:	0001883a 	nop
 2008fc8:	00000106 	br	2008fd0 <___vfprintf_internal_r+0x2064>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
 2008fcc:	0001883a 	nop
error:
	if (malloc_buf != NULL)
 2008fd0:	e0bfb817 	ldw	r2,-288(fp)
 2008fd4:	10000326 	beq	r2,zero,2008fe4 <___vfprintf_internal_r+0x2078>
		_free_r (data, malloc_buf);
 2008fd8:	e17fb817 	ldw	r5,-288(fp)
 2008fdc:	e13fe617 	ldw	r4,-104(fp)
 2008fe0:	200bdf80 	call	200bdf8 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
 2008fe4:	e0bfe717 	ldw	r2,-100(fp)
 2008fe8:	1080030b 	ldhu	r2,12(r2)
 2008fec:	10bfffcc 	andi	r2,r2,65535
 2008ff0:	1080100c 	andi	r2,r2,64
 2008ff4:	1000021e 	bne	r2,zero,2009000 <___vfprintf_internal_r+0x2094>
 2008ff8:	e0bfac17 	ldw	r2,-336(fp)
 2008ffc:	00000206 	br	2009008 <___vfprintf_internal_r+0x209c>
 2009000:	00bfffc4 	movi	r2,-1
 2009004:	0001883a 	nop
	/* NOTREACHED */
}
 2009008:	e6fff804 	addi	sp,fp,-32
 200900c:	dfc00917 	ldw	ra,36(sp)
 2009010:	df000817 	ldw	fp,32(sp)
 2009014:	ddc00717 	ldw	r23,28(sp)
 2009018:	dd800617 	ldw	r22,24(sp)
 200901c:	dd400517 	ldw	r21,20(sp)
 2009020:	dd000417 	ldw	r20,16(sp)
 2009024:	dcc00317 	ldw	r19,12(sp)
 2009028:	dc800217 	ldw	r18,8(sp)
 200902c:	dc400117 	ldw	r17,4(sp)
 2009030:	dc000017 	ldw	r16,0(sp)
 2009034:	dec00a04 	addi	sp,sp,40
 2009038:	f800283a 	ret

0200903c <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
 200903c:	deffef04 	addi	sp,sp,-68
 2009040:	dfc01015 	stw	ra,64(sp)
 2009044:	df000f15 	stw	fp,60(sp)
 2009048:	df000f04 	addi	fp,sp,60
 200904c:	e13ffc15 	stw	r4,-16(fp)
 2009050:	e17ffd15 	stw	r5,-12(fp)
 2009054:	e1bffe15 	stw	r6,-8(fp)
 2009058:	e1ffff15 	stw	r7,-4(fp)
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
 200905c:	e0bffd17 	ldw	r2,-12(fp)
 2009060:	e0bffa15 	stw	r2,-24(fp)
 2009064:	e0bffe17 	ldw	r2,-8(fp)
 2009068:	e0bffb15 	stw	r2,-20(fp)
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
 200906c:	e0bffb17 	ldw	r2,-20(fp)
 2009070:	1000090e 	bge	r2,zero,2009098 <cvt+0x5c>
		value = -value;
 2009074:	e0bffd17 	ldw	r2,-12(fp)
 2009078:	e0bffd15 	stw	r2,-12(fp)
 200907c:	e0bffe17 	ldw	r2,-8(fp)
 2009080:	10a0003c 	xorhi	r2,r2,32768
 2009084:	e0bffe15 	stw	r2,-8(fp)
		*sign = '-';
 2009088:	e0800317 	ldw	r2,12(fp)
 200908c:	00c00b44 	movi	r3,45
 2009090:	10c00005 	stb	r3,0(r2)
 2009094:	00000206 	br	20090a0 <cvt+0x64>
	} else
		*sign = '\000';
 2009098:	e0800317 	ldw	r2,12(fp)
 200909c:	10000005 	stb	zero,0(r2)
		}
		*length = bp - buf;
		return buf;
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
 20090a0:	e0800517 	ldw	r2,20(fp)
 20090a4:	108019a0 	cmpeqi	r2,r2,102
 20090a8:	1000031e 	bne	r2,zero,20090b8 <cvt+0x7c>
 20090ac:	e0800517 	ldw	r2,20(fp)
 20090b0:	10801198 	cmpnei	r2,r2,70
 20090b4:	1000031e 	bne	r2,zero,20090c4 <cvt+0x88>
		mode = 3;		/* ndigits after the decimal point */
 20090b8:	008000c4 	movi	r2,3
 20090bc:	e0bff515 	stw	r2,-44(fp)
 20090c0:	00000b06 	br	20090f0 <cvt+0xb4>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
 20090c4:	e0800517 	ldw	r2,20(fp)
 20090c8:	10801960 	cmpeqi	r2,r2,101
 20090cc:	1000031e 	bne	r2,zero,20090dc <cvt+0xa0>
 20090d0:	e0800517 	ldw	r2,20(fp)
 20090d4:	10801158 	cmpnei	r2,r2,69
 20090d8:	1000031e 	bne	r2,zero,20090e8 <cvt+0xac>
			ndigits++;
 20090dc:	e0bfff17 	ldw	r2,-4(fp)
 20090e0:	10800044 	addi	r2,r2,1
 20090e4:	e0bfff15 	stw	r2,-4(fp)
		}
		mode = 2;		/* ndigits significant digits */
 20090e8:	00800084 	movi	r2,2
 20090ec:	e0bff515 	stw	r2,-44(fp)
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
 20090f0:	e0bff904 	addi	r2,fp,-28
 20090f4:	d8800315 	stw	r2,12(sp)
 20090f8:	e0bff804 	addi	r2,fp,-32
 20090fc:	d8800215 	stw	r2,8(sp)
 2009100:	e0800417 	ldw	r2,16(fp)
 2009104:	d8800115 	stw	r2,4(sp)
 2009108:	e0bfff17 	ldw	r2,-4(fp)
 200910c:	d8800015 	stw	r2,0(sp)
 2009110:	e1fff517 	ldw	r7,-44(fp)
 2009114:	e17ffd17 	ldw	r5,-12(fp)
 2009118:	e1bffe17 	ldw	r6,-8(fp)
 200911c:	e13ffc17 	ldw	r4,-16(fp)
 2009120:	20098dc0 	call	20098dc <_dtoa_r>
 2009124:	e0bff715 	stw	r2,-36(fp)

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
 2009128:	e0800517 	ldw	r2,20(fp)
 200912c:	108019e0 	cmpeqi	r2,r2,103
 2009130:	1000031e 	bne	r2,zero,2009140 <cvt+0x104>
 2009134:	e0800517 	ldw	r2,20(fp)
 2009138:	108011d8 	cmpnei	r2,r2,71
 200913c:	1000031e 	bne	r2,zero,200914c <cvt+0x110>
 2009140:	e0800217 	ldw	r2,8(fp)
 2009144:	1080004c 	andi	r2,r2,1
 2009148:	10003326 	beq	r2,zero,2009218 <cvt+0x1dc>
		bp = digits + ndigits;
 200914c:	e0bfff17 	ldw	r2,-4(fp)
 2009150:	e0fff717 	ldw	r3,-36(fp)
 2009154:	1885883a 	add	r2,r3,r2
 2009158:	e0bff615 	stw	r2,-40(fp)
		if (ch == 'f' || ch == 'F') {
 200915c:	e0800517 	ldw	r2,20(fp)
 2009160:	108019a0 	cmpeqi	r2,r2,102
 2009164:	1000031e 	bne	r2,zero,2009174 <cvt+0x138>
 2009168:	e0800517 	ldw	r2,20(fp)
 200916c:	10801198 	cmpnei	r2,r2,70
 2009170:	1000181e 	bne	r2,zero,20091d4 <cvt+0x198>
			if (*digits == '0' && value)
 2009174:	e0bff717 	ldw	r2,-36(fp)
 2009178:	10800003 	ldbu	r2,0(r2)
 200917c:	10803fcc 	andi	r2,r2,255
 2009180:	1080201c 	xori	r2,r2,128
 2009184:	10bfe004 	addi	r2,r2,-128
 2009188:	10800c18 	cmpnei	r2,r2,48
 200918c:	10000b1e 	bne	r2,zero,20091bc <cvt+0x180>
 2009190:	000d883a 	mov	r6,zero
 2009194:	000f883a 	mov	r7,zero
 2009198:	e13ffd17 	ldw	r4,-12(fp)
 200919c:	e17ffe17 	ldw	r5,-8(fp)
 20091a0:	20052280 	call	2005228 <__eqdf2>
 20091a4:	10000526 	beq	r2,zero,20091bc <cvt+0x180>
				*decpt = -ndigits + 1;
 20091a8:	00c00044 	movi	r3,1
 20091ac:	e0bfff17 	ldw	r2,-4(fp)
 20091b0:	1887c83a 	sub	r3,r3,r2
 20091b4:	e0800417 	ldw	r2,16(fp)
 20091b8:	10c00015 	stw	r3,0(r2)
			bp += *decpt;
 20091bc:	e0800417 	ldw	r2,16(fp)
 20091c0:	10800017 	ldw	r2,0(r2)
 20091c4:	1007883a 	mov	r3,r2
 20091c8:	e0bff617 	ldw	r2,-40(fp)
 20091cc:	10c5883a 	add	r2,r2,r3
 20091d0:	e0bff615 	stw	r2,-40(fp)
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
 20091d4:	000d883a 	mov	r6,zero
 20091d8:	000f883a 	mov	r7,zero
 20091dc:	e13ffd17 	ldw	r4,-12(fp)
 20091e0:	e17ffe17 	ldw	r5,-8(fp)
 20091e4:	20052280 	call	2005228 <__eqdf2>
 20091e8:	1000081e 	bne	r2,zero,200920c <cvt+0x1d0>
			rve = bp;
 20091ec:	e0bff617 	ldw	r2,-40(fp)
 20091f0:	e0bff915 	stw	r2,-28(fp)
		while (rve < bp)
 20091f4:	00000506 	br	200920c <cvt+0x1d0>
			*rve++ = '0';
 20091f8:	e0bff917 	ldw	r2,-28(fp)
 20091fc:	10c00044 	addi	r3,r2,1
 2009200:	e0fff915 	stw	r3,-28(fp)
 2009204:	00c00c04 	movi	r3,48
 2009208:	10c00005 	stb	r3,0(r2)
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
 200920c:	e0fff917 	ldw	r3,-28(fp)
 2009210:	e0bff617 	ldw	r2,-40(fp)
 2009214:	18bff836 	bltu	r3,r2,20091f8 <cvt+0x1bc>
			*rve++ = '0';
	}
	*length = rve - digits;
 2009218:	e0bff917 	ldw	r2,-28(fp)
 200921c:	1007883a 	mov	r3,r2
 2009220:	e0bff717 	ldw	r2,-36(fp)
 2009224:	1887c83a 	sub	r3,r3,r2
 2009228:	e0800617 	ldw	r2,24(fp)
 200922c:	10c00015 	stw	r3,0(r2)
	return (digits);
 2009230:	e0bff717 	ldw	r2,-36(fp)
}
 2009234:	e037883a 	mov	sp,fp
 2009238:	dfc00117 	ldw	ra,4(sp)
 200923c:	df000017 	ldw	fp,0(sp)
 2009240:	dec00204 	addi	sp,sp,8
 2009244:	f800283a 	ret

02009248 <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
 2009248:	defff704 	addi	sp,sp,-36
 200924c:	dfc00815 	stw	ra,32(sp)
 2009250:	df000715 	stw	fp,28(sp)
 2009254:	dc400615 	stw	r17,24(sp)
 2009258:	dc000515 	stw	r16,20(sp)
 200925c:	df000704 	addi	fp,sp,28
 2009260:	e13ffb15 	stw	r4,-20(fp)
 2009264:	e17ffc15 	stw	r5,-16(fp)
 2009268:	e1bffd15 	stw	r6,-12(fp)
	int isa = fmtch == 'a' || fmtch == 'A';
# else
#  define isa 0
# endif

	p = p0;
 200926c:	e47ffb17 	ldw	r17,-20(fp)
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
 2009270:	8805883a 	mov	r2,r17
 2009274:	14400044 	addi	r17,r2,1
 2009278:	e0fffd17 	ldw	r3,-12(fp)
 200927c:	10c00005 	stb	r3,0(r2)
	if (exp < 0) {
 2009280:	e0bffc17 	ldw	r2,-16(fp)
 2009284:	1000080e 	bge	r2,zero,20092a8 <exponent+0x60>
		exp = -exp;
 2009288:	e0bffc17 	ldw	r2,-16(fp)
 200928c:	0085c83a 	sub	r2,zero,r2
 2009290:	e0bffc15 	stw	r2,-16(fp)
		*p++ = '-';
 2009294:	8805883a 	mov	r2,r17
 2009298:	14400044 	addi	r17,r2,1
 200929c:	00c00b44 	movi	r3,45
 20092a0:	10c00005 	stb	r3,0(r2)
 20092a4:	00000406 	br	20092b8 <exponent+0x70>
	}
	else
		*p++ = '+';
 20092a8:	8805883a 	mov	r2,r17
 20092ac:	14400044 	addi	r17,r2,1
 20092b0:	00c00ac4 	movi	r3,43
 20092b4:	10c00005 	stb	r3,0(r2)
	t = expbuf + MAXEXPLEN;
 20092b8:	e43ffac4 	addi	r16,fp,-21
	if (exp > 9) {
 20092bc:	e0bffc17 	ldw	r2,-16(fp)
 20092c0:	10800290 	cmplti	r2,r2,10
 20092c4:	10001d1e 	bne	r2,zero,200933c <exponent+0xf4>
		do {
			*--t = to_char (exp % 10);
 20092c8:	843fffc4 	addi	r16,r16,-1
 20092cc:	e0bffc17 	ldw	r2,-16(fp)
 20092d0:	01400284 	movi	r5,10
 20092d4:	1009883a 	mov	r4,r2
 20092d8:	2003f640 	call	2003f64 <__modsi3>
 20092dc:	10800c04 	addi	r2,r2,48
 20092e0:	80800005 	stb	r2,0(r16)
		} while ((exp /= 10) > 9);
 20092e4:	e0bffc17 	ldw	r2,-16(fp)
 20092e8:	01400284 	movi	r5,10
 20092ec:	1009883a 	mov	r4,r2
 20092f0:	2003ee00 	call	2003ee0 <__divsi3>
 20092f4:	e0bffc15 	stw	r2,-16(fp)
 20092f8:	e0bffc17 	ldw	r2,-16(fp)
 20092fc:	10800288 	cmpgei	r2,r2,10
 2009300:	103ff11e 	bne	r2,zero,20092c8 <exponent+0x80>
		*--t = to_char (exp);
 2009304:	843fffc4 	addi	r16,r16,-1
 2009308:	e0bffc17 	ldw	r2,-16(fp)
 200930c:	10800c04 	addi	r2,r2,48
 2009310:	80800005 	stb	r2,0(r16)
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
 2009314:	00000606 	br	2009330 <exponent+0xe8>
 2009318:	8805883a 	mov	r2,r17
 200931c:	14400044 	addi	r17,r2,1
 2009320:	8007883a 	mov	r3,r16
 2009324:	1c000044 	addi	r16,r3,1
 2009328:	18c00003 	ldbu	r3,0(r3)
 200932c:	10c00005 	stb	r3,0(r2)
 2009330:	e0bffac4 	addi	r2,fp,-21
 2009334:	80bff836 	bltu	r16,r2,2009318 <exponent+0xd0>
 2009338:	00000906 	br	2009360 <exponent+0x118>
	}
	else {
		if (!isa)
			*p++ = '0';
 200933c:	8805883a 	mov	r2,r17
 2009340:	14400044 	addi	r17,r2,1
 2009344:	00c00c04 	movi	r3,48
 2009348:	10c00005 	stb	r3,0(r2)
		*p++ = to_char (exp);
 200934c:	8805883a 	mov	r2,r17
 2009350:	14400044 	addi	r17,r2,1
 2009354:	e0fffc17 	ldw	r3,-16(fp)
 2009358:	18c00c04 	addi	r3,r3,48
 200935c:	10c00005 	stb	r3,0(r2)
	}
	return (p - p0);
 2009360:	8807883a 	mov	r3,r17
 2009364:	e0bffb17 	ldw	r2,-20(fp)
 2009368:	1885c83a 	sub	r2,r3,r2
}
 200936c:	e6fffe04 	addi	sp,fp,-8
 2009370:	dfc00317 	ldw	ra,12(sp)
 2009374:	df000217 	ldw	fp,8(sp)
 2009378:	dc400117 	ldw	r17,4(sp)
 200937c:	dc000017 	ldw	r16,0(sp)
 2009380:	dec00404 	addi	sp,sp,16
 2009384:	f800283a 	ret

02009388 <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 2009388:	defffb04 	addi	sp,sp,-20
 200938c:	dfc00415 	stw	ra,16(sp)
 2009390:	df000315 	stw	fp,12(sp)
 2009394:	dc000215 	stw	r16,8(sp)
 2009398:	df000304 	addi	fp,sp,12
 200939c:	e13ffe15 	stw	r4,-8(fp)
 20093a0:	2821883a 	mov	r16,r5
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
 20093a4:	d0a00617 	ldw	r2,-32744(gp)
 20093a8:	e0bffd15 	stw	r2,-12(fp)
 20093ac:	e0bffd17 	ldw	r2,-12(fp)
 20093b0:	10000526 	beq	r2,zero,20093c8 <__swsetup_r+0x40>
 20093b4:	e0bffd17 	ldw	r2,-12(fp)
 20093b8:	10800e17 	ldw	r2,56(r2)
 20093bc:	1000021e 	bne	r2,zero,20093c8 <__swsetup_r+0x40>
 20093c0:	e13ffd17 	ldw	r4,-12(fp)
 20093c4:	200bbd80 	call	200bbd8 <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
 20093c8:	8080030b 	ldhu	r2,12(r16)
 20093cc:	10bfffcc 	andi	r2,r2,65535
 20093d0:	1080020c 	andi	r2,r2,8
 20093d4:	1000241e 	bne	r2,zero,2009468 <__swsetup_r+0xe0>
    {
      if ((fp->_flags & __SRW) == 0)
 20093d8:	8080030b 	ldhu	r2,12(r16)
 20093dc:	10bfffcc 	andi	r2,r2,65535
 20093e0:	1080040c 	andi	r2,r2,16
 20093e4:	1000081e 	bne	r2,zero,2009408 <__swsetup_r+0x80>
        {
	  ptr->_errno = EBADF;
 20093e8:	e0bffe17 	ldw	r2,-8(fp)
 20093ec:	00c00244 	movi	r3,9
 20093f0:	10c00015 	stw	r3,0(r2)
	  fp->_flags |= __SERR;
 20093f4:	8080030b 	ldhu	r2,12(r16)
 20093f8:	10801014 	ori	r2,r2,64
 20093fc:	8080030d 	sth	r2,12(r16)
	  return EOF;
 2009400:	00bfffc4 	movi	r2,-1
 2009404:	00004206 	br	2009510 <__swsetup_r+0x188>
        }
      if (fp->_flags & __SRD)
 2009408:	8080030b 	ldhu	r2,12(r16)
 200940c:	10bfffcc 	andi	r2,r2,65535
 2009410:	1080010c 	andi	r2,r2,4
 2009414:	10001126 	beq	r2,zero,200945c <__swsetup_r+0xd4>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
 2009418:	80800c17 	ldw	r2,48(r16)
 200941c:	10000826 	beq	r2,zero,2009440 <__swsetup_r+0xb8>
	    FREEUB (ptr, fp);
 2009420:	80c00c17 	ldw	r3,48(r16)
 2009424:	80801004 	addi	r2,r16,64
 2009428:	18800426 	beq	r3,r2,200943c <__swsetup_r+0xb4>
 200942c:	80800c17 	ldw	r2,48(r16)
 2009430:	100b883a 	mov	r5,r2
 2009434:	e13ffe17 	ldw	r4,-8(fp)
 2009438:	200bdf80 	call	200bdf8 <_free_r>
 200943c:	80000c15 	stw	zero,48(r16)
	  fp->_flags &= ~(__SRD | __SEOF);
 2009440:	80c0030b 	ldhu	r3,12(r16)
 2009444:	00bff6c4 	movi	r2,-37
 2009448:	1884703a 	and	r2,r3,r2
 200944c:	8080030d 	sth	r2,12(r16)
	  fp->_r = 0;
 2009450:	80000115 	stw	zero,4(r16)
	  fp->_p = fp->_bf._base;
 2009454:	80800417 	ldw	r2,16(r16)
 2009458:	80800015 	stw	r2,0(r16)
	}
      fp->_flags |= __SWR;
 200945c:	8080030b 	ldhu	r2,12(r16)
 2009460:	10800214 	ori	r2,r2,8
 2009464:	8080030d 	sth	r2,12(r16)
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
 2009468:	80800417 	ldw	r2,16(r16)
 200946c:	10000b1e 	bne	r2,zero,200949c <__swsetup_r+0x114>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
 2009470:	8080030b 	ldhu	r2,12(r16)
 2009474:	10bfffcc 	andi	r2,r2,65535
 2009478:	1080800c 	andi	r2,r2,512
 200947c:	10000426 	beq	r2,zero,2009490 <__swsetup_r+0x108>
 2009480:	8080030b 	ldhu	r2,12(r16)
 2009484:	10bfffcc 	andi	r2,r2,65535
 2009488:	1080200c 	andi	r2,r2,128
 200948c:	10000326 	beq	r2,zero,200949c <__swsetup_r+0x114>
    __smakebuf_r (ptr, fp);
 2009490:	800b883a 	mov	r5,r16
 2009494:	e13ffe17 	ldw	r4,-8(fp)
 2009498:	200ce580 	call	200ce58 <__smakebuf_r>

  if (fp->_flags & __SLBF)
 200949c:	8080030b 	ldhu	r2,12(r16)
 20094a0:	10bfffcc 	andi	r2,r2,65535
 20094a4:	1080004c 	andi	r2,r2,1
 20094a8:	10000526 	beq	r2,zero,20094c0 <__swsetup_r+0x138>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
 20094ac:	80000215 	stw	zero,8(r16)
      fp->_lbfsize = -fp->_bf._size;
 20094b0:	80800517 	ldw	r2,20(r16)
 20094b4:	0085c83a 	sub	r2,zero,r2
 20094b8:	80800615 	stw	r2,24(r16)
 20094bc:	00000806 	br	20094e0 <__swsetup_r+0x158>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
 20094c0:	8080030b 	ldhu	r2,12(r16)
 20094c4:	10bfffcc 	andi	r2,r2,65535
 20094c8:	1080008c 	andi	r2,r2,2
 20094cc:	1000021e 	bne	r2,zero,20094d8 <__swsetup_r+0x150>
 20094d0:	80800517 	ldw	r2,20(r16)
 20094d4:	00000106 	br	20094dc <__swsetup_r+0x154>
 20094d8:	0005883a 	mov	r2,zero
 20094dc:	80800215 	stw	r2,8(r16)

  if (!fp->_bf._base && (fp->_flags & __SMBF))
 20094e0:	80800417 	ldw	r2,16(r16)
 20094e4:	1000091e 	bne	r2,zero,200950c <__swsetup_r+0x184>
 20094e8:	8080030b 	ldhu	r2,12(r16)
 20094ec:	10bfffcc 	andi	r2,r2,65535
 20094f0:	1080200c 	andi	r2,r2,128
 20094f4:	10000526 	beq	r2,zero,200950c <__swsetup_r+0x184>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
 20094f8:	8080030b 	ldhu	r2,12(r16)
 20094fc:	10801014 	ori	r2,r2,64
 2009500:	8080030d 	sth	r2,12(r16)
      return EOF;
 2009504:	00bfffc4 	movi	r2,-1
 2009508:	00000106 	br	2009510 <__swsetup_r+0x188>
    }
  return 0;
 200950c:	0005883a 	mov	r2,zero
}
 2009510:	e6ffff04 	addi	sp,fp,-4
 2009514:	dfc00217 	ldw	ra,8(sp)
 2009518:	df000117 	ldw	fp,4(sp)
 200951c:	dc000017 	ldw	r16,0(sp)
 2009520:	dec00304 	addi	sp,sp,12
 2009524:	f800283a 	ret

02009528 <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
 2009528:	deffef04 	addi	sp,sp,-68
 200952c:	dfc01015 	stw	ra,64(sp)
 2009530:	df000f15 	stw	fp,60(sp)
 2009534:	df000f04 	addi	fp,sp,60
 2009538:	e13ffe15 	stw	r4,-8(fp)
 200953c:	e17fff15 	stw	r5,-4(fp)
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
 2009540:	e0bfff17 	ldw	r2,-4(fp)
 2009544:	10800417 	ldw	r2,16(r2)
 2009548:	e0bff115 	stw	r2,-60(fp)
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
 200954c:	e0bffe17 	ldw	r2,-8(fp)
 2009550:	10c00417 	ldw	r3,16(r2)
 2009554:	e0bff117 	ldw	r2,-60(fp)
 2009558:	1880020e 	bge	r3,r2,2009564 <quorem+0x3c>
    return 0;
 200955c:	0005883a 	mov	r2,zero
 2009560:	0000d906 	br	20098c8 <quorem+0x3a0>
  sx = S->_x;
 2009564:	e0bfff17 	ldw	r2,-4(fp)
 2009568:	10800504 	addi	r2,r2,20
 200956c:	e0bff715 	stw	r2,-36(fp)
  sxe = sx + --n;
 2009570:	e0bff117 	ldw	r2,-60(fp)
 2009574:	10bfffc4 	addi	r2,r2,-1
 2009578:	e0bff115 	stw	r2,-60(fp)
 200957c:	e0bff117 	ldw	r2,-60(fp)
 2009580:	1085883a 	add	r2,r2,r2
 2009584:	1085883a 	add	r2,r2,r2
 2009588:	1007883a 	mov	r3,r2
 200958c:	e0bff717 	ldw	r2,-36(fp)
 2009590:	10c5883a 	add	r2,r2,r3
 2009594:	e0bff815 	stw	r2,-32(fp)
  bx = b->_x;
 2009598:	e0bffe17 	ldw	r2,-8(fp)
 200959c:	10800504 	addi	r2,r2,20
 20095a0:	e0bff515 	stw	r2,-44(fp)
  bxe = bx + n;
 20095a4:	e0bff117 	ldw	r2,-60(fp)
 20095a8:	1085883a 	add	r2,r2,r2
 20095ac:	1085883a 	add	r2,r2,r2
 20095b0:	1007883a 	mov	r3,r2
 20095b4:	e0bff517 	ldw	r2,-44(fp)
 20095b8:	10c5883a 	add	r2,r2,r3
 20095bc:	e0bff615 	stw	r2,-40(fp)
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
 20095c0:	e0bff617 	ldw	r2,-40(fp)
 20095c4:	10c00017 	ldw	r3,0(r2)
 20095c8:	e0bff817 	ldw	r2,-32(fp)
 20095cc:	10800017 	ldw	r2,0(r2)
 20095d0:	10800044 	addi	r2,r2,1
 20095d4:	100b883a 	mov	r5,r2
 20095d8:	1809883a 	mov	r4,r3
 20095dc:	2003fd80 	call	2003fd8 <__udivsi3>
 20095e0:	e0bff415 	stw	r2,-48(fp)
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
 20095e4:	e0bff417 	ldw	r2,-48(fp)
 20095e8:	10005326 	beq	r2,zero,2009738 <quorem+0x210>
    {
      borrow = 0;
 20095ec:	e03ff215 	stw	zero,-56(fp)
      carry = 0;
 20095f0:	e03ff315 	stw	zero,-52(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 20095f4:	e0bff717 	ldw	r2,-36(fp)
 20095f8:	10c00104 	addi	r3,r2,4
 20095fc:	e0fff715 	stw	r3,-36(fp)
 2009600:	10800017 	ldw	r2,0(r2)
 2009604:	e0bff915 	stw	r2,-28(fp)
	  ys = (si & 0xffff) * q + carry;
 2009608:	e0bff917 	ldw	r2,-28(fp)
 200960c:	10ffffcc 	andi	r3,r2,65535
 2009610:	e0bff417 	ldw	r2,-48(fp)
 2009614:	1887383a 	mul	r3,r3,r2
 2009618:	e0bff317 	ldw	r2,-52(fp)
 200961c:	1885883a 	add	r2,r3,r2
 2009620:	e0bffa15 	stw	r2,-24(fp)
	  zs = (si >> 16) * q + (ys >> 16);
 2009624:	e0bff917 	ldw	r2,-28(fp)
 2009628:	1006d43a 	srli	r3,r2,16
 200962c:	e0bff417 	ldw	r2,-48(fp)
 2009630:	1887383a 	mul	r3,r3,r2
 2009634:	e0bffa17 	ldw	r2,-24(fp)
 2009638:	1004d43a 	srli	r2,r2,16
 200963c:	1885883a 	add	r2,r3,r2
 2009640:	e0bffb15 	stw	r2,-20(fp)
	  carry = zs >> 16;
 2009644:	e0bffb17 	ldw	r2,-20(fp)
 2009648:	1004d43a 	srli	r2,r2,16
 200964c:	e0bff315 	stw	r2,-52(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 2009650:	e0bff517 	ldw	r2,-44(fp)
 2009654:	10800017 	ldw	r2,0(r2)
 2009658:	10ffffcc 	andi	r3,r2,65535
 200965c:	e0bffa17 	ldw	r2,-24(fp)
 2009660:	10bfffcc 	andi	r2,r2,65535
 2009664:	1887c83a 	sub	r3,r3,r2
 2009668:	e0bff217 	ldw	r2,-56(fp)
 200966c:	1885883a 	add	r2,r3,r2
 2009670:	e0bffc15 	stw	r2,-16(fp)
	  borrow = y >> 16;
 2009674:	e0bffc17 	ldw	r2,-16(fp)
 2009678:	1005d43a 	srai	r2,r2,16
 200967c:	e0bff215 	stw	r2,-56(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 2009680:	e0bff517 	ldw	r2,-44(fp)
 2009684:	10800017 	ldw	r2,0(r2)
 2009688:	1006d43a 	srli	r3,r2,16
 200968c:	e0bffb17 	ldw	r2,-20(fp)
 2009690:	10bfffcc 	andi	r2,r2,65535
 2009694:	1887c83a 	sub	r3,r3,r2
 2009698:	e0bff217 	ldw	r2,-56(fp)
 200969c:	1885883a 	add	r2,r3,r2
 20096a0:	e0bffd15 	stw	r2,-12(fp)
	  borrow = z >> 16;
 20096a4:	e0bffd17 	ldw	r2,-12(fp)
 20096a8:	1005d43a 	srai	r2,r2,16
 20096ac:	e0bff215 	stw	r2,-56(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 20096b0:	e0bff517 	ldw	r2,-44(fp)
 20096b4:	10c00104 	addi	r3,r2,4
 20096b8:	e0fff515 	stw	r3,-44(fp)
 20096bc:	e0fffd17 	ldw	r3,-12(fp)
 20096c0:	1808943a 	slli	r4,r3,16
 20096c4:	e0fffc17 	ldw	r3,-16(fp)
 20096c8:	18ffffcc 	andi	r3,r3,65535
 20096cc:	20c6b03a 	or	r3,r4,r3
 20096d0:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 20096d4:	e0bff717 	ldw	r2,-36(fp)
 20096d8:	e0fff817 	ldw	r3,-32(fp)
 20096dc:	18bfc52e 	bgeu	r3,r2,20095f4 <quorem+0xcc>
      if (!*bxe)
 20096e0:	e0bff617 	ldw	r2,-40(fp)
 20096e4:	10800017 	ldw	r2,0(r2)
 20096e8:	1000131e 	bne	r2,zero,2009738 <quorem+0x210>
	{
	  bx = b->_x;
 20096ec:	e0bffe17 	ldw	r2,-8(fp)
 20096f0:	10800504 	addi	r2,r2,20
 20096f4:	e0bff515 	stw	r2,-44(fp)
	  while (--bxe > bx && !*bxe)
 20096f8:	00000306 	br	2009708 <quorem+0x1e0>
	    --n;
 20096fc:	e0bff117 	ldw	r2,-60(fp)
 2009700:	10bfffc4 	addi	r2,r2,-1
 2009704:	e0bff115 	stw	r2,-60(fp)
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
 2009708:	e0bff617 	ldw	r2,-40(fp)
 200970c:	10bfff04 	addi	r2,r2,-4
 2009710:	e0bff615 	stw	r2,-40(fp)
 2009714:	e0bff617 	ldw	r2,-40(fp)
 2009718:	e0fff517 	ldw	r3,-44(fp)
 200971c:	1880032e 	bgeu	r3,r2,200972c <quorem+0x204>
 2009720:	e0bff617 	ldw	r2,-40(fp)
 2009724:	10800017 	ldw	r2,0(r2)
 2009728:	103ff426 	beq	r2,zero,20096fc <quorem+0x1d4>
	    --n;
	  b->_wds = n;
 200972c:	e0bffe17 	ldw	r2,-8(fp)
 2009730:	e0fff117 	ldw	r3,-60(fp)
 2009734:	10c00415 	stw	r3,16(r2)
	}
    }
  if (cmp (b, S) >= 0)
 2009738:	e17fff17 	ldw	r5,-4(fp)
 200973c:	e13ffe17 	ldw	r4,-8(fp)
 2009740:	200f1580 	call	200f158 <__mcmp>
 2009744:	10005f16 	blt	r2,zero,20098c4 <quorem+0x39c>
    {
      q++;
 2009748:	e0bff417 	ldw	r2,-48(fp)
 200974c:	10800044 	addi	r2,r2,1
 2009750:	e0bff415 	stw	r2,-48(fp)
      borrow = 0;
 2009754:	e03ff215 	stw	zero,-56(fp)
      carry = 0;
 2009758:	e03ff315 	stw	zero,-52(fp)
      bx = b->_x;
 200975c:	e0bffe17 	ldw	r2,-8(fp)
 2009760:	10800504 	addi	r2,r2,20
 2009764:	e0bff515 	stw	r2,-44(fp)
      sx = S->_x;
 2009768:	e0bfff17 	ldw	r2,-4(fp)
 200976c:	10800504 	addi	r2,r2,20
 2009770:	e0bff715 	stw	r2,-36(fp)
      do
	{
#ifdef Pack_32
	  si = *sx++;
 2009774:	e0bff717 	ldw	r2,-36(fp)
 2009778:	10c00104 	addi	r3,r2,4
 200977c:	e0fff715 	stw	r3,-36(fp)
 2009780:	10800017 	ldw	r2,0(r2)
 2009784:	e0bff915 	stw	r2,-28(fp)
	  ys = (si & 0xffff) + carry;
 2009788:	e0bff917 	ldw	r2,-28(fp)
 200978c:	10ffffcc 	andi	r3,r2,65535
 2009790:	e0bff317 	ldw	r2,-52(fp)
 2009794:	1885883a 	add	r2,r3,r2
 2009798:	e0bffa15 	stw	r2,-24(fp)
	  zs = (si >> 16) + (ys >> 16);
 200979c:	e0bff917 	ldw	r2,-28(fp)
 20097a0:	1006d43a 	srli	r3,r2,16
 20097a4:	e0bffa17 	ldw	r2,-24(fp)
 20097a8:	1004d43a 	srli	r2,r2,16
 20097ac:	1885883a 	add	r2,r3,r2
 20097b0:	e0bffb15 	stw	r2,-20(fp)
	  carry = zs >> 16;
 20097b4:	e0bffb17 	ldw	r2,-20(fp)
 20097b8:	1004d43a 	srli	r2,r2,16
 20097bc:	e0bff315 	stw	r2,-52(fp)
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
 20097c0:	e0bff517 	ldw	r2,-44(fp)
 20097c4:	10800017 	ldw	r2,0(r2)
 20097c8:	10ffffcc 	andi	r3,r2,65535
 20097cc:	e0bffa17 	ldw	r2,-24(fp)
 20097d0:	10bfffcc 	andi	r2,r2,65535
 20097d4:	1887c83a 	sub	r3,r3,r2
 20097d8:	e0bff217 	ldw	r2,-56(fp)
 20097dc:	1885883a 	add	r2,r3,r2
 20097e0:	e0bffc15 	stw	r2,-16(fp)
	  borrow = y >> 16;
 20097e4:	e0bffc17 	ldw	r2,-16(fp)
 20097e8:	1005d43a 	srai	r2,r2,16
 20097ec:	e0bff215 	stw	r2,-56(fp)
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
 20097f0:	e0bff517 	ldw	r2,-44(fp)
 20097f4:	10800017 	ldw	r2,0(r2)
 20097f8:	1006d43a 	srli	r3,r2,16
 20097fc:	e0bffb17 	ldw	r2,-20(fp)
 2009800:	10bfffcc 	andi	r2,r2,65535
 2009804:	1887c83a 	sub	r3,r3,r2
 2009808:	e0bff217 	ldw	r2,-56(fp)
 200980c:	1885883a 	add	r2,r3,r2
 2009810:	e0bffd15 	stw	r2,-12(fp)
	  borrow = z >> 16;
 2009814:	e0bffd17 	ldw	r2,-12(fp)
 2009818:	1005d43a 	srai	r2,r2,16
 200981c:	e0bff215 	stw	r2,-56(fp)
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
 2009820:	e0bff517 	ldw	r2,-44(fp)
 2009824:	10c00104 	addi	r3,r2,4
 2009828:	e0fff515 	stw	r3,-44(fp)
 200982c:	e0fffd17 	ldw	r3,-12(fp)
 2009830:	1808943a 	slli	r4,r3,16
 2009834:	e0fffc17 	ldw	r3,-16(fp)
 2009838:	18ffffcc 	andi	r3,r3,65535
 200983c:	20c6b03a 	or	r3,r4,r3
 2009840:	10c00015 	stw	r3,0(r2)
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
 2009844:	e0bff717 	ldw	r2,-36(fp)
 2009848:	e0fff817 	ldw	r3,-32(fp)
 200984c:	18bfc92e 	bgeu	r3,r2,2009774 <quorem+0x24c>
      bx = b->_x;
 2009850:	e0bffe17 	ldw	r2,-8(fp)
 2009854:	10800504 	addi	r2,r2,20
 2009858:	e0bff515 	stw	r2,-44(fp)
      bxe = bx + n;
 200985c:	e0bff117 	ldw	r2,-60(fp)
 2009860:	1085883a 	add	r2,r2,r2
 2009864:	1085883a 	add	r2,r2,r2
 2009868:	1007883a 	mov	r3,r2
 200986c:	e0bff517 	ldw	r2,-44(fp)
 2009870:	10c5883a 	add	r2,r2,r3
 2009874:	e0bff615 	stw	r2,-40(fp)
      if (!*bxe)
 2009878:	e0bff617 	ldw	r2,-40(fp)
 200987c:	10800017 	ldw	r2,0(r2)
 2009880:	1000101e 	bne	r2,zero,20098c4 <quorem+0x39c>
	{
	  while (--bxe > bx && !*bxe)
 2009884:	00000306 	br	2009894 <quorem+0x36c>
	    --n;
 2009888:	e0bff117 	ldw	r2,-60(fp)
 200988c:	10bfffc4 	addi	r2,r2,-1
 2009890:	e0bff115 	stw	r2,-60(fp)
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
 2009894:	e0bff617 	ldw	r2,-40(fp)
 2009898:	10bfff04 	addi	r2,r2,-4
 200989c:	e0bff615 	stw	r2,-40(fp)
 20098a0:	e0bff617 	ldw	r2,-40(fp)
 20098a4:	e0fff517 	ldw	r3,-44(fp)
 20098a8:	1880032e 	bgeu	r3,r2,20098b8 <quorem+0x390>
 20098ac:	e0bff617 	ldw	r2,-40(fp)
 20098b0:	10800017 	ldw	r2,0(r2)
 20098b4:	103ff426 	beq	r2,zero,2009888 <quorem+0x360>
	    --n;
	  b->_wds = n;
 20098b8:	e0bffe17 	ldw	r2,-8(fp)
 20098bc:	e0fff117 	ldw	r3,-60(fp)
 20098c0:	10c00415 	stw	r3,16(r2)
	}
    }
  return q;
 20098c4:	e0bff417 	ldw	r2,-48(fp)
}
 20098c8:	e037883a 	mov	sp,fp
 20098cc:	dfc00117 	ldw	ra,4(sp)
 20098d0:	df000017 	ldw	fp,0(sp)
 20098d4:	dec00204 	addi	sp,sp,8
 20098d8:	f800283a 	ret

020098dc <_dtoa_r>:
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
 20098dc:	deffcc04 	addi	sp,sp,-208
 20098e0:	dfc03315 	stw	ra,204(sp)
 20098e4:	df003215 	stw	fp,200(sp)
 20098e8:	dcc03115 	stw	r19,196(sp)
 20098ec:	dc803015 	stw	r18,192(sp)
 20098f0:	dc402f15 	stw	r17,188(sp)
 20098f4:	dc002e15 	stw	r16,184(sp)
 20098f8:	df003204 	addi	fp,sp,200
 20098fc:	e13ff815 	stw	r4,-32(fp)
 2009900:	e17ff915 	stw	r5,-28(fp)
 2009904:	e1bffa15 	stw	r6,-24(fp)
 2009908:	e1fffb15 	stw	r7,-20(fp)
  __Long L;
#ifndef Sudden_Underflow
  int denorm;
  __ULong x;
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
 200990c:	e03fe215 	stw	zero,-120(fp)
  double ds;
  char *s, *s0;

  d.d = _d;
 2009910:	e0bff917 	ldw	r2,-28(fp)
 2009914:	e0bff215 	stw	r2,-56(fp)
 2009918:	e0bffa17 	ldw	r2,-24(fp)
 200991c:	e0bff315 	stw	r2,-52(fp)

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
 2009920:	e0bff817 	ldw	r2,-32(fp)
 2009924:	10801017 	ldw	r2,64(r2)
 2009928:	10001326 	beq	r2,zero,2009978 <_dtoa_r+0x9c>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
 200992c:	e0bff817 	ldw	r2,-32(fp)
 2009930:	10801017 	ldw	r2,64(r2)
 2009934:	e0fff817 	ldw	r3,-32(fp)
 2009938:	18c01117 	ldw	r3,68(r3)
 200993c:	10c00115 	stw	r3,4(r2)
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
 2009940:	e0bff817 	ldw	r2,-32(fp)
 2009944:	10801017 	ldw	r2,64(r2)
 2009948:	e0fff817 	ldw	r3,-32(fp)
 200994c:	18c01117 	ldw	r3,68(r3)
 2009950:	01000044 	movi	r4,1
 2009954:	20c6983a 	sll	r3,r4,r3
 2009958:	10c00215 	stw	r3,8(r2)
      Bfree (ptr, _REENT_MP_RESULT(ptr));
 200995c:	e0bff817 	ldw	r2,-32(fp)
 2009960:	10801017 	ldw	r2,64(r2)
 2009964:	100b883a 	mov	r5,r2
 2009968:	e13ff817 	ldw	r4,-32(fp)
 200996c:	200e4a80 	call	200e4a8 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
 2009970:	e0bff817 	ldw	r2,-32(fp)
 2009974:	10001015 	stw	zero,64(r2)
    }

  if (word0 (d) & Sign_bit)
 2009978:	e0bff317 	ldw	r2,-52(fp)
 200997c:	1000090e 	bge	r2,zero,20099a4 <_dtoa_r+0xc8>
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
 2009980:	e0800417 	ldw	r2,16(fp)
 2009984:	00c00044 	movi	r3,1
 2009988:	10c00015 	stw	r3,0(r2)
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
 200998c:	e0fff317 	ldw	r3,-52(fp)
 2009990:	00a00034 	movhi	r2,32768
 2009994:	10bfffc4 	addi	r2,r2,-1
 2009998:	1884703a 	and	r2,r3,r2
 200999c:	e0bff315 	stw	r2,-52(fp)
 20099a0:	00000206 	br	20099ac <_dtoa_r+0xd0>
    }
  else
    *sign = 0;
 20099a4:	e0800417 	ldw	r2,16(fp)
 20099a8:	10000015 	stw	zero,0(r2)

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
 20099ac:	e0bff317 	ldw	r2,-52(fp)
 20099b0:	10dffc2c 	andhi	r3,r2,32752
 20099b4:	009ffc34 	movhi	r2,32752
 20099b8:	1880221e 	bne	r3,r2,2009a44 <_dtoa_r+0x168>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
 20099bc:	e0800317 	ldw	r2,12(fp)
 20099c0:	00c9c3c4 	movi	r3,9999
 20099c4:	10c00015 	stw	r3,0(r2)
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
 20099c8:	e0bff217 	ldw	r2,-56(fp)
 20099cc:	1000081e 	bne	r2,zero,20099f0 <_dtoa_r+0x114>
 20099d0:	e0fff317 	ldw	r3,-52(fp)
 20099d4:	00800434 	movhi	r2,16
 20099d8:	10bfffc4 	addi	r2,r2,-1
 20099dc:	1884703a 	and	r2,r3,r2
 20099e0:	1000031e 	bne	r2,zero,20099f0 <_dtoa_r+0x114>
 20099e4:	008080b4 	movhi	r2,514
 20099e8:	10be0904 	addi	r2,r2,-2012
 20099ec:	00000206 	br	20099f8 <_dtoa_r+0x11c>
 20099f0:	008080b4 	movhi	r2,514
 20099f4:	10be0c04 	addi	r2,r2,-2000
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
 20099f8:	e0bfe715 	stw	r2,-100(fp)
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
 20099fc:	e0800517 	ldw	r2,20(fp)
 2009a00:	10000e26 	beq	r2,zero,2009a3c <_dtoa_r+0x160>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
 2009a04:	e0bfe717 	ldw	r2,-100(fp)
 2009a08:	108000c4 	addi	r2,r2,3
 2009a0c:	10800003 	ldbu	r2,0(r2)
 2009a10:	10803fcc 	andi	r2,r2,255
 2009a14:	1080201c 	xori	r2,r2,128
 2009a18:	10bfe004 	addi	r2,r2,-128
 2009a1c:	10000326 	beq	r2,zero,2009a2c <_dtoa_r+0x150>
 2009a20:	e0bfe717 	ldw	r2,-100(fp)
 2009a24:	10800204 	addi	r2,r2,8
 2009a28:	00000206 	br	2009a34 <_dtoa_r+0x158>
 2009a2c:	e0bfe717 	ldw	r2,-100(fp)
 2009a30:	108000c4 	addi	r2,r2,3
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
 2009a34:	e0c00517 	ldw	r3,20(fp)
 2009a38:	18800015 	stw	r2,0(r3)
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
#endif
	  s + 3;
      return s;
 2009a3c:	e0bfe717 	ldw	r2,-100(fp)
 2009a40:	00067b06 	br	200b430 <_dtoa_r+0x1b54>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
 2009a44:	e0bff217 	ldw	r2,-56(fp)
 2009a48:	e0fff317 	ldw	r3,-52(fp)
 2009a4c:	000d883a 	mov	r6,zero
 2009a50:	000f883a 	mov	r7,zero
 2009a54:	1009883a 	mov	r4,r2
 2009a58:	180b883a 	mov	r5,r3
 2009a5c:	20052280 	call	2005228 <__eqdf2>
 2009a60:	10000e1e 	bne	r2,zero,2009a9c <_dtoa_r+0x1c0>
    {
      *decpt = 1;
 2009a64:	e0800317 	ldw	r2,12(fp)
 2009a68:	00c00044 	movi	r3,1
 2009a6c:	10c00015 	stw	r3,0(r2)
      s = "0";
 2009a70:	008080b4 	movhi	r2,514
 2009a74:	10be0d04 	addi	r2,r2,-1996
 2009a78:	e0bfe715 	stw	r2,-100(fp)
      if (rve)
 2009a7c:	e0800517 	ldw	r2,20(fp)
 2009a80:	10000426 	beq	r2,zero,2009a94 <_dtoa_r+0x1b8>
	*rve = s + 1;
 2009a84:	e0bfe717 	ldw	r2,-100(fp)
 2009a88:	10c00044 	addi	r3,r2,1
 2009a8c:	e0800517 	ldw	r2,20(fp)
 2009a90:	10c00015 	stw	r3,0(r2)
      return s;
 2009a94:	e0bfe717 	ldw	r2,-100(fp)
 2009a98:	00066506 	br	200b430 <_dtoa_r+0x1b54>
    }

  b = d2b (ptr, d.d, &be, &bbits);
 2009a9c:	e0bff217 	ldw	r2,-56(fp)
 2009aa0:	e0fff317 	ldw	r3,-52(fp)
 2009aa4:	e17ff104 	addi	r5,fp,-60
 2009aa8:	e13ff004 	addi	r4,fp,-64
 2009aac:	d9000015 	stw	r4,0(sp)
 2009ab0:	280f883a 	mov	r7,r5
 2009ab4:	100b883a 	mov	r5,r2
 2009ab8:	180d883a 	mov	r6,r3
 2009abc:	e13ff817 	ldw	r4,-32(fp)
 2009ac0:	200f7e00 	call	200f7e0 <__d2b>
 2009ac4:	e0bfe115 	stw	r2,-124(fp)
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
 2009ac8:	e0bff317 	ldw	r2,-52(fp)
 2009acc:	1004d53a 	srli	r2,r2,20
 2009ad0:	1081ffcc 	andi	r2,r2,2047
 2009ad4:	e0bfd215 	stw	r2,-184(fp)
 2009ad8:	e0bfd217 	ldw	r2,-184(fp)
 2009adc:	10001126 	beq	r2,zero,2009b24 <_dtoa_r+0x248>
    {
#endif
      d2.d = d.d;
 2009ae0:	e0bff217 	ldw	r2,-56(fp)
 2009ae4:	e0fff317 	ldw	r3,-52(fp)
 2009ae8:	e0bff415 	stw	r2,-48(fp)
 2009aec:	e0fff515 	stw	r3,-44(fp)
      word0 (d2) &= Frac_mask1;
 2009af0:	e0fff517 	ldw	r3,-44(fp)
 2009af4:	00800434 	movhi	r2,16
 2009af8:	10bfffc4 	addi	r2,r2,-1
 2009afc:	1884703a 	and	r2,r3,r2
 2009b00:	e0bff515 	stw	r2,-44(fp)
      word0 (d2) |= Exp_11;
 2009b04:	e0bff517 	ldw	r2,-44(fp)
 2009b08:	108ffc34 	orhi	r2,r2,16368
 2009b0c:	e0bff515 	stw	r2,-44(fp)
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
 2009b10:	e0bfd217 	ldw	r2,-184(fp)
 2009b14:	10bf0044 	addi	r2,r2,-1023
 2009b18:	e0bfd215 	stw	r2,-184(fp)
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
 2009b1c:	e03fe015 	stw	zero,-128(fp)
 2009b20:	00002806 	br	2009bc4 <_dtoa_r+0x2e8>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
 2009b24:	e0fff017 	ldw	r3,-64(fp)
 2009b28:	e0bff117 	ldw	r2,-60(fp)
 2009b2c:	1885883a 	add	r2,r3,r2
 2009b30:	10810c84 	addi	r2,r2,1074
 2009b34:	e0bfd215 	stw	r2,-184(fp)
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
       : (word1 (d) << (32 - i));
 2009b38:	e0bfd217 	ldw	r2,-184(fp)
 2009b3c:	10800850 	cmplti	r2,r2,33
 2009b40:	10000b1e 	bne	r2,zero,2009b70 <_dtoa_r+0x294>

      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 2009b44:	e0fff317 	ldw	r3,-52(fp)
 2009b48:	01001004 	movi	r4,64
 2009b4c:	e0bfd217 	ldw	r2,-184(fp)
 2009b50:	2085c83a 	sub	r2,r4,r2
 2009b54:	1886983a 	sll	r3,r3,r2
 2009b58:	e13ff217 	ldw	r4,-56(fp)
 2009b5c:	e0bfd217 	ldw	r2,-184(fp)
 2009b60:	10bff804 	addi	r2,r2,-32
 2009b64:	2084d83a 	srl	r2,r4,r2
       : (word1 (d) << (32 - i));
 2009b68:	1884b03a 	or	r2,r3,r2
 2009b6c:	00000506 	br	2009b84 <_dtoa_r+0x2a8>
 2009b70:	e0fff217 	ldw	r3,-56(fp)
 2009b74:	01000804 	movi	r4,32
 2009b78:	e0bfd217 	ldw	r2,-184(fp)
 2009b7c:	2085c83a 	sub	r2,r4,r2
 2009b80:	1884983a 	sll	r2,r3,r2

      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
 2009b84:	e0bfe815 	stw	r2,-96(fp)
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
 2009b88:	e13fe817 	ldw	r4,-96(fp)
 2009b8c:	2013b940 	call	2013b94 <__floatunsidf>
 2009b90:	1009883a 	mov	r4,r2
 2009b94:	180b883a 	mov	r5,r3
 2009b98:	e13ff415 	stw	r4,-48(fp)
 2009b9c:	e17ff515 	stw	r5,-44(fp)
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
 2009ba0:	e0fff517 	ldw	r3,-44(fp)
 2009ba4:	00bf8434 	movhi	r2,65040
 2009ba8:	1885883a 	add	r2,r3,r2
 2009bac:	e0bff515 	stw	r2,-44(fp)
      i -= (Bias + (P - 1) - 1) + 1;
 2009bb0:	e0bfd217 	ldw	r2,-184(fp)
 2009bb4:	10bef344 	addi	r2,r2,-1075
 2009bb8:	e0bfd215 	stw	r2,-184(fp)
      denorm = 1;
 2009bbc:	00800044 	movi	r2,1
 2009bc0:	e0bfe015 	stw	r2,-128(fp)
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
 2009bc4:	e0bff417 	ldw	r2,-48(fp)
 2009bc8:	e0fff517 	ldw	r3,-44(fp)
 2009bcc:	000d883a 	mov	r6,zero
 2009bd0:	01cffe34 	movhi	r7,16376
 2009bd4:	1009883a 	mov	r4,r2
 2009bd8:	180b883a 	mov	r5,r3
 2009bdc:	2005b980 	call	2005b98 <__subdf3>
 2009be0:	1009883a 	mov	r4,r2
 2009be4:	180b883a 	mov	r5,r3
 2009be8:	2005883a 	mov	r2,r4
 2009bec:	2807883a 	mov	r3,r5
 2009bf0:	0198dbf4 	movhi	r6,25455
 2009bf4:	3190d844 	addi	r6,r6,17249
 2009bf8:	01cff4f4 	movhi	r7,16339
 2009bfc:	39e1e9c4 	addi	r7,r7,-30809
 2009c00:	1009883a 	mov	r4,r2
 2009c04:	180b883a 	mov	r5,r3
 2009c08:	20054800 	call	2005480 <__muldf3>
 2009c0c:	1009883a 	mov	r4,r2
 2009c10:	180b883a 	mov	r5,r3
 2009c14:	2005883a 	mov	r2,r4
 2009c18:	2807883a 	mov	r3,r5
 2009c1c:	01a2d874 	movhi	r6,35681
 2009c20:	31b22cc4 	addi	r6,r6,-14157
 2009c24:	01cff1f4 	movhi	r7,16327
 2009c28:	39e28a04 	addi	r7,r7,-30168
 2009c2c:	1009883a 	mov	r4,r2
 2009c30:	180b883a 	mov	r5,r3
 2009c34:	20040940 	call	2004094 <__adddf3>
 2009c38:	1009883a 	mov	r4,r2
 2009c3c:	180b883a 	mov	r5,r3
 2009c40:	2025883a 	mov	r18,r4
 2009c44:	2827883a 	mov	r19,r5
 2009c48:	e13fd217 	ldw	r4,-184(fp)
 2009c4c:	2013ab80 	call	2013ab8 <__floatsidf>
 2009c50:	1011883a 	mov	r8,r2
 2009c54:	1813883a 	mov	r9,r3
 2009c58:	019427f4 	movhi	r6,20639
 2009c5c:	319e7ec4 	addi	r6,r6,31227
 2009c60:	01cff4f4 	movhi	r7,16339
 2009c64:	39d104c4 	addi	r7,r7,17427
 2009c68:	4009883a 	mov	r4,r8
 2009c6c:	480b883a 	mov	r5,r9
 2009c70:	20054800 	call	2005480 <__muldf3>
 2009c74:	1009883a 	mov	r4,r2
 2009c78:	180b883a 	mov	r5,r3
 2009c7c:	2005883a 	mov	r2,r4
 2009c80:	2807883a 	mov	r3,r5
 2009c84:	100d883a 	mov	r6,r2
 2009c88:	180f883a 	mov	r7,r3
 2009c8c:	9009883a 	mov	r4,r18
 2009c90:	980b883a 	mov	r5,r19
 2009c94:	20040940 	call	2004094 <__adddf3>
 2009c98:	1009883a 	mov	r4,r2
 2009c9c:	180b883a 	mov	r5,r3
 2009ca0:	e13fe515 	stw	r4,-108(fp)
 2009ca4:	e17fe615 	stw	r5,-104(fp)
#endif
  k = (int) ds;
 2009ca8:	e13fe517 	ldw	r4,-108(fp)
 2009cac:	e17fe617 	ldw	r5,-104(fp)
 2009cb0:	2013a380 	call	2013a38 <__fixdfsi>
 2009cb4:	e0bfd715 	stw	r2,-164(fp)
  if (ds < 0. && ds != k)
 2009cb8:	000d883a 	mov	r6,zero
 2009cbc:	000f883a 	mov	r7,zero
 2009cc0:	e13fe517 	ldw	r4,-108(fp)
 2009cc4:	e17fe617 	ldw	r5,-104(fp)
 2009cc8:	200538c0 	call	200538c <__ledf2>
 2009ccc:	10000d0e 	bge	r2,zero,2009d04 <_dtoa_r+0x428>
 2009cd0:	e13fd717 	ldw	r4,-164(fp)
 2009cd4:	2013ab80 	call	2013ab8 <__floatsidf>
 2009cd8:	1011883a 	mov	r8,r2
 2009cdc:	1813883a 	mov	r9,r3
 2009ce0:	e1bfe517 	ldw	r6,-108(fp)
 2009ce4:	e1ffe617 	ldw	r7,-104(fp)
 2009ce8:	4009883a 	mov	r4,r8
 2009cec:	480b883a 	mov	r5,r9
 2009cf0:	20052280 	call	2005228 <__eqdf2>
 2009cf4:	10000326 	beq	r2,zero,2009d04 <_dtoa_r+0x428>
    k--;			/* want k = floor(ds) */
 2009cf8:	e0bfd717 	ldw	r2,-164(fp)
 2009cfc:	10bfffc4 	addi	r2,r2,-1
 2009d00:	e0bfd715 	stw	r2,-164(fp)
  k_check = 1;
 2009d04:	00800044 	movi	r2,1
 2009d08:	e0bfd815 	stw	r2,-160(fp)
  if (k >= 0 && k <= Ten_pmax)
 2009d0c:	e0bfd717 	ldw	r2,-164(fp)
 2009d10:	10001616 	blt	r2,zero,2009d6c <_dtoa_r+0x490>
 2009d14:	e0bfd717 	ldw	r2,-164(fp)
 2009d18:	108005c8 	cmpgei	r2,r2,23
 2009d1c:	1000131e 	bne	r2,zero,2009d6c <_dtoa_r+0x490>
    {
      if (d.d < tens[k])
 2009d20:	e0bff217 	ldw	r2,-56(fp)
 2009d24:	e0fff317 	ldw	r3,-52(fp)
 2009d28:	010080b4 	movhi	r4,514
 2009d2c:	213e1304 	addi	r4,r4,-1972
 2009d30:	e17fd717 	ldw	r5,-164(fp)
 2009d34:	280a90fa 	slli	r5,r5,3
 2009d38:	214d883a 	add	r6,r4,r5
 2009d3c:	31000017 	ldw	r4,0(r6)
 2009d40:	31400117 	ldw	r5,4(r6)
 2009d44:	200d883a 	mov	r6,r4
 2009d48:	280f883a 	mov	r7,r5
 2009d4c:	1009883a 	mov	r4,r2
 2009d50:	180b883a 	mov	r5,r3
 2009d54:	200538c0 	call	200538c <__ledf2>
 2009d58:	1000030e 	bge	r2,zero,2009d68 <_dtoa_r+0x48c>
	k--;
 2009d5c:	e0bfd717 	ldw	r2,-164(fp)
 2009d60:	10bfffc4 	addi	r2,r2,-1
 2009d64:	e0bfd715 	stw	r2,-164(fp)
      k_check = 0;
 2009d68:	e03fd815 	stw	zero,-160(fp)
    }
  j = bbits - i - 1;
 2009d6c:	e0fff017 	ldw	r3,-64(fp)
 2009d70:	e0bfd217 	ldw	r2,-184(fp)
 2009d74:	1885c83a 	sub	r2,r3,r2
 2009d78:	10bfffc4 	addi	r2,r2,-1
 2009d7c:	e0bfd615 	stw	r2,-168(fp)
  if (j >= 0)
 2009d80:	e0bfd617 	ldw	r2,-168(fp)
 2009d84:	10000416 	blt	r2,zero,2009d98 <_dtoa_r+0x4bc>
    {
      b2 = 0;
 2009d88:	e03fcf15 	stw	zero,-196(fp)
      s2 = j;
 2009d8c:	e0bfd617 	ldw	r2,-168(fp)
 2009d90:	e0bfdc15 	stw	r2,-144(fp)
 2009d94:	00000406 	br	2009da8 <_dtoa_r+0x4cc>
    }
  else
    {
      b2 = -j;
 2009d98:	e0bfd617 	ldw	r2,-168(fp)
 2009d9c:	0085c83a 	sub	r2,zero,r2
 2009da0:	e0bfcf15 	stw	r2,-196(fp)
      s2 = 0;
 2009da4:	e03fdc15 	stw	zero,-144(fp)
    }
  if (k >= 0)
 2009da8:	e0bfd717 	ldw	r2,-164(fp)
 2009dac:	10000816 	blt	r2,zero,2009dd0 <_dtoa_r+0x4f4>
    {
      b5 = 0;
 2009db0:	e03fd015 	stw	zero,-192(fp)
      s5 = k;
 2009db4:	e0bfd717 	ldw	r2,-164(fp)
 2009db8:	e0bfdd15 	stw	r2,-140(fp)
      s2 += k;
 2009dbc:	e0ffdc17 	ldw	r3,-144(fp)
 2009dc0:	e0bfd717 	ldw	r2,-164(fp)
 2009dc4:	1885883a 	add	r2,r3,r2
 2009dc8:	e0bfdc15 	stw	r2,-144(fp)
 2009dcc:	00000806 	br	2009df0 <_dtoa_r+0x514>
    }
  else
    {
      b2 -= k;
 2009dd0:	e0ffcf17 	ldw	r3,-196(fp)
 2009dd4:	e0bfd717 	ldw	r2,-164(fp)
 2009dd8:	1885c83a 	sub	r2,r3,r2
 2009ddc:	e0bfcf15 	stw	r2,-196(fp)
      b5 = -k;
 2009de0:	e0bfd717 	ldw	r2,-164(fp)
 2009de4:	0085c83a 	sub	r2,zero,r2
 2009de8:	e0bfd015 	stw	r2,-192(fp)
      s5 = 0;
 2009dec:	e03fdd15 	stw	zero,-140(fp)
    }
  if (mode < 0 || mode > 9)
 2009df0:	e0bffb17 	ldw	r2,-20(fp)
 2009df4:	10000316 	blt	r2,zero,2009e04 <_dtoa_r+0x528>
 2009df8:	e0bffb17 	ldw	r2,-20(fp)
 2009dfc:	10800290 	cmplti	r2,r2,10
 2009e00:	1000011e 	bne	r2,zero,2009e08 <_dtoa_r+0x52c>
    mode = 0;
 2009e04:	e03ffb15 	stw	zero,-20(fp)
  try_quick = 1;
 2009e08:	00800044 	movi	r2,1
 2009e0c:	e0bfdf15 	stw	r2,-132(fp)
  if (mode > 5)
 2009e10:	e0bffb17 	ldw	r2,-20(fp)
 2009e14:	10800190 	cmplti	r2,r2,6
 2009e18:	1000041e 	bne	r2,zero,2009e2c <_dtoa_r+0x550>
    {
      mode -= 4;
 2009e1c:	e0bffb17 	ldw	r2,-20(fp)
 2009e20:	10bfff04 	addi	r2,r2,-4
 2009e24:	e0bffb15 	stw	r2,-20(fp)
      try_quick = 0;
 2009e28:	e03fdf15 	stw	zero,-132(fp)
    }
  leftright = 1;
 2009e2c:	00800044 	movi	r2,1
 2009e30:	e0bfd915 	stw	r2,-156(fp)
  ilim = ilim1 = -1;
 2009e34:	00bfffc4 	movi	r2,-1
 2009e38:	e0bfd515 	stw	r2,-172(fp)
 2009e3c:	e0bfd517 	ldw	r2,-172(fp)
 2009e40:	e0bfd415 	stw	r2,-176(fp)
  switch (mode)
 2009e44:	e0bffb17 	ldw	r2,-20(fp)
 2009e48:	108001a8 	cmpgeui	r2,r2,6
 2009e4c:	10002c1e 	bne	r2,zero,2009f00 <_dtoa_r+0x624>
 2009e50:	e0bffb17 	ldw	r2,-20(fp)
 2009e54:	100690ba 	slli	r3,r2,2
 2009e58:	00808074 	movhi	r2,513
 2009e5c:	10a79b04 	addi	r2,r2,-24980
 2009e60:	1885883a 	add	r2,r3,r2
 2009e64:	10800017 	ldw	r2,0(r2)
 2009e68:	1000683a 	jmp	r2
 2009e6c:	02009e84 	movi	r8,634
 2009e70:	02009e84 	movi	r8,634
 2009e74:	02009e94 	movui	r8,634
 2009e78:	02009ec4 	movi	r8,635
 2009e7c:	02009e98 	cmpnei	r8,zero,634
 2009e80:	02009ec8 	cmpgei	r8,zero,635
    {
    case 0:
    case 1:
      i = 18;
 2009e84:	00800484 	movi	r2,18
 2009e88:	e0bfd215 	stw	r2,-184(fp)
      ndigits = 0;
 2009e8c:	e0000215 	stw	zero,8(fp)
      break;
 2009e90:	00001b06 	br	2009f00 <_dtoa_r+0x624>
    case 2:
      leftright = 0;
 2009e94:	e03fd915 	stw	zero,-156(fp)
      /* no break */
    case 4:
      if (ndigits <= 0)
 2009e98:	e0800217 	ldw	r2,8(fp)
 2009e9c:	00800216 	blt	zero,r2,2009ea8 <_dtoa_r+0x5cc>
	ndigits = 1;
 2009ea0:	00800044 	movi	r2,1
 2009ea4:	e0800215 	stw	r2,8(fp)
      ilim = ilim1 = i = ndigits;
 2009ea8:	e0800217 	ldw	r2,8(fp)
 2009eac:	e0bfd215 	stw	r2,-184(fp)
 2009eb0:	e0bfd217 	ldw	r2,-184(fp)
 2009eb4:	e0bfd515 	stw	r2,-172(fp)
 2009eb8:	e0bfd517 	ldw	r2,-172(fp)
 2009ebc:	e0bfd415 	stw	r2,-176(fp)
      break;
 2009ec0:	00000f06 	br	2009f00 <_dtoa_r+0x624>
    case 3:
      leftright = 0;
 2009ec4:	e03fd915 	stw	zero,-156(fp)
      /* no break */
    case 5:
      i = ndigits + k + 1;
 2009ec8:	e0c00217 	ldw	r3,8(fp)
 2009ecc:	e0bfd717 	ldw	r2,-164(fp)
 2009ed0:	1885883a 	add	r2,r3,r2
 2009ed4:	10800044 	addi	r2,r2,1
 2009ed8:	e0bfd215 	stw	r2,-184(fp)
      ilim = i;
 2009edc:	e0bfd217 	ldw	r2,-184(fp)
 2009ee0:	e0bfd415 	stw	r2,-176(fp)
      ilim1 = i - 1;
 2009ee4:	e0bfd217 	ldw	r2,-184(fp)
 2009ee8:	10bfffc4 	addi	r2,r2,-1
 2009eec:	e0bfd515 	stw	r2,-172(fp)
      if (i <= 0)
 2009ef0:	e0bfd217 	ldw	r2,-184(fp)
 2009ef4:	00800216 	blt	zero,r2,2009f00 <_dtoa_r+0x624>
	i = 1;
 2009ef8:	00800044 	movi	r2,1
 2009efc:	e0bfd215 	stw	r2,-184(fp)
    }
  j = sizeof (__ULong);
 2009f00:	00800104 	movi	r2,4
 2009f04:	e0bfd615 	stw	r2,-168(fp)
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 2009f08:	e0bff817 	ldw	r2,-32(fp)
 2009f0c:	10001115 	stw	zero,68(r2)
 2009f10:	00000806 	br	2009f34 <_dtoa_r+0x658>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
 2009f14:	e0bff817 	ldw	r2,-32(fp)
 2009f18:	10801117 	ldw	r2,68(r2)
 2009f1c:	10c00044 	addi	r3,r2,1
 2009f20:	e0bff817 	ldw	r2,-32(fp)
 2009f24:	10c01115 	stw	r3,68(r2)
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
 2009f28:	e0bfd617 	ldw	r2,-168(fp)
 2009f2c:	1085883a 	add	r2,r2,r2
 2009f30:	e0bfd615 	stw	r2,-168(fp)
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
 2009f34:	e0bfd617 	ldw	r2,-168(fp)
 2009f38:	10800504 	addi	r2,r2,20
 2009f3c:	e0ffd217 	ldw	r3,-184(fp)
 2009f40:	18bff42e 	bgeu	r3,r2,2009f14 <_dtoa_r+0x638>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
 2009f44:	e0bff817 	ldw	r2,-32(fp)
 2009f48:	10801117 	ldw	r2,68(r2)
 2009f4c:	100b883a 	mov	r5,r2
 2009f50:	e13ff817 	ldw	r4,-32(fp)
 2009f54:	200e3780 	call	200e378 <_Balloc>
 2009f58:	1007883a 	mov	r3,r2
 2009f5c:	e0bff817 	ldw	r2,-32(fp)
 2009f60:	10c01015 	stw	r3,64(r2)
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
 2009f64:	e0bff817 	ldw	r2,-32(fp)
 2009f68:	10801017 	ldw	r2,64(r2)
 2009f6c:	e0bfe915 	stw	r2,-92(fp)
 2009f70:	e0bfe917 	ldw	r2,-92(fp)
 2009f74:	e0bfe715 	stw	r2,-100(fp)

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
 2009f78:	e0bfd417 	ldw	r2,-176(fp)
 2009f7c:	10021616 	blt	r2,zero,200a7d8 <_dtoa_r+0xefc>
 2009f80:	e0bfd417 	ldw	r2,-176(fp)
 2009f84:	108003c8 	cmpgei	r2,r2,15
 2009f88:	1002131e 	bne	r2,zero,200a7d8 <_dtoa_r+0xefc>
 2009f8c:	e0bfdf17 	ldw	r2,-132(fp)
 2009f90:	10021126 	beq	r2,zero,200a7d8 <_dtoa_r+0xefc>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
 2009f94:	e03fd215 	stw	zero,-184(fp)
      d2.d = d.d;
 2009f98:	e0bff217 	ldw	r2,-56(fp)
 2009f9c:	e0fff317 	ldw	r3,-52(fp)
 2009fa0:	e0bff415 	stw	r2,-48(fp)
 2009fa4:	e0fff515 	stw	r3,-44(fp)
      k0 = k;
 2009fa8:	e0bfd717 	ldw	r2,-164(fp)
 2009fac:	e0bfea15 	stw	r2,-88(fp)
      ilim0 = ilim;
 2009fb0:	e0bfd417 	ldw	r2,-176(fp)
 2009fb4:	e0bfeb15 	stw	r2,-84(fp)
      ieps = 2;			/* conservative */
 2009fb8:	00800084 	movi	r2,2
 2009fbc:	e0bfd315 	stw	r2,-180(fp)
      if (k > 0)
 2009fc0:	e0bfd717 	ldw	r2,-164(fp)
 2009fc4:	0080540e 	bge	zero,r2,200a118 <_dtoa_r+0x83c>
	{
	  ds = tens[k & 0xf];
 2009fc8:	e0bfd717 	ldw	r2,-164(fp)
 2009fcc:	10c003cc 	andi	r3,r2,15
 2009fd0:	008080b4 	movhi	r2,514
 2009fd4:	10be1304 	addi	r2,r2,-1972
 2009fd8:	180690fa 	slli	r3,r3,3
 2009fdc:	10c5883a 	add	r2,r2,r3
 2009fe0:	10c00017 	ldw	r3,0(r2)
 2009fe4:	e0ffe515 	stw	r3,-108(fp)
 2009fe8:	10800117 	ldw	r2,4(r2)
 2009fec:	e0bfe615 	stw	r2,-104(fp)
	  j = k >> 4;
 2009ff0:	e0bfd717 	ldw	r2,-164(fp)
 2009ff4:	1005d13a 	srai	r2,r2,4
 2009ff8:	e0bfd615 	stw	r2,-168(fp)
	  if (j & Bletch)
 2009ffc:	e0bfd617 	ldw	r2,-168(fp)
 200a000:	1080040c 	andi	r2,r2,16
 200a004:	10003426 	beq	r2,zero,200a0d8 <_dtoa_r+0x7fc>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
 200a008:	e0bfd617 	ldw	r2,-168(fp)
 200a00c:	108003cc 	andi	r2,r2,15
 200a010:	e0bfd615 	stw	r2,-168(fp)
	      d.d /= bigtens[n_bigtens - 1];
 200a014:	e0bff217 	ldw	r2,-56(fp)
 200a018:	e0fff317 	ldw	r3,-52(fp)
 200a01c:	018080b4 	movhi	r6,514
 200a020:	31be4504 	addi	r6,r6,-1772
 200a024:	31000817 	ldw	r4,32(r6)
 200a028:	31400917 	ldw	r5,36(r6)
 200a02c:	200d883a 	mov	r6,r4
 200a030:	280f883a 	mov	r7,r5
 200a034:	1009883a 	mov	r4,r2
 200a038:	180b883a 	mov	r5,r3
 200a03c:	20049400 	call	2004940 <__divdf3>
 200a040:	1009883a 	mov	r4,r2
 200a044:	180b883a 	mov	r5,r3
 200a048:	2005883a 	mov	r2,r4
 200a04c:	2807883a 	mov	r3,r5
 200a050:	e0bff215 	stw	r2,-56(fp)
 200a054:	e0fff315 	stw	r3,-52(fp)
	      ieps++;
 200a058:	e0bfd317 	ldw	r2,-180(fp)
 200a05c:	10800044 	addi	r2,r2,1
 200a060:	e0bfd315 	stw	r2,-180(fp)
	    }
	  for (; j; j >>= 1, i++)
 200a064:	00001c06 	br	200a0d8 <_dtoa_r+0x7fc>
	    if (j & 1)
 200a068:	e0bfd617 	ldw	r2,-168(fp)
 200a06c:	1080004c 	andi	r2,r2,1
 200a070:	10001326 	beq	r2,zero,200a0c0 <_dtoa_r+0x7e4>
	      {
		ieps++;
 200a074:	e0bfd317 	ldw	r2,-180(fp)
 200a078:	10800044 	addi	r2,r2,1
 200a07c:	e0bfd315 	stw	r2,-180(fp)
		ds *= bigtens[i];
 200a080:	008080b4 	movhi	r2,514
 200a084:	10be4504 	addi	r2,r2,-1772
 200a088:	e0ffd217 	ldw	r3,-184(fp)
 200a08c:	180690fa 	slli	r3,r3,3
 200a090:	10c9883a 	add	r4,r2,r3
 200a094:	20800017 	ldw	r2,0(r4)
 200a098:	20c00117 	ldw	r3,4(r4)
 200a09c:	100d883a 	mov	r6,r2
 200a0a0:	180f883a 	mov	r7,r3
 200a0a4:	e13fe517 	ldw	r4,-108(fp)
 200a0a8:	e17fe617 	ldw	r5,-104(fp)
 200a0ac:	20054800 	call	2005480 <__muldf3>
 200a0b0:	1009883a 	mov	r4,r2
 200a0b4:	180b883a 	mov	r5,r3
 200a0b8:	e13fe515 	stw	r4,-108(fp)
 200a0bc:	e17fe615 	stw	r5,-104(fp)
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
 200a0c0:	e0bfd617 	ldw	r2,-168(fp)
 200a0c4:	1005d07a 	srai	r2,r2,1
 200a0c8:	e0bfd615 	stw	r2,-168(fp)
 200a0cc:	e0bfd217 	ldw	r2,-184(fp)
 200a0d0:	10800044 	addi	r2,r2,1
 200a0d4:	e0bfd215 	stw	r2,-184(fp)
 200a0d8:	e0bfd617 	ldw	r2,-168(fp)
 200a0dc:	103fe21e 	bne	r2,zero,200a068 <_dtoa_r+0x78c>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
 200a0e0:	e0bff217 	ldw	r2,-56(fp)
 200a0e4:	e0fff317 	ldw	r3,-52(fp)
 200a0e8:	e1bfe517 	ldw	r6,-108(fp)
 200a0ec:	e1ffe617 	ldw	r7,-104(fp)
 200a0f0:	1009883a 	mov	r4,r2
 200a0f4:	180b883a 	mov	r5,r3
 200a0f8:	20049400 	call	2004940 <__divdf3>
 200a0fc:	1009883a 	mov	r4,r2
 200a100:	180b883a 	mov	r5,r3
 200a104:	2005883a 	mov	r2,r4
 200a108:	2807883a 	mov	r3,r5
 200a10c:	e0bff215 	stw	r2,-56(fp)
 200a110:	e0fff315 	stw	r3,-52(fp)
 200a114:	00004006 	br	200a218 <_dtoa_r+0x93c>
	}
      else if ((j1 = -k) != 0)
 200a118:	e0bfd717 	ldw	r2,-164(fp)
 200a11c:	0085c83a 	sub	r2,zero,r2
 200a120:	e0bfec15 	stw	r2,-80(fp)
 200a124:	e0bfec17 	ldw	r2,-80(fp)
 200a128:	10003b26 	beq	r2,zero,200a218 <_dtoa_r+0x93c>
	{
	  d.d *= tens[j1 & 0xf];
 200a12c:	e0bff217 	ldw	r2,-56(fp)
 200a130:	e0fff317 	ldw	r3,-52(fp)
 200a134:	e13fec17 	ldw	r4,-80(fp)
 200a138:	214003cc 	andi	r5,r4,15
 200a13c:	010080b4 	movhi	r4,514
 200a140:	213e1304 	addi	r4,r4,-1972
 200a144:	280a90fa 	slli	r5,r5,3
 200a148:	214d883a 	add	r6,r4,r5
 200a14c:	31000017 	ldw	r4,0(r6)
 200a150:	31400117 	ldw	r5,4(r6)
 200a154:	200d883a 	mov	r6,r4
 200a158:	280f883a 	mov	r7,r5
 200a15c:	1009883a 	mov	r4,r2
 200a160:	180b883a 	mov	r5,r3
 200a164:	20054800 	call	2005480 <__muldf3>
 200a168:	1009883a 	mov	r4,r2
 200a16c:	180b883a 	mov	r5,r3
 200a170:	2005883a 	mov	r2,r4
 200a174:	2807883a 	mov	r3,r5
 200a178:	e0bff215 	stw	r2,-56(fp)
 200a17c:	e0fff315 	stw	r3,-52(fp)
	  for (j = j1 >> 4; j; j >>= 1, i++)
 200a180:	e0bfec17 	ldw	r2,-80(fp)
 200a184:	1005d13a 	srai	r2,r2,4
 200a188:	e0bfd615 	stw	r2,-168(fp)
 200a18c:	00002006 	br	200a210 <_dtoa_r+0x934>
	    if (j & 1)
 200a190:	e0bfd617 	ldw	r2,-168(fp)
 200a194:	1080004c 	andi	r2,r2,1
 200a198:	10001726 	beq	r2,zero,200a1f8 <_dtoa_r+0x91c>
	      {
		ieps++;
 200a19c:	e0bfd317 	ldw	r2,-180(fp)
 200a1a0:	10800044 	addi	r2,r2,1
 200a1a4:	e0bfd315 	stw	r2,-180(fp)
		d.d *= bigtens[i];
 200a1a8:	e0bff217 	ldw	r2,-56(fp)
 200a1ac:	e0fff317 	ldw	r3,-52(fp)
 200a1b0:	010080b4 	movhi	r4,514
 200a1b4:	213e4504 	addi	r4,r4,-1772
 200a1b8:	e17fd217 	ldw	r5,-184(fp)
 200a1bc:	280a90fa 	slli	r5,r5,3
 200a1c0:	214d883a 	add	r6,r4,r5
 200a1c4:	31000017 	ldw	r4,0(r6)
 200a1c8:	31400117 	ldw	r5,4(r6)
 200a1cc:	200d883a 	mov	r6,r4
 200a1d0:	280f883a 	mov	r7,r5
 200a1d4:	1009883a 	mov	r4,r2
 200a1d8:	180b883a 	mov	r5,r3
 200a1dc:	20054800 	call	2005480 <__muldf3>
 200a1e0:	1009883a 	mov	r4,r2
 200a1e4:	180b883a 	mov	r5,r3
 200a1e8:	2005883a 	mov	r2,r4
 200a1ec:	2807883a 	mov	r3,r5
 200a1f0:	e0bff215 	stw	r2,-56(fp)
 200a1f4:	e0fff315 	stw	r3,-52(fp)
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
 200a1f8:	e0bfd617 	ldw	r2,-168(fp)
 200a1fc:	1005d07a 	srai	r2,r2,1
 200a200:	e0bfd615 	stw	r2,-168(fp)
 200a204:	e0bfd217 	ldw	r2,-184(fp)
 200a208:	10800044 	addi	r2,r2,1
 200a20c:	e0bfd215 	stw	r2,-184(fp)
 200a210:	e0bfd617 	ldw	r2,-168(fp)
 200a214:	103fde1e 	bne	r2,zero,200a190 <_dtoa_r+0x8b4>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
 200a218:	e0bfd817 	ldw	r2,-160(fp)
 200a21c:	10002126 	beq	r2,zero,200a2a4 <_dtoa_r+0x9c8>
 200a220:	e0bff217 	ldw	r2,-56(fp)
 200a224:	e0fff317 	ldw	r3,-52(fp)
 200a228:	000d883a 	mov	r6,zero
 200a22c:	01cffc34 	movhi	r7,16368
 200a230:	1009883a 	mov	r4,r2
 200a234:	180b883a 	mov	r5,r3
 200a238:	200538c0 	call	200538c <__ledf2>
 200a23c:	1000190e 	bge	r2,zero,200a2a4 <_dtoa_r+0x9c8>
 200a240:	e0bfd417 	ldw	r2,-176(fp)
 200a244:	0080170e 	bge	zero,r2,200a2a4 <_dtoa_r+0x9c8>
	{
	  if (ilim1 <= 0)
 200a248:	e0bfd517 	ldw	r2,-172(fp)
 200a24c:	0081550e 	bge	zero,r2,200a7a4 <_dtoa_r+0xec8>
	    goto fast_failed;
	  ilim = ilim1;
 200a250:	e0bfd517 	ldw	r2,-172(fp)
 200a254:	e0bfd415 	stw	r2,-176(fp)
	  k--;
 200a258:	e0bfd717 	ldw	r2,-164(fp)
 200a25c:	10bfffc4 	addi	r2,r2,-1
 200a260:	e0bfd715 	stw	r2,-164(fp)
	  d.d *= 10.;
 200a264:	e0bff217 	ldw	r2,-56(fp)
 200a268:	e0fff317 	ldw	r3,-52(fp)
 200a26c:	000d883a 	mov	r6,zero
 200a270:	01d00934 	movhi	r7,16420
 200a274:	1009883a 	mov	r4,r2
 200a278:	180b883a 	mov	r5,r3
 200a27c:	20054800 	call	2005480 <__muldf3>
 200a280:	1009883a 	mov	r4,r2
 200a284:	180b883a 	mov	r5,r3
 200a288:	2005883a 	mov	r2,r4
 200a28c:	2807883a 	mov	r3,r5
 200a290:	e0bff215 	stw	r2,-56(fp)
 200a294:	e0fff315 	stw	r3,-52(fp)
	  ieps++;
 200a298:	e0bfd317 	ldw	r2,-180(fp)
 200a29c:	10800044 	addi	r2,r2,1
 200a2a0:	e0bfd315 	stw	r2,-180(fp)
	}
      eps.d = ieps * d.d + 7.;
 200a2a4:	e13fd317 	ldw	r4,-180(fp)
 200a2a8:	2013ab80 	call	2013ab8 <__floatsidf>
 200a2ac:	1011883a 	mov	r8,r2
 200a2b0:	1813883a 	mov	r9,r3
 200a2b4:	e0bff217 	ldw	r2,-56(fp)
 200a2b8:	e0fff317 	ldw	r3,-52(fp)
 200a2bc:	100d883a 	mov	r6,r2
 200a2c0:	180f883a 	mov	r7,r3
 200a2c4:	4009883a 	mov	r4,r8
 200a2c8:	480b883a 	mov	r5,r9
 200a2cc:	20054800 	call	2005480 <__muldf3>
 200a2d0:	1009883a 	mov	r4,r2
 200a2d4:	180b883a 	mov	r5,r3
 200a2d8:	2005883a 	mov	r2,r4
 200a2dc:	2807883a 	mov	r3,r5
 200a2e0:	000d883a 	mov	r6,zero
 200a2e4:	01d00734 	movhi	r7,16412
 200a2e8:	1009883a 	mov	r4,r2
 200a2ec:	180b883a 	mov	r5,r3
 200a2f0:	20040940 	call	2004094 <__adddf3>
 200a2f4:	1009883a 	mov	r4,r2
 200a2f8:	180b883a 	mov	r5,r3
 200a2fc:	2005883a 	mov	r2,r4
 200a300:	2807883a 	mov	r3,r5
 200a304:	e0bff615 	stw	r2,-40(fp)
 200a308:	e0fff715 	stw	r3,-36(fp)
      word0 (eps) -= (P - 1) * Exp_msk1;
 200a30c:	e0fff717 	ldw	r3,-36(fp)
 200a310:	00bf3034 	movhi	r2,64704
 200a314:	1885883a 	add	r2,r3,r2
 200a318:	e0bff715 	stw	r2,-36(fp)
      if (ilim == 0)
 200a31c:	e0bfd417 	ldw	r2,-176(fp)
 200a320:	1000271e 	bne	r2,zero,200a3c0 <_dtoa_r+0xae4>
	{
	  S = mhi = 0;
 200a324:	e03fe315 	stw	zero,-116(fp)
 200a328:	e0bfe317 	ldw	r2,-116(fp)
 200a32c:	e0bfe415 	stw	r2,-112(fp)
	  d.d -= 5.;
 200a330:	e0bff217 	ldw	r2,-56(fp)
 200a334:	e0fff317 	ldw	r3,-52(fp)
 200a338:	000d883a 	mov	r6,zero
 200a33c:	01d00534 	movhi	r7,16404
 200a340:	1009883a 	mov	r4,r2
 200a344:	180b883a 	mov	r5,r3
 200a348:	2005b980 	call	2005b98 <__subdf3>
 200a34c:	1009883a 	mov	r4,r2
 200a350:	180b883a 	mov	r5,r3
 200a354:	2005883a 	mov	r2,r4
 200a358:	2807883a 	mov	r3,r5
 200a35c:	e0bff215 	stw	r2,-56(fp)
 200a360:	e0fff315 	stw	r3,-52(fp)
	  if (d.d > eps.d)
 200a364:	e0bff217 	ldw	r2,-56(fp)
 200a368:	e0fff317 	ldw	r3,-52(fp)
 200a36c:	e13ff617 	ldw	r4,-40(fp)
 200a370:	e17ff717 	ldw	r5,-36(fp)
 200a374:	200d883a 	mov	r6,r4
 200a378:	280f883a 	mov	r7,r5
 200a37c:	1009883a 	mov	r4,r2
 200a380:	180b883a 	mov	r5,r3
 200a384:	20052b00 	call	20052b0 <__gedf2>
 200a388:	0082eb16 	blt	zero,r2,200af38 <_dtoa_r+0x165c>
	    goto one_digit;
	  if (d.d < -eps.d)
 200a38c:	e23ff217 	ldw	r8,-56(fp)
 200a390:	e27ff317 	ldw	r9,-52(fp)
 200a394:	e0bff617 	ldw	r2,-40(fp)
 200a398:	e0fff717 	ldw	r3,-36(fp)
 200a39c:	1021883a 	mov	r16,r2
 200a3a0:	1c60003c 	xorhi	r17,r3,32768
 200a3a4:	800d883a 	mov	r6,r16
 200a3a8:	880f883a 	mov	r7,r17
 200a3ac:	4009883a 	mov	r4,r8
 200a3b0:	480b883a 	mov	r5,r9
 200a3b4:	200538c0 	call	200538c <__ledf2>
 200a3b8:	1002da16 	blt	r2,zero,200af24 <_dtoa_r+0x1648>
	    goto no_digits;
	  goto fast_failed;
 200a3bc:	0000fc06 	br	200a7b0 <_dtoa_r+0xed4>
	}
#ifndef No_leftright
      if (leftright)
 200a3c0:	e0bfd917 	ldw	r2,-156(fp)
 200a3c4:	10007a26 	beq	r2,zero,200a5b0 <_dtoa_r+0xcd4>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
 200a3c8:	e0bfd417 	ldw	r2,-176(fp)
 200a3cc:	10ffffc4 	addi	r3,r2,-1
 200a3d0:	008080b4 	movhi	r2,514
 200a3d4:	10be1304 	addi	r2,r2,-1972
 200a3d8:	180690fa 	slli	r3,r3,3
 200a3dc:	10c9883a 	add	r4,r2,r3
 200a3e0:	20800017 	ldw	r2,0(r4)
 200a3e4:	20c00117 	ldw	r3,4(r4)
 200a3e8:	100d883a 	mov	r6,r2
 200a3ec:	180f883a 	mov	r7,r3
 200a3f0:	0009883a 	mov	r4,zero
 200a3f4:	014ff834 	movhi	r5,16352
 200a3f8:	20049400 	call	2004940 <__divdf3>
 200a3fc:	1009883a 	mov	r4,r2
 200a400:	180b883a 	mov	r5,r3
 200a404:	2011883a 	mov	r8,r4
 200a408:	2813883a 	mov	r9,r5
 200a40c:	e0bff617 	ldw	r2,-40(fp)
 200a410:	e0fff717 	ldw	r3,-36(fp)
 200a414:	100d883a 	mov	r6,r2
 200a418:	180f883a 	mov	r7,r3
 200a41c:	4009883a 	mov	r4,r8
 200a420:	480b883a 	mov	r5,r9
 200a424:	2005b980 	call	2005b98 <__subdf3>
 200a428:	1009883a 	mov	r4,r2
 200a42c:	180b883a 	mov	r5,r3
 200a430:	2005883a 	mov	r2,r4
 200a434:	2807883a 	mov	r3,r5
 200a438:	e0bff615 	stw	r2,-40(fp)
 200a43c:	e0fff715 	stw	r3,-36(fp)
	  for (i = 0;;)
 200a440:	e03fd215 	stw	zero,-184(fp)
	    {
	      L = d.d;
 200a444:	e0bff217 	ldw	r2,-56(fp)
 200a448:	e0fff317 	ldw	r3,-52(fp)
 200a44c:	1009883a 	mov	r4,r2
 200a450:	180b883a 	mov	r5,r3
 200a454:	2013a380 	call	2013a38 <__fixdfsi>
 200a458:	e0bfed15 	stw	r2,-76(fp)
	      d.d -= L;
 200a45c:	e43ff217 	ldw	r16,-56(fp)
 200a460:	e47ff317 	ldw	r17,-52(fp)
 200a464:	e13fed17 	ldw	r4,-76(fp)
 200a468:	2013ab80 	call	2013ab8 <__floatsidf>
 200a46c:	1009883a 	mov	r4,r2
 200a470:	180b883a 	mov	r5,r3
 200a474:	200d883a 	mov	r6,r4
 200a478:	280f883a 	mov	r7,r5
 200a47c:	8009883a 	mov	r4,r16
 200a480:	880b883a 	mov	r5,r17
 200a484:	2005b980 	call	2005b98 <__subdf3>
 200a488:	1009883a 	mov	r4,r2
 200a48c:	180b883a 	mov	r5,r3
 200a490:	2005883a 	mov	r2,r4
 200a494:	2807883a 	mov	r3,r5
 200a498:	e0bff215 	stw	r2,-56(fp)
 200a49c:	e0fff315 	stw	r3,-52(fp)
	      *s++ = '0' + (int) L;
 200a4a0:	e0bfe717 	ldw	r2,-100(fp)
 200a4a4:	10c00044 	addi	r3,r2,1
 200a4a8:	e0ffe715 	stw	r3,-100(fp)
 200a4ac:	e0ffed17 	ldw	r3,-76(fp)
 200a4b0:	18c00c04 	addi	r3,r3,48
 200a4b4:	10c00005 	stb	r3,0(r2)
	      if (d.d < eps.d)
 200a4b8:	e0bff217 	ldw	r2,-56(fp)
 200a4bc:	e0fff317 	ldw	r3,-52(fp)
 200a4c0:	e13ff617 	ldw	r4,-40(fp)
 200a4c4:	e17ff717 	ldw	r5,-36(fp)
 200a4c8:	200d883a 	mov	r6,r4
 200a4cc:	280f883a 	mov	r7,r5
 200a4d0:	1009883a 	mov	r4,r2
 200a4d4:	180b883a 	mov	r5,r3
 200a4d8:	200538c0 	call	200538c <__ledf2>
 200a4dc:	1003c416 	blt	r2,zero,200b3f0 <_dtoa_r+0x1b14>
		goto ret1;
	      if (1. - d.d < eps.d)
 200a4e0:	e0bff217 	ldw	r2,-56(fp)
 200a4e4:	e0fff317 	ldw	r3,-52(fp)
 200a4e8:	100d883a 	mov	r6,r2
 200a4ec:	180f883a 	mov	r7,r3
 200a4f0:	0009883a 	mov	r4,zero
 200a4f4:	014ffc34 	movhi	r5,16368
 200a4f8:	2005b980 	call	2005b98 <__subdf3>
 200a4fc:	1009883a 	mov	r4,r2
 200a500:	180b883a 	mov	r5,r3
 200a504:	2011883a 	mov	r8,r4
 200a508:	2813883a 	mov	r9,r5
 200a50c:	e0bff617 	ldw	r2,-40(fp)
 200a510:	e0fff717 	ldw	r3,-36(fp)
 200a514:	100d883a 	mov	r6,r2
 200a518:	180f883a 	mov	r7,r3
 200a51c:	4009883a 	mov	r4,r8
 200a520:	480b883a 	mov	r5,r9
 200a524:	200538c0 	call	200538c <__ledf2>
 200a528:	10012916 	blt	r2,zero,200a9d0 <_dtoa_r+0x10f4>
		goto bump_up;
	      if (++i >= ilim)
 200a52c:	e0bfd217 	ldw	r2,-184(fp)
 200a530:	10800044 	addi	r2,r2,1
 200a534:	e0bfd215 	stw	r2,-184(fp)
 200a538:	e0ffd217 	ldw	r3,-184(fp)
 200a53c:	e0bfd417 	ldw	r2,-176(fp)
 200a540:	18809a0e 	bge	r3,r2,200a7ac <_dtoa_r+0xed0>
		break;
	      eps.d *= 10.;
 200a544:	e0bff617 	ldw	r2,-40(fp)
 200a548:	e0fff717 	ldw	r3,-36(fp)
 200a54c:	000d883a 	mov	r6,zero
 200a550:	01d00934 	movhi	r7,16420
 200a554:	1009883a 	mov	r4,r2
 200a558:	180b883a 	mov	r5,r3
 200a55c:	20054800 	call	2005480 <__muldf3>
 200a560:	1009883a 	mov	r4,r2
 200a564:	180b883a 	mov	r5,r3
 200a568:	2005883a 	mov	r2,r4
 200a56c:	2807883a 	mov	r3,r5
 200a570:	e0bff615 	stw	r2,-40(fp)
 200a574:	e0fff715 	stw	r3,-36(fp)
	      d.d *= 10.;
 200a578:	e0bff217 	ldw	r2,-56(fp)
 200a57c:	e0fff317 	ldw	r3,-52(fp)
 200a580:	000d883a 	mov	r6,zero
 200a584:	01d00934 	movhi	r7,16420
 200a588:	1009883a 	mov	r4,r2
 200a58c:	180b883a 	mov	r5,r3
 200a590:	20054800 	call	2005480 <__muldf3>
 200a594:	1009883a 	mov	r4,r2
 200a598:	180b883a 	mov	r5,r3
 200a59c:	2005883a 	mov	r2,r4
 200a5a0:	2807883a 	mov	r3,r5
 200a5a4:	e0bff215 	stw	r2,-56(fp)
 200a5a8:	e0fff315 	stw	r3,-52(fp)
	    }
 200a5ac:	003fa506 	br	200a444 <_dtoa_r+0xb68>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
 200a5b0:	e0bff617 	ldw	r2,-40(fp)
 200a5b4:	e0fff717 	ldw	r3,-36(fp)
 200a5b8:	e13fd417 	ldw	r4,-176(fp)
 200a5bc:	217fffc4 	addi	r5,r4,-1
 200a5c0:	010080b4 	movhi	r4,514
 200a5c4:	213e1304 	addi	r4,r4,-1972
 200a5c8:	280a90fa 	slli	r5,r5,3
 200a5cc:	214d883a 	add	r6,r4,r5
 200a5d0:	31000017 	ldw	r4,0(r6)
 200a5d4:	31400117 	ldw	r5,4(r6)
 200a5d8:	200d883a 	mov	r6,r4
 200a5dc:	280f883a 	mov	r7,r5
 200a5e0:	1009883a 	mov	r4,r2
 200a5e4:	180b883a 	mov	r5,r3
 200a5e8:	20054800 	call	2005480 <__muldf3>
 200a5ec:	1009883a 	mov	r4,r2
 200a5f0:	180b883a 	mov	r5,r3
 200a5f4:	2005883a 	mov	r2,r4
 200a5f8:	2807883a 	mov	r3,r5
 200a5fc:	e0bff615 	stw	r2,-40(fp)
 200a600:	e0fff715 	stw	r3,-36(fp)
	  for (i = 1;; i++, d.d *= 10.)
 200a604:	00800044 	movi	r2,1
 200a608:	e0bfd215 	stw	r2,-184(fp)
	    {
	      L = d.d;
 200a60c:	e0bff217 	ldw	r2,-56(fp)
 200a610:	e0fff317 	ldw	r3,-52(fp)
 200a614:	1009883a 	mov	r4,r2
 200a618:	180b883a 	mov	r5,r3
 200a61c:	2013a380 	call	2013a38 <__fixdfsi>
 200a620:	e0bfed15 	stw	r2,-76(fp)
	      d.d -= L;
 200a624:	e43ff217 	ldw	r16,-56(fp)
 200a628:	e47ff317 	ldw	r17,-52(fp)
 200a62c:	e13fed17 	ldw	r4,-76(fp)
 200a630:	2013ab80 	call	2013ab8 <__floatsidf>
 200a634:	1009883a 	mov	r4,r2
 200a638:	180b883a 	mov	r5,r3
 200a63c:	200d883a 	mov	r6,r4
 200a640:	280f883a 	mov	r7,r5
 200a644:	8009883a 	mov	r4,r16
 200a648:	880b883a 	mov	r5,r17
 200a64c:	2005b980 	call	2005b98 <__subdf3>
 200a650:	1009883a 	mov	r4,r2
 200a654:	180b883a 	mov	r5,r3
 200a658:	2005883a 	mov	r2,r4
 200a65c:	2807883a 	mov	r3,r5
 200a660:	e0bff215 	stw	r2,-56(fp)
 200a664:	e0fff315 	stw	r3,-52(fp)
	      *s++ = '0' + (int) L;
 200a668:	e0bfe717 	ldw	r2,-100(fp)
 200a66c:	10c00044 	addi	r3,r2,1
 200a670:	e0ffe715 	stw	r3,-100(fp)
 200a674:	e0ffed17 	ldw	r3,-76(fp)
 200a678:	18c00c04 	addi	r3,r3,48
 200a67c:	10c00005 	stb	r3,0(r2)
	      if (i == ilim)
 200a680:	e0ffd217 	ldw	r3,-184(fp)
 200a684:	e0bfd417 	ldw	r2,-176(fp)
 200a688:	1880351e 	bne	r3,r2,200a760 <_dtoa_r+0xe84>
		{
		  if (d.d > 0.5 + eps.d)
 200a68c:	e43ff217 	ldw	r16,-56(fp)
 200a690:	e47ff317 	ldw	r17,-52(fp)
 200a694:	e0bff617 	ldw	r2,-40(fp)
 200a698:	e0fff717 	ldw	r3,-36(fp)
 200a69c:	000d883a 	mov	r6,zero
 200a6a0:	01cff834 	movhi	r7,16352
 200a6a4:	1009883a 	mov	r4,r2
 200a6a8:	180b883a 	mov	r5,r3
 200a6ac:	20040940 	call	2004094 <__adddf3>
 200a6b0:	1009883a 	mov	r4,r2
 200a6b4:	180b883a 	mov	r5,r3
 200a6b8:	2005883a 	mov	r2,r4
 200a6bc:	2807883a 	mov	r3,r5
 200a6c0:	100d883a 	mov	r6,r2
 200a6c4:	180f883a 	mov	r7,r3
 200a6c8:	8009883a 	mov	r4,r16
 200a6cc:	880b883a 	mov	r5,r17
 200a6d0:	20052b00 	call	20052b0 <__gedf2>
 200a6d4:	0080c016 	blt	zero,r2,200a9d8 <_dtoa_r+0x10fc>
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
 200a6d8:	e43ff217 	ldw	r16,-56(fp)
 200a6dc:	e47ff317 	ldw	r17,-52(fp)
 200a6e0:	e0bff617 	ldw	r2,-40(fp)
 200a6e4:	e0fff717 	ldw	r3,-36(fp)
 200a6e8:	100d883a 	mov	r6,r2
 200a6ec:	180f883a 	mov	r7,r3
 200a6f0:	0009883a 	mov	r4,zero
 200a6f4:	014ff834 	movhi	r5,16352
 200a6f8:	2005b980 	call	2005b98 <__subdf3>
 200a6fc:	1009883a 	mov	r4,r2
 200a700:	180b883a 	mov	r5,r3
 200a704:	2005883a 	mov	r2,r4
 200a708:	2807883a 	mov	r3,r5
 200a70c:	100d883a 	mov	r6,r2
 200a710:	180f883a 	mov	r7,r3
 200a714:	8009883a 	mov	r4,r16
 200a718:	880b883a 	mov	r5,r17
 200a71c:	200538c0 	call	200538c <__ledf2>
 200a720:	10000116 	blt	r2,zero,200a728 <_dtoa_r+0xe4c>
		    {
		      while (*--s == '0');
		      s++;
		      goto ret1;
		    }
		  break;
 200a724:	00002206 	br	200a7b0 <_dtoa_r+0xed4>
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
		    {
		      while (*--s == '0');
 200a728:	e0bfe717 	ldw	r2,-100(fp)
 200a72c:	10bfffc4 	addi	r2,r2,-1
 200a730:	e0bfe715 	stw	r2,-100(fp)
 200a734:	e0bfe717 	ldw	r2,-100(fp)
 200a738:	10800003 	ldbu	r2,0(r2)
 200a73c:	10803fcc 	andi	r2,r2,255
 200a740:	1080201c 	xori	r2,r2,128
 200a744:	10bfe004 	addi	r2,r2,-128
 200a748:	10800c20 	cmpeqi	r2,r2,48
 200a74c:	103ff61e 	bne	r2,zero,200a728 <_dtoa_r+0xe4c>
		      s++;
 200a750:	e0bfe717 	ldw	r2,-100(fp)
 200a754:	10800044 	addi	r2,r2,1
 200a758:	e0bfe715 	stw	r2,-100(fp)
		      goto ret1;
 200a75c:	00032506 	br	200b3f4 <_dtoa_r+0x1b18>
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
 200a760:	e0bfd217 	ldw	r2,-184(fp)
 200a764:	10800044 	addi	r2,r2,1
 200a768:	e0bfd215 	stw	r2,-184(fp)
 200a76c:	e0bff217 	ldw	r2,-56(fp)
 200a770:	e0fff317 	ldw	r3,-52(fp)
 200a774:	000d883a 	mov	r6,zero
 200a778:	01d00934 	movhi	r7,16420
 200a77c:	1009883a 	mov	r4,r2
 200a780:	180b883a 	mov	r5,r3
 200a784:	20054800 	call	2005480 <__muldf3>
 200a788:	1009883a 	mov	r4,r2
 200a78c:	180b883a 	mov	r5,r3
 200a790:	2005883a 	mov	r2,r4
 200a794:	2807883a 	mov	r3,r5
 200a798:	e0bff215 	stw	r2,-56(fp)
 200a79c:	e0fff315 	stw	r3,-52(fp)
		      s++;
		      goto ret1;
		    }
		  break;
		}
	    }
 200a7a0:	003f9a06 	br	200a60c <_dtoa_r+0xd30>
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
	{
	  if (ilim1 <= 0)
	    goto fast_failed;
 200a7a4:	0001883a 	nop
 200a7a8:	00000106 	br	200a7b0 <_dtoa_r+0xed4>
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
	      if (++i >= ilim)
		break;
 200a7ac:	0001883a 	nop
	    }
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
 200a7b0:	e0bfe917 	ldw	r2,-92(fp)
 200a7b4:	e0bfe715 	stw	r2,-100(fp)
      d.d = d2.d;
 200a7b8:	e0bff417 	ldw	r2,-48(fp)
 200a7bc:	e0fff517 	ldw	r3,-44(fp)
 200a7c0:	e0bff215 	stw	r2,-56(fp)
 200a7c4:	e0fff315 	stw	r3,-52(fp)
      k = k0;
 200a7c8:	e0bfea17 	ldw	r2,-88(fp)
 200a7cc:	e0bfd715 	stw	r2,-164(fp)
      ilim = ilim0;
 200a7d0:	e0bfeb17 	ldw	r2,-84(fp)
 200a7d4:	e0bfd415 	stw	r2,-176(fp)
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
 200a7d8:	e0bff117 	ldw	r2,-60(fp)
 200a7dc:	1000b816 	blt	r2,zero,200aac0 <_dtoa_r+0x11e4>
 200a7e0:	e0bfd717 	ldw	r2,-164(fp)
 200a7e4:	108003c8 	cmpgei	r2,r2,15
 200a7e8:	1000b51e 	bne	r2,zero,200aac0 <_dtoa_r+0x11e4>
    {
      /* Yes. */
      ds = tens[k];
 200a7ec:	008080b4 	movhi	r2,514
 200a7f0:	10be1304 	addi	r2,r2,-1972
 200a7f4:	e0ffd717 	ldw	r3,-164(fp)
 200a7f8:	180690fa 	slli	r3,r3,3
 200a7fc:	10c5883a 	add	r2,r2,r3
 200a800:	10c00017 	ldw	r3,0(r2)
 200a804:	e0ffe515 	stw	r3,-108(fp)
 200a808:	10800117 	ldw	r2,4(r2)
 200a80c:	e0bfe615 	stw	r2,-104(fp)
      if (ndigits < 0 && ilim <= 0)
 200a810:	e0800217 	ldw	r2,8(fp)
 200a814:	1000190e 	bge	r2,zero,200a87c <_dtoa_r+0xfa0>
 200a818:	e0bfd417 	ldw	r2,-176(fp)
 200a81c:	00801716 	blt	zero,r2,200a87c <_dtoa_r+0xfa0>
	{
	  S = mhi = 0;
 200a820:	e03fe315 	stw	zero,-116(fp)
 200a824:	e0bfe317 	ldw	r2,-116(fp)
 200a828:	e0bfe415 	stw	r2,-112(fp)
	  if (ilim < 0 || d.d <= 5 * ds)
 200a82c:	e0bfd417 	ldw	r2,-176(fp)
 200a830:	1001bd16 	blt	r2,zero,200af28 <_dtoa_r+0x164c>
 200a834:	e43ff217 	ldw	r16,-56(fp)
 200a838:	e47ff317 	ldw	r17,-52(fp)
 200a83c:	000d883a 	mov	r6,zero
 200a840:	01d00534 	movhi	r7,16404
 200a844:	e13fe517 	ldw	r4,-108(fp)
 200a848:	e17fe617 	ldw	r5,-104(fp)
 200a84c:	20054800 	call	2005480 <__muldf3>
 200a850:	1009883a 	mov	r4,r2
 200a854:	180b883a 	mov	r5,r3
 200a858:	2005883a 	mov	r2,r4
 200a85c:	2807883a 	mov	r3,r5
 200a860:	100d883a 	mov	r6,r2
 200a864:	180f883a 	mov	r7,r3
 200a868:	8009883a 	mov	r4,r16
 200a86c:	880b883a 	mov	r5,r17
 200a870:	200538c0 	call	200538c <__ledf2>
 200a874:	0081ac0e 	bge	zero,r2,200af28 <_dtoa_r+0x164c>
	    goto no_digits;
	  goto one_digit;
 200a878:	0001b006 	br	200af3c <_dtoa_r+0x1660>
	}
      for (i = 1;; i++)
 200a87c:	00800044 	movi	r2,1
 200a880:	e0bfd215 	stw	r2,-184(fp)
	{
	  L = d.d / ds;
 200a884:	e0bff217 	ldw	r2,-56(fp)
 200a888:	e0fff317 	ldw	r3,-52(fp)
 200a88c:	e1bfe517 	ldw	r6,-108(fp)
 200a890:	e1ffe617 	ldw	r7,-104(fp)
 200a894:	1009883a 	mov	r4,r2
 200a898:	180b883a 	mov	r5,r3
 200a89c:	20049400 	call	2004940 <__divdf3>
 200a8a0:	1009883a 	mov	r4,r2
 200a8a4:	180b883a 	mov	r5,r3
 200a8a8:	2005883a 	mov	r2,r4
 200a8ac:	2807883a 	mov	r3,r5
 200a8b0:	1009883a 	mov	r4,r2
 200a8b4:	180b883a 	mov	r5,r3
 200a8b8:	2013a380 	call	2013a38 <__fixdfsi>
 200a8bc:	e0bfed15 	stw	r2,-76(fp)
	  d.d -= L * ds;
 200a8c0:	e43ff217 	ldw	r16,-56(fp)
 200a8c4:	e47ff317 	ldw	r17,-52(fp)
 200a8c8:	e13fed17 	ldw	r4,-76(fp)
 200a8cc:	2013ab80 	call	2013ab8 <__floatsidf>
 200a8d0:	1011883a 	mov	r8,r2
 200a8d4:	1813883a 	mov	r9,r3
 200a8d8:	e1bfe517 	ldw	r6,-108(fp)
 200a8dc:	e1ffe617 	ldw	r7,-104(fp)
 200a8e0:	4009883a 	mov	r4,r8
 200a8e4:	480b883a 	mov	r5,r9
 200a8e8:	20054800 	call	2005480 <__muldf3>
 200a8ec:	1009883a 	mov	r4,r2
 200a8f0:	180b883a 	mov	r5,r3
 200a8f4:	2005883a 	mov	r2,r4
 200a8f8:	2807883a 	mov	r3,r5
 200a8fc:	100d883a 	mov	r6,r2
 200a900:	180f883a 	mov	r7,r3
 200a904:	8009883a 	mov	r4,r16
 200a908:	880b883a 	mov	r5,r17
 200a90c:	2005b980 	call	2005b98 <__subdf3>
 200a910:	1009883a 	mov	r4,r2
 200a914:	180b883a 	mov	r5,r3
 200a918:	2005883a 	mov	r2,r4
 200a91c:	2807883a 	mov	r3,r5
 200a920:	e0bff215 	stw	r2,-56(fp)
 200a924:	e0fff315 	stw	r3,-52(fp)
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
 200a928:	e0bfe717 	ldw	r2,-100(fp)
 200a92c:	10c00044 	addi	r3,r2,1
 200a930:	e0ffe715 	stw	r3,-100(fp)
 200a934:	e0ffed17 	ldw	r3,-76(fp)
 200a938:	18c00c04 	addi	r3,r3,48
 200a93c:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 200a940:	e0ffd217 	ldw	r3,-184(fp)
 200a944:	e0bfd417 	ldw	r2,-176(fp)
 200a948:	1880401e 	bne	r3,r2,200aa4c <_dtoa_r+0x1170>
	    {
	      d.d += d.d;
 200a94c:	e0bff217 	ldw	r2,-56(fp)
 200a950:	e0fff317 	ldw	r3,-52(fp)
 200a954:	100d883a 	mov	r6,r2
 200a958:	180f883a 	mov	r7,r3
 200a95c:	1009883a 	mov	r4,r2
 200a960:	180b883a 	mov	r5,r3
 200a964:	20040940 	call	2004094 <__adddf3>
 200a968:	1009883a 	mov	r4,r2
 200a96c:	180b883a 	mov	r5,r3
 200a970:	2005883a 	mov	r2,r4
 200a974:	2807883a 	mov	r3,r5
 200a978:	e0bff215 	stw	r2,-56(fp)
 200a97c:	e0fff315 	stw	r3,-52(fp)
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
 200a980:	e0bff217 	ldw	r2,-56(fp)
 200a984:	e0fff317 	ldw	r3,-52(fp)
 200a988:	e1bfe517 	ldw	r6,-108(fp)
 200a98c:	e1ffe617 	ldw	r7,-104(fp)
 200a990:	1009883a 	mov	r4,r2
 200a994:	180b883a 	mov	r5,r3
 200a998:	20052b00 	call	20052b0 <__gedf2>
 200a99c:	00801a16 	blt	zero,r2,200aa08 <_dtoa_r+0x112c>
 200a9a0:	e0bff217 	ldw	r2,-56(fp)
 200a9a4:	e0fff317 	ldw	r3,-52(fp)
 200a9a8:	e1bfe517 	ldw	r6,-108(fp)
 200a9ac:	e1ffe617 	ldw	r7,-104(fp)
 200a9b0:	1009883a 	mov	r4,r2
 200a9b4:	180b883a 	mov	r5,r3
 200a9b8:	20052280 	call	2005228 <__eqdf2>
 200a9bc:	10003c1e 	bne	r2,zero,200aab0 <_dtoa_r+0x11d4>
 200a9c0:	e0bfed17 	ldw	r2,-76(fp)
 200a9c4:	1080004c 	andi	r2,r2,1
 200a9c8:	10003926 	beq	r2,zero,200aab0 <_dtoa_r+0x11d4>
 200a9cc:	00000e06 	br	200aa08 <_dtoa_r+0x112c>
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
	      if (1. - d.d < eps.d)
		goto bump_up;
 200a9d0:	0001883a 	nop
 200a9d4:	00000c06 	br	200aa08 <_dtoa_r+0x112c>
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (i == ilim)
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
 200a9d8:	0001883a 	nop
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
 200a9dc:	00000a06 	br	200aa08 <_dtoa_r+0x112c>
		    if (s == s0)
 200a9e0:	e0ffe717 	ldw	r3,-100(fp)
 200a9e4:	e0bfe917 	ldw	r2,-92(fp)
 200a9e8:	1880071e 	bne	r3,r2,200aa08 <_dtoa_r+0x112c>
		      {
			k++;
 200a9ec:	e0bfd717 	ldw	r2,-164(fp)
 200a9f0:	10800044 	addi	r2,r2,1
 200a9f4:	e0bfd715 	stw	r2,-164(fp)
			*s = '0';
 200a9f8:	e0bfe717 	ldw	r2,-100(fp)
 200a9fc:	00c00c04 	movi	r3,48
 200aa00:	10c00005 	stb	r3,0(r2)
			break;
 200aa04:	00000a06 	br	200aa30 <_dtoa_r+0x1154>
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
 200aa08:	e0bfe717 	ldw	r2,-100(fp)
 200aa0c:	10bfffc4 	addi	r2,r2,-1
 200aa10:	e0bfe715 	stw	r2,-100(fp)
 200aa14:	e0bfe717 	ldw	r2,-100(fp)
 200aa18:	10800003 	ldbu	r2,0(r2)
 200aa1c:	10803fcc 	andi	r2,r2,255
 200aa20:	1080201c 	xori	r2,r2,128
 200aa24:	10bfe004 	addi	r2,r2,-128
 200aa28:	10800e60 	cmpeqi	r2,r2,57
 200aa2c:	103fec1e 	bne	r2,zero,200a9e0 <_dtoa_r+0x1104>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
 200aa30:	e0bfe717 	ldw	r2,-100(fp)
 200aa34:	10c00044 	addi	r3,r2,1
 200aa38:	e0ffe715 	stw	r3,-100(fp)
 200aa3c:	10c00003 	ldbu	r3,0(r2)
 200aa40:	18c00044 	addi	r3,r3,1
 200aa44:	10c00005 	stb	r3,0(r2)
		}
	      break;
 200aa48:	00001906 	br	200aab0 <_dtoa_r+0x11d4>
	    }
	  if (!(d.d *= 10.))
 200aa4c:	e0bff217 	ldw	r2,-56(fp)
 200aa50:	e0fff317 	ldw	r3,-52(fp)
 200aa54:	000d883a 	mov	r6,zero
 200aa58:	01d00934 	movhi	r7,16420
 200aa5c:	1009883a 	mov	r4,r2
 200aa60:	180b883a 	mov	r5,r3
 200aa64:	20054800 	call	2005480 <__muldf3>
 200aa68:	1009883a 	mov	r4,r2
 200aa6c:	180b883a 	mov	r5,r3
 200aa70:	2005883a 	mov	r2,r4
 200aa74:	2807883a 	mov	r3,r5
 200aa78:	e0bff215 	stw	r2,-56(fp)
 200aa7c:	e0fff315 	stw	r3,-52(fp)
 200aa80:	e0bff217 	ldw	r2,-56(fp)
 200aa84:	e0fff317 	ldw	r3,-52(fp)
 200aa88:	000d883a 	mov	r6,zero
 200aa8c:	000f883a 	mov	r7,zero
 200aa90:	1009883a 	mov	r4,r2
 200aa94:	180b883a 	mov	r5,r3
 200aa98:	20052280 	call	2005228 <__eqdf2>
 200aa9c:	10000626 	beq	r2,zero,200aab8 <_dtoa_r+0x11dc>
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
 200aaa0:	e0bfd217 	ldw	r2,-184(fp)
 200aaa4:	10800044 	addi	r2,r2,1
 200aaa8:	e0bfd215 	stw	r2,-184(fp)
		}
	      break;
	    }
	  if (!(d.d *= 10.))
	    break;
	}
 200aaac:	003f7506 	br	200a884 <_dtoa_r+0xfa8>
			*s = '0';
			break;
		      }
		  ++*s++;
		}
	      break;
 200aab0:	0001883a 	nop
 200aab4:	00024f06 	br	200b3f4 <_dtoa_r+0x1b18>
	    }
	  if (!(d.d *= 10.))
	    break;
 200aab8:	0001883a 	nop
	}
      goto ret1;
 200aabc:	00024d06 	br	200b3f4 <_dtoa_r+0x1b18>
    }

  m2 = b2;
 200aac0:	e0bfcf17 	ldw	r2,-196(fp)
 200aac4:	e0bfda15 	stw	r2,-152(fp)
  m5 = b5;
 200aac8:	e0bfd017 	ldw	r2,-192(fp)
 200aacc:	e0bfdb15 	stw	r2,-148(fp)
  mhi = mlo = 0;
 200aad0:	e03fe215 	stw	zero,-120(fp)
 200aad4:	e0bfe217 	ldw	r2,-120(fp)
 200aad8:	e0bfe315 	stw	r2,-116(fp)
  if (leftright)
 200aadc:	e0bfd917 	ldw	r2,-156(fp)
 200aae0:	10003a26 	beq	r2,zero,200abcc <_dtoa_r+0x12f0>
    {
      if (mode < 2)
 200aae4:	e0bffb17 	ldw	r2,-20(fp)
 200aae8:	10800088 	cmpgei	r2,r2,2
 200aaec:	10000a1e 	bne	r2,zero,200ab18 <_dtoa_r+0x123c>
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 200aaf0:	e0bfe017 	ldw	r2,-128(fp)
 200aaf4:	10000326 	beq	r2,zero,200ab04 <_dtoa_r+0x1228>
 200aaf8:	e0bff117 	ldw	r2,-60(fp)
 200aafc:	10810cc4 	addi	r2,r2,1075
 200ab00:	00000306 	br	200ab10 <_dtoa_r+0x1234>
#endif
#ifdef IBM
	    1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
#else
	    1 + P - bbits;
 200ab04:	e0bff017 	ldw	r2,-64(fp)
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
 200ab08:	00c00d84 	movi	r3,54
 200ab0c:	1885c83a 	sub	r2,r3,r2
  mhi = mlo = 0;
  if (leftright)
    {
      if (mode < 2)
	{
	  i =
 200ab10:	e0bfd215 	stw	r2,-184(fp)
 200ab14:	00002106 	br	200ab9c <_dtoa_r+0x12c0>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
 200ab18:	e0bfd417 	ldw	r2,-176(fp)
 200ab1c:	10bfffc4 	addi	r2,r2,-1
 200ab20:	e0bfd615 	stw	r2,-168(fp)
	  if (m5 >= j)
 200ab24:	e0ffdb17 	ldw	r3,-148(fp)
 200ab28:	e0bfd617 	ldw	r2,-168(fp)
 200ab2c:	18800516 	blt	r3,r2,200ab44 <_dtoa_r+0x1268>
	    m5 -= j;
 200ab30:	e0ffdb17 	ldw	r3,-148(fp)
 200ab34:	e0bfd617 	ldw	r2,-168(fp)
 200ab38:	1885c83a 	sub	r2,r3,r2
 200ab3c:	e0bfdb15 	stw	r2,-148(fp)
 200ab40:	00000d06 	br	200ab78 <_dtoa_r+0x129c>
	  else
	    {
	      s5 += j -= m5;
 200ab44:	e0ffd617 	ldw	r3,-168(fp)
 200ab48:	e0bfdb17 	ldw	r2,-148(fp)
 200ab4c:	1885c83a 	sub	r2,r3,r2
 200ab50:	e0bfd615 	stw	r2,-168(fp)
 200ab54:	e0bfd617 	ldw	r2,-168(fp)
 200ab58:	e0ffdd17 	ldw	r3,-140(fp)
 200ab5c:	1885883a 	add	r2,r3,r2
 200ab60:	e0bfdd15 	stw	r2,-140(fp)
	      b5 += j;
 200ab64:	e0ffd017 	ldw	r3,-192(fp)
 200ab68:	e0bfd617 	ldw	r2,-168(fp)
 200ab6c:	1885883a 	add	r2,r3,r2
 200ab70:	e0bfd015 	stw	r2,-192(fp)
	      m5 = 0;
 200ab74:	e03fdb15 	stw	zero,-148(fp)
	    }
	  if ((i = ilim) < 0)
 200ab78:	e0bfd417 	ldw	r2,-176(fp)
 200ab7c:	e0bfd215 	stw	r2,-184(fp)
 200ab80:	e0bfd217 	ldw	r2,-184(fp)
 200ab84:	1000050e 	bge	r2,zero,200ab9c <_dtoa_r+0x12c0>
	    {
	      m2 -= i;
 200ab88:	e0ffda17 	ldw	r3,-152(fp)
 200ab8c:	e0bfd217 	ldw	r2,-184(fp)
 200ab90:	1885c83a 	sub	r2,r3,r2
 200ab94:	e0bfda15 	stw	r2,-152(fp)
	      i = 0;
 200ab98:	e03fd215 	stw	zero,-184(fp)
	    }
	}
      b2 += i;
 200ab9c:	e0ffcf17 	ldw	r3,-196(fp)
 200aba0:	e0bfd217 	ldw	r2,-184(fp)
 200aba4:	1885883a 	add	r2,r3,r2
 200aba8:	e0bfcf15 	stw	r2,-196(fp)
      s2 += i;
 200abac:	e0ffdc17 	ldw	r3,-144(fp)
 200abb0:	e0bfd217 	ldw	r2,-184(fp)
 200abb4:	1885883a 	add	r2,r3,r2
 200abb8:	e0bfdc15 	stw	r2,-144(fp)
      mhi = i2b (ptr, 1);
 200abbc:	01400044 	movi	r5,1
 200abc0:	e13ff817 	ldw	r4,-32(fp)
 200abc4:	200e9c00 	call	200e9c0 <__i2b>
 200abc8:	e0bfe315 	stw	r2,-116(fp)
    }
  if (m2 > 0 && s2 > 0)
 200abcc:	e0bfda17 	ldw	r2,-152(fp)
 200abd0:	0080130e 	bge	zero,r2,200ac20 <_dtoa_r+0x1344>
 200abd4:	e0bfdc17 	ldw	r2,-144(fp)
 200abd8:	0080110e 	bge	zero,r2,200ac20 <_dtoa_r+0x1344>
    {
      i = m2 < s2 ? m2 : s2;
 200abdc:	e0ffda17 	ldw	r3,-152(fp)
 200abe0:	e0bfdc17 	ldw	r2,-144(fp)
 200abe4:	1880010e 	bge	r3,r2,200abec <_dtoa_r+0x1310>
 200abe8:	1805883a 	mov	r2,r3
 200abec:	e0bfd215 	stw	r2,-184(fp)
      b2 -= i;
 200abf0:	e0ffcf17 	ldw	r3,-196(fp)
 200abf4:	e0bfd217 	ldw	r2,-184(fp)
 200abf8:	1885c83a 	sub	r2,r3,r2
 200abfc:	e0bfcf15 	stw	r2,-196(fp)
      m2 -= i;
 200ac00:	e0ffda17 	ldw	r3,-152(fp)
 200ac04:	e0bfd217 	ldw	r2,-184(fp)
 200ac08:	1885c83a 	sub	r2,r3,r2
 200ac0c:	e0bfda15 	stw	r2,-152(fp)
      s2 -= i;
 200ac10:	e0ffdc17 	ldw	r3,-144(fp)
 200ac14:	e0bfd217 	ldw	r2,-184(fp)
 200ac18:	1885c83a 	sub	r2,r3,r2
 200ac1c:	e0bfdc15 	stw	r2,-144(fp)
    }
  if (b5 > 0)
 200ac20:	e0bfd017 	ldw	r2,-192(fp)
 200ac24:	0080240e 	bge	zero,r2,200acb8 <_dtoa_r+0x13dc>
    {
      if (leftright)
 200ac28:	e0bfd917 	ldw	r2,-156(fp)
 200ac2c:	10001d26 	beq	r2,zero,200aca4 <_dtoa_r+0x13c8>
	{
	  if (m5 > 0)
 200ac30:	e0bfdb17 	ldw	r2,-148(fp)
 200ac34:	00800f0e 	bge	zero,r2,200ac74 <_dtoa_r+0x1398>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
 200ac38:	e1bfdb17 	ldw	r6,-148(fp)
 200ac3c:	e17fe317 	ldw	r5,-116(fp)
 200ac40:	e13ff817 	ldw	r4,-32(fp)
 200ac44:	200ede80 	call	200ede8 <__pow5mult>
 200ac48:	e0bfe315 	stw	r2,-116(fp)
	      b1 = mult (ptr, mhi, b);
 200ac4c:	e1bfe117 	ldw	r6,-124(fp)
 200ac50:	e17fe317 	ldw	r5,-116(fp)
 200ac54:	e13ff817 	ldw	r4,-32(fp)
 200ac58:	200ea180 	call	200ea18 <__multiply>
 200ac5c:	e0bfee15 	stw	r2,-72(fp)
	      Bfree (ptr, b);
 200ac60:	e17fe117 	ldw	r5,-124(fp)
 200ac64:	e13ff817 	ldw	r4,-32(fp)
 200ac68:	200e4a80 	call	200e4a8 <_Bfree>
	      b = b1;
 200ac6c:	e0bfee17 	ldw	r2,-72(fp)
 200ac70:	e0bfe115 	stw	r2,-124(fp)
	    }
         if ((j = b5 - m5) != 0)
 200ac74:	e0ffd017 	ldw	r3,-192(fp)
 200ac78:	e0bfdb17 	ldw	r2,-148(fp)
 200ac7c:	1885c83a 	sub	r2,r3,r2
 200ac80:	e0bfd615 	stw	r2,-168(fp)
 200ac84:	e0bfd617 	ldw	r2,-168(fp)
 200ac88:	10000b26 	beq	r2,zero,200acb8 <_dtoa_r+0x13dc>
	    b = pow5mult (ptr, b, j);
 200ac8c:	e1bfd617 	ldw	r6,-168(fp)
 200ac90:	e17fe117 	ldw	r5,-124(fp)
 200ac94:	e13ff817 	ldw	r4,-32(fp)
 200ac98:	200ede80 	call	200ede8 <__pow5mult>
 200ac9c:	e0bfe115 	stw	r2,-124(fp)
 200aca0:	00000506 	br	200acb8 <_dtoa_r+0x13dc>
	}
      else
	b = pow5mult (ptr, b, b5);
 200aca4:	e1bfd017 	ldw	r6,-192(fp)
 200aca8:	e17fe117 	ldw	r5,-124(fp)
 200acac:	e13ff817 	ldw	r4,-32(fp)
 200acb0:	200ede80 	call	200ede8 <__pow5mult>
 200acb4:	e0bfe115 	stw	r2,-124(fp)
    }
  S = i2b (ptr, 1);
 200acb8:	01400044 	movi	r5,1
 200acbc:	e13ff817 	ldw	r4,-32(fp)
 200acc0:	200e9c00 	call	200e9c0 <__i2b>
 200acc4:	e0bfe415 	stw	r2,-112(fp)
  if (s5 > 0)
 200acc8:	e0bfdd17 	ldw	r2,-140(fp)
 200accc:	0080050e 	bge	zero,r2,200ace4 <_dtoa_r+0x1408>
    S = pow5mult (ptr, S, s5);
 200acd0:	e1bfdd17 	ldw	r6,-140(fp)
 200acd4:	e17fe417 	ldw	r5,-112(fp)
 200acd8:	e13ff817 	ldw	r4,-32(fp)
 200acdc:	200ede80 	call	200ede8 <__pow5mult>
 200ace0:	e0bfe415 	stw	r2,-112(fp)

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
 200ace4:	e03fde15 	stw	zero,-136(fp)
  if (mode < 2)
 200ace8:	e0bffb17 	ldw	r2,-20(fp)
 200acec:	10800088 	cmpgei	r2,r2,2
 200acf0:	1000121e 	bne	r2,zero,200ad3c <_dtoa_r+0x1460>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
 200acf4:	e0bff217 	ldw	r2,-56(fp)
 200acf8:	1000101e 	bne	r2,zero,200ad3c <_dtoa_r+0x1460>
 200acfc:	e0fff317 	ldw	r3,-52(fp)
 200ad00:	00800434 	movhi	r2,16
 200ad04:	10bfffc4 	addi	r2,r2,-1
 200ad08:	1884703a 	and	r2,r3,r2
 200ad0c:	10000b1e 	bne	r2,zero,200ad3c <_dtoa_r+0x1460>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
 200ad10:	e0bff317 	ldw	r2,-52(fp)
 200ad14:	109ffc2c 	andhi	r2,r2,32752
 200ad18:	10000826 	beq	r2,zero,200ad3c <_dtoa_r+0x1460>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
 200ad1c:	e0bfcf17 	ldw	r2,-196(fp)
 200ad20:	10800044 	addi	r2,r2,1
 200ad24:	e0bfcf15 	stw	r2,-196(fp)
	  s2 += Log2P;
 200ad28:	e0bfdc17 	ldw	r2,-144(fp)
 200ad2c:	10800044 	addi	r2,r2,1
 200ad30:	e0bfdc15 	stw	r2,-144(fp)
	  spec_case = 1;
 200ad34:	00800044 	movi	r2,1
 200ad38:	e0bfde15 	stw	r2,-136(fp)
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
 200ad3c:	e0bfdd17 	ldw	r2,-140(fp)
 200ad40:	10000f26 	beq	r2,zero,200ad80 <_dtoa_r+0x14a4>
 200ad44:	e0bfe417 	ldw	r2,-112(fp)
 200ad48:	10800417 	ldw	r2,16(r2)
 200ad4c:	10bfffc4 	addi	r2,r2,-1
 200ad50:	e0ffe417 	ldw	r3,-112(fp)
 200ad54:	10800144 	addi	r2,r2,5
 200ad58:	1085883a 	add	r2,r2,r2
 200ad5c:	1085883a 	add	r2,r2,r2
 200ad60:	1885883a 	add	r2,r3,r2
 200ad64:	10800017 	ldw	r2,0(r2)
 200ad68:	1009883a 	mov	r4,r2
 200ad6c:	200e8440 	call	200e844 <__hi0bits>
 200ad70:	1007883a 	mov	r3,r2
 200ad74:	00800804 	movi	r2,32
 200ad78:	10c5c83a 	sub	r2,r2,r3
 200ad7c:	00000106 	br	200ad84 <_dtoa_r+0x14a8>
 200ad80:	00800044 	movi	r2,1
 200ad84:	e0ffdc17 	ldw	r3,-144(fp)
 200ad88:	10c5883a 	add	r2,r2,r3
 200ad8c:	108007cc 	andi	r2,r2,31
 200ad90:	e0bfd215 	stw	r2,-184(fp)
 200ad94:	e0bfd217 	ldw	r2,-184(fp)
 200ad98:	10000426 	beq	r2,zero,200adac <_dtoa_r+0x14d0>
    i = 32 - i;
 200ad9c:	00c00804 	movi	r3,32
 200ada0:	e0bfd217 	ldw	r2,-184(fp)
 200ada4:	1885c83a 	sub	r2,r3,r2
 200ada8:	e0bfd215 	stw	r2,-184(fp)
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
 200adac:	e0bfd217 	ldw	r2,-184(fp)
 200adb0:	10800150 	cmplti	r2,r2,5
 200adb4:	1000101e 	bne	r2,zero,200adf8 <_dtoa_r+0x151c>
    {
      i -= 4;
 200adb8:	e0bfd217 	ldw	r2,-184(fp)
 200adbc:	10bfff04 	addi	r2,r2,-4
 200adc0:	e0bfd215 	stw	r2,-184(fp)
      b2 += i;
 200adc4:	e0ffcf17 	ldw	r3,-196(fp)
 200adc8:	e0bfd217 	ldw	r2,-184(fp)
 200adcc:	1885883a 	add	r2,r3,r2
 200add0:	e0bfcf15 	stw	r2,-196(fp)
      m2 += i;
 200add4:	e0ffda17 	ldw	r3,-152(fp)
 200add8:	e0bfd217 	ldw	r2,-184(fp)
 200addc:	1885883a 	add	r2,r3,r2
 200ade0:	e0bfda15 	stw	r2,-152(fp)
      s2 += i;
 200ade4:	e0ffdc17 	ldw	r3,-144(fp)
 200ade8:	e0bfd217 	ldw	r2,-184(fp)
 200adec:	1885883a 	add	r2,r3,r2
 200adf0:	e0bfdc15 	stw	r2,-144(fp)
 200adf4:	00001206 	br	200ae40 <_dtoa_r+0x1564>
    }
  else if (i < 4)
 200adf8:	e0bfd217 	ldw	r2,-184(fp)
 200adfc:	10800108 	cmpgei	r2,r2,4
 200ae00:	10000f1e 	bne	r2,zero,200ae40 <_dtoa_r+0x1564>
    {
      i += 28;
 200ae04:	e0bfd217 	ldw	r2,-184(fp)
 200ae08:	10800704 	addi	r2,r2,28
 200ae0c:	e0bfd215 	stw	r2,-184(fp)
      b2 += i;
 200ae10:	e0ffcf17 	ldw	r3,-196(fp)
 200ae14:	e0bfd217 	ldw	r2,-184(fp)
 200ae18:	1885883a 	add	r2,r3,r2
 200ae1c:	e0bfcf15 	stw	r2,-196(fp)
      m2 += i;
 200ae20:	e0ffda17 	ldw	r3,-152(fp)
 200ae24:	e0bfd217 	ldw	r2,-184(fp)
 200ae28:	1885883a 	add	r2,r3,r2
 200ae2c:	e0bfda15 	stw	r2,-152(fp)
      s2 += i;
 200ae30:	e0ffdc17 	ldw	r3,-144(fp)
 200ae34:	e0bfd217 	ldw	r2,-184(fp)
 200ae38:	1885883a 	add	r2,r3,r2
 200ae3c:	e0bfdc15 	stw	r2,-144(fp)
    }
  if (b2 > 0)
 200ae40:	e0bfcf17 	ldw	r2,-196(fp)
 200ae44:	0080050e 	bge	zero,r2,200ae5c <_dtoa_r+0x1580>
    b = lshift (ptr, b, b2);
 200ae48:	e1bfcf17 	ldw	r6,-196(fp)
 200ae4c:	e17fe117 	ldw	r5,-124(fp)
 200ae50:	e13ff817 	ldw	r4,-32(fp)
 200ae54:	200ef600 	call	200ef60 <__lshift>
 200ae58:	e0bfe115 	stw	r2,-124(fp)
  if (s2 > 0)
 200ae5c:	e0bfdc17 	ldw	r2,-144(fp)
 200ae60:	0080050e 	bge	zero,r2,200ae78 <_dtoa_r+0x159c>
    S = lshift (ptr, S, s2);
 200ae64:	e1bfdc17 	ldw	r6,-144(fp)
 200ae68:	e17fe417 	ldw	r5,-112(fp)
 200ae6c:	e13ff817 	ldw	r4,-32(fp)
 200ae70:	200ef600 	call	200ef60 <__lshift>
 200ae74:	e0bfe415 	stw	r2,-112(fp)
  if (k_check)
 200ae78:	e0bfd817 	ldw	r2,-160(fp)
 200ae7c:	10001726 	beq	r2,zero,200aedc <_dtoa_r+0x1600>
    {
      if (cmp (b, S) < 0)
 200ae80:	e17fe417 	ldw	r5,-112(fp)
 200ae84:	e13fe117 	ldw	r4,-124(fp)
 200ae88:	200f1580 	call	200f158 <__mcmp>
 200ae8c:	1000130e 	bge	r2,zero,200aedc <_dtoa_r+0x1600>
	{
	  k--;
 200ae90:	e0bfd717 	ldw	r2,-164(fp)
 200ae94:	10bfffc4 	addi	r2,r2,-1
 200ae98:	e0bfd715 	stw	r2,-164(fp)
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
 200ae9c:	000f883a 	mov	r7,zero
 200aea0:	01800284 	movi	r6,10
 200aea4:	e17fe117 	ldw	r5,-124(fp)
 200aea8:	e13ff817 	ldw	r4,-32(fp)
 200aeac:	200e5240 	call	200e524 <__multadd>
 200aeb0:	e0bfe115 	stw	r2,-124(fp)
	  if (leftright)
 200aeb4:	e0bfd917 	ldw	r2,-156(fp)
 200aeb8:	10000626 	beq	r2,zero,200aed4 <_dtoa_r+0x15f8>
	    mhi = multadd (ptr, mhi, 10, 0);
 200aebc:	000f883a 	mov	r7,zero
 200aec0:	01800284 	movi	r6,10
 200aec4:	e17fe317 	ldw	r5,-116(fp)
 200aec8:	e13ff817 	ldw	r4,-32(fp)
 200aecc:	200e5240 	call	200e524 <__multadd>
 200aed0:	e0bfe315 	stw	r2,-116(fp)
	  ilim = ilim1;
 200aed4:	e0bfd517 	ldw	r2,-172(fp)
 200aed8:	e0bfd415 	stw	r2,-176(fp)
	}
    }
  if (ilim <= 0 && mode > 2)
 200aedc:	e0bfd417 	ldw	r2,-176(fp)
 200aee0:	00801f16 	blt	zero,r2,200af60 <_dtoa_r+0x1684>
 200aee4:	e0bffb17 	ldw	r2,-20(fp)
 200aee8:	108000d0 	cmplti	r2,r2,3
 200aeec:	10001c1e 	bne	r2,zero,200af60 <_dtoa_r+0x1684>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
 200aef0:	e0bfd417 	ldw	r2,-176(fp)
 200aef4:	10000c16 	blt	r2,zero,200af28 <_dtoa_r+0x164c>
 200aef8:	000f883a 	mov	r7,zero
 200aefc:	01800144 	movi	r6,5
 200af00:	e17fe417 	ldw	r5,-112(fp)
 200af04:	e13ff817 	ldw	r4,-32(fp)
 200af08:	200e5240 	call	200e524 <__multadd>
 200af0c:	e0bfe415 	stw	r2,-112(fp)
 200af10:	e17fe417 	ldw	r5,-112(fp)
 200af14:	e13fe117 	ldw	r4,-124(fp)
 200af18:	200f1580 	call	200f158 <__mcmp>
 200af1c:	00800716 	blt	zero,r2,200af3c <_dtoa_r+0x1660>
 200af20:	00000106 	br	200af28 <_dtoa_r+0x164c>
	  S = mhi = 0;
	  d.d -= 5.;
	  if (d.d > eps.d)
	    goto one_digit;
	  if (d.d < -eps.d)
	    goto no_digits;
 200af24:	0001883a 	nop
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
 200af28:	e0800217 	ldw	r2,8(fp)
 200af2c:	0084303a 	nor	r2,zero,r2
 200af30:	e0bfd715 	stw	r2,-164(fp)
	  goto ret;
 200af34:	00011d06 	br	200b3ac <_dtoa_r+0x1ad0>
      if (ilim == 0)
	{
	  S = mhi = 0;
	  d.d -= 5.;
	  if (d.d > eps.d)
	    goto one_digit;
 200af38:	0001883a 	nop
	no_digits:
	  k = -1 - ndigits;
	  goto ret;
	}
    one_digit:
      *s++ = '1';
 200af3c:	e0bfe717 	ldw	r2,-100(fp)
 200af40:	10c00044 	addi	r3,r2,1
 200af44:	e0ffe715 	stw	r3,-100(fp)
 200af48:	00c00c44 	movi	r3,49
 200af4c:	10c00005 	stb	r3,0(r2)
      k++;
 200af50:	e0bfd717 	ldw	r2,-164(fp)
 200af54:	10800044 	addi	r2,r2,1
 200af58:	e0bfd715 	stw	r2,-164(fp)
      goto ret;
 200af5c:	00011306 	br	200b3ac <_dtoa_r+0x1ad0>
    }
  if (leftright)
 200af60:	e0bfd917 	ldw	r2,-156(fp)
 200af64:	1000ba26 	beq	r2,zero,200b250 <_dtoa_r+0x1974>
    {
      if (m2 > 0)
 200af68:	e0bfda17 	ldw	r2,-152(fp)
 200af6c:	0080050e 	bge	zero,r2,200af84 <_dtoa_r+0x16a8>
	mhi = lshift (ptr, mhi, m2);
 200af70:	e1bfda17 	ldw	r6,-152(fp)
 200af74:	e17fe317 	ldw	r5,-116(fp)
 200af78:	e13ff817 	ldw	r4,-32(fp)
 200af7c:	200ef600 	call	200ef60 <__lshift>
 200af80:	e0bfe315 	stw	r2,-116(fp)

      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
 200af84:	e0bfe317 	ldw	r2,-116(fp)
 200af88:	e0bfe215 	stw	r2,-120(fp)
      if (spec_case)
 200af8c:	e0bfde17 	ldw	r2,-136(fp)
 200af90:	10001826 	beq	r2,zero,200aff4 <_dtoa_r+0x1718>
	{
	  mhi = Balloc (ptr, mhi->_k);
 200af94:	e0bfe317 	ldw	r2,-116(fp)
 200af98:	10800117 	ldw	r2,4(r2)
 200af9c:	100b883a 	mov	r5,r2
 200afa0:	e13ff817 	ldw	r4,-32(fp)
 200afa4:	200e3780 	call	200e378 <_Balloc>
 200afa8:	e0bfe315 	stw	r2,-116(fp)
	  Bcopy (mhi, mlo);
 200afac:	e0bfe317 	ldw	r2,-116(fp)
 200afb0:	10c00304 	addi	r3,r2,12
 200afb4:	e0bfe217 	ldw	r2,-120(fp)
 200afb8:	11000304 	addi	r4,r2,12
 200afbc:	e0bfe217 	ldw	r2,-120(fp)
 200afc0:	10800417 	ldw	r2,16(r2)
 200afc4:	10800084 	addi	r2,r2,2
 200afc8:	1085883a 	add	r2,r2,r2
 200afcc:	1085883a 	add	r2,r2,r2
 200afd0:	100d883a 	mov	r6,r2
 200afd4:	200b883a 	mov	r5,r4
 200afd8:	1809883a 	mov	r4,r3
 200afdc:	20067d00 	call	20067d0 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
 200afe0:	01800044 	movi	r6,1
 200afe4:	e17fe317 	ldw	r5,-116(fp)
 200afe8:	e13ff817 	ldw	r4,-32(fp)
 200afec:	200ef600 	call	200ef60 <__lshift>
 200aff0:	e0bfe315 	stw	r2,-116(fp)
	}

      for (i = 1;; i++)
 200aff4:	00800044 	movi	r2,1
 200aff8:	e0bfd215 	stw	r2,-184(fp)
	{
	  dig = quorem (b, S) + '0';
 200affc:	e17fe417 	ldw	r5,-112(fp)
 200b000:	e13fe117 	ldw	r4,-124(fp)
 200b004:	20095280 	call	2009528 <quorem>
 200b008:	10800c04 	addi	r2,r2,48
 200b00c:	e0bfd115 	stw	r2,-188(fp)
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
 200b010:	e17fe217 	ldw	r5,-120(fp)
 200b014:	e13fe117 	ldw	r4,-124(fp)
 200b018:	200f1580 	call	200f158 <__mcmp>
 200b01c:	e0bfd615 	stw	r2,-168(fp)
	  delta = diff (ptr, S, mhi);
 200b020:	e1bfe317 	ldw	r6,-116(fp)
 200b024:	e17fe417 	ldw	r5,-112(fp)
 200b028:	e13ff817 	ldw	r4,-32(fp)
 200b02c:	200f26c0 	call	200f26c <__mdiff>
 200b030:	e0bfef15 	stw	r2,-68(fp)
	  j1 = delta->_sign ? 1 : cmp (b, delta);
 200b034:	e0bfef17 	ldw	r2,-68(fp)
 200b038:	10800317 	ldw	r2,12(r2)
 200b03c:	1000041e 	bne	r2,zero,200b050 <_dtoa_r+0x1774>
 200b040:	e17fef17 	ldw	r5,-68(fp)
 200b044:	e13fe117 	ldw	r4,-124(fp)
 200b048:	200f1580 	call	200f158 <__mcmp>
 200b04c:	00000106 	br	200b054 <_dtoa_r+0x1778>
 200b050:	00800044 	movi	r2,1
 200b054:	e0bfec15 	stw	r2,-80(fp)
	  Bfree (ptr, delta);
 200b058:	e17fef17 	ldw	r5,-68(fp)
 200b05c:	e13ff817 	ldw	r4,-32(fp)
 200b060:	200e4a80 	call	200e4a8 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
 200b064:	e0bfec17 	ldw	r2,-80(fp)
 200b068:	1000131e 	bne	r2,zero,200b0b8 <_dtoa_r+0x17dc>
 200b06c:	e0bffb17 	ldw	r2,-20(fp)
 200b070:	1000111e 	bne	r2,zero,200b0b8 <_dtoa_r+0x17dc>
 200b074:	e0bff217 	ldw	r2,-56(fp)
 200b078:	1080004c 	andi	r2,r2,1
 200b07c:	10000e1e 	bne	r2,zero,200b0b8 <_dtoa_r+0x17dc>
	    {
	      if (dig == '9')
 200b080:	e0bfd117 	ldw	r2,-188(fp)
 200b084:	10800e58 	cmpnei	r2,r2,57
 200b088:	10003726 	beq	r2,zero,200b168 <_dtoa_r+0x188c>
		goto round_9_up;
	      if (j > 0)
 200b08c:	e0bfd617 	ldw	r2,-168(fp)
 200b090:	0080030e 	bge	zero,r2,200b0a0 <_dtoa_r+0x17c4>
		dig++;
 200b094:	e0bfd117 	ldw	r2,-188(fp)
 200b098:	10800044 	addi	r2,r2,1
 200b09c:	e0bfd115 	stw	r2,-188(fp)
	      *s++ = dig;
 200b0a0:	e0bfe717 	ldw	r2,-100(fp)
 200b0a4:	10c00044 	addi	r3,r2,1
 200b0a8:	e0ffe715 	stw	r3,-100(fp)
 200b0ac:	e0ffd117 	ldw	r3,-188(fp)
 200b0b0:	10c00005 	stb	r3,0(r2)
	      goto ret;
 200b0b4:	0000bd06 	br	200b3ac <_dtoa_r+0x1ad0>
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
 200b0b8:	e0bfd617 	ldw	r2,-168(fp)
 200b0bc:	10000716 	blt	r2,zero,200b0dc <_dtoa_r+0x1800>
 200b0c0:	e0bfd617 	ldw	r2,-168(fp)
 200b0c4:	1000221e 	bne	r2,zero,200b150 <_dtoa_r+0x1874>
 200b0c8:	e0bffb17 	ldw	r2,-20(fp)
 200b0cc:	1000201e 	bne	r2,zero,200b150 <_dtoa_r+0x1874>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
 200b0d0:	e0bff217 	ldw	r2,-56(fp)
 200b0d4:	1080004c 	andi	r2,r2,1
 200b0d8:	10001d1e 	bne	r2,zero,200b150 <_dtoa_r+0x1874>
#endif
           ))
	    {
	      if (j1 > 0)
 200b0dc:	e0bfec17 	ldw	r2,-80(fp)
 200b0e0:	0080150e 	bge	zero,r2,200b138 <_dtoa_r+0x185c>
		{
		  b = lshift (ptr, b, 1);
 200b0e4:	01800044 	movi	r6,1
 200b0e8:	e17fe117 	ldw	r5,-124(fp)
 200b0ec:	e13ff817 	ldw	r4,-32(fp)
 200b0f0:	200ef600 	call	200ef60 <__lshift>
 200b0f4:	e0bfe115 	stw	r2,-124(fp)
		  j1 = cmp (b, S);
 200b0f8:	e17fe417 	ldw	r5,-112(fp)
 200b0fc:	e13fe117 	ldw	r4,-124(fp)
 200b100:	200f1580 	call	200f158 <__mcmp>
 200b104:	e0bfec15 	stw	r2,-80(fp)
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
 200b108:	e0bfec17 	ldw	r2,-80(fp)
 200b10c:	00800516 	blt	zero,r2,200b124 <_dtoa_r+0x1848>
 200b110:	e0bfec17 	ldw	r2,-80(fp)
 200b114:	1000081e 	bne	r2,zero,200b138 <_dtoa_r+0x185c>
 200b118:	e0bfd117 	ldw	r2,-188(fp)
 200b11c:	1080004c 	andi	r2,r2,1
 200b120:	10000526 	beq	r2,zero,200b138 <_dtoa_r+0x185c>
		      && dig++ == '9')
 200b124:	e0bfd117 	ldw	r2,-188(fp)
 200b128:	10c00044 	addi	r3,r2,1
 200b12c:	e0ffd115 	stw	r3,-188(fp)
 200b130:	10800e58 	cmpnei	r2,r2,57
 200b134:	10000e26 	beq	r2,zero,200b170 <_dtoa_r+0x1894>
		    goto round_9_up;
		}
	      *s++ = dig;
 200b138:	e0bfe717 	ldw	r2,-100(fp)
 200b13c:	10c00044 	addi	r3,r2,1
 200b140:	e0ffe715 	stw	r3,-100(fp)
 200b144:	e0ffd117 	ldw	r3,-188(fp)
 200b148:	10c00005 	stb	r3,0(r2)
	      goto ret;
 200b14c:	00009706 	br	200b3ac <_dtoa_r+0x1ad0>
	    }
	  if (j1 > 0)
 200b150:	e0bfec17 	ldw	r2,-80(fp)
 200b154:	0080140e 	bge	zero,r2,200b1a8 <_dtoa_r+0x18cc>
	    {
	      if (dig == '9')
 200b158:	e0bfd117 	ldw	r2,-188(fp)
 200b15c:	10800e58 	cmpnei	r2,r2,57
 200b160:	10000a1e 	bne	r2,zero,200b18c <_dtoa_r+0x18b0>
 200b164:	00000306 	br	200b174 <_dtoa_r+0x1898>
	  Bfree (ptr, delta);
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
	    {
	      if (dig == '9')
		goto round_9_up;
 200b168:	0001883a 	nop
 200b16c:	00000106 	br	200b174 <_dtoa_r+0x1898>
		{
		  b = lshift (ptr, b, 1);
		  j1 = cmp (b, S);
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
		      && dig++ == '9')
		    goto round_9_up;
 200b170:	0001883a 	nop
	  if (j1 > 0)
	    {
	      if (dig == '9')
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
 200b174:	e0bfe717 	ldw	r2,-100(fp)
 200b178:	10c00044 	addi	r3,r2,1
 200b17c:	e0ffe715 	stw	r3,-100(fp)
 200b180:	00c00e44 	movi	r3,57
 200b184:	10c00005 	stb	r3,0(r2)
		  goto roundoff;
 200b188:	00005d06 	br	200b300 <_dtoa_r+0x1a24>
		}
	      *s++ = dig + 1;
 200b18c:	e0bfe717 	ldw	r2,-100(fp)
 200b190:	10c00044 	addi	r3,r2,1
 200b194:	e0ffe715 	stw	r3,-100(fp)
 200b198:	e0ffd117 	ldw	r3,-188(fp)
 200b19c:	18c00044 	addi	r3,r3,1
 200b1a0:	10c00005 	stb	r3,0(r2)
	      goto ret;
 200b1a4:	00008106 	br	200b3ac <_dtoa_r+0x1ad0>
	    }
	  *s++ = dig;
 200b1a8:	e0bfe717 	ldw	r2,-100(fp)
 200b1ac:	10c00044 	addi	r3,r2,1
 200b1b0:	e0ffe715 	stw	r3,-100(fp)
 200b1b4:	e0ffd117 	ldw	r3,-188(fp)
 200b1b8:	10c00005 	stb	r3,0(r2)
	  if (i == ilim)
 200b1bc:	e0ffd217 	ldw	r3,-184(fp)
 200b1c0:	e0bfd417 	ldw	r2,-176(fp)
 200b1c4:	18803b26 	beq	r3,r2,200b2b4 <_dtoa_r+0x19d8>
	    break;
	  b = multadd (ptr, b, 10, 0);
 200b1c8:	000f883a 	mov	r7,zero
 200b1cc:	01800284 	movi	r6,10
 200b1d0:	e17fe117 	ldw	r5,-124(fp)
 200b1d4:	e13ff817 	ldw	r4,-32(fp)
 200b1d8:	200e5240 	call	200e524 <__multadd>
 200b1dc:	e0bfe115 	stw	r2,-124(fp)
	  if (mlo == mhi)
 200b1e0:	e0ffe217 	ldw	r3,-120(fp)
 200b1e4:	e0bfe317 	ldw	r2,-116(fp)
 200b1e8:	1880091e 	bne	r3,r2,200b210 <_dtoa_r+0x1934>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
 200b1ec:	000f883a 	mov	r7,zero
 200b1f0:	01800284 	movi	r6,10
 200b1f4:	e17fe317 	ldw	r5,-116(fp)
 200b1f8:	e13ff817 	ldw	r4,-32(fp)
 200b1fc:	200e5240 	call	200e524 <__multadd>
 200b200:	e0bfe315 	stw	r2,-116(fp)
 200b204:	e0bfe317 	ldw	r2,-116(fp)
 200b208:	e0bfe215 	stw	r2,-120(fp)
 200b20c:	00000c06 	br	200b240 <_dtoa_r+0x1964>
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
 200b210:	000f883a 	mov	r7,zero
 200b214:	01800284 	movi	r6,10
 200b218:	e17fe217 	ldw	r5,-120(fp)
 200b21c:	e13ff817 	ldw	r4,-32(fp)
 200b220:	200e5240 	call	200e524 <__multadd>
 200b224:	e0bfe215 	stw	r2,-120(fp)
	      mhi = multadd (ptr, mhi, 10, 0);
 200b228:	000f883a 	mov	r7,zero
 200b22c:	01800284 	movi	r6,10
 200b230:	e17fe317 	ldw	r5,-116(fp)
 200b234:	e13ff817 	ldw	r4,-32(fp)
 200b238:	200e5240 	call	200e524 <__multadd>
 200b23c:	e0bfe315 	stw	r2,-116(fp)
	  mhi = Balloc (ptr, mhi->_k);
	  Bcopy (mhi, mlo);
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
 200b240:	e0bfd217 	ldw	r2,-184(fp)
 200b244:	10800044 	addi	r2,r2,1
 200b248:	e0bfd215 	stw	r2,-184(fp)
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
 200b24c:	003f6b06 	br	200affc <_dtoa_r+0x1720>
    }
  else
    for (i = 1;; i++)
 200b250:	00800044 	movi	r2,1
 200b254:	e0bfd215 	stw	r2,-184(fp)
      {
	*s++ = dig = quorem (b, S) + '0';
 200b258:	e43fe717 	ldw	r16,-100(fp)
 200b25c:	80800044 	addi	r2,r16,1
 200b260:	e0bfe715 	stw	r2,-100(fp)
 200b264:	e17fe417 	ldw	r5,-112(fp)
 200b268:	e13fe117 	ldw	r4,-124(fp)
 200b26c:	20095280 	call	2009528 <quorem>
 200b270:	10800c04 	addi	r2,r2,48
 200b274:	e0bfd115 	stw	r2,-188(fp)
 200b278:	e0bfd117 	ldw	r2,-188(fp)
 200b27c:	80800005 	stb	r2,0(r16)
	if (i >= ilim)
 200b280:	e0ffd217 	ldw	r3,-184(fp)
 200b284:	e0bfd417 	ldw	r2,-176(fp)
 200b288:	18800c0e 	bge	r3,r2,200b2bc <_dtoa_r+0x19e0>
	  break;
	b = multadd (ptr, b, 10, 0);
 200b28c:	000f883a 	mov	r7,zero
 200b290:	01800284 	movi	r6,10
 200b294:	e17fe117 	ldw	r5,-124(fp)
 200b298:	e13ff817 	ldw	r4,-32(fp)
 200b29c:	200e5240 	call	200e524 <__multadd>
 200b2a0:	e0bfe115 	stw	r2,-124(fp)
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
    }
  else
    for (i = 1;; i++)
 200b2a4:	e0bfd217 	ldw	r2,-184(fp)
 200b2a8:	10800044 	addi	r2,r2,1
 200b2ac:	e0bfd215 	stw	r2,-184(fp)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
      }
 200b2b0:	003fe906 	br	200b258 <_dtoa_r+0x197c>
	      *s++ = dig + 1;
	      goto ret;
	    }
	  *s++ = dig;
	  if (i == ilim)
	    break;
 200b2b4:	0001883a 	nop
 200b2b8:	00000106 	br	200b2c0 <_dtoa_r+0x19e4>
  else
    for (i = 1;; i++)
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
 200b2bc:	0001883a 	nop
	b = multadd (ptr, b, 10, 0);
      }

  /* Round off last digit */

  b = lshift (ptr, b, 1);
 200b2c0:	01800044 	movi	r6,1
 200b2c4:	e17fe117 	ldw	r5,-124(fp)
 200b2c8:	e13ff817 	ldw	r4,-32(fp)
 200b2cc:	200ef600 	call	200ef60 <__lshift>
 200b2d0:	e0bfe115 	stw	r2,-124(fp)
  j = cmp (b, S);
 200b2d4:	e17fe417 	ldw	r5,-112(fp)
 200b2d8:	e13fe117 	ldw	r4,-124(fp)
 200b2dc:	200f1580 	call	200f158 <__mcmp>
 200b2e0:	e0bfd615 	stw	r2,-168(fp)
  if ((j > 0) || ((j == 0) && (dig & 1)))
 200b2e4:	e0bfd617 	ldw	r2,-168(fp)
 200b2e8:	00801216 	blt	zero,r2,200b334 <_dtoa_r+0x1a58>
 200b2ec:	e0bfd617 	ldw	r2,-168(fp)
 200b2f0:	1000211e 	bne	r2,zero,200b378 <_dtoa_r+0x1a9c>
 200b2f4:	e0bfd117 	ldw	r2,-188(fp)
 200b2f8:	1080004c 	andi	r2,r2,1
 200b2fc:	10001e26 	beq	r2,zero,200b378 <_dtoa_r+0x1a9c>
    {
    roundoff:
      while (*--s == '9')
 200b300:	00000c06 	br	200b334 <_dtoa_r+0x1a58>
	if (s == s0)
 200b304:	e0ffe717 	ldw	r3,-100(fp)
 200b308:	e0bfe917 	ldw	r2,-92(fp)
 200b30c:	1880091e 	bne	r3,r2,200b334 <_dtoa_r+0x1a58>
	  {
	    k++;
 200b310:	e0bfd717 	ldw	r2,-164(fp)
 200b314:	10800044 	addi	r2,r2,1
 200b318:	e0bfd715 	stw	r2,-164(fp)
	    *s++ = '1';
 200b31c:	e0bfe717 	ldw	r2,-100(fp)
 200b320:	10c00044 	addi	r3,r2,1
 200b324:	e0ffe715 	stw	r3,-100(fp)
 200b328:	00c00c44 	movi	r3,49
 200b32c:	10c00005 	stb	r3,0(r2)
	    goto ret;
 200b330:	00001e06 	br	200b3ac <_dtoa_r+0x1ad0>
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
 200b334:	e0bfe717 	ldw	r2,-100(fp)
 200b338:	10bfffc4 	addi	r2,r2,-1
 200b33c:	e0bfe715 	stw	r2,-100(fp)
 200b340:	e0bfe717 	ldw	r2,-100(fp)
 200b344:	10800003 	ldbu	r2,0(r2)
 200b348:	10803fcc 	andi	r2,r2,255
 200b34c:	1080201c 	xori	r2,r2,128
 200b350:	10bfe004 	addi	r2,r2,-128
 200b354:	10800e60 	cmpeqi	r2,r2,57
 200b358:	103fea1e 	bne	r2,zero,200b304 <_dtoa_r+0x1a28>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
 200b35c:	e0bfe717 	ldw	r2,-100(fp)
 200b360:	10c00044 	addi	r3,r2,1
 200b364:	e0ffe715 	stw	r3,-100(fp)
 200b368:	10c00003 	ldbu	r3,0(r2)
 200b36c:	18c00044 	addi	r3,r3,1
 200b370:	10c00005 	stb	r3,0(r2)
 200b374:	00000d06 	br	200b3ac <_dtoa_r+0x1ad0>
    }
  else
    {
      while (*--s == '0');
 200b378:	e0bfe717 	ldw	r2,-100(fp)
 200b37c:	10bfffc4 	addi	r2,r2,-1
 200b380:	e0bfe715 	stw	r2,-100(fp)
 200b384:	e0bfe717 	ldw	r2,-100(fp)
 200b388:	10800003 	ldbu	r2,0(r2)
 200b38c:	10803fcc 	andi	r2,r2,255
 200b390:	1080201c 	xori	r2,r2,128
 200b394:	10bfe004 	addi	r2,r2,-128
 200b398:	10800c20 	cmpeqi	r2,r2,48
 200b39c:	103ff61e 	bne	r2,zero,200b378 <_dtoa_r+0x1a9c>
      s++;
 200b3a0:	e0bfe717 	ldw	r2,-100(fp)
 200b3a4:	10800044 	addi	r2,r2,1
 200b3a8:	e0bfe715 	stw	r2,-100(fp)
    }
ret:
  Bfree (ptr, S);
 200b3ac:	e17fe417 	ldw	r5,-112(fp)
 200b3b0:	e13ff817 	ldw	r4,-32(fp)
 200b3b4:	200e4a80 	call	200e4a8 <_Bfree>
  if (mhi)
 200b3b8:	e0bfe317 	ldw	r2,-116(fp)
 200b3bc:	10000d26 	beq	r2,zero,200b3f4 <_dtoa_r+0x1b18>
    {
      if (mlo && mlo != mhi)
 200b3c0:	e0bfe217 	ldw	r2,-120(fp)
 200b3c4:	10000626 	beq	r2,zero,200b3e0 <_dtoa_r+0x1b04>
 200b3c8:	e0ffe217 	ldw	r3,-120(fp)
 200b3cc:	e0bfe317 	ldw	r2,-116(fp)
 200b3d0:	18800326 	beq	r3,r2,200b3e0 <_dtoa_r+0x1b04>
	Bfree (ptr, mlo);
 200b3d4:	e17fe217 	ldw	r5,-120(fp)
 200b3d8:	e13ff817 	ldw	r4,-32(fp)
 200b3dc:	200e4a80 	call	200e4a8 <_Bfree>
      Bfree (ptr, mhi);
 200b3e0:	e17fe317 	ldw	r5,-116(fp)
 200b3e4:	e13ff817 	ldw	r4,-32(fp)
 200b3e8:	200e4a80 	call	200e4a8 <_Bfree>
 200b3ec:	00000106 	br	200b3f4 <_dtoa_r+0x1b18>
	    {
	      L = d.d;
	      d.d -= L;
	      *s++ = '0' + (int) L;
	      if (d.d < eps.d)
		goto ret1;
 200b3f0:	0001883a 	nop
      if (mlo && mlo != mhi)
	Bfree (ptr, mlo);
      Bfree (ptr, mhi);
    }
ret1:
  Bfree (ptr, b);
 200b3f4:	e17fe117 	ldw	r5,-124(fp)
 200b3f8:	e13ff817 	ldw	r4,-32(fp)
 200b3fc:	200e4a80 	call	200e4a8 <_Bfree>
  *s = 0;
 200b400:	e0bfe717 	ldw	r2,-100(fp)
 200b404:	10000005 	stb	zero,0(r2)
  *decpt = k + 1;
 200b408:	e0bfd717 	ldw	r2,-164(fp)
 200b40c:	10c00044 	addi	r3,r2,1
 200b410:	e0800317 	ldw	r2,12(fp)
 200b414:	10c00015 	stw	r3,0(r2)
  if (rve)
 200b418:	e0800517 	ldw	r2,20(fp)
 200b41c:	10000326 	beq	r2,zero,200b42c <_dtoa_r+0x1b50>
    *rve = s;
 200b420:	e0800517 	ldw	r2,20(fp)
 200b424:	e0ffe717 	ldw	r3,-100(fp)
 200b428:	10c00015 	stw	r3,0(r2)
  return s0;
 200b42c:	e0bfe917 	ldw	r2,-92(fp)
}
 200b430:	e6fffc04 	addi	sp,fp,-16
 200b434:	dfc00517 	ldw	ra,20(sp)
 200b438:	df000417 	ldw	fp,16(sp)
 200b43c:	dcc00317 	ldw	r19,12(sp)
 200b440:	dc800217 	ldw	r18,8(sp)
 200b444:	dc400117 	ldw	r17,4(sp)
 200b448:	dc000017 	ldw	r16,0(sp)
 200b44c:	dec00604 	addi	sp,sp,24
 200b450:	f800283a 	ret

0200b454 <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 200b454:	defff504 	addi	sp,sp,-44
 200b458:	dfc00a15 	stw	ra,40(sp)
 200b45c:	df000915 	stw	fp,36(sp)
 200b460:	dcc00815 	stw	r19,32(sp)
 200b464:	dc800715 	stw	r18,28(sp)
 200b468:	dc400615 	stw	r17,24(sp)
 200b46c:	dc000515 	stw	r16,20(sp)
 200b470:	df000904 	addi	fp,sp,36
 200b474:	e13ffb15 	stw	r4,-20(fp)
 200b478:	2821883a 	mov	r16,r5
  register unsigned char *p;
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
 200b47c:	8080030b 	ldhu	r2,12(r16)
 200b480:	e0bff90d 	sth	r2,-28(fp)
  if ((flags & __SWR) == 0)
 200b484:	e0bff90b 	ldhu	r2,-28(fp)
 200b488:	10bfffcc 	andi	r2,r2,65535
 200b48c:	1080020c 	andi	r2,r2,8
 200b490:	1000831e 	bne	r2,zero,200b6a0 <__sflush_r+0x24c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
 200b494:	8080030b 	ldhu	r2,12(r16)
 200b498:	10820014 	ori	r2,r2,2048
 200b49c:	8080030d 	sth	r2,12(r16)
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
 200b4a0:	80800117 	ldw	r2,4(r16)
 200b4a4:	00800216 	blt	zero,r2,200b4b0 <__sflush_r+0x5c>
 200b4a8:	80800f17 	ldw	r2,60(r16)
 200b4ac:	00807a0e 	bge	zero,r2,200b698 <__sflush_r+0x244>
 200b4b0:	80800a17 	ldw	r2,40(r16)
 200b4b4:	10007826 	beq	r2,zero,200b698 <__sflush_r+0x244>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
 200b4b8:	e0bffb17 	ldw	r2,-20(fp)
 200b4bc:	10800017 	ldw	r2,0(r2)
 200b4c0:	e0bffa15 	stw	r2,-24(fp)
	  ptr->_errno = 0;
 200b4c4:	e0bffb17 	ldw	r2,-20(fp)
 200b4c8:	10000015 	stw	zero,0(r2)
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
 200b4cc:	8080030b 	ldhu	r2,12(r16)
 200b4d0:	10bfffcc 	andi	r2,r2,65535
 200b4d4:	1084000c 	andi	r2,r2,4096
 200b4d8:	10000326 	beq	r2,zero,200b4e8 <__sflush_r+0x94>
	    curoff = fp->_offset;
 200b4dc:	80801417 	ldw	r2,80(r16)
 200b4e0:	e0bff715 	stw	r2,-36(fp)
 200b4e4:	00002206 	br	200b570 <__sflush_r+0x11c>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
 200b4e8:	80800a17 	ldw	r2,40(r16)
 200b4ec:	80c00717 	ldw	r3,28(r16)
 200b4f0:	01c00044 	movi	r7,1
 200b4f4:	000d883a 	mov	r6,zero
 200b4f8:	180b883a 	mov	r5,r3
 200b4fc:	e13ffb17 	ldw	r4,-20(fp)
 200b500:	103ee83a 	callr	r2
 200b504:	e0bff715 	stw	r2,-36(fp)
	      if (curoff == -1L && ptr->_errno != 0)
 200b508:	e0bff717 	ldw	r2,-36(fp)
 200b50c:	10bfffd8 	cmpnei	r2,r2,-1
 200b510:	1000171e 	bne	r2,zero,200b570 <__sflush_r+0x11c>
 200b514:	e0bffb17 	ldw	r2,-20(fp)
 200b518:	10800017 	ldw	r2,0(r2)
 200b51c:	10001426 	beq	r2,zero,200b570 <__sflush_r+0x11c>
		{
		  int result = EOF;
 200b520:	00bfffc4 	movi	r2,-1
 200b524:	e0bff815 	stw	r2,-32(fp)
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 200b528:	e0bffb17 	ldw	r2,-20(fp)
 200b52c:	10800017 	ldw	r2,0(r2)
 200b530:	10800760 	cmpeqi	r2,r2,29
 200b534:	1000041e 	bne	r2,zero,200b548 <__sflush_r+0xf4>
 200b538:	e0bffb17 	ldw	r2,-20(fp)
 200b53c:	10800017 	ldw	r2,0(r2)
 200b540:	10800598 	cmpnei	r2,r2,22
 200b544:	1000051e 	bne	r2,zero,200b55c <__sflush_r+0x108>
		    {
		      result = 0;
 200b548:	e03ff815 	stw	zero,-32(fp)
		      ptr->_errno = tmp_errno;
 200b54c:	e0bffb17 	ldw	r2,-20(fp)
 200b550:	e0fffa17 	ldw	r3,-24(fp)
 200b554:	10c00015 	stw	r3,0(r2)
 200b558:	00000306 	br	200b568 <__sflush_r+0x114>
		    }
		  else
		    fp->_flags |= __SERR;
 200b55c:	8080030b 	ldhu	r2,12(r16)
 200b560:	10801014 	ori	r2,r2,64
 200b564:	8080030d 	sth	r2,12(r16)
		  return result;
 200b568:	e0bff817 	ldw	r2,-32(fp)
 200b56c:	00007106 	br	200b734 <__sflush_r+0x2e0>
		}
            }
          if (fp->_flags & __SRD)
 200b570:	8080030b 	ldhu	r2,12(r16)
 200b574:	10bfffcc 	andi	r2,r2,65535
 200b578:	1080010c 	andi	r2,r2,4
 200b57c:	10000a26 	beq	r2,zero,200b5a8 <__sflush_r+0x154>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
 200b580:	80800117 	ldw	r2,4(r16)
 200b584:	e0fff717 	ldw	r3,-36(fp)
 200b588:	1885c83a 	sub	r2,r3,r2
 200b58c:	e0bff715 	stw	r2,-36(fp)
              if (HASUB (fp))
 200b590:	80800c17 	ldw	r2,48(r16)
 200b594:	10000426 	beq	r2,zero,200b5a8 <__sflush_r+0x154>
                curoff -= fp->_ur;
 200b598:	80800f17 	ldw	r2,60(r16)
 200b59c:	e0fff717 	ldw	r3,-36(fp)
 200b5a0:	1885c83a 	sub	r2,r3,r2
 200b5a4:	e0bff715 	stw	r2,-36(fp)
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
 200b5a8:	80800a17 	ldw	r2,40(r16)
 200b5ac:	80c00717 	ldw	r3,28(r16)
 200b5b0:	000f883a 	mov	r7,zero
 200b5b4:	e1bff717 	ldw	r6,-36(fp)
 200b5b8:	180b883a 	mov	r5,r3
 200b5bc:	e13ffb17 	ldw	r4,-20(fp)
 200b5c0:	103ee83a 	callr	r2
 200b5c4:	e0bff715 	stw	r2,-36(fp)
	  if (curoff != -1 || ptr->_errno == 0
 200b5c8:	e0bff717 	ldw	r2,-36(fp)
 200b5cc:	10bfffd8 	cmpnei	r2,r2,-1
 200b5d0:	10000b1e 	bne	r2,zero,200b600 <__sflush_r+0x1ac>
 200b5d4:	e0bffb17 	ldw	r2,-20(fp)
 200b5d8:	10800017 	ldw	r2,0(r2)
 200b5dc:	10000826 	beq	r2,zero,200b600 <__sflush_r+0x1ac>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
 200b5e0:	e0bffb17 	ldw	r2,-20(fp)
 200b5e4:	10800017 	ldw	r2,0(r2)
 200b5e8:	10800760 	cmpeqi	r2,r2,29
 200b5ec:	1000041e 	bne	r2,zero,200b600 <__sflush_r+0x1ac>
 200b5f0:	e0bffb17 	ldw	r2,-20(fp)
 200b5f4:	10800017 	ldw	r2,0(r2)
 200b5f8:	10800598 	cmpnei	r2,r2,22
 200b5fc:	1000211e 	bne	r2,zero,200b684 <__sflush_r+0x230>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
 200b600:	80c0030b 	ldhu	r3,12(r16)
 200b604:	00bdffc4 	movi	r2,-2049
 200b608:	1884703a 	and	r2,r3,r2
 200b60c:	8080030d 	sth	r2,12(r16)
#endif
	      fp->_r = 0;
 200b610:	80000115 	stw	zero,4(r16)
	      fp->_p = fp->_bf._base;
 200b614:	80800417 	ldw	r2,16(r16)
 200b618:	80800015 	stw	r2,0(r16)
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
 200b61c:	8080030b 	ldhu	r2,12(r16)
 200b620:	10bfffcc 	andi	r2,r2,65535
 200b624:	1084000c 	andi	r2,r2,4096
 200b628:	10000826 	beq	r2,zero,200b64c <__sflush_r+0x1f8>
 200b62c:	e0bff717 	ldw	r2,-36(fp)
 200b630:	10bfffd8 	cmpnei	r2,r2,-1
 200b634:	1000031e 	bne	r2,zero,200b644 <__sflush_r+0x1f0>
 200b638:	e0bffb17 	ldw	r2,-20(fp)
 200b63c:	10800017 	ldw	r2,0(r2)
 200b640:	1000021e 	bne	r2,zero,200b64c <__sflush_r+0x1f8>
		fp->_offset = curoff;
 200b644:	e0bff717 	ldw	r2,-36(fp)
 200b648:	80801415 	stw	r2,80(r16)
	      ptr->_errno = tmp_errno;
 200b64c:	e0bffb17 	ldw	r2,-20(fp)
 200b650:	e0fffa17 	ldw	r3,-24(fp)
 200b654:	10c00015 	stw	r3,0(r2)
	      if (HASUB (fp))
 200b658:	80800c17 	ldw	r2,48(r16)
 200b65c:	10000e26 	beq	r2,zero,200b698 <__sflush_r+0x244>
		FREEUB (ptr, fp);
 200b660:	80c00c17 	ldw	r3,48(r16)
 200b664:	80801004 	addi	r2,r16,64
 200b668:	18800426 	beq	r3,r2,200b67c <__sflush_r+0x228>
 200b66c:	80800c17 	ldw	r2,48(r16)
 200b670:	100b883a 	mov	r5,r2
 200b674:	e13ffb17 	ldw	r4,-20(fp)
 200b678:	200bdf80 	call	200bdf8 <_free_r>
 200b67c:	80000c15 	stw	zero,48(r16)
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
 200b680:	00000506 	br	200b698 <__sflush_r+0x244>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
 200b684:	8080030b 	ldhu	r2,12(r16)
 200b688:	10801014 	ori	r2,r2,64
 200b68c:	8080030d 	sth	r2,12(r16)
	      return EOF;
 200b690:	00bfffc4 	movi	r2,-1
 200b694:	00002706 	br	200b734 <__sflush_r+0x2e0>
	    }
	}
      return 0;
 200b698:	0005883a 	mov	r2,zero
 200b69c:	00002506 	br	200b734 <__sflush_r+0x2e0>
    }
  if ((p = fp->_bf._base) == NULL)
 200b6a0:	84400417 	ldw	r17,16(r16)
 200b6a4:	8800021e 	bne	r17,zero,200b6b0 <__sflush_r+0x25c>
    {
      /* Nothing to flush.  */
      return 0;
 200b6a8:	0005883a 	mov	r2,zero
 200b6ac:	00002106 	br	200b734 <__sflush_r+0x2e0>
    }
  n = fp->_p - p;		/* write this much */
 200b6b0:	80800017 	ldw	r2,0(r16)
 200b6b4:	1007883a 	mov	r3,r2
 200b6b8:	8805883a 	mov	r2,r17
 200b6bc:	18a5c83a 	sub	r18,r3,r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
 200b6c0:	84400015 	stw	r17,0(r16)
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
 200b6c4:	e0bff90b 	ldhu	r2,-28(fp)
 200b6c8:	10bfffcc 	andi	r2,r2,65535
 200b6cc:	108000cc 	andi	r2,r2,3
 200b6d0:	1000021e 	bne	r2,zero,200b6dc <__sflush_r+0x288>
 200b6d4:	80800517 	ldw	r2,20(r16)
 200b6d8:	00000106 	br	200b6e0 <__sflush_r+0x28c>
 200b6dc:	0005883a 	mov	r2,zero
 200b6e0:	80800215 	stw	r2,8(r16)

  while (n > 0)
 200b6e4:	00001106 	br	200b72c <__sflush_r+0x2d8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
 200b6e8:	80800917 	ldw	r2,36(r16)
 200b6ec:	80c00717 	ldw	r3,28(r16)
 200b6f0:	900f883a 	mov	r7,r18
 200b6f4:	880d883a 	mov	r6,r17
 200b6f8:	180b883a 	mov	r5,r3
 200b6fc:	e13ffb17 	ldw	r4,-20(fp)
 200b700:	103ee83a 	callr	r2
 200b704:	1027883a 	mov	r19,r2
      if (t <= 0)
 200b708:	04c00516 	blt	zero,r19,200b720 <__sflush_r+0x2cc>
	{
          fp->_flags |= __SERR;
 200b70c:	8080030b 	ldhu	r2,12(r16)
 200b710:	10801014 	ori	r2,r2,64
 200b714:	8080030d 	sth	r2,12(r16)
          return EOF;
 200b718:	00bfffc4 	movi	r2,-1
 200b71c:	00000506 	br	200b734 <__sflush_r+0x2e0>
	}
      p += t;
 200b720:	9805883a 	mov	r2,r19
 200b724:	88a3883a 	add	r17,r17,r2
      n -= t;
 200b728:	94e5c83a 	sub	r18,r18,r19
   * write function.
   */
  fp->_p = p;
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
 200b72c:	04bfee16 	blt	zero,r18,200b6e8 <__sflush_r+0x294>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
 200b730:	0005883a 	mov	r2,zero
}
 200b734:	e6fffc04 	addi	sp,fp,-16
 200b738:	dfc00517 	ldw	ra,20(sp)
 200b73c:	df000417 	ldw	fp,16(sp)
 200b740:	dcc00317 	ldw	r19,12(sp)
 200b744:	dc800217 	ldw	r18,8(sp)
 200b748:	dc400117 	ldw	r17,4(sp)
 200b74c:	dc000017 	ldw	r16,0(sp)
 200b750:	dec00604 	addi	sp,sp,24
 200b754:	f800283a 	ret

0200b758 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
 200b758:	defffa04 	addi	sp,sp,-24
 200b75c:	dfc00515 	stw	ra,20(sp)
 200b760:	df000415 	stw	fp,16(sp)
 200b764:	dc000315 	stw	r16,12(sp)
 200b768:	df000404 	addi	fp,sp,16
 200b76c:	e13ffe15 	stw	r4,-8(fp)
 200b770:	2821883a 	mov	r16,r5
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
 200b774:	e0bffe17 	ldw	r2,-8(fp)
 200b778:	e0bffc15 	stw	r2,-16(fp)
 200b77c:	e0bffc17 	ldw	r2,-16(fp)
 200b780:	10000526 	beq	r2,zero,200b798 <_fflush_r+0x40>
 200b784:	e0bffc17 	ldw	r2,-16(fp)
 200b788:	10800e17 	ldw	r2,56(r2)
 200b78c:	1000021e 	bne	r2,zero,200b798 <_fflush_r+0x40>
 200b790:	e13ffc17 	ldw	r4,-16(fp)
 200b794:	200bbd80 	call	200bbd8 <__sinit>

  if (!fp->_flags)
 200b798:	8080030b 	ldhu	r2,12(r16)
 200b79c:	10bfffcc 	andi	r2,r2,65535
 200b7a0:	10a0001c 	xori	r2,r2,32768
 200b7a4:	10a00004 	addi	r2,r2,-32768
 200b7a8:	1000021e 	bne	r2,zero,200b7b4 <_fflush_r+0x5c>
    return 0;
 200b7ac:	0005883a 	mov	r2,zero
 200b7b0:	00000506 	br	200b7c8 <_fflush_r+0x70>

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
 200b7b4:	800b883a 	mov	r5,r16
 200b7b8:	e13ffe17 	ldw	r4,-8(fp)
 200b7bc:	200b4540 	call	200b454 <__sflush_r>
 200b7c0:	e0bffd15 	stw	r2,-12(fp)
  _newlib_flockfile_end (fp);
  return ret;
 200b7c4:	e0bffd17 	ldw	r2,-12(fp)
}
 200b7c8:	e6ffff04 	addi	sp,fp,-4
 200b7cc:	dfc00217 	ldw	ra,8(sp)
 200b7d0:	df000117 	ldw	fp,4(sp)
 200b7d4:	dc000017 	ldw	r16,0(sp)
 200b7d8:	dec00304 	addi	sp,sp,12
 200b7dc:	f800283a 	ret

0200b7e0 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
 200b7e0:	defffe04 	addi	sp,sp,-8
 200b7e4:	dfc00115 	stw	ra,4(sp)
 200b7e8:	df000015 	stw	fp,0(sp)
 200b7ec:	d839883a 	mov	fp,sp
 200b7f0:	2005883a 	mov	r2,r4
  if (fp == NULL)
 200b7f4:	1000061e 	bne	r2,zero,200b810 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
 200b7f8:	d0a00717 	ldw	r2,-32740(gp)
 200b7fc:	01408074 	movhi	r5,513
 200b800:	296dd604 	addi	r5,r5,-18600
 200b804:	1009883a 	mov	r4,r2
 200b808:	200cbd80 	call	200cbd8 <_fwalk_reent>
 200b80c:	00000406 	br	200b820 <fflush+0x40>

  return _fflush_r (_REENT, fp);
 200b810:	d0e00617 	ldw	r3,-32744(gp)
 200b814:	100b883a 	mov	r5,r2
 200b818:	1809883a 	mov	r4,r3
 200b81c:	200b7580 	call	200b758 <_fflush_r>
}
 200b820:	e037883a 	mov	sp,fp
 200b824:	dfc00117 	ldw	ra,4(sp)
 200b828:	df000017 	ldw	fp,0(sp)
 200b82c:	dec00204 	addi	sp,sp,8
 200b830:	f800283a 	ret

0200b834 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
 200b834:	defffa04 	addi	sp,sp,-24
 200b838:	dfc00515 	stw	ra,20(sp)
 200b83c:	df000415 	stw	fp,16(sp)
 200b840:	df000404 	addi	fp,sp,16
 200b844:	e13ffc15 	stw	r4,-16(fp)
 200b848:	e17ffd15 	stw	r5,-12(fp)
 200b84c:	e1bffe15 	stw	r6,-8(fp)
 200b850:	e1ffff15 	stw	r7,-4(fp)
  ptr->_p = 0;
 200b854:	e0bffc17 	ldw	r2,-16(fp)
 200b858:	10000015 	stw	zero,0(r2)
  ptr->_r = 0;
 200b85c:	e0bffc17 	ldw	r2,-16(fp)
 200b860:	10000115 	stw	zero,4(r2)
  ptr->_w = 0;
 200b864:	e0bffc17 	ldw	r2,-16(fp)
 200b868:	10000215 	stw	zero,8(r2)
  ptr->_flags = flags;
 200b86c:	e0bffd17 	ldw	r2,-12(fp)
 200b870:	1007883a 	mov	r3,r2
 200b874:	e0bffc17 	ldw	r2,-16(fp)
 200b878:	10c0030d 	sth	r3,12(r2)
  ptr->_flags2 = 0;
 200b87c:	e0bffc17 	ldw	r2,-16(fp)
 200b880:	10001915 	stw	zero,100(r2)
  ptr->_file = file;
 200b884:	e0bffe17 	ldw	r2,-8(fp)
 200b888:	1007883a 	mov	r3,r2
 200b88c:	e0bffc17 	ldw	r2,-16(fp)
 200b890:	10c0038d 	sth	r3,14(r2)
  ptr->_bf._base = 0;
 200b894:	e0bffc17 	ldw	r2,-16(fp)
 200b898:	10000415 	stw	zero,16(r2)
  ptr->_bf._size = 0;
 200b89c:	e0bffc17 	ldw	r2,-16(fp)
 200b8a0:	10000515 	stw	zero,20(r2)
  ptr->_lbfsize = 0;
 200b8a4:	e0bffc17 	ldw	r2,-16(fp)
 200b8a8:	10000615 	stw	zero,24(r2)
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
 200b8ac:	e0bffc17 	ldw	r2,-16(fp)
 200b8b0:	10801704 	addi	r2,r2,92
 200b8b4:	01800204 	movi	r6,8
 200b8b8:	000b883a 	mov	r5,zero
 200b8bc:	1009883a 	mov	r4,r2
 200b8c0:	20069580 	call	2006958 <memset>
  ptr->_cookie = ptr;
 200b8c4:	e0bffc17 	ldw	r2,-16(fp)
 200b8c8:	e0fffc17 	ldw	r3,-16(fp)
 200b8cc:	10c00715 	stw	r3,28(r2)
  ptr->_read = __sread;
 200b8d0:	e0fffc17 	ldw	r3,-16(fp)
 200b8d4:	00808074 	movhi	r2,513
 200b8d8:	10829004 	addi	r2,r2,2624
 200b8dc:	18800815 	stw	r2,32(r3)
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
 200b8e0:	e0fffc17 	ldw	r3,-16(fp)
 200b8e4:	00808074 	movhi	r2,513
 200b8e8:	1082c304 	addi	r2,r2,2828
 200b8ec:	18800915 	stw	r2,36(r3)
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
 200b8f0:	e0fffc17 	ldw	r3,-16(fp)
 200b8f4:	00808074 	movhi	r2,513
 200b8f8:	1082f004 	addi	r2,r2,3008
 200b8fc:	18800a15 	stw	r2,40(r3)
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
 200b900:	e0fffc17 	ldw	r3,-16(fp)
 200b904:	00808074 	movhi	r2,513
 200b908:	10831804 	addi	r2,r2,3168
 200b90c:	18800b15 	stw	r2,44(r3)

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
 200b910:	0001883a 	nop
 200b914:	e037883a 	mov	sp,fp
 200b918:	dfc00117 	ldw	ra,4(sp)
 200b91c:	df000017 	ldw	fp,0(sp)
 200b920:	dec00204 	addi	sp,sp,8
 200b924:	f800283a 	ret

0200b928 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
 200b928:	defffb04 	addi	sp,sp,-20
 200b92c:	dfc00415 	stw	ra,16(sp)
 200b930:	df000315 	stw	fp,12(sp)
 200b934:	dc000215 	stw	r16,8(sp)
 200b938:	df000304 	addi	fp,sp,12
 200b93c:	e13ffe15 	stw	r4,-8(fp)
 200b940:	2821883a 	mov	r16,r5
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
 200b944:	80bfffc4 	addi	r2,r16,-1
 200b948:	10801a24 	muli	r2,r2,104
 200b94c:	10801d04 	addi	r2,r2,116
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
 200b950:	100b883a 	mov	r5,r2
 200b954:	e13ffe17 	ldw	r4,-8(fp)
 200b958:	200d4380 	call	200d438 <_malloc_r>
 200b95c:	e0bffd15 	stw	r2,-12(fp)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
 200b960:	e0bffd17 	ldw	r2,-12(fp)
 200b964:	1000021e 	bne	r2,zero,200b970 <__sfmoreglue+0x48>
    return NULL;
 200b968:	0005883a 	mov	r2,zero
 200b96c:	00001106 	br	200b9b4 <__sfmoreglue+0x8c>
  g->glue._next = NULL;
 200b970:	e0bffd17 	ldw	r2,-12(fp)
 200b974:	10000015 	stw	zero,0(r2)
  g->glue._niobs = n;
 200b978:	e0bffd17 	ldw	r2,-12(fp)
 200b97c:	14000115 	stw	r16,4(r2)
  g->glue._iobs = &g->file;
 200b980:	e0bffd17 	ldw	r2,-12(fp)
 200b984:	10c00304 	addi	r3,r2,12
 200b988:	e0bffd17 	ldw	r2,-12(fp)
 200b98c:	10c00215 	stw	r3,8(r2)
  memset (&g->file, 0, n * sizeof (FILE));
 200b990:	e0bffd17 	ldw	r2,-12(fp)
 200b994:	10800304 	addi	r2,r2,12
 200b998:	8007883a 	mov	r3,r16
 200b99c:	18c01a24 	muli	r3,r3,104
 200b9a0:	180d883a 	mov	r6,r3
 200b9a4:	000b883a 	mov	r5,zero
 200b9a8:	1009883a 	mov	r4,r2
 200b9ac:	20069580 	call	2006958 <memset>
  return &g->glue;
 200b9b0:	e0bffd17 	ldw	r2,-12(fp)
}
 200b9b4:	e6ffff04 	addi	sp,fp,-4
 200b9b8:	dfc00217 	ldw	ra,8(sp)
 200b9bc:	df000117 	ldw	fp,4(sp)
 200b9c0:	dc000017 	ldw	r16,0(sp)
 200b9c4:	dec00304 	addi	sp,sp,12
 200b9c8:	f800283a 	ret

0200b9cc <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
 200b9cc:	defffa04 	addi	sp,sp,-24
 200b9d0:	dfc00515 	stw	ra,20(sp)
 200b9d4:	df000415 	stw	fp,16(sp)
 200b9d8:	df000404 	addi	fp,sp,16
 200b9dc:	e13fff15 	stw	r4,-4(fp)
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
 200b9e0:	200bcb00 	call	200bcb0 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
 200b9e4:	d0a00717 	ldw	r2,-32740(gp)
 200b9e8:	10800e17 	ldw	r2,56(r2)
 200b9ec:	1000031e 	bne	r2,zero,200b9fc <__sfp+0x30>
    __sinit (_GLOBAL_REENT);
 200b9f0:	d0a00717 	ldw	r2,-32740(gp)
 200b9f4:	1009883a 	mov	r4,r2
 200b9f8:	200bbd80 	call	200bbd8 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 200b9fc:	d0a00717 	ldw	r2,-32740(gp)
 200ba00:	1080b804 	addi	r2,r2,736
 200ba04:	e0bffe15 	stw	r2,-8(fp)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200ba08:	e0bffe17 	ldw	r2,-8(fp)
 200ba0c:	10800217 	ldw	r2,8(r2)
 200ba10:	e0bffc15 	stw	r2,-16(fp)
 200ba14:	e0bffe17 	ldw	r2,-8(fp)
 200ba18:	10800117 	ldw	r2,4(r2)
 200ba1c:	e0bffd15 	stw	r2,-12(fp)
 200ba20:	00000906 	br	200ba48 <__sfp+0x7c>
	if (fp->_flags == 0)
 200ba24:	e0bffc17 	ldw	r2,-16(fp)
 200ba28:	1080030b 	ldhu	r2,12(r2)
 200ba2c:	10bfffcc 	andi	r2,r2,65535
 200ba30:	10a0001c 	xori	r2,r2,32768
 200ba34:	10a00004 	addi	r2,r2,-32768
 200ba38:	10001f26 	beq	r2,zero,200bab8 <__sfp+0xec>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200ba3c:	e0bffc17 	ldw	r2,-16(fp)
 200ba40:	10801a04 	addi	r2,r2,104
 200ba44:	e0bffc15 	stw	r2,-16(fp)
 200ba48:	e0bffd17 	ldw	r2,-12(fp)
 200ba4c:	10bfffc4 	addi	r2,r2,-1
 200ba50:	e0bffd15 	stw	r2,-12(fp)
 200ba54:	e0bffd17 	ldw	r2,-12(fp)
 200ba58:	103ff20e 	bge	r2,zero,200ba24 <__sfp+0x58>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 200ba5c:	e0bffe17 	ldw	r2,-8(fp)
 200ba60:	10800017 	ldw	r2,0(r2)
 200ba64:	1000091e 	bne	r2,zero,200ba8c <__sfp+0xc0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
 200ba68:	01400104 	movi	r5,4
 200ba6c:	e13fff17 	ldw	r4,-4(fp)
 200ba70:	200b9280 	call	200b928 <__sfmoreglue>
 200ba74:	1007883a 	mov	r3,r2
 200ba78:	e0bffe17 	ldw	r2,-8(fp)
 200ba7c:	10c00015 	stw	r3,0(r2)
 200ba80:	e0bffe17 	ldw	r2,-8(fp)
 200ba84:	10800017 	ldw	r2,0(r2)
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
 200ba88:	10000426 	beq	r2,zero,200ba9c <__sfp+0xd0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
 200ba8c:	e0bffe17 	ldw	r2,-8(fp)
 200ba90:	10800017 	ldw	r2,0(r2)
 200ba94:	e0bffe15 	stw	r2,-8(fp)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
 200ba98:	003fdb06 	br	200ba08 <__sfp+0x3c>
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
 200ba9c:	0001883a 	nop
    }
  _newlib_sfp_lock_exit ();
 200baa0:	200bcd00 	call	200bcd0 <__sfp_lock_release>
  d->_errno = ENOMEM;
 200baa4:	e0bfff17 	ldw	r2,-4(fp)
 200baa8:	00c00304 	movi	r3,12
 200baac:	10c00015 	stw	r3,0(r2)
  return NULL;
 200bab0:	0005883a 	mov	r2,zero
 200bab4:	00002506 	br	200bb4c <__sfp+0x180>
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
 200bab8:	0001883a 	nop
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
 200babc:	e0bffc17 	ldw	r2,-16(fp)
 200bac0:	00ffffc4 	movi	r3,-1
 200bac4:	10c0038d 	sth	r3,14(r2)
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
 200bac8:	e0bffc17 	ldw	r2,-16(fp)
 200bacc:	00c00044 	movi	r3,1
 200bad0:	10c0030d 	sth	r3,12(r2)
  fp->_flags2 = 0;
 200bad4:	e0bffc17 	ldw	r2,-16(fp)
 200bad8:	10001915 	stw	zero,100(r2)
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
#endif
  _newlib_sfp_lock_end ();
 200badc:	200bcd00 	call	200bcd0 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
 200bae0:	e0bffc17 	ldw	r2,-16(fp)
 200bae4:	10000015 	stw	zero,0(r2)
  fp->_w = 0;			/* nothing to read or write */
 200bae8:	e0bffc17 	ldw	r2,-16(fp)
 200baec:	10000215 	stw	zero,8(r2)
  fp->_r = 0;
 200baf0:	e0bffc17 	ldw	r2,-16(fp)
 200baf4:	10000115 	stw	zero,4(r2)
  fp->_bf._base = NULL;		/* no buffer */
 200baf8:	e0bffc17 	ldw	r2,-16(fp)
 200bafc:	10000415 	stw	zero,16(r2)
  fp->_bf._size = 0;
 200bb00:	e0bffc17 	ldw	r2,-16(fp)
 200bb04:	10000515 	stw	zero,20(r2)
  fp->_lbfsize = 0;		/* not line buffered */
 200bb08:	e0bffc17 	ldw	r2,-16(fp)
 200bb0c:	10000615 	stw	zero,24(r2)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
 200bb10:	e0bffc17 	ldw	r2,-16(fp)
 200bb14:	10801704 	addi	r2,r2,92
 200bb18:	01800204 	movi	r6,8
 200bb1c:	000b883a 	mov	r5,zero
 200bb20:	1009883a 	mov	r4,r2
 200bb24:	20069580 	call	2006958 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
 200bb28:	e0bffc17 	ldw	r2,-16(fp)
 200bb2c:	10000c15 	stw	zero,48(r2)
  fp->_ub._size = 0;
 200bb30:	e0bffc17 	ldw	r2,-16(fp)
 200bb34:	10000d15 	stw	zero,52(r2)
  fp->_lb._base = NULL;		/* no line buffer */
 200bb38:	e0bffc17 	ldw	r2,-16(fp)
 200bb3c:	10001115 	stw	zero,68(r2)
  fp->_lb._size = 0;
 200bb40:	e0bffc17 	ldw	r2,-16(fp)
 200bb44:	10001215 	stw	zero,72(r2)

  return fp;
 200bb48:	e0bffc17 	ldw	r2,-16(fp)
}
 200bb4c:	e037883a 	mov	sp,fp
 200bb50:	dfc00117 	ldw	ra,4(sp)
 200bb54:	df000017 	ldw	fp,0(sp)
 200bb58:	dec00204 	addi	sp,sp,8
 200bb5c:	f800283a 	ret

0200bb60 <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
 200bb60:	defffc04 	addi	sp,sp,-16
 200bb64:	dfc00315 	stw	ra,12(sp)
 200bb68:	df000215 	stw	fp,8(sp)
 200bb6c:	df000204 	addi	fp,sp,8
 200bb70:	e13fff15 	stw	r4,-4(fp)
  /* Otherwise close files and flush read streams, too.
     Note we call flush directly if "--enable-lite-exit" is in effect.  */
#ifdef _LITE_EXIT
  cleanup_func = _fflush_r;
#else
  cleanup_func = _fclose_r;
 200bb74:	00808074 	movhi	r2,513
 200bb78:	10895a04 	addi	r2,r2,9576
 200bb7c:	e0bffe15 	stw	r2,-8(fp)
#endif
#endif
  _CAST_VOID _fwalk_reent (ptr, cleanup_func);
 200bb80:	e17ffe17 	ldw	r5,-8(fp)
 200bb84:	e13fff17 	ldw	r4,-4(fp)
 200bb88:	200cbd80 	call	200cbd8 <_fwalk_reent>
}
 200bb8c:	0001883a 	nop
 200bb90:	e037883a 	mov	sp,fp
 200bb94:	dfc00117 	ldw	ra,4(sp)
 200bb98:	df000017 	ldw	fp,0(sp)
 200bb9c:	dec00204 	addi	sp,sp,8
 200bba0:	f800283a 	ret

0200bba4 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
 200bba4:	defffe04 	addi	sp,sp,-8
 200bba8:	dfc00115 	stw	ra,4(sp)
 200bbac:	df000015 	stw	fp,0(sp)
 200bbb0:	d839883a 	mov	fp,sp
  _cleanup_r (_GLOBAL_REENT);
 200bbb4:	d0a00717 	ldw	r2,-32740(gp)
 200bbb8:	1009883a 	mov	r4,r2
 200bbbc:	200bb600 	call	200bb60 <_cleanup_r>
}
 200bbc0:	0001883a 	nop
 200bbc4:	e037883a 	mov	sp,fp
 200bbc8:	dfc00117 	ldw	ra,4(sp)
 200bbcc:	df000017 	ldw	fp,0(sp)
 200bbd0:	dec00204 	addi	sp,sp,8
 200bbd4:	f800283a 	ret

0200bbd8 <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
 200bbd8:	defffd04 	addi	sp,sp,-12
 200bbdc:	dfc00215 	stw	ra,8(sp)
 200bbe0:	df000115 	stw	fp,4(sp)
 200bbe4:	df000104 	addi	fp,sp,4
 200bbe8:	e13fff15 	stw	r4,-4(fp)
  __sinit_lock_acquire ();
 200bbec:	200bcf00 	call	200bcf0 <__sinit_lock_acquire>

  if (s->__sdidinit)
 200bbf0:	e0bfff17 	ldw	r2,-4(fp)
 200bbf4:	10800e17 	ldw	r2,56(r2)
 200bbf8:	10000226 	beq	r2,zero,200bc04 <__sinit+0x2c>
    {
      __sinit_lock_release ();
 200bbfc:	200bd100 	call	200bd10 <__sinit_lock_release>
      return;
 200bc00:	00002606 	br	200bc9c <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
 200bc04:	e0ffff17 	ldw	r3,-4(fp)
 200bc08:	00808074 	movhi	r2,513
 200bc0c:	10aed804 	addi	r2,r2,-17568
 200bc10:	18800f15 	stw	r2,60(r3)

  s->__sglue._next = NULL;
 200bc14:	e0bfff17 	ldw	r2,-4(fp)
 200bc18:	1000b815 	stw	zero,736(r2)
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
 200bc1c:	e0bfff17 	ldw	r2,-4(fp)
 200bc20:	00c000c4 	movi	r3,3
 200bc24:	10c0b915 	stw	r3,740(r2)
  s->__sglue._iobs = &s->__sf[0];
 200bc28:	e0bfff17 	ldw	r2,-4(fp)
 200bc2c:	10c0bb04 	addi	r3,r2,748
 200bc30:	e0bfff17 	ldw	r2,-4(fp)
 200bc34:	10c0ba15 	stw	r3,744(r2)
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
 200bc38:	e0bfff17 	ldw	r2,-4(fp)
 200bc3c:	10800117 	ldw	r2,4(r2)
 200bc40:	e1ffff17 	ldw	r7,-4(fp)
 200bc44:	000d883a 	mov	r6,zero
 200bc48:	01400104 	movi	r5,4
 200bc4c:	1009883a 	mov	r4,r2
 200bc50:	200b8340 	call	200b834 <std>
#ifdef HAVE_FCNTL
/*std (s->_stdout, __SWR, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
#else
/*std (s->_stdout, __SWR | __SLBF, 1, s); */
  std (s->_stdout, __SWR | __SNBF, 1, s);	/* AlteraSpecific: Change to have no buffering on stdout. */
 200bc54:	e0bfff17 	ldw	r2,-4(fp)
 200bc58:	10800217 	ldw	r2,8(r2)
 200bc5c:	e1ffff17 	ldw	r7,-4(fp)
 200bc60:	01800044 	movi	r6,1
 200bc64:	01400284 	movi	r5,10
 200bc68:	1009883a 	mov	r4,r2
 200bc6c:	200b8340 	call	200b834 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
 200bc70:	e0bfff17 	ldw	r2,-4(fp)
 200bc74:	10800317 	ldw	r2,12(r2)
 200bc78:	e1ffff17 	ldw	r7,-4(fp)
 200bc7c:	01800084 	movi	r6,2
 200bc80:	01400484 	movi	r5,18
 200bc84:	1009883a 	mov	r4,r2
 200bc88:	200b8340 	call	200b834 <std>

  s->__sdidinit = 1;
 200bc8c:	e0bfff17 	ldw	r2,-4(fp)
 200bc90:	00c00044 	movi	r3,1
 200bc94:	10c00e15 	stw	r3,56(r2)

  __sinit_lock_release ();
 200bc98:	200bd100 	call	200bd10 <__sinit_lock_release>
}
 200bc9c:	e037883a 	mov	sp,fp
 200bca0:	dfc00117 	ldw	ra,4(sp)
 200bca4:	df000017 	ldw	fp,0(sp)
 200bca8:	dec00204 	addi	sp,sp,8
 200bcac:	f800283a 	ret

0200bcb0 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
 200bcb0:	deffff04 	addi	sp,sp,-4
 200bcb4:	df000015 	stw	fp,0(sp)
 200bcb8:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sfp_lock);
}
 200bcbc:	0001883a 	nop
 200bcc0:	e037883a 	mov	sp,fp
 200bcc4:	df000017 	ldw	fp,0(sp)
 200bcc8:	dec00104 	addi	sp,sp,4
 200bccc:	f800283a 	ret

0200bcd0 <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
 200bcd0:	deffff04 	addi	sp,sp,-4
 200bcd4:	df000015 	stw	fp,0(sp)
 200bcd8:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sfp_lock);
}
 200bcdc:	0001883a 	nop
 200bce0:	e037883a 	mov	sp,fp
 200bce4:	df000017 	ldw	fp,0(sp)
 200bce8:	dec00104 	addi	sp,sp,4
 200bcec:	f800283a 	ret

0200bcf0 <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
 200bcf0:	deffff04 	addi	sp,sp,-4
 200bcf4:	df000015 	stw	fp,0(sp)
 200bcf8:	d839883a 	mov	fp,sp
  __lock_acquire_recursive (__sinit_lock);
}
 200bcfc:	0001883a 	nop
 200bd00:	e037883a 	mov	sp,fp
 200bd04:	df000017 	ldw	fp,0(sp)
 200bd08:	dec00104 	addi	sp,sp,4
 200bd0c:	f800283a 	ret

0200bd10 <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
 200bd10:	deffff04 	addi	sp,sp,-4
 200bd14:	df000015 	stw	fp,0(sp)
 200bd18:	d839883a 	mov	fp,sp
  __lock_release_recursive (__sinit_lock);
}
 200bd1c:	0001883a 	nop
 200bd20:	e037883a 	mov	sp,fp
 200bd24:	df000017 	ldw	fp,0(sp)
 200bd28:	dec00104 	addi	sp,sp,4
 200bd2c:	f800283a 	ret

0200bd30 <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
 200bd30:	defffe04 	addi	sp,sp,-8
 200bd34:	df000115 	stw	fp,4(sp)
 200bd38:	df000104 	addi	fp,sp,4
 200bd3c:	e13fff15 	stw	r4,-4(fp)
  _flockfile (ptr);

  return 0;
 200bd40:	0005883a 	mov	r2,zero
}
 200bd44:	e037883a 	mov	sp,fp
 200bd48:	df000017 	ldw	fp,0(sp)
 200bd4c:	dec00104 	addi	sp,sp,4
 200bd50:	f800283a 	ret

0200bd54 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
 200bd54:	defffe04 	addi	sp,sp,-8
 200bd58:	df000115 	stw	fp,4(sp)
 200bd5c:	df000104 	addi	fp,sp,4
 200bd60:	e13fff15 	stw	r4,-4(fp)
  _funlockfile (ptr);

  return 0;
 200bd64:	0005883a 	mov	r2,zero
}
 200bd68:	e037883a 	mov	sp,fp
 200bd6c:	df000017 	ldw	fp,0(sp)
 200bd70:	dec00104 	addi	sp,sp,4
 200bd74:	f800283a 	ret

0200bd78 <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
 200bd78:	defffe04 	addi	sp,sp,-8
 200bd7c:	dfc00115 	stw	ra,4(sp)
 200bd80:	df000015 	stw	fp,0(sp)
 200bd84:	d839883a 	mov	fp,sp
  __sfp_lock_acquire ();
 200bd88:	200bcb00 	call	200bcb0 <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
 200bd8c:	d0a00617 	ldw	r2,-32744(gp)
 200bd90:	01408074 	movhi	r5,513
 200bd94:	296f4c04 	addi	r5,r5,-17104
 200bd98:	1009883a 	mov	r4,r2
 200bd9c:	200cb000 	call	200cb00 <_fwalk>
}
 200bda0:	0001883a 	nop
 200bda4:	e037883a 	mov	sp,fp
 200bda8:	dfc00117 	ldw	ra,4(sp)
 200bdac:	df000017 	ldw	fp,0(sp)
 200bdb0:	dec00204 	addi	sp,sp,8
 200bdb4:	f800283a 	ret

0200bdb8 <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
 200bdb8:	defffe04 	addi	sp,sp,-8
 200bdbc:	dfc00115 	stw	ra,4(sp)
 200bdc0:	df000015 	stw	fp,0(sp)
 200bdc4:	d839883a 	mov	fp,sp
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
 200bdc8:	d0a00617 	ldw	r2,-32744(gp)
 200bdcc:	01408074 	movhi	r5,513
 200bdd0:	296f5504 	addi	r5,r5,-17068
 200bdd4:	1009883a 	mov	r4,r2
 200bdd8:	200cb000 	call	200cb00 <_fwalk>

  __sfp_lock_release ();
 200bddc:	200bcd00 	call	200bcd0 <__sfp_lock_release>
}
 200bde0:	0001883a 	nop
 200bde4:	e037883a 	mov	sp,fp
 200bde8:	dfc00117 	ldw	ra,4(sp)
 200bdec:	df000017 	ldw	fp,0(sp)
 200bdf0:	dec00204 	addi	sp,sp,8
 200bdf4:	f800283a 	ret

0200bdf8 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
 200bdf8:	defff204 	addi	sp,sp,-56
 200bdfc:	dfc00d15 	stw	ra,52(sp)
 200be00:	df000c15 	stw	fp,48(sp)
 200be04:	df000c04 	addi	fp,sp,48
 200be08:	e13ffe15 	stw	r4,-8(fp)
 200be0c:	e17fff15 	stw	r5,-4(fp)
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
 200be10:	e0bfff17 	ldw	r2,-4(fp)
 200be14:	10014a26 	beq	r2,zero,200c340 <_free_r+0x548>
    return;

  MALLOC_LOCK;
 200be18:	e13ffe17 	ldw	r4,-8(fp)
 200be1c:	201469c0 	call	201469c <__malloc_lock>

  p = mem2chunk(mem);
 200be20:	e0bfff17 	ldw	r2,-4(fp)
 200be24:	10bffe04 	addi	r2,r2,-8
 200be28:	e0bff415 	stw	r2,-48(fp)
  hd = p->size;
 200be2c:	e0bff417 	ldw	r2,-48(fp)
 200be30:	10800117 	ldw	r2,4(r2)
 200be34:	e0bff915 	stw	r2,-28(fp)
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
 200be38:	e0fff917 	ldw	r3,-28(fp)
 200be3c:	00bfff84 	movi	r2,-2
 200be40:	1884703a 	and	r2,r3,r2
 200be44:	e0bff515 	stw	r2,-44(fp)
  next = chunk_at_offset(p, sz);
 200be48:	e0fff417 	ldw	r3,-48(fp)
 200be4c:	e0bff517 	ldw	r2,-44(fp)
 200be50:	1885883a 	add	r2,r3,r2
 200be54:	e0bffa15 	stw	r2,-24(fp)
  nextsz = chunksize(next);
 200be58:	e0bffa17 	ldw	r2,-24(fp)
 200be5c:	10c00117 	ldw	r3,4(r2)
 200be60:	00bfff04 	movi	r2,-4
 200be64:	1884703a 	and	r2,r3,r2
 200be68:	e0bffb15 	stw	r2,-20(fp)
  
  if (next == top)                            /* merge with top */
 200be6c:	008080b4 	movhi	r2,514
 200be70:	10800504 	addi	r2,r2,20
 200be74:	10c00217 	ldw	r3,8(r2)
 200be78:	e0bffa17 	ldw	r2,-24(fp)
 200be7c:	1880311e 	bne	r3,r2,200bf44 <_free_r+0x14c>
  {
    sz += nextsz;
 200be80:	e0fff517 	ldw	r3,-44(fp)
 200be84:	e0bffb17 	ldw	r2,-20(fp)
 200be88:	1885883a 	add	r2,r3,r2
 200be8c:	e0bff515 	stw	r2,-44(fp)

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
 200be90:	e0bff917 	ldw	r2,-28(fp)
 200be94:	1080004c 	andi	r2,r2,1
 200be98:	1000181e 	bne	r2,zero,200befc <_free_r+0x104>
    {
      prevsz = p->prev_size;
 200be9c:	e0bff417 	ldw	r2,-48(fp)
 200bea0:	10800017 	ldw	r2,0(r2)
 200bea4:	e0bffc15 	stw	r2,-16(fp)
      p = chunk_at_offset(p, -prevsz);
 200bea8:	e0bffc17 	ldw	r2,-16(fp)
 200beac:	0085c83a 	sub	r2,zero,r2
 200beb0:	e0fff417 	ldw	r3,-48(fp)
 200beb4:	1885883a 	add	r2,r3,r2
 200beb8:	e0bff415 	stw	r2,-48(fp)
      sz += prevsz;
 200bebc:	e0fff517 	ldw	r3,-44(fp)
 200bec0:	e0bffc17 	ldw	r2,-16(fp)
 200bec4:	1885883a 	add	r2,r3,r2
 200bec8:	e0bff515 	stw	r2,-44(fp)
      unlink(p, bck, fwd);
 200becc:	e0bff417 	ldw	r2,-48(fp)
 200bed0:	10800317 	ldw	r2,12(r2)
 200bed4:	e0bff615 	stw	r2,-40(fp)
 200bed8:	e0bff417 	ldw	r2,-48(fp)
 200bedc:	10800217 	ldw	r2,8(r2)
 200bee0:	e0bff715 	stw	r2,-36(fp)
 200bee4:	e0bff717 	ldw	r2,-36(fp)
 200bee8:	e0fff617 	ldw	r3,-40(fp)
 200beec:	10c00315 	stw	r3,12(r2)
 200bef0:	e0bff617 	ldw	r2,-40(fp)
 200bef4:	e0fff717 	ldw	r3,-36(fp)
 200bef8:	10c00215 	stw	r3,8(r2)
    }

    set_head(p, sz | PREV_INUSE);
 200befc:	e0bff517 	ldw	r2,-44(fp)
 200bf00:	10c00054 	ori	r3,r2,1
 200bf04:	e0bff417 	ldw	r2,-48(fp)
 200bf08:	10c00115 	stw	r3,4(r2)
    top = p;
 200bf0c:	008080b4 	movhi	r2,514
 200bf10:	10800504 	addi	r2,r2,20
 200bf14:	e0fff417 	ldw	r3,-48(fp)
 200bf18:	10c00215 	stw	r3,8(r2)
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
 200bf1c:	d0a00917 	ldw	r2,-32732(gp)
 200bf20:	e0fff517 	ldw	r3,-44(fp)
 200bf24:	18800436 	bltu	r3,r2,200bf38 <_free_r+0x140>
      malloc_trim(RCALL top_pad); 
 200bf28:	d0a74317 	ldw	r2,-25332(gp)
 200bf2c:	100b883a 	mov	r5,r2
 200bf30:	e13ffe17 	ldw	r4,-8(fp)
 200bf34:	200c3580 	call	200c358 <_malloc_trim_r>
    MALLOC_UNLOCK;
 200bf38:	e13ffe17 	ldw	r4,-8(fp)
 200bf3c:	20147bc0 	call	20147bc <__malloc_unlock>
    return;
 200bf40:	00010006 	br	200c344 <_free_r+0x54c>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
 200bf44:	e0bffa17 	ldw	r2,-24(fp)
 200bf48:	e0fffb17 	ldw	r3,-20(fp)
 200bf4c:	10c00115 	stw	r3,4(r2)

  islr = 0;
 200bf50:	e03ff815 	stw	zero,-32(fp)

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
 200bf54:	e0bff917 	ldw	r2,-28(fp)
 200bf58:	1080004c 	andi	r2,r2,1
 200bf5c:	1000201e 	bne	r2,zero,200bfe0 <_free_r+0x1e8>
  {
    prevsz = p->prev_size;
 200bf60:	e0bff417 	ldw	r2,-48(fp)
 200bf64:	10800017 	ldw	r2,0(r2)
 200bf68:	e0bffc15 	stw	r2,-16(fp)
    p = chunk_at_offset(p, -prevsz);
 200bf6c:	e0bffc17 	ldw	r2,-16(fp)
 200bf70:	0085c83a 	sub	r2,zero,r2
 200bf74:	e0fff417 	ldw	r3,-48(fp)
 200bf78:	1885883a 	add	r2,r3,r2
 200bf7c:	e0bff415 	stw	r2,-48(fp)
    sz += prevsz;
 200bf80:	e0fff517 	ldw	r3,-44(fp)
 200bf84:	e0bffc17 	ldw	r2,-16(fp)
 200bf88:	1885883a 	add	r2,r3,r2
 200bf8c:	e0bff515 	stw	r2,-44(fp)
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
 200bf90:	e0bff417 	ldw	r2,-48(fp)
 200bf94:	10c00217 	ldw	r3,8(r2)
 200bf98:	008080b4 	movhi	r2,514
 200bf9c:	10800704 	addi	r2,r2,28
 200bfa0:	1880031e 	bne	r3,r2,200bfb0 <_free_r+0x1b8>
      islr = 1;
 200bfa4:	00800044 	movi	r2,1
 200bfa8:	e0bff815 	stw	r2,-32(fp)
 200bfac:	00000c06 	br	200bfe0 <_free_r+0x1e8>
    else
      unlink(p, bck, fwd);
 200bfb0:	e0bff417 	ldw	r2,-48(fp)
 200bfb4:	10800317 	ldw	r2,12(r2)
 200bfb8:	e0bff615 	stw	r2,-40(fp)
 200bfbc:	e0bff417 	ldw	r2,-48(fp)
 200bfc0:	10800217 	ldw	r2,8(r2)
 200bfc4:	e0bff715 	stw	r2,-36(fp)
 200bfc8:	e0bff717 	ldw	r2,-36(fp)
 200bfcc:	e0fff617 	ldw	r3,-40(fp)
 200bfd0:	10c00315 	stw	r3,12(r2)
 200bfd4:	e0bff617 	ldw	r2,-40(fp)
 200bfd8:	e0fff717 	ldw	r3,-36(fp)
 200bfdc:	10c00215 	stw	r3,8(r2)
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
 200bfe0:	e0fffa17 	ldw	r3,-24(fp)
 200bfe4:	e0bffb17 	ldw	r2,-20(fp)
 200bfe8:	1885883a 	add	r2,r3,r2
 200bfec:	10800117 	ldw	r2,4(r2)
 200bff0:	1080004c 	andi	r2,r2,1
 200bff4:	10002a1e 	bne	r2,zero,200c0a0 <_free_r+0x2a8>
  {
    sz += nextsz;
 200bff8:	e0fff517 	ldw	r3,-44(fp)
 200bffc:	e0bffb17 	ldw	r2,-20(fp)
 200c000:	1885883a 	add	r2,r3,r2
 200c004:	e0bff515 	stw	r2,-44(fp)
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
 200c008:	e0bff817 	ldw	r2,-32(fp)
 200c00c:	1000181e 	bne	r2,zero,200c070 <_free_r+0x278>
 200c010:	e0bffa17 	ldw	r2,-24(fp)
 200c014:	10c00217 	ldw	r3,8(r2)
 200c018:	008080b4 	movhi	r2,514
 200c01c:	10800704 	addi	r2,r2,28
 200c020:	1880131e 	bne	r3,r2,200c070 <_free_r+0x278>
    {
      islr = 1;
 200c024:	00800044 	movi	r2,1
 200c028:	e0bff815 	stw	r2,-32(fp)
      link_last_remainder(p);   
 200c02c:	00c080b4 	movhi	r3,514
 200c030:	18c00704 	addi	r3,r3,28
 200c034:	008080b4 	movhi	r2,514
 200c038:	10800704 	addi	r2,r2,28
 200c03c:	e13ff417 	ldw	r4,-48(fp)
 200c040:	11000315 	stw	r4,12(r2)
 200c044:	10800317 	ldw	r2,12(r2)
 200c048:	18800215 	stw	r2,8(r3)
 200c04c:	008080b4 	movhi	r2,514
 200c050:	10800704 	addi	r2,r2,28
 200c054:	e0fff417 	ldw	r3,-48(fp)
 200c058:	18800315 	stw	r2,12(r3)
 200c05c:	e0bff417 	ldw	r2,-48(fp)
 200c060:	10c00317 	ldw	r3,12(r2)
 200c064:	e0bff417 	ldw	r2,-48(fp)
 200c068:	10c00215 	stw	r3,8(r2)
 200c06c:	00000c06 	br	200c0a0 <_free_r+0x2a8>
    }
    else
      unlink(next, bck, fwd);
 200c070:	e0bffa17 	ldw	r2,-24(fp)
 200c074:	10800317 	ldw	r2,12(r2)
 200c078:	e0bff615 	stw	r2,-40(fp)
 200c07c:	e0bffa17 	ldw	r2,-24(fp)
 200c080:	10800217 	ldw	r2,8(r2)
 200c084:	e0bff715 	stw	r2,-36(fp)
 200c088:	e0bff717 	ldw	r2,-36(fp)
 200c08c:	e0fff617 	ldw	r3,-40(fp)
 200c090:	10c00315 	stw	r3,12(r2)
 200c094:	e0bff617 	ldw	r2,-40(fp)
 200c098:	e0fff717 	ldw	r3,-36(fp)
 200c09c:	10c00215 	stw	r3,8(r2)
  }


  set_head(p, sz | PREV_INUSE);
 200c0a0:	e0bff517 	ldw	r2,-44(fp)
 200c0a4:	10c00054 	ori	r3,r2,1
 200c0a8:	e0bff417 	ldw	r2,-48(fp)
 200c0ac:	10c00115 	stw	r3,4(r2)
  set_foot(p, sz);
 200c0b0:	e0fff417 	ldw	r3,-48(fp)
 200c0b4:	e0bff517 	ldw	r2,-44(fp)
 200c0b8:	1885883a 	add	r2,r3,r2
 200c0bc:	e0fff517 	ldw	r3,-44(fp)
 200c0c0:	10c00015 	stw	r3,0(r2)
  if (!islr)
 200c0c4:	e0bff817 	ldw	r2,-32(fp)
 200c0c8:	10009a1e 	bne	r2,zero,200c334 <_free_r+0x53c>
    frontlink(p, sz, idx, bck, fwd);  
 200c0cc:	e0bff517 	ldw	r2,-44(fp)
 200c0d0:	10808028 	cmpgeui	r2,r2,512
 200c0d4:	10002c1e 	bne	r2,zero,200c188 <_free_r+0x390>
 200c0d8:	e0bff517 	ldw	r2,-44(fp)
 200c0dc:	1004d0fa 	srli	r2,r2,3
 200c0e0:	e0bffd15 	stw	r2,-12(fp)
 200c0e4:	00c080b4 	movhi	r3,514
 200c0e8:	18c00504 	addi	r3,r3,20
 200c0ec:	008080b4 	movhi	r2,514
 200c0f0:	10800504 	addi	r2,r2,20
 200c0f4:	11000117 	ldw	r4,4(r2)
 200c0f8:	e0bffd17 	ldw	r2,-12(fp)
 200c0fc:	1000010e 	bge	r2,zero,200c104 <_free_r+0x30c>
 200c100:	108000c4 	addi	r2,r2,3
 200c104:	1005d0ba 	srai	r2,r2,2
 200c108:	100b883a 	mov	r5,r2
 200c10c:	00800044 	movi	r2,1
 200c110:	1144983a 	sll	r2,r2,r5
 200c114:	2084b03a 	or	r2,r4,r2
 200c118:	18800115 	stw	r2,4(r3)
 200c11c:	e0bffd17 	ldw	r2,-12(fp)
 200c120:	10800044 	addi	r2,r2,1
 200c124:	1085883a 	add	r2,r2,r2
 200c128:	1085883a 	add	r2,r2,r2
 200c12c:	1087883a 	add	r3,r2,r2
 200c130:	008080b4 	movhi	r2,514
 200c134:	10800504 	addi	r2,r2,20
 200c138:	1885883a 	add	r2,r3,r2
 200c13c:	10bffe04 	addi	r2,r2,-8
 200c140:	e0bff615 	stw	r2,-40(fp)
 200c144:	e0bff617 	ldw	r2,-40(fp)
 200c148:	10800217 	ldw	r2,8(r2)
 200c14c:	e0bff715 	stw	r2,-36(fp)
 200c150:	e0bff417 	ldw	r2,-48(fp)
 200c154:	e0fff617 	ldw	r3,-40(fp)
 200c158:	10c00315 	stw	r3,12(r2)
 200c15c:	e0bff417 	ldw	r2,-48(fp)
 200c160:	e0fff717 	ldw	r3,-36(fp)
 200c164:	10c00215 	stw	r3,8(r2)
 200c168:	e0bff617 	ldw	r2,-40(fp)
 200c16c:	e0fff417 	ldw	r3,-48(fp)
 200c170:	10c00215 	stw	r3,8(r2)
 200c174:	e0bff617 	ldw	r2,-40(fp)
 200c178:	10c00217 	ldw	r3,8(r2)
 200c17c:	e0bff717 	ldw	r2,-36(fp)
 200c180:	10c00315 	stw	r3,12(r2)
 200c184:	00006b06 	br	200c334 <_free_r+0x53c>
 200c188:	e0bff517 	ldw	r2,-44(fp)
 200c18c:	1004d27a 	srli	r2,r2,9
 200c190:	1000031e 	bne	r2,zero,200c1a0 <_free_r+0x3a8>
 200c194:	e0bff517 	ldw	r2,-44(fp)
 200c198:	1004d0fa 	srli	r2,r2,3
 200c19c:	00002906 	br	200c244 <_free_r+0x44c>
 200c1a0:	e0bff517 	ldw	r2,-44(fp)
 200c1a4:	1004d27a 	srli	r2,r2,9
 200c1a8:	10800168 	cmpgeui	r2,r2,5
 200c1ac:	1000041e 	bne	r2,zero,200c1c0 <_free_r+0x3c8>
 200c1b0:	e0bff517 	ldw	r2,-44(fp)
 200c1b4:	1004d1ba 	srli	r2,r2,6
 200c1b8:	10800e04 	addi	r2,r2,56
 200c1bc:	00002106 	br	200c244 <_free_r+0x44c>
 200c1c0:	e0bff517 	ldw	r2,-44(fp)
 200c1c4:	1004d27a 	srli	r2,r2,9
 200c1c8:	10800568 	cmpgeui	r2,r2,21
 200c1cc:	1000041e 	bne	r2,zero,200c1e0 <_free_r+0x3e8>
 200c1d0:	e0bff517 	ldw	r2,-44(fp)
 200c1d4:	1004d27a 	srli	r2,r2,9
 200c1d8:	108016c4 	addi	r2,r2,91
 200c1dc:	00001906 	br	200c244 <_free_r+0x44c>
 200c1e0:	e0bff517 	ldw	r2,-44(fp)
 200c1e4:	1004d27a 	srli	r2,r2,9
 200c1e8:	10801568 	cmpgeui	r2,r2,85
 200c1ec:	1000041e 	bne	r2,zero,200c200 <_free_r+0x408>
 200c1f0:	e0bff517 	ldw	r2,-44(fp)
 200c1f4:	1004d33a 	srli	r2,r2,12
 200c1f8:	10801b84 	addi	r2,r2,110
 200c1fc:	00001106 	br	200c244 <_free_r+0x44c>
 200c200:	e0bff517 	ldw	r2,-44(fp)
 200c204:	1004d27a 	srli	r2,r2,9
 200c208:	10805568 	cmpgeui	r2,r2,341
 200c20c:	1000041e 	bne	r2,zero,200c220 <_free_r+0x428>
 200c210:	e0bff517 	ldw	r2,-44(fp)
 200c214:	1004d3fa 	srli	r2,r2,15
 200c218:	10801dc4 	addi	r2,r2,119
 200c21c:	00000906 	br	200c244 <_free_r+0x44c>
 200c220:	e0bff517 	ldw	r2,-44(fp)
 200c224:	1004d27a 	srli	r2,r2,9
 200c228:	10815568 	cmpgeui	r2,r2,1365
 200c22c:	1000041e 	bne	r2,zero,200c240 <_free_r+0x448>
 200c230:	e0bff517 	ldw	r2,-44(fp)
 200c234:	1004d4ba 	srli	r2,r2,18
 200c238:	10801f04 	addi	r2,r2,124
 200c23c:	00000106 	br	200c244 <_free_r+0x44c>
 200c240:	00801f84 	movi	r2,126
 200c244:	e0bffd15 	stw	r2,-12(fp)
 200c248:	e0bffd17 	ldw	r2,-12(fp)
 200c24c:	10800044 	addi	r2,r2,1
 200c250:	1085883a 	add	r2,r2,r2
 200c254:	1085883a 	add	r2,r2,r2
 200c258:	1087883a 	add	r3,r2,r2
 200c25c:	008080b4 	movhi	r2,514
 200c260:	10800504 	addi	r2,r2,20
 200c264:	1885883a 	add	r2,r3,r2
 200c268:	10bffe04 	addi	r2,r2,-8
 200c26c:	e0bff615 	stw	r2,-40(fp)
 200c270:	e0bff617 	ldw	r2,-40(fp)
 200c274:	10800217 	ldw	r2,8(r2)
 200c278:	e0bff715 	stw	r2,-36(fp)
 200c27c:	e0fff717 	ldw	r3,-36(fp)
 200c280:	e0bff617 	ldw	r2,-40(fp)
 200c284:	1880121e 	bne	r3,r2,200c2d0 <_free_r+0x4d8>
 200c288:	00c080b4 	movhi	r3,514
 200c28c:	18c00504 	addi	r3,r3,20
 200c290:	008080b4 	movhi	r2,514
 200c294:	10800504 	addi	r2,r2,20
 200c298:	11000117 	ldw	r4,4(r2)
 200c29c:	e0bffd17 	ldw	r2,-12(fp)
 200c2a0:	1000010e 	bge	r2,zero,200c2a8 <_free_r+0x4b0>
 200c2a4:	108000c4 	addi	r2,r2,3
 200c2a8:	1005d0ba 	srai	r2,r2,2
 200c2ac:	100b883a 	mov	r5,r2
 200c2b0:	00800044 	movi	r2,1
 200c2b4:	1144983a 	sll	r2,r2,r5
 200c2b8:	2084b03a 	or	r2,r4,r2
 200c2bc:	18800115 	stw	r2,4(r3)
 200c2c0:	00000f06 	br	200c300 <_free_r+0x508>
 200c2c4:	e0bff717 	ldw	r2,-36(fp)
 200c2c8:	10800217 	ldw	r2,8(r2)
 200c2cc:	e0bff715 	stw	r2,-36(fp)
 200c2d0:	e0fff717 	ldw	r3,-36(fp)
 200c2d4:	e0bff617 	ldw	r2,-40(fp)
 200c2d8:	18800626 	beq	r3,r2,200c2f4 <_free_r+0x4fc>
 200c2dc:	e0bff717 	ldw	r2,-36(fp)
 200c2e0:	10c00117 	ldw	r3,4(r2)
 200c2e4:	00bfff04 	movi	r2,-4
 200c2e8:	1884703a 	and	r2,r3,r2
 200c2ec:	e0fff517 	ldw	r3,-44(fp)
 200c2f0:	18bff436 	bltu	r3,r2,200c2c4 <_free_r+0x4cc>
 200c2f4:	e0bff717 	ldw	r2,-36(fp)
 200c2f8:	10800317 	ldw	r2,12(r2)
 200c2fc:	e0bff615 	stw	r2,-40(fp)
 200c300:	e0bff417 	ldw	r2,-48(fp)
 200c304:	e0fff617 	ldw	r3,-40(fp)
 200c308:	10c00315 	stw	r3,12(r2)
 200c30c:	e0bff417 	ldw	r2,-48(fp)
 200c310:	e0fff717 	ldw	r3,-36(fp)
 200c314:	10c00215 	stw	r3,8(r2)
 200c318:	e0bff617 	ldw	r2,-40(fp)
 200c31c:	e0fff417 	ldw	r3,-48(fp)
 200c320:	10c00215 	stw	r3,8(r2)
 200c324:	e0bff617 	ldw	r2,-40(fp)
 200c328:	10c00217 	ldw	r3,8(r2)
 200c32c:	e0bff717 	ldw	r2,-36(fp)
 200c330:	10c00315 	stw	r3,12(r2)

  MALLOC_UNLOCK;
 200c334:	e13ffe17 	ldw	r4,-8(fp)
 200c338:	20147bc0 	call	20147bc <__malloc_unlock>
 200c33c:	00000106 	br	200c344 <_free_r+0x54c>
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;
 200c340:	0001883a 	nop
    frontlink(p, sz, idx, bck, fwd);  

  MALLOC_UNLOCK;

#endif /* MALLOC_PROVIDED */
}
 200c344:	e037883a 	mov	sp,fp
 200c348:	dfc00117 	ldw	ra,4(sp)
 200c34c:	df000017 	ldw	fp,0(sp)
 200c350:	dec00204 	addi	sp,sp,8
 200c354:	f800283a 	ret

0200c358 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
 200c358:	defff704 	addi	sp,sp,-36
 200c35c:	dfc00815 	stw	ra,32(sp)
 200c360:	df000715 	stw	fp,28(sp)
 200c364:	df000704 	addi	fp,sp,28
 200c368:	e13ffe15 	stw	r4,-8(fp)
 200c36c:	e17fff15 	stw	r5,-4(fp)
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
 200c370:	00840004 	movi	r2,4096
 200c374:	e0bff915 	stw	r2,-28(fp)

  MALLOC_LOCK;
 200c378:	e13ffe17 	ldw	r4,-8(fp)
 200c37c:	201469c0 	call	201469c <__malloc_lock>

  top_size = chunksize(top);
 200c380:	008080b4 	movhi	r2,514
 200c384:	10800504 	addi	r2,r2,20
 200c388:	10800217 	ldw	r2,8(r2)
 200c38c:	10800117 	ldw	r2,4(r2)
 200c390:	1007883a 	mov	r3,r2
 200c394:	00bfff04 	movi	r2,-4
 200c398:	1884703a 	and	r2,r3,r2
 200c39c:	e0bffa15 	stw	r2,-24(fp)
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
 200c3a0:	e0fffa17 	ldw	r3,-24(fp)
 200c3a4:	e0bfff17 	ldw	r2,-4(fp)
 200c3a8:	1887c83a 	sub	r3,r3,r2
 200c3ac:	e0bff917 	ldw	r2,-28(fp)
 200c3b0:	1885883a 	add	r2,r3,r2
 200c3b4:	10bffbc4 	addi	r2,r2,-17
 200c3b8:	e17ff917 	ldw	r5,-28(fp)
 200c3bc:	1009883a 	mov	r4,r2
 200c3c0:	2003fd80 	call	2003fd8 <__udivsi3>
 200c3c4:	10ffffc4 	addi	r3,r2,-1
 200c3c8:	e0bff917 	ldw	r2,-28(fp)
 200c3cc:	1885383a 	mul	r2,r3,r2
 200c3d0:	e0bffb15 	stw	r2,-20(fp)

  if (extra < (long)pagesz)  /* Not enough memory to release */
 200c3d4:	e0bff917 	ldw	r2,-28(fp)
 200c3d8:	e0fffb17 	ldw	r3,-20(fp)
 200c3dc:	1880040e 	bge	r3,r2,200c3f0 <_malloc_trim_r+0x98>
  {
    MALLOC_UNLOCK;
 200c3e0:	e13ffe17 	ldw	r4,-8(fp)
 200c3e4:	20147bc0 	call	20147bc <__malloc_unlock>
    return 0;
 200c3e8:	0005883a 	mov	r2,zero
 200c3ec:	00004806 	br	200c510 <_malloc_trim_r+0x1b8>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
 200c3f0:	000b883a 	mov	r5,zero
 200c3f4:	e13ffe17 	ldw	r4,-8(fp)
 200c3f8:	20109e00 	call	20109e0 <_sbrk_r>
 200c3fc:	e0bffc15 	stw	r2,-16(fp)
    if (current_brk != (char*)(top) + top_size)
 200c400:	008080b4 	movhi	r2,514
 200c404:	10800504 	addi	r2,r2,20
 200c408:	10c00217 	ldw	r3,8(r2)
 200c40c:	e0bffa17 	ldw	r2,-24(fp)
 200c410:	1887883a 	add	r3,r3,r2
 200c414:	e0bffc17 	ldw	r2,-16(fp)
 200c418:	18800426 	beq	r3,r2,200c42c <_malloc_trim_r+0xd4>
    {
      MALLOC_UNLOCK;
 200c41c:	e13ffe17 	ldw	r4,-8(fp)
 200c420:	20147bc0 	call	20147bc <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
 200c424:	0005883a 	mov	r2,zero
 200c428:	00003906 	br	200c510 <_malloc_trim_r+0x1b8>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
 200c42c:	e0bffb17 	ldw	r2,-20(fp)
 200c430:	0085c83a 	sub	r2,zero,r2
 200c434:	100b883a 	mov	r5,r2
 200c438:	e13ffe17 	ldw	r4,-8(fp)
 200c43c:	20109e00 	call	20109e0 <_sbrk_r>
 200c440:	e0bffd15 	stw	r2,-12(fp)
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
 200c444:	e0bffd17 	ldw	r2,-12(fp)
 200c448:	10bfffd8 	cmpnei	r2,r2,-1
 200c44c:	10001d1e 	bne	r2,zero,200c4c4 <_malloc_trim_r+0x16c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
 200c450:	000b883a 	mov	r5,zero
 200c454:	e13ffe17 	ldw	r4,-8(fp)
 200c458:	20109e00 	call	20109e0 <_sbrk_r>
 200c45c:	e0bffc15 	stw	r2,-16(fp)
        top_size = current_brk - (char*)top;
 200c460:	e0fffc17 	ldw	r3,-16(fp)
 200c464:	008080b4 	movhi	r2,514
 200c468:	10800504 	addi	r2,r2,20
 200c46c:	10800217 	ldw	r2,8(r2)
 200c470:	1885c83a 	sub	r2,r3,r2
 200c474:	e0bffa15 	stw	r2,-24(fp)
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
 200c478:	e0bffa17 	ldw	r2,-24(fp)
 200c47c:	10800410 	cmplti	r2,r2,16
 200c480:	10000c1e 	bne	r2,zero,200c4b4 <_malloc_trim_r+0x15c>
        {
          sbrked_mem = current_brk - sbrk_base;
 200c484:	e0bffc17 	ldw	r2,-16(fp)
 200c488:	d0e00a17 	ldw	r3,-32728(gp)
 200c48c:	10c7c83a 	sub	r3,r2,r3
 200c490:	008080b4 	movhi	r2,514
 200c494:	108cff04 	addi	r2,r2,13308
 200c498:	10c00015 	stw	r3,0(r2)
          set_head(top, top_size | PREV_INUSE);
 200c49c:	008080b4 	movhi	r2,514
 200c4a0:	10800504 	addi	r2,r2,20
 200c4a4:	10800217 	ldw	r2,8(r2)
 200c4a8:	e0fffa17 	ldw	r3,-24(fp)
 200c4ac:	18c00054 	ori	r3,r3,1
 200c4b0:	10c00115 	stw	r3,4(r2)
        }
        check_chunk(top);
	MALLOC_UNLOCK;
 200c4b4:	e13ffe17 	ldw	r4,-8(fp)
 200c4b8:	20147bc0 	call	20147bc <__malloc_unlock>
        return 0; 
 200c4bc:	0005883a 	mov	r2,zero
 200c4c0:	00001306 	br	200c510 <_malloc_trim_r+0x1b8>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
 200c4c4:	008080b4 	movhi	r2,514
 200c4c8:	10800504 	addi	r2,r2,20
 200c4cc:	10800217 	ldw	r2,8(r2)
 200c4d0:	e13ffa17 	ldw	r4,-24(fp)
 200c4d4:	e0fffb17 	ldw	r3,-20(fp)
 200c4d8:	20c7c83a 	sub	r3,r4,r3
 200c4dc:	18c00054 	ori	r3,r3,1
 200c4e0:	10c00115 	stw	r3,4(r2)
        sbrked_mem -= extra;
 200c4e4:	008080b4 	movhi	r2,514
 200c4e8:	108cff04 	addi	r2,r2,13308
 200c4ec:	10c00017 	ldw	r3,0(r2)
 200c4f0:	e0bffb17 	ldw	r2,-20(fp)
 200c4f4:	1887c83a 	sub	r3,r3,r2
 200c4f8:	008080b4 	movhi	r2,514
 200c4fc:	108cff04 	addi	r2,r2,13308
 200c500:	10c00015 	stw	r3,0(r2)
        check_chunk(top);
	MALLOC_UNLOCK;
 200c504:	e13ffe17 	ldw	r4,-8(fp)
 200c508:	20147bc0 	call	20147bc <__malloc_unlock>
        return 1;
 200c50c:	00800044 	movi	r2,1
      }
    }
  }
}
 200c510:	e037883a 	mov	sp,fp
 200c514:	dfc00117 	ldw	ra,4(sp)
 200c518:	df000017 	ldw	fp,0(sp)
 200c51c:	dec00204 	addi	sp,sp,8
 200c520:	f800283a 	ret

0200c524 <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
 200c524:	defff004 	addi	sp,sp,-64
 200c528:	dfc00f15 	stw	ra,60(sp)
 200c52c:	df000e15 	stw	fp,56(sp)
 200c530:	dd800d15 	stw	r22,52(sp)
 200c534:	dd400c15 	stw	r21,48(sp)
 200c538:	dd000b15 	stw	r20,44(sp)
 200c53c:	dcc00a15 	stw	r19,40(sp)
 200c540:	dc800915 	stw	r18,36(sp)
 200c544:	dc400815 	stw	r17,32(sp)
 200c548:	dc000715 	stw	r16,28(sp)
 200c54c:	df000e04 	addi	fp,sp,56
 200c550:	e13ff815 	stw	r4,-32(fp)
 200c554:	2821883a 	mov	r16,r5
 200c558:	302b883a 	mov	r21,r6
  register size_t len;
  register _CONST char *p = NULL;
 200c55c:	0027883a 	mov	r19,zero
  register struct __siov *iov;
  register _READ_WRITE_RETURN_TYPE w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
 200c560:	ac800217 	ldw	r18,8(r21)
 200c564:	9000021e 	bne	r18,zero,200c570 <__sfvwrite_r+0x4c>
    return 0;
 200c568:	0005883a 	mov	r2,zero
 200c56c:	00015806 	br	200cad0 <__sfvwrite_r+0x5ac>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
 200c570:	8080030b 	ldhu	r2,12(r16)
 200c574:	10bfffcc 	andi	r2,r2,65535
 200c578:	1080020c 	andi	r2,r2,8
 200c57c:	10000226 	beq	r2,zero,200c588 <__sfvwrite_r+0x64>
 200c580:	80800417 	ldw	r2,16(r16)
 200c584:	1000061e 	bne	r2,zero,200c5a0 <__sfvwrite_r+0x7c>
 200c588:	800b883a 	mov	r5,r16
 200c58c:	e13ff817 	ldw	r4,-32(fp)
 200c590:	20093880 	call	2009388 <__swsetup_r>
 200c594:	10000226 	beq	r2,zero,200c5a0 <__sfvwrite_r+0x7c>
    return EOF;
 200c598:	00bfffc4 	movi	r2,-1
 200c59c:	00014c06 	br	200cad0 <__sfvwrite_r+0x5ac>

  iov = uio->uio_iov;
 200c5a0:	ad000017 	ldw	r20,0(r21)
  len = 0;
 200c5a4:	0025883a 	mov	r18,zero
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
 200c5a8:	8080030b 	ldhu	r2,12(r16)
 200c5ac:	10bfffcc 	andi	r2,r2,65535
 200c5b0:	1080008c 	andi	r2,r2,2
 200c5b4:	10001f26 	beq	r2,zero,200c634 <__sfvwrite_r+0x110>
       * Unbuffered: Split buffer in the largest multiple of BUFSIZ < INT_MAX
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
 200c5b8:	00000306 	br	200c5c8 <__sfvwrite_r+0xa4>
 200c5bc:	a4c00017 	ldw	r19,0(r20)
 200c5c0:	a4800117 	ldw	r18,4(r20)
 200c5c4:	a5000204 	addi	r20,r20,8
 200c5c8:	903ffc26 	beq	r18,zero,200c5bc <__sfvwrite_r+0x98>
	  w = fp->_write (ptr, fp->_cookie, p,
 200c5cc:	82000917 	ldw	r8,36(r16)
 200c5d0:	81000717 	ldw	r4,28(r16)
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
 200c5d4:	9005883a 	mov	r2,r18
 200c5d8:	00e00034 	movhi	r3,32768
 200c5dc:	18ff0004 	addi	r3,r3,-1024
 200c5e0:	1880022e 	bgeu	r3,r2,200c5ec <__sfvwrite_r+0xc8>
 200c5e4:	00a00034 	movhi	r2,32768
 200c5e8:	10bf0004 	addi	r2,r2,-1024
       * as some legacy code may expect int instead of size_t.
       */
      do
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
 200c5ec:	100f883a 	mov	r7,r2
 200c5f0:	980d883a 	mov	r6,r19
 200c5f4:	200b883a 	mov	r5,r4
 200c5f8:	e13ff817 	ldw	r4,-32(fp)
 200c5fc:	403ee83a 	callr	r8
 200c600:	1023883a 	mov	r17,r2
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
 200c604:	0441290e 	bge	zero,r17,200caac <__sfvwrite_r+0x588>
	    goto err;
	  p += w;
 200c608:	8805883a 	mov	r2,r17
 200c60c:	98a7883a 	add	r19,r19,r2
	  len -= w;
 200c610:	8805883a 	mov	r2,r17
 200c614:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 200c618:	a8800217 	ldw	r2,8(r21)
 200c61c:	8807883a 	mov	r3,r17
 200c620:	10c5c83a 	sub	r2,r2,r3
 200c624:	a8800215 	stw	r2,8(r21)
 200c628:	a8800217 	ldw	r2,8(r21)
 200c62c:	103fe61e 	bne	r2,zero,200c5c8 <__sfvwrite_r+0xa4>
 200c630:	00011c06 	br	200caa4 <__sfvwrite_r+0x580>
    }
  else if ((fp->_flags & __SLBF) == 0)
 200c634:	8080030b 	ldhu	r2,12(r16)
 200c638:	10bfffcc 	andi	r2,r2,65535
 200c63c:	1080004c 	andi	r2,r2,1
 200c640:	1000b51e 	bne	r2,zero,200c918 <__sfvwrite_r+0x3f4>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
 200c644:	00000306 	br	200c654 <__sfvwrite_r+0x130>
 200c648:	a4c00017 	ldw	r19,0(r20)
 200c64c:	a4800117 	ldw	r18,4(r20)
 200c650:	a5000204 	addi	r20,r20,8
 200c654:	903ffc26 	beq	r18,zero,200c648 <__sfvwrite_r+0x124>
	  w = fp->_w;
 200c658:	84400217 	ldw	r17,8(r16)
	  if (fp->_flags & __SSTR)
 200c65c:	8080030b 	ldhu	r2,12(r16)
 200c660:	10bfffcc 	andi	r2,r2,65535
 200c664:	1080800c 	andi	r2,r2,512
 200c668:	10006b26 	beq	r2,zero,200c818 <__sfvwrite_r+0x2f4>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
 200c66c:	8805883a 	mov	r2,r17
 200c670:	90805736 	bltu	r18,r2,200c7d0 <__sfvwrite_r+0x2ac>
 200c674:	8080030b 	ldhu	r2,12(r16)
 200c678:	10bfffcc 	andi	r2,r2,65535
 200c67c:	1081200c 	andi	r2,r2,1152
 200c680:	10005326 	beq	r2,zero,200c7d0 <__sfvwrite_r+0x2ac>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
 200c684:	80800017 	ldw	r2,0(r16)
 200c688:	1007883a 	mov	r3,r2
 200c68c:	80800417 	ldw	r2,16(r16)
 200c690:	1885c83a 	sub	r2,r3,r2
 200c694:	e0bff615 	stw	r2,-40(fp)
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
 200c698:	80c00517 	ldw	r3,20(r16)
 200c69c:	1805883a 	mov	r2,r3
 200c6a0:	1085883a 	add	r2,r2,r2
 200c6a4:	10c5883a 	add	r2,r2,r3
 200c6a8:	1006d7fa 	srli	r3,r2,31
 200c6ac:	1885883a 	add	r2,r3,r2
 200c6b0:	1005d07a 	srai	r2,r2,1
 200c6b4:	e0bff515 	stw	r2,-44(fp)
		  if (newsize < curpos + len + 1)
 200c6b8:	e0bff617 	ldw	r2,-40(fp)
 200c6bc:	1485883a 	add	r2,r2,r18
 200c6c0:	10800044 	addi	r2,r2,1
 200c6c4:	e0fff517 	ldw	r3,-44(fp)
 200c6c8:	1880042e 	bgeu	r3,r2,200c6dc <__sfvwrite_r+0x1b8>
		    newsize = curpos + len + 1;
 200c6cc:	e0bff617 	ldw	r2,-40(fp)
 200c6d0:	1485883a 	add	r2,r2,r18
 200c6d4:	10800044 	addi	r2,r2,1
 200c6d8:	e0bff515 	stw	r2,-44(fp)
		  if (fp->_flags & __SOPT)
 200c6dc:	8080030b 	ldhu	r2,12(r16)
 200c6e0:	10bfffcc 	andi	r2,r2,65535
 200c6e4:	1081000c 	andi	r2,r2,1024
 200c6e8:	10001726 	beq	r2,zero,200c748 <__sfvwrite_r+0x224>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
 200c6ec:	e0bff517 	ldw	r2,-44(fp)
 200c6f0:	100b883a 	mov	r5,r2
 200c6f4:	e13ff817 	ldw	r4,-32(fp)
 200c6f8:	200d4380 	call	200d438 <_malloc_r>
 200c6fc:	e0bff415 	stw	r2,-48(fp)
		      if (!str)
 200c700:	e0bff417 	ldw	r2,-48(fp)
 200c704:	1000041e 	bne	r2,zero,200c718 <__sfvwrite_r+0x1f4>
			{
			  ptr->_errno = ENOMEM;
 200c708:	e0bff817 	ldw	r2,-32(fp)
 200c70c:	00c00304 	movi	r3,12
 200c710:	10c00015 	stw	r3,0(r2)
			  goto err;
 200c714:	0000ea06 	br	200cac0 <__sfvwrite_r+0x59c>
			}
		      memcpy (str, fp->_bf._base, curpos);
 200c718:	80800417 	ldw	r2,16(r16)
 200c71c:	e0fff617 	ldw	r3,-40(fp)
 200c720:	180d883a 	mov	r6,r3
 200c724:	100b883a 	mov	r5,r2
 200c728:	e13ff417 	ldw	r4,-48(fp)
 200c72c:	20067d00 	call	20067d0 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
 200c730:	80c0030b 	ldhu	r3,12(r16)
 200c734:	00bedfc4 	movi	r2,-1153
 200c738:	1884703a 	and	r2,r3,r2
 200c73c:	10802014 	ori	r2,r2,128
 200c740:	8080030d 	sth	r2,12(r16)
 200c744:	00001506 	br	200c79c <__sfvwrite_r+0x278>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
 200c748:	80800417 	ldw	r2,16(r16)
 200c74c:	e0fff517 	ldw	r3,-44(fp)
 200c750:	180d883a 	mov	r6,r3
 200c754:	100b883a 	mov	r5,r2
 200c758:	e13ff817 	ldw	r4,-32(fp)
 200c75c:	200fdf00 	call	200fdf0 <_realloc_r>
 200c760:	e0bff415 	stw	r2,-48(fp)
							 newsize);
		      if (!str)
 200c764:	e0bff417 	ldw	r2,-48(fp)
 200c768:	10000c1e 	bne	r2,zero,200c79c <__sfvwrite_r+0x278>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
 200c76c:	80800417 	ldw	r2,16(r16)
 200c770:	100b883a 	mov	r5,r2
 200c774:	e13ff817 	ldw	r4,-32(fp)
 200c778:	200bdf80 	call	200bdf8 <_free_r>
			  fp->_flags &=  ~__SMBF;
 200c77c:	80c0030b 	ldhu	r3,12(r16)
 200c780:	00bfdfc4 	movi	r2,-129
 200c784:	1884703a 	and	r2,r3,r2
 200c788:	8080030d 	sth	r2,12(r16)
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
 200c78c:	e0bff817 	ldw	r2,-32(fp)
 200c790:	00c00304 	movi	r3,12
 200c794:	10c00015 	stw	r3,0(r2)
			  goto err;
 200c798:	0000c906 	br	200cac0 <__sfvwrite_r+0x59c>
			}
		    }
		  fp->_bf._base = str;
 200c79c:	e0bff417 	ldw	r2,-48(fp)
 200c7a0:	80800415 	stw	r2,16(r16)
		  fp->_p = str + curpos;
 200c7a4:	e0bff617 	ldw	r2,-40(fp)
 200c7a8:	e0fff417 	ldw	r3,-48(fp)
 200c7ac:	1885883a 	add	r2,r3,r2
 200c7b0:	80800015 	stw	r2,0(r16)
		  fp->_bf._size = newsize;
 200c7b4:	e0bff517 	ldw	r2,-44(fp)
 200c7b8:	80800515 	stw	r2,20(r16)
		  w = len;
 200c7bc:	9023883a 	mov	r17,r18
		  fp->_w = newsize - curpos;
 200c7c0:	e0fff517 	ldw	r3,-44(fp)
 200c7c4:	e0bff617 	ldw	r2,-40(fp)
 200c7c8:	1885c83a 	sub	r2,r3,r2
 200c7cc:	80800215 	stw	r2,8(r16)
		}
	      if (len < w)
 200c7d0:	8805883a 	mov	r2,r17
 200c7d4:	9080012e 	bgeu	r18,r2,200c7dc <__sfvwrite_r+0x2b8>
		w = len;
 200c7d8:	9023883a 	mov	r17,r18
	      COPY (w);		/* copy MIN(fp->_w,len), */
 200c7dc:	80800017 	ldw	r2,0(r16)
 200c7e0:	8807883a 	mov	r3,r17
 200c7e4:	180d883a 	mov	r6,r3
 200c7e8:	980b883a 	mov	r5,r19
 200c7ec:	1009883a 	mov	r4,r2
 200c7f0:	200e1700 	call	200e170 <memmove>
	      fp->_w -= w;
 200c7f4:	80800217 	ldw	r2,8(r16)
 200c7f8:	1445c83a 	sub	r2,r2,r17
 200c7fc:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 200c800:	80800017 	ldw	r2,0(r16)
 200c804:	8807883a 	mov	r3,r17
 200c808:	10c5883a 	add	r2,r2,r3
 200c80c:	80800015 	stw	r2,0(r16)
	      w = len;		/* but pretend copied all */
 200c810:	9023883a 	mov	r17,r18
 200c814:	00003506 	br	200c8ec <__sfvwrite_r+0x3c8>
	    }
	  else if (fp->_p > fp->_bf._base || len < fp->_bf._size)
 200c818:	80800017 	ldw	r2,0(r16)
 200c81c:	80c00417 	ldw	r3,16(r16)
 200c820:	18800236 	bltu	r3,r2,200c82c <__sfvwrite_r+0x308>
 200c824:	80800517 	ldw	r2,20(r16)
 200c828:	9080182e 	bgeu	r18,r2,200c88c <__sfvwrite_r+0x368>
	    {
	      /* pass through the buffer */
	      w = MIN (len, w);
 200c82c:	8805883a 	mov	r2,r17
 200c830:	9080012e 	bgeu	r18,r2,200c838 <__sfvwrite_r+0x314>
 200c834:	9005883a 	mov	r2,r18
 200c838:	1023883a 	mov	r17,r2
	      COPY (w);
 200c83c:	80800017 	ldw	r2,0(r16)
 200c840:	8807883a 	mov	r3,r17
 200c844:	180d883a 	mov	r6,r3
 200c848:	980b883a 	mov	r5,r19
 200c84c:	1009883a 	mov	r4,r2
 200c850:	200e1700 	call	200e170 <memmove>
	      fp->_w -= w;
 200c854:	80800217 	ldw	r2,8(r16)
 200c858:	1445c83a 	sub	r2,r2,r17
 200c85c:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 200c860:	80800017 	ldw	r2,0(r16)
 200c864:	8807883a 	mov	r3,r17
 200c868:	10c5883a 	add	r2,r2,r3
 200c86c:	80800015 	stw	r2,0(r16)
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 200c870:	80800217 	ldw	r2,8(r16)
 200c874:	10001c1e 	bne	r2,zero,200c8e8 <__sfvwrite_r+0x3c4>
 200c878:	800b883a 	mov	r5,r16
 200c87c:	e13ff817 	ldw	r4,-32(fp)
 200c880:	200b7580 	call	200b758 <_fflush_r>
 200c884:	10001826 	beq	r2,zero,200c8e8 <__sfvwrite_r+0x3c4>
		goto err;
 200c888:	00008d06 	br	200cac0 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
 200c88c:	9005883a 	mov	r2,r18
 200c890:	00e00034 	movhi	r3,32768
 200c894:	10c00236 	bltu	r2,r3,200c8a0 <__sfvwrite_r+0x37c>
 200c898:	00a00034 	movhi	r2,32768
 200c89c:	10bfffc4 	addi	r2,r2,-1
 200c8a0:	1007883a 	mov	r3,r2
 200c8a4:	80800517 	ldw	r2,20(r16)
 200c8a8:	100b883a 	mov	r5,r2
 200c8ac:	1809883a 	mov	r4,r3
 200c8b0:	2003ee00 	call	2003ee0 <__divsi3>
 200c8b4:	1007883a 	mov	r3,r2
 200c8b8:	80800517 	ldw	r2,20(r16)
 200c8bc:	18a3383a 	mul	r17,r3,r2
	      w = fp->_write (ptr, fp->_cookie, p, w);
 200c8c0:	80800917 	ldw	r2,36(r16)
 200c8c4:	80c00717 	ldw	r3,28(r16)
 200c8c8:	880f883a 	mov	r7,r17
 200c8cc:	980d883a 	mov	r6,r19
 200c8d0:	180b883a 	mov	r5,r3
 200c8d4:	e13ff817 	ldw	r4,-32(fp)
 200c8d8:	103ee83a 	callr	r2
 200c8dc:	1023883a 	mov	r17,r2
	      if (w <= 0)
 200c8e0:	0440740e 	bge	zero,r17,200cab4 <__sfvwrite_r+0x590>
 200c8e4:	00000106 	br	200c8ec <__sfvwrite_r+0x3c8>
	      /* pass through the buffer */
	      w = MIN (len, w);
	      COPY (w);
	      fp->_w -= w;
	      fp->_p += w;
	      if (fp->_w == 0 && _fflush_r (ptr, fp))
 200c8e8:	0001883a 	nop
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
	    }
	  p += w;
 200c8ec:	8805883a 	mov	r2,r17
 200c8f0:	98a7883a 	add	r19,r19,r2
	  len -= w;
 200c8f4:	8805883a 	mov	r2,r17
 200c8f8:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 200c8fc:	a8800217 	ldw	r2,8(r21)
 200c900:	8807883a 	mov	r3,r17
 200c904:	10c5c83a 	sub	r2,r2,r3
 200c908:	a8800215 	stw	r2,8(r21)
 200c90c:	a8800217 	ldw	r2,8(r21)
 200c910:	103f501e 	bne	r2,zero,200c654 <__sfvwrite_r+0x130>
 200c914:	00006306 	br	200caa4 <__sfvwrite_r+0x580>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
 200c918:	e03ff215 	stw	zero,-56(fp)
      nldist = 0;
 200c91c:	e03ff315 	stw	zero,-52(fp)
      do
	{
	  GETIOV (nlknown = 0);
 200c920:	00000406 	br	200c934 <__sfvwrite_r+0x410>
 200c924:	e03ff215 	stw	zero,-56(fp)
 200c928:	a4c00017 	ldw	r19,0(r20)
 200c92c:	a4800117 	ldw	r18,4(r20)
 200c930:	a5000204 	addi	r20,r20,8
 200c934:	903ffb26 	beq	r18,zero,200c924 <__sfvwrite_r+0x400>
	  if (!nlknown)
 200c938:	e0bff217 	ldw	r2,-56(fp)
 200c93c:	1000111e 	bne	r2,zero,200c984 <__sfvwrite_r+0x460>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
 200c940:	900d883a 	mov	r6,r18
 200c944:	01400284 	movi	r5,10
 200c948:	9809883a 	mov	r4,r19
 200c94c:	200dfb40 	call	200dfb4 <memchr>
 200c950:	e0bff715 	stw	r2,-36(fp)
	      nldist = nl ? nl + 1 - p : len + 1;
 200c954:	e0bff717 	ldw	r2,-36(fp)
 200c958:	10000626 	beq	r2,zero,200c974 <__sfvwrite_r+0x450>
 200c95c:	e0bff717 	ldw	r2,-36(fp)
 200c960:	10800044 	addi	r2,r2,1
 200c964:	1007883a 	mov	r3,r2
 200c968:	9805883a 	mov	r2,r19
 200c96c:	1885c83a 	sub	r2,r3,r2
 200c970:	00000106 	br	200c978 <__sfvwrite_r+0x454>
 200c974:	90800044 	addi	r2,r18,1
 200c978:	e0bff315 	stw	r2,-52(fp)
	      nlknown = 1;
 200c97c:	00800044 	movi	r2,1
 200c980:	e0bff215 	stw	r2,-56(fp)
	    }
	  s = MIN (len, nldist);
 200c984:	e0bff317 	ldw	r2,-52(fp)
 200c988:	9080012e 	bgeu	r18,r2,200c990 <__sfvwrite_r+0x46c>
 200c98c:	9005883a 	mov	r2,r18
 200c990:	102d883a 	mov	r22,r2
	  w = fp->_w + fp->_bf._size;
 200c994:	80c00217 	ldw	r3,8(r16)
 200c998:	80800517 	ldw	r2,20(r16)
 200c99c:	18a3883a 	add	r17,r3,r2
	  if (fp->_p > fp->_bf._base && s > w)
 200c9a0:	80800017 	ldw	r2,0(r16)
 200c9a4:	80c00417 	ldw	r3,16(r16)
 200c9a8:	1880102e 	bgeu	r3,r2,200c9ec <__sfvwrite_r+0x4c8>
 200c9ac:	8d800f0e 	bge	r17,r22,200c9ec <__sfvwrite_r+0x4c8>
	    {
	      COPY (w);
 200c9b0:	80800017 	ldw	r2,0(r16)
 200c9b4:	8807883a 	mov	r3,r17
 200c9b8:	180d883a 	mov	r6,r3
 200c9bc:	980b883a 	mov	r5,r19
 200c9c0:	1009883a 	mov	r4,r2
 200c9c4:	200e1700 	call	200e170 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
 200c9c8:	80800017 	ldw	r2,0(r16)
 200c9cc:	8807883a 	mov	r3,r17
 200c9d0:	10c5883a 	add	r2,r2,r3
 200c9d4:	80800015 	stw	r2,0(r16)
	      if (_fflush_r (ptr, fp))
 200c9d8:	800b883a 	mov	r5,r16
 200c9dc:	e13ff817 	ldw	r4,-32(fp)
 200c9e0:	200b7580 	call	200b758 <_fflush_r>
 200c9e4:	10001b26 	beq	r2,zero,200ca54 <__sfvwrite_r+0x530>
		goto err;
 200c9e8:	00003506 	br	200cac0 <__sfvwrite_r+0x59c>
	    }
	  else if (s >= (w = fp->_bf._size))
 200c9ec:	84400517 	ldw	r17,20(r16)
 200c9f0:	b4400a16 	blt	r22,r17,200ca1c <__sfvwrite_r+0x4f8>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
 200c9f4:	80800917 	ldw	r2,36(r16)
 200c9f8:	80c00717 	ldw	r3,28(r16)
 200c9fc:	880f883a 	mov	r7,r17
 200ca00:	980d883a 	mov	r6,r19
 200ca04:	180b883a 	mov	r5,r3
 200ca08:	e13ff817 	ldw	r4,-32(fp)
 200ca0c:	103ee83a 	callr	r2
 200ca10:	1023883a 	mov	r17,r2
	      if (w <= 0)
 200ca14:	04400f16 	blt	zero,r17,200ca54 <__sfvwrite_r+0x530>
		goto err;
 200ca18:	00002906 	br	200cac0 <__sfvwrite_r+0x59c>
	    }
	  else
	    {
	      w = s;
 200ca1c:	b023883a 	mov	r17,r22
	      COPY (w);
 200ca20:	80800017 	ldw	r2,0(r16)
 200ca24:	8807883a 	mov	r3,r17
 200ca28:	180d883a 	mov	r6,r3
 200ca2c:	980b883a 	mov	r5,r19
 200ca30:	1009883a 	mov	r4,r2
 200ca34:	200e1700 	call	200e170 <memmove>
	      fp->_w -= w;
 200ca38:	80800217 	ldw	r2,8(r16)
 200ca3c:	1445c83a 	sub	r2,r2,r17
 200ca40:	80800215 	stw	r2,8(r16)
	      fp->_p += w;
 200ca44:	80800017 	ldw	r2,0(r16)
 200ca48:	8807883a 	mov	r3,r17
 200ca4c:	10c5883a 	add	r2,r2,r3
 200ca50:	80800015 	stw	r2,0(r16)
	    }
	  if ((nldist -= w) == 0)
 200ca54:	e0bff317 	ldw	r2,-52(fp)
 200ca58:	1445c83a 	sub	r2,r2,r17
 200ca5c:	e0bff315 	stw	r2,-52(fp)
 200ca60:	e0bff317 	ldw	r2,-52(fp)
 200ca64:	1000051e 	bne	r2,zero,200ca7c <__sfvwrite_r+0x558>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
 200ca68:	800b883a 	mov	r5,r16
 200ca6c:	e13ff817 	ldw	r4,-32(fp)
 200ca70:	200b7580 	call	200b758 <_fflush_r>
 200ca74:	1000111e 	bne	r2,zero,200cabc <__sfvwrite_r+0x598>
		goto err;
	      nlknown = 0;
 200ca78:	e03ff215 	stw	zero,-56(fp)
	    }
	  p += w;
 200ca7c:	8805883a 	mov	r2,r17
 200ca80:	98a7883a 	add	r19,r19,r2
	  len -= w;
 200ca84:	8805883a 	mov	r2,r17
 200ca88:	90a5c83a 	sub	r18,r18,r2
	}
      while ((uio->uio_resid -= w) != 0);
 200ca8c:	a8800217 	ldw	r2,8(r21)
 200ca90:	8807883a 	mov	r3,r17
 200ca94:	10c5c83a 	sub	r2,r2,r3
 200ca98:	a8800215 	stw	r2,8(r21)
 200ca9c:	a8800217 	ldw	r2,8(r21)
 200caa0:	103fa41e 	bne	r2,zero,200c934 <__sfvwrite_r+0x410>
    }
  return 0;
 200caa4:	0005883a 	mov	r2,zero
 200caa8:	00000906 	br	200cad0 <__sfvwrite_r+0x5ac>
	{
	  GETIOV (;);
	  w = fp->_write (ptr, fp->_cookie, p,
			  MIN (len, INT_MAX - INT_MAX % BUFSIZ));
	  if (w <= 0)
	    goto err;
 200caac:	0001883a 	nop
 200cab0:	00000306 	br	200cac0 <__sfvwrite_r+0x59c>
	    {
	      /* write directly */
	      w = ((int)MIN (len, INT_MAX)) / fp->_bf._size * fp->_bf._size;
	      w = fp->_write (ptr, fp->_cookie, p, w);
	      if (w <= 0)
		goto err;
 200cab4:	0001883a 	nop
 200cab8:	00000106 	br	200cac0 <__sfvwrite_r+0x59c>
	    }
	  if ((nldist -= w) == 0)
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
		goto err;
 200cabc:	0001883a 	nop
      while ((uio->uio_resid -= w) != 0);
    }
  return 0;

err:
  fp->_flags |= __SERR;
 200cac0:	8080030b 	ldhu	r2,12(r16)
 200cac4:	10801014 	ori	r2,r2,64
 200cac8:	8080030d 	sth	r2,12(r16)
  return EOF;
 200cacc:	00bfffc4 	movi	r2,-1
}
 200cad0:	e6fff904 	addi	sp,fp,-28
 200cad4:	dfc00817 	ldw	ra,32(sp)
 200cad8:	df000717 	ldw	fp,28(sp)
 200cadc:	dd800617 	ldw	r22,24(sp)
 200cae0:	dd400517 	ldw	r21,20(sp)
 200cae4:	dd000417 	ldw	r20,16(sp)
 200cae8:	dcc00317 	ldw	r19,12(sp)
 200caec:	dc800217 	ldw	r18,8(sp)
 200caf0:	dc400117 	ldw	r17,4(sp)
 200caf4:	dc000017 	ldw	r16,0(sp)
 200caf8:	dec00904 	addi	sp,sp,36
 200cafc:	f800283a 	ret

0200cb00 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
 200cb00:	defff804 	addi	sp,sp,-32
 200cb04:	dfc00715 	stw	ra,28(sp)
 200cb08:	df000615 	stw	fp,24(sp)
 200cb0c:	dd000515 	stw	r20,20(sp)
 200cb10:	dcc00415 	stw	r19,16(sp)
 200cb14:	dc800315 	stw	r18,12(sp)
 200cb18:	dc400215 	stw	r17,8(sp)
 200cb1c:	dc000115 	stw	r16,4(sp)
 200cb20:	df000604 	addi	fp,sp,24
 200cb24:	e13ffa15 	stw	r4,-24(fp)
 200cb28:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 200cb2c:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 200cb30:	e0bffa17 	ldw	r2,-24(fp)
 200cb34:	1440b804 	addi	r17,r2,736
 200cb38:	00001b06 	br	200cba8 <_fwalk+0xa8>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200cb3c:	8c000217 	ldw	r16,8(r17)
 200cb40:	8c800117 	ldw	r18,4(r17)
 200cb44:	00001506 	br	200cb9c <_fwalk+0x9c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 200cb48:	8080030b 	ldhu	r2,12(r16)
 200cb4c:	10bfffcc 	andi	r2,r2,65535
 200cb50:	10a0001c 	xori	r2,r2,32768
 200cb54:	10a00004 	addi	r2,r2,-32768
 200cb58:	10000f26 	beq	r2,zero,200cb98 <_fwalk+0x98>
 200cb5c:	8080030b 	ldhu	r2,12(r16)
 200cb60:	10bfffcc 	andi	r2,r2,65535
 200cb64:	10a0001c 	xori	r2,r2,32768
 200cb68:	10a00004 	addi	r2,r2,-32768
 200cb6c:	10800060 	cmpeqi	r2,r2,1
 200cb70:	1000091e 	bne	r2,zero,200cb98 <_fwalk+0x98>
 200cb74:	8080038b 	ldhu	r2,14(r16)
 200cb78:	10bfffcc 	andi	r2,r2,65535
 200cb7c:	10a0001c 	xori	r2,r2,32768
 200cb80:	10a00004 	addi	r2,r2,-32768
 200cb84:	10bfffe0 	cmpeqi	r2,r2,-1
 200cb88:	1000031e 	bne	r2,zero,200cb98 <_fwalk+0x98>
	ret |= (*function) (fp);
 200cb8c:	8009883a 	mov	r4,r16
 200cb90:	a03ee83a 	callr	r20
 200cb94:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200cb98:	84001a04 	addi	r16,r16,104
 200cb9c:	94bfffc4 	addi	r18,r18,-1
 200cba0:	903fe90e 	bge	r18,zero,200cb48 <_fwalk+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 200cba4:	8c400017 	ldw	r17,0(r17)
 200cba8:	883fe41e 	bne	r17,zero,200cb3c <_fwalk+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
 200cbac:	9805883a 	mov	r2,r19
}
 200cbb0:	e6fffb04 	addi	sp,fp,-20
 200cbb4:	dfc00617 	ldw	ra,24(sp)
 200cbb8:	df000517 	ldw	fp,20(sp)
 200cbbc:	dd000417 	ldw	r20,16(sp)
 200cbc0:	dcc00317 	ldw	r19,12(sp)
 200cbc4:	dc800217 	ldw	r18,8(sp)
 200cbc8:	dc400117 	ldw	r17,4(sp)
 200cbcc:	dc000017 	ldw	r16,0(sp)
 200cbd0:	dec00704 	addi	sp,sp,28
 200cbd4:	f800283a 	ret

0200cbd8 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
 200cbd8:	defff804 	addi	sp,sp,-32
 200cbdc:	dfc00715 	stw	ra,28(sp)
 200cbe0:	df000615 	stw	fp,24(sp)
 200cbe4:	dd000515 	stw	r20,20(sp)
 200cbe8:	dcc00415 	stw	r19,16(sp)
 200cbec:	dc800315 	stw	r18,12(sp)
 200cbf0:	dc400215 	stw	r17,8(sp)
 200cbf4:	dc000115 	stw	r16,4(sp)
 200cbf8:	df000604 	addi	fp,sp,24
 200cbfc:	e13ffa15 	stw	r4,-24(fp)
 200cc00:	2829883a 	mov	r20,r5
  register FILE *fp;
  register int n, ret = 0;
 200cc04:	0027883a 	mov	r19,zero
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 200cc08:	e0bffa17 	ldw	r2,-24(fp)
 200cc0c:	1440b804 	addi	r17,r2,736
 200cc10:	00001c06 	br	200cc84 <_fwalk_reent+0xac>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200cc14:	8c000217 	ldw	r16,8(r17)
 200cc18:	8c800117 	ldw	r18,4(r17)
 200cc1c:	00001606 	br	200cc78 <_fwalk_reent+0xa0>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
 200cc20:	8080030b 	ldhu	r2,12(r16)
 200cc24:	10bfffcc 	andi	r2,r2,65535
 200cc28:	10a0001c 	xori	r2,r2,32768
 200cc2c:	10a00004 	addi	r2,r2,-32768
 200cc30:	10001026 	beq	r2,zero,200cc74 <_fwalk_reent+0x9c>
 200cc34:	8080030b 	ldhu	r2,12(r16)
 200cc38:	10bfffcc 	andi	r2,r2,65535
 200cc3c:	10a0001c 	xori	r2,r2,32768
 200cc40:	10a00004 	addi	r2,r2,-32768
 200cc44:	10800060 	cmpeqi	r2,r2,1
 200cc48:	10000a1e 	bne	r2,zero,200cc74 <_fwalk_reent+0x9c>
 200cc4c:	8080038b 	ldhu	r2,14(r16)
 200cc50:	10bfffcc 	andi	r2,r2,65535
 200cc54:	10a0001c 	xori	r2,r2,32768
 200cc58:	10a00004 	addi	r2,r2,-32768
 200cc5c:	10bfffe0 	cmpeqi	r2,r2,-1
 200cc60:	1000041e 	bne	r2,zero,200cc74 <_fwalk_reent+0x9c>
	ret |= (*reent_function) (ptr, fp);
 200cc64:	800b883a 	mov	r5,r16
 200cc68:	e13ffa17 	ldw	r4,-24(fp)
 200cc6c:	a03ee83a 	callr	r20
 200cc70:	98a6b03a 	or	r19,r19,r2
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
 200cc74:	84001a04 	addi	r16,r16,104
 200cc78:	94bfffc4 	addi	r18,r18,-1
 200cc7c:	903fe80e 	bge	r18,zero,200cc20 <_fwalk_reent+0x48>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
 200cc80:	8c400017 	ldw	r17,0(r17)
 200cc84:	883fe31e 	bne	r17,zero,200cc14 <_fwalk_reent+0x3c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
 200cc88:	9805883a 	mov	r2,r19
}
 200cc8c:	e6fffb04 	addi	sp,fp,-20
 200cc90:	dfc00617 	ldw	ra,24(sp)
 200cc94:	df000517 	ldw	fp,20(sp)
 200cc98:	dd000417 	ldw	r20,16(sp)
 200cc9c:	dcc00317 	ldw	r19,12(sp)
 200cca0:	dc800217 	ldw	r18,8(sp)
 200cca4:	dc400117 	ldw	r17,4(sp)
 200cca8:	dc000017 	ldw	r16,0(sp)
 200ccac:	dec00704 	addi	sp,sp,28
 200ccb0:	f800283a 	ret

0200ccb4 <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
 200ccb4:	defffb04 	addi	sp,sp,-20
 200ccb8:	dfc00415 	stw	ra,16(sp)
 200ccbc:	df000315 	stw	fp,12(sp)
 200ccc0:	df000304 	addi	fp,sp,12
 200ccc4:	e13ffd15 	stw	r4,-12(fp)
 200ccc8:	e17ffe15 	stw	r5,-8(fp)
 200cccc:	e1bfff15 	stw	r6,-4(fp)
#ifndef _MB_CAPABLE
  if (locale)
 200ccd0:	e0bfff17 	ldw	r2,-4(fp)
 200ccd4:	10001126 	beq	r2,zero,200cd1c <_setlocale_r+0x68>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
 200ccd8:	014080b4 	movhi	r5,514
 200ccdc:	297e1004 	addi	r5,r5,-1984
 200cce0:	e13fff17 	ldw	r4,-4(fp)
 200cce4:	2010cb40 	call	2010cb4 <strcmp>
 200cce8:	10000c26 	beq	r2,zero,200cd1c <_setlocale_r+0x68>
 200ccec:	014080b4 	movhi	r5,514
 200ccf0:	297e1204 	addi	r5,r5,-1976
 200ccf4:	e13fff17 	ldw	r4,-4(fp)
 200ccf8:	2010cb40 	call	2010cb4 <strcmp>
 200ccfc:	10000726 	beq	r2,zero,200cd1c <_setlocale_r+0x68>
	  && strcmp (locale, ""))
 200cd00:	014080b4 	movhi	r5,514
 200cd04:	297e0f04 	addi	r5,r5,-1988
 200cd08:	e13fff17 	ldw	r4,-4(fp)
 200cd0c:	2010cb40 	call	2010cb4 <strcmp>
 200cd10:	10000226 	beq	r2,zero,200cd1c <_setlocale_r+0x68>
        return NULL;
 200cd14:	0005883a 	mov	r2,zero
 200cd18:	00000206 	br	200cd24 <_setlocale_r+0x70>
    }
  return "C";
 200cd1c:	008080b4 	movhi	r2,514
 200cd20:	10be1204 	addi	r2,r2,-1976
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
 200cd24:	e037883a 	mov	sp,fp
 200cd28:	dfc00117 	ldw	ra,4(sp)
 200cd2c:	df000017 	ldw	fp,0(sp)
 200cd30:	dec00204 	addi	sp,sp,8
 200cd34:	f800283a 	ret

0200cd38 <__locale_charset>:
}
#endif /* _MB_CAPABLE */

char *
_DEFUN_VOID(__locale_charset)
{
 200cd38:	deffff04 	addi	sp,sp,-4
 200cd3c:	df000015 	stw	fp,0(sp)
 200cd40:	d839883a 	mov	fp,sp
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
 200cd44:	008080b4 	movhi	r2,514
 200cd48:	10bff504 	addi	r2,r2,-44
#endif
}
 200cd4c:	e037883a 	mov	sp,fp
 200cd50:	df000017 	ldw	fp,0(sp)
 200cd54:	dec00104 	addi	sp,sp,4
 200cd58:	f800283a 	ret

0200cd5c <__locale_mb_cur_max>:

int
_DEFUN_VOID(__locale_mb_cur_max)
{
 200cd5c:	deffff04 	addi	sp,sp,-4
 200cd60:	df000015 	stw	fp,0(sp)
 200cd64:	d839883a 	mov	fp,sp
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
 200cd68:	d0a00817 	ldw	r2,-32736(gp)
#endif
}
 200cd6c:	e037883a 	mov	sp,fp
 200cd70:	df000017 	ldw	fp,0(sp)
 200cd74:	dec00104 	addi	sp,sp,4
 200cd78:	f800283a 	ret

0200cd7c <__locale_msgcharset>:


char *
_DEFUN_VOID(__locale_msgcharset)
{
 200cd7c:	deffff04 	addi	sp,sp,-4
 200cd80:	df000015 	stw	fp,0(sp)
 200cd84:	d839883a 	mov	fp,sp
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
 200cd88:	008080b4 	movhi	r2,514
 200cd8c:	10bffd04 	addi	r2,r2,-12
#endif
}
 200cd90:	e037883a 	mov	sp,fp
 200cd94:	df000017 	ldw	fp,0(sp)
 200cd98:	dec00104 	addi	sp,sp,4
 200cd9c:	f800283a 	ret

0200cda0 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
 200cda0:	deffff04 	addi	sp,sp,-4
 200cda4:	df000015 	stw	fp,0(sp)
 200cda8:	d839883a 	mov	fp,sp
  return lc_ctype_cjk_lang;
 200cdac:	d0a74217 	ldw	r2,-25336(gp)
}
 200cdb0:	e037883a 	mov	sp,fp
 200cdb4:	df000017 	ldw	fp,0(sp)
 200cdb8:	dec00104 	addi	sp,sp,4
 200cdbc:	f800283a 	ret

0200cdc0 <_localeconv_r>:

struct lconv *
_DEFUN(_localeconv_r, (data), 
      struct _reent *data)
{
 200cdc0:	defffe04 	addi	sp,sp,-8
 200cdc4:	df000115 	stw	fp,4(sp)
 200cdc8:	df000104 	addi	fp,sp,4
 200cdcc:	e13fff15 	stw	r4,-4(fp)
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
 200cdd0:	008080b4 	movhi	r2,514
 200cdd4:	10bfe704 	addi	r2,r2,-100
}
 200cdd8:	e037883a 	mov	sp,fp
 200cddc:	df000017 	ldw	fp,0(sp)
 200cde0:	dec00104 	addi	sp,sp,4
 200cde4:	f800283a 	ret

0200cde8 <setlocale>:
   initialization work.  It calls _setlocale_r, though. */
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
 200cde8:	defffc04 	addi	sp,sp,-16
 200cdec:	dfc00315 	stw	ra,12(sp)
 200cdf0:	df000215 	stw	fp,8(sp)
 200cdf4:	df000204 	addi	fp,sp,8
 200cdf8:	e13ffe15 	stw	r4,-8(fp)
 200cdfc:	e17fff15 	stw	r5,-4(fp)
  return _setlocale_r (_REENT, category, locale);
 200ce00:	d0a00617 	ldw	r2,-32744(gp)
 200ce04:	e1bfff17 	ldw	r6,-4(fp)
 200ce08:	e17ffe17 	ldw	r5,-8(fp)
 200ce0c:	1009883a 	mov	r4,r2
 200ce10:	200ccb40 	call	200ccb4 <_setlocale_r>
}
 200ce14:	e037883a 	mov	sp,fp
 200ce18:	dfc00117 	ldw	ra,4(sp)
 200ce1c:	df000017 	ldw	fp,0(sp)
 200ce20:	dec00204 	addi	sp,sp,8
 200ce24:	f800283a 	ret

0200ce28 <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
 200ce28:	defffe04 	addi	sp,sp,-8
 200ce2c:	dfc00115 	stw	ra,4(sp)
 200ce30:	df000015 	stw	fp,0(sp)
 200ce34:	d839883a 	mov	fp,sp
  return _localeconv_r (_REENT);
 200ce38:	d0a00617 	ldw	r2,-32744(gp)
 200ce3c:	1009883a 	mov	r4,r2
 200ce40:	200cdc00 	call	200cdc0 <_localeconv_r>
}
 200ce44:	e037883a 	mov	sp,fp
 200ce48:	dfc00117 	ldw	ra,4(sp)
 200ce4c:	df000017 	ldw	fp,0(sp)
 200ce50:	dec00204 	addi	sp,sp,8
 200ce54:	f800283a 	ret

0200ce58 <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
 200ce58:	deffea04 	addi	sp,sp,-88
 200ce5c:	dfc01515 	stw	ra,84(sp)
 200ce60:	df001415 	stw	fp,80(sp)
 200ce64:	dcc01315 	stw	r19,76(sp)
 200ce68:	dc801215 	stw	r18,72(sp)
 200ce6c:	dc401115 	stw	r17,68(sp)
 200ce70:	dc001015 	stw	r16,64(sp)
 200ce74:	df001404 	addi	fp,sp,80
 200ce78:	e13ffb15 	stw	r4,-20(fp)
 200ce7c:	2821883a 	mov	r16,r5
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
 200ce80:	8080030b 	ldhu	r2,12(r16)
 200ce84:	10bfffcc 	andi	r2,r2,65535
 200ce88:	1080008c 	andi	r2,r2,2
 200ce8c:	10000726 	beq	r2,zero,200ceac <__smakebuf_r+0x54>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
 200ce90:	808010c4 	addi	r2,r16,67
 200ce94:	80800015 	stw	r2,0(r16)
 200ce98:	80800017 	ldw	r2,0(r16)
 200ce9c:	80800415 	stw	r2,16(r16)
      fp->_bf._size = 1;
 200cea0:	00800044 	movi	r2,1
 200cea4:	80800515 	stw	r2,20(r16)
 200cea8:	00006d06 	br	200d060 <__smakebuf_r+0x208>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
 200ceac:	8080038b 	ldhu	r2,14(r16)
 200ceb0:	10bfffcc 	andi	r2,r2,65535
 200ceb4:	10a0001c 	xori	r2,r2,32768
 200ceb8:	10a00004 	addi	r2,r2,-32768
 200cebc:	10000916 	blt	r2,zero,200cee4 <__smakebuf_r+0x8c>
 200cec0:	8080038b 	ldhu	r2,14(r16)
 200cec4:	10bfffcc 	andi	r2,r2,65535
 200cec8:	10a0001c 	xori	r2,r2,32768
 200cecc:	10a00004 	addi	r2,r2,-32768
 200ced0:	e1bfec04 	addi	r6,fp,-80
 200ced4:	100b883a 	mov	r5,r2
 200ced8:	e13ffb17 	ldw	r4,-20(fp)
 200cedc:	20129b00 	call	20129b0 <_fstat_r>
 200cee0:	10000c0e 	bge	r2,zero,200cf14 <__smakebuf_r+0xbc>
#endif
    {
      couldbetty = 0;
 200cee4:	0025883a 	mov	r18,zero
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
 200cee8:	8080030b 	ldhu	r2,12(r16)
 200ceec:	10bfffcc 	andi	r2,r2,65535
 200cef0:	1080200c 	andi	r2,r2,128
 200cef4:	10000226 	beq	r2,zero,200cf00 <__smakebuf_r+0xa8>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
 200cef8:	04401004 	movi	r17,64
 200cefc:	00000106 	br	200cf04 <__smakebuf_r+0xac>
      else
        size = BUFSIZ;
 200cf00:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
 200cf04:	8080030b 	ldhu	r2,12(r16)
 200cf08:	10820014 	ori	r2,r2,2048
 200cf0c:	8080030d 	sth	r2,12(r16)
 200cf10:	00001606 	br	200cf6c <__smakebuf_r+0x114>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
 200cf14:	e0bfed17 	ldw	r2,-76(fp)
 200cf18:	10bc000c 	andi	r2,r2,61440
 200cf1c:	10880020 	cmpeqi	r2,r2,8192
 200cf20:	14803fcc 	andi	r18,r2,255
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
 200cf24:	04410004 	movi	r17,1024
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
 200cf28:	e0bfed17 	ldw	r2,-76(fp)
 200cf2c:	10fc000c 	andi	r3,r2,61440
 200cf30:	00a00014 	movui	r2,32768
 200cf34:	18800a1e 	bne	r3,r2,200cf60 <__smakebuf_r+0x108>
 200cf38:	80c00a17 	ldw	r3,40(r16)
 200cf3c:	00808074 	movhi	r2,513
 200cf40:	1082f004 	addi	r2,r2,3008
 200cf44:	1880061e 	bne	r3,r2,200cf60 <__smakebuf_r+0x108>
	{
	  fp->_flags |= __SOPT;
 200cf48:	8080030b 	ldhu	r2,12(r16)
 200cf4c:	10810014 	ori	r2,r2,1024
 200cf50:	8080030d 	sth	r2,12(r16)
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
 200cf54:	00810004 	movi	r2,1024
 200cf58:	80801315 	stw	r2,76(r16)
 200cf5c:	00000306 	br	200cf6c <__smakebuf_r+0x114>
#endif
	}
      else
	fp->_flags |= __SNPT;
 200cf60:	8080030b 	ldhu	r2,12(r16)
 200cf64:	10820014 	ori	r2,r2,2048
 200cf68:	8080030d 	sth	r2,12(r16)
#endif
    }

  /* Make unbuffered by default: */			/* AlteraSpecific */
  if (couldbetty && _isatty_r (ptr, fp->_file))		/* AlteraSpecific */
 200cf6c:	90001126 	beq	r18,zero,200cfb4 <__smakebuf_r+0x15c>
 200cf70:	8080038b 	ldhu	r2,14(r16)
 200cf74:	10bfffcc 	andi	r2,r2,65535
 200cf78:	10a0001c 	xori	r2,r2,32768
 200cf7c:	10a00004 	addi	r2,r2,-32768
 200cf80:	100b883a 	mov	r5,r2
 200cf84:	e13ffb17 	ldw	r4,-20(fp)
 200cf88:	2012a180 	call	2012a18 <_isatty_r>
 200cf8c:	10000926 	beq	r2,zero,200cfb4 <__smakebuf_r+0x15c>
  {							/* AlteraSpecific */
    fp->_flags |= __SLBF;				/* AlteraSpecific __SLBF == "line buffered */
 200cf90:	8080030b 	ldhu	r2,12(r16)
 200cf94:	10800054 	ori	r2,r2,1
 200cf98:	8080030d 	sth	r2,12(r16)
    fp->_bf._base = fp->_p = fp->_nbuf;			/* AlteraSpecific (see newlib/libc/include/stdio.h) */
 200cf9c:	808010c4 	addi	r2,r16,67
 200cfa0:	80800015 	stw	r2,0(r16)
 200cfa4:	80800017 	ldw	r2,0(r16)
 200cfa8:	80800415 	stw	r2,16(r16)
    fp->_bf._size = 1;					/* AlteraSpecific */
 200cfac:	00800044 	movi	r2,1
 200cfb0:	80800515 	stw	r2,20(r16)
  }							/* AlteraSpecific */

  if ((p = _malloc_r (ptr, size)) == NULL)
 200cfb4:	880b883a 	mov	r5,r17
 200cfb8:	e13ffb17 	ldw	r4,-20(fp)
 200cfbc:	200d4380 	call	200d438 <_malloc_r>
 200cfc0:	1027883a 	mov	r19,r2
 200cfc4:	98000e1e 	bne	r19,zero,200d000 <__smakebuf_r+0x1a8>
    {
      if (!(fp->_flags & __SSTR))
 200cfc8:	8080030b 	ldhu	r2,12(r16)
 200cfcc:	10bfffcc 	andi	r2,r2,65535
 200cfd0:	1080800c 	andi	r2,r2,512
 200cfd4:	1000221e 	bne	r2,zero,200d060 <__smakebuf_r+0x208>
	{
	  fp->_flags |= __SNBF;
 200cfd8:	8080030b 	ldhu	r2,12(r16)
 200cfdc:	10800094 	ori	r2,r2,2
 200cfe0:	8080030d 	sth	r2,12(r16)
	  fp->_bf._base = fp->_p = fp->_nbuf;
 200cfe4:	808010c4 	addi	r2,r16,67
 200cfe8:	80800015 	stw	r2,0(r16)
 200cfec:	80800017 	ldw	r2,0(r16)
 200cff0:	80800415 	stw	r2,16(r16)
	  fp->_bf._size = 1;
 200cff4:	00800044 	movi	r2,1
 200cff8:	80800515 	stw	r2,20(r16)
 200cffc:	00001806 	br	200d060 <__smakebuf_r+0x208>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
 200d000:	e0fffb17 	ldw	r3,-20(fp)
 200d004:	00808074 	movhi	r2,513
 200d008:	10aed804 	addi	r2,r2,-17568
 200d00c:	18800f15 	stw	r2,60(r3)
      fp->_flags |= __SMBF;
 200d010:	8080030b 	ldhu	r2,12(r16)
 200d014:	10802014 	ori	r2,r2,128
 200d018:	8080030d 	sth	r2,12(r16)
      fp->_bf._base = fp->_p = (unsigned char *) p;
 200d01c:	84c00015 	stw	r19,0(r16)
 200d020:	80800017 	ldw	r2,0(r16)
 200d024:	80800415 	stw	r2,16(r16)
      fp->_bf._size = size;
 200d028:	8805883a 	mov	r2,r17
 200d02c:	80800515 	stw	r2,20(r16)
      if (couldbetty && _isatty_r (ptr, fp->_file))
 200d030:	90000b26 	beq	r18,zero,200d060 <__smakebuf_r+0x208>
 200d034:	8080038b 	ldhu	r2,14(r16)
 200d038:	10bfffcc 	andi	r2,r2,65535
 200d03c:	10a0001c 	xori	r2,r2,32768
 200d040:	10a00004 	addi	r2,r2,-32768
 200d044:	100b883a 	mov	r5,r2
 200d048:	e13ffb17 	ldw	r4,-20(fp)
 200d04c:	2012a180 	call	2012a18 <_isatty_r>
 200d050:	10000326 	beq	r2,zero,200d060 <__smakebuf_r+0x208>
	fp->_flags |= __SLBF;
 200d054:	8080030b 	ldhu	r2,12(r16)
 200d058:	10800054 	ori	r2,r2,1
 200d05c:	8080030d 	sth	r2,12(r16)
    }
}
 200d060:	e6fffc04 	addi	sp,fp,-16
 200d064:	dfc00517 	ldw	ra,20(sp)
 200d068:	df000417 	ldw	fp,16(sp)
 200d06c:	dcc00317 	ldw	r19,12(sp)
 200d070:	dc800217 	ldw	r18,8(sp)
 200d074:	dc400117 	ldw	r17,4(sp)
 200d078:	dc000017 	ldw	r16,0(sp)
 200d07c:	dec00604 	addi	sp,sp,24
 200d080:	f800283a 	ret

0200d084 <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
 200d084:	defff104 	addi	sp,sp,-60
 200d088:	dfc00e15 	stw	ra,56(sp)
 200d08c:	df000d15 	stw	fp,52(sp)
 200d090:	df000d04 	addi	fp,sp,52
 200d094:	e13ffe15 	stw	r4,-8(fp)
 200d098:	e17fff15 	stw	r5,-4(fp)
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
 200d09c:	e03ff715 	stw	zero,-36(fp)
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
 200d0a0:	008080b4 	movhi	r2,514
 200d0a4:	10800504 	addi	r2,r2,20
 200d0a8:	10800217 	ldw	r2,8(r2)
 200d0ac:	e0bff815 	stw	r2,-32(fp)
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
 200d0b0:	e0bff817 	ldw	r2,-32(fp)
 200d0b4:	10c00117 	ldw	r3,4(r2)
 200d0b8:	00bfff04 	movi	r2,-4
 200d0bc:	1884703a 	and	r2,r3,r2
 200d0c0:	e0bff915 	stw	r2,-28(fp)
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
 200d0c4:	e0fff817 	ldw	r3,-32(fp)
 200d0c8:	e0bff917 	ldw	r2,-28(fp)
 200d0cc:	1885883a 	add	r2,r3,r2
 200d0d0:	e0bffa15 	stw	r2,-24(fp)

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
 200d0d4:	d0e74317 	ldw	r3,-25332(gp)
 200d0d8:	e0bfff17 	ldw	r2,-4(fp)
 200d0dc:	1885883a 	add	r2,r3,r2
 200d0e0:	10800404 	addi	r2,r2,16
 200d0e4:	e0bff615 	stw	r2,-40(fp)
  unsigned long pagesz    = malloc_getpagesize;
 200d0e8:	00840004 	movi	r2,4096
 200d0ec:	e0bffb15 	stw	r2,-20(fp)

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
 200d0f0:	d0a00a17 	ldw	r2,-32728(gp)
 200d0f4:	10bfffe0 	cmpeqi	r2,r2,-1
 200d0f8:	1000081e 	bne	r2,zero,200d11c <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
 200d0fc:	e0fffb17 	ldw	r3,-20(fp)
 200d100:	e0bff617 	ldw	r2,-40(fp)
 200d104:	1885883a 	add	r2,r3,r2
 200d108:	10ffffc4 	addi	r3,r2,-1
 200d10c:	e0bffb17 	ldw	r2,-20(fp)
 200d110:	0085c83a 	sub	r2,zero,r2
 200d114:	1884703a 	and	r2,r3,r2
 200d118:	e0bff615 	stw	r2,-40(fp)

  brk = (char*)(MORECORE (sbrk_size));
 200d11c:	e0bff617 	ldw	r2,-40(fp)
 200d120:	100b883a 	mov	r5,r2
 200d124:	e13ffe17 	ldw	r4,-8(fp)
 200d128:	20109e00 	call	20109e0 <_sbrk_r>
 200d12c:	e0bff315 	stw	r2,-52(fp)

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
 200d130:	e0bff317 	ldw	r2,-52(fp)
 200d134:	10bfffe0 	cmpeqi	r2,r2,-1
 200d138:	1000b91e 	bne	r2,zero,200d420 <malloc_extend_top+0x39c>
 200d13c:	e0fff317 	ldw	r3,-52(fp)
 200d140:	e0bffa17 	ldw	r2,-24(fp)
 200d144:	1880042e 	bgeu	r3,r2,200d158 <malloc_extend_top+0xd4>
      (brk < old_end && old_top != initial_top))
 200d148:	008080b4 	movhi	r2,514
 200d14c:	10800504 	addi	r2,r2,20
 200d150:	e0fff817 	ldw	r3,-32(fp)
 200d154:	1880b21e 	bne	r3,r2,200d420 <malloc_extend_top+0x39c>
    return;

  sbrked_mem += sbrk_size;
 200d158:	008080b4 	movhi	r2,514
 200d15c:	108cff04 	addi	r2,r2,13308
 200d160:	10800017 	ldw	r2,0(r2)
 200d164:	1007883a 	mov	r3,r2
 200d168:	e0bff617 	ldw	r2,-40(fp)
 200d16c:	1885883a 	add	r2,r3,r2
 200d170:	1007883a 	mov	r3,r2
 200d174:	008080b4 	movhi	r2,514
 200d178:	108cff04 	addi	r2,r2,13308
 200d17c:	10c00015 	stw	r3,0(r2)

  if (brk == old_end /* can just add bytes to current top, unless
 200d180:	e0fff317 	ldw	r3,-52(fp)
 200d184:	e0bffa17 	ldw	r2,-24(fp)
 200d188:	1880101e 	bne	r3,r2,200d1cc <malloc_extend_top+0x148>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
 200d18c:	e0bffb17 	ldw	r2,-20(fp)
 200d190:	10ffffc4 	addi	r3,r2,-1
 200d194:	e0bffa17 	ldw	r2,-24(fp)
 200d198:	1884703a 	and	r2,r3,r2
 200d19c:	10000b1e 	bne	r2,zero,200d1cc <malloc_extend_top+0x148>
  {
    top_size = sbrk_size + old_top_size;
 200d1a0:	e0fff617 	ldw	r3,-40(fp)
 200d1a4:	e0bff917 	ldw	r2,-28(fp)
 200d1a8:	1885883a 	add	r2,r3,r2
 200d1ac:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 200d1b0:	008080b4 	movhi	r2,514
 200d1b4:	10800504 	addi	r2,r2,20
 200d1b8:	10800217 	ldw	r2,8(r2)
 200d1bc:	e0fffc17 	ldw	r3,-16(fp)
 200d1c0:	18c00054 	ori	r3,r3,1
 200d1c4:	10c00115 	stw	r3,4(r2)
 200d1c8:	00008006 	br	200d3cc <malloc_extend_top+0x348>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
 200d1cc:	d0a00a17 	ldw	r2,-32728(gp)
 200d1d0:	10bfffd8 	cmpnei	r2,r2,-1
 200d1d4:	1000031e 	bne	r2,zero,200d1e4 <malloc_extend_top+0x160>
      sbrk_base = brk;
 200d1d8:	e0bff317 	ldw	r2,-52(fp)
 200d1dc:	d0a00a15 	stw	r2,-32728(gp)
 200d1e0:	00000a06 	br	200d20c <malloc_extend_top+0x188>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
 200d1e4:	008080b4 	movhi	r2,514
 200d1e8:	108cff04 	addi	r2,r2,13308
 200d1ec:	10c00017 	ldw	r3,0(r2)
 200d1f0:	e13ff317 	ldw	r4,-52(fp)
 200d1f4:	e0bffa17 	ldw	r2,-24(fp)
 200d1f8:	2085c83a 	sub	r2,r4,r2
 200d1fc:	1887883a 	add	r3,r3,r2
 200d200:	008080b4 	movhi	r2,514
 200d204:	108cff04 	addi	r2,r2,13308
 200d208:	10c00015 	stw	r3,0(r2)

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
 200d20c:	e0bff317 	ldw	r2,-52(fp)
 200d210:	10800204 	addi	r2,r2,8
 200d214:	108001cc 	andi	r2,r2,7
 200d218:	e0bffd15 	stw	r2,-12(fp)
    if (front_misalign > 0) 
 200d21c:	e0bffd17 	ldw	r2,-12(fp)
 200d220:	10000926 	beq	r2,zero,200d248 <malloc_extend_top+0x1c4>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
 200d224:	00c00204 	movi	r3,8
 200d228:	e0bffd17 	ldw	r2,-12(fp)
 200d22c:	1885c83a 	sub	r2,r3,r2
 200d230:	e0bff415 	stw	r2,-48(fp)
      brk += correction;
 200d234:	e0fff317 	ldw	r3,-52(fp)
 200d238:	e0bff417 	ldw	r2,-48(fp)
 200d23c:	1885883a 	add	r2,r3,r2
 200d240:	e0bff315 	stw	r2,-52(fp)
 200d244:	00000106 	br	200d24c <malloc_extend_top+0x1c8>
    }
    else
      correction = 0;
 200d248:	e03ff415 	stw	zero,-48(fp)

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
 200d24c:	e0fff317 	ldw	r3,-52(fp)
 200d250:	e0bff617 	ldw	r2,-40(fp)
 200d254:	1885883a 	add	r2,r3,r2
 200d258:	1007883a 	mov	r3,r2
 200d25c:	e0bffb17 	ldw	r2,-20(fp)
 200d260:	10bfffc4 	addi	r2,r2,-1
 200d264:	1884703a 	and	r2,r3,r2
 200d268:	e0fffb17 	ldw	r3,-20(fp)
 200d26c:	1885c83a 	sub	r2,r3,r2
 200d270:	e0fff417 	ldw	r3,-48(fp)
 200d274:	1885883a 	add	r2,r3,r2
 200d278:	e0bff415 	stw	r2,-48(fp)

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
 200d27c:	e0bff417 	ldw	r2,-48(fp)
 200d280:	100b883a 	mov	r5,r2
 200d284:	e13ffe17 	ldw	r4,-8(fp)
 200d288:	20109e00 	call	20109e0 <_sbrk_r>
 200d28c:	e0bff515 	stw	r2,-44(fp)
    if (new_brk == (char*)(MORECORE_FAILURE))
 200d290:	e0bff517 	ldw	r2,-44(fp)
 200d294:	10bfffd8 	cmpnei	r2,r2,-1
 200d298:	1000051e 	bne	r2,zero,200d2b0 <malloc_extend_top+0x22c>
      {
	correction = 0;
 200d29c:	e03ff415 	stw	zero,-48(fp)
	correction_failed = 1;
 200d2a0:	00800044 	movi	r2,1
 200d2a4:	e0bff715 	stw	r2,-36(fp)
	new_brk = brk;
 200d2a8:	e0bff317 	ldw	r2,-52(fp)
 200d2ac:	e0bff515 	stw	r2,-44(fp)
      }

    sbrked_mem += correction;
 200d2b0:	008080b4 	movhi	r2,514
 200d2b4:	108cff04 	addi	r2,r2,13308
 200d2b8:	10800017 	ldw	r2,0(r2)
 200d2bc:	1007883a 	mov	r3,r2
 200d2c0:	e0bff417 	ldw	r2,-48(fp)
 200d2c4:	1885883a 	add	r2,r3,r2
 200d2c8:	1007883a 	mov	r3,r2
 200d2cc:	008080b4 	movhi	r2,514
 200d2d0:	108cff04 	addi	r2,r2,13308
 200d2d4:	10c00015 	stw	r3,0(r2)

    top = (mchunkptr)brk;
 200d2d8:	008080b4 	movhi	r2,514
 200d2dc:	10800504 	addi	r2,r2,20
 200d2e0:	e0fff317 	ldw	r3,-52(fp)
 200d2e4:	10c00215 	stw	r3,8(r2)
    top_size = new_brk - brk + correction;
 200d2e8:	e0fff517 	ldw	r3,-44(fp)
 200d2ec:	e0bff317 	ldw	r2,-52(fp)
 200d2f0:	1885c83a 	sub	r2,r3,r2
 200d2f4:	1007883a 	mov	r3,r2
 200d2f8:	e0bff417 	ldw	r2,-48(fp)
 200d2fc:	1885883a 	add	r2,r3,r2
 200d300:	e0bffc15 	stw	r2,-16(fp)
    set_head(top, top_size | PREV_INUSE);
 200d304:	008080b4 	movhi	r2,514
 200d308:	10800504 	addi	r2,r2,20
 200d30c:	10800217 	ldw	r2,8(r2)
 200d310:	e0fffc17 	ldw	r3,-16(fp)
 200d314:	18c00054 	ori	r3,r3,1
 200d318:	10c00115 	stw	r3,4(r2)

    if (old_top != initial_top)
 200d31c:	008080b4 	movhi	r2,514
 200d320:	10800504 	addi	r2,r2,20
 200d324:	e0fff817 	ldw	r3,-32(fp)
 200d328:	18802826 	beq	r3,r2,200d3cc <malloc_extend_top+0x348>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
 200d32c:	e0bff917 	ldw	r2,-28(fp)
 200d330:	10800428 	cmpgeui	r2,r2,16
 200d334:	1000061e 	bne	r2,zero,200d350 <malloc_extend_top+0x2cc>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
 200d338:	008080b4 	movhi	r2,514
 200d33c:	10800504 	addi	r2,r2,20
 200d340:	10800217 	ldw	r2,8(r2)
 200d344:	00c00044 	movi	r3,1
 200d348:	10c00115 	stw	r3,4(r2)
        return;
 200d34c:	00003506 	br	200d424 <malloc_extend_top+0x3a0>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
 200d350:	e0bff917 	ldw	r2,-28(fp)
 200d354:	10fffd04 	addi	r3,r2,-12
 200d358:	00bffe04 	movi	r2,-8
 200d35c:	1884703a 	and	r2,r3,r2
 200d360:	e0bff915 	stw	r2,-28(fp)
      set_head_size(old_top, old_top_size);
 200d364:	e0bff817 	ldw	r2,-32(fp)
 200d368:	10800117 	ldw	r2,4(r2)
 200d36c:	10c0004c 	andi	r3,r2,1
 200d370:	e0bff917 	ldw	r2,-28(fp)
 200d374:	1886b03a 	or	r3,r3,r2
 200d378:	e0bff817 	ldw	r2,-32(fp)
 200d37c:	10c00115 	stw	r3,4(r2)
      chunk_at_offset(old_top, old_top_size          )->size =
 200d380:	e0fff817 	ldw	r3,-32(fp)
 200d384:	e0bff917 	ldw	r2,-28(fp)
 200d388:	1885883a 	add	r2,r3,r2
 200d38c:	00c00144 	movi	r3,5
 200d390:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
 200d394:	e0bff917 	ldw	r2,-28(fp)
 200d398:	10800104 	addi	r2,r2,4
 200d39c:	e0fff817 	ldw	r3,-32(fp)
 200d3a0:	1885883a 	add	r2,r3,r2
 200d3a4:	00c00144 	movi	r3,5
 200d3a8:	10c00115 	stw	r3,4(r2)
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
 200d3ac:	e0bff917 	ldw	r2,-28(fp)
 200d3b0:	10800430 	cmpltui	r2,r2,16
 200d3b4:	1000051e 	bne	r2,zero,200d3cc <malloc_extend_top+0x348>
        fREe(RCALL chunk2mem(old_top));
 200d3b8:	e0bff817 	ldw	r2,-32(fp)
 200d3bc:	10800204 	addi	r2,r2,8
 200d3c0:	100b883a 	mov	r5,r2
 200d3c4:	e13ffe17 	ldw	r4,-8(fp)
 200d3c8:	200bdf80 	call	200bdf8 <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
 200d3cc:	008080b4 	movhi	r2,514
 200d3d0:	108cff04 	addi	r2,r2,13308
 200d3d4:	10800017 	ldw	r2,0(r2)
 200d3d8:	1007883a 	mov	r3,r2
 200d3dc:	d0a74417 	ldw	r2,-25328(gp)
 200d3e0:	10c0042e 	bgeu	r2,r3,200d3f4 <malloc_extend_top+0x370>
    max_sbrked_mem = sbrked_mem;
 200d3e4:	008080b4 	movhi	r2,514
 200d3e8:	108cff04 	addi	r2,r2,13308
 200d3ec:	10800017 	ldw	r2,0(r2)
 200d3f0:	d0a74415 	stw	r2,-25328(gp)
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
 200d3f4:	008080b4 	movhi	r2,514
 200d3f8:	108cff04 	addi	r2,r2,13308
 200d3fc:	10800017 	ldw	r2,0(r2)
 200d400:	1007883a 	mov	r3,r2
 200d404:	d0a74517 	ldw	r2,-25324(gp)
 200d408:	10c0062e 	bgeu	r2,r3,200d424 <malloc_extend_top+0x3a0>
    max_total_mem = sbrked_mem;
 200d40c:	008080b4 	movhi	r2,514
 200d410:	108cff04 	addi	r2,r2,13308
 200d414:	10800017 	ldw	r2,0(r2)
 200d418:	d0a74515 	stw	r2,-25324(gp)
 200d41c:	00000106 	br	200d424 <malloc_extend_top+0x3a0>
  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
      (brk < old_end && old_top != initial_top))
    return;
 200d420:	0001883a 	nop
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
 200d424:	e037883a 	mov	sp,fp
 200d428:	dfc00117 	ldw	ra,4(sp)
 200d42c:	df000017 	ldw	fp,0(sp)
 200d430:	dec00204 	addi	sp,sp,8
 200d434:	f800283a 	ret

0200d438 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
 200d438:	deffef04 	addi	sp,sp,-68
 200d43c:	dfc01015 	stw	ra,64(sp)
 200d440:	df000f15 	stw	fp,60(sp)
 200d444:	df000f04 	addi	fp,sp,60
 200d448:	e13ffe15 	stw	r4,-8(fp)
 200d44c:	e17fff15 	stw	r5,-4(fp)
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
 200d450:	e0bfff17 	ldw	r2,-4(fp)
 200d454:	108002c4 	addi	r2,r2,11
 200d458:	108005f0 	cmpltui	r2,r2,23
 200d45c:	1000051e 	bne	r2,zero,200d474 <_malloc_r+0x3c>
 200d460:	e0bfff17 	ldw	r2,-4(fp)
 200d464:	10c002c4 	addi	r3,r2,11
 200d468:	00bffe04 	movi	r2,-8
 200d46c:	1884703a 	and	r2,r3,r2
 200d470:	00000106 	br	200d478 <_malloc_r+0x40>
 200d474:	00800404 	movi	r2,16
 200d478:	e0bffa15 	stw	r2,-24(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 200d47c:	e0bffa17 	ldw	r2,-24(fp)
 200d480:	10000316 	blt	r2,zero,200d490 <_malloc_r+0x58>
 200d484:	e0fffa17 	ldw	r3,-24(fp)
 200d488:	e0bfff17 	ldw	r2,-4(fp)
 200d48c:	1880052e 	bgeu	r3,r2,200d4a4 <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
 200d490:	e0bffe17 	ldw	r2,-8(fp)
 200d494:	00c00304 	movi	r3,12
 200d498:	10c00015 	stw	r3,0(r2)
    return 0;
 200d49c:	0005883a 	mov	r2,zero
 200d4a0:	0002bf06 	br	200dfa0 <_malloc_r+0xb68>
  }

  MALLOC_LOCK;
 200d4a4:	e13ffe17 	ldw	r4,-8(fp)
 200d4a8:	201469c0 	call	201469c <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
 200d4ac:	e0bffa17 	ldw	r2,-24(fp)
 200d4b0:	10807e28 	cmpgeui	r2,r2,504
 200d4b4:	10003f1e 	bne	r2,zero,200d5b4 <_malloc_r+0x17c>
  {
    idx = smallbin_index(nb); 
 200d4b8:	e0bffa17 	ldw	r2,-24(fp)
 200d4bc:	1004d0fa 	srli	r2,r2,3
 200d4c0:	e0bff215 	stw	r2,-56(fp)

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
 200d4c4:	e0bff217 	ldw	r2,-56(fp)
 200d4c8:	10800044 	addi	r2,r2,1
 200d4cc:	1085883a 	add	r2,r2,r2
 200d4d0:	1085883a 	add	r2,r2,r2
 200d4d4:	1087883a 	add	r3,r2,r2
 200d4d8:	008080b4 	movhi	r2,514
 200d4dc:	10800504 	addi	r2,r2,20
 200d4e0:	1885883a 	add	r2,r3,r2
 200d4e4:	10bffe04 	addi	r2,r2,-8
 200d4e8:	e0bff915 	stw	r2,-28(fp)
    victim = last(q);
 200d4ec:	e0bff917 	ldw	r2,-28(fp)
 200d4f0:	10800317 	ldw	r2,12(r2)
 200d4f4:	e0bff115 	stw	r2,-60(fp)

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
 200d4f8:	e0fff117 	ldw	r3,-60(fp)
 200d4fc:	e0bff917 	ldw	r2,-28(fp)
 200d500:	1880061e 	bne	r3,r2,200d51c <_malloc_r+0xe4>
    {
      q = next_bin(q);
 200d504:	e0bff917 	ldw	r2,-28(fp)
 200d508:	10800204 	addi	r2,r2,8
 200d50c:	e0bff915 	stw	r2,-28(fp)
      victim = last(q);
 200d510:	e0bff917 	ldw	r2,-28(fp)
 200d514:	10800317 	ldw	r2,12(r2)
 200d518:	e0bff115 	stw	r2,-60(fp)
    }
#endif
    if (victim != q)
 200d51c:	e0fff117 	ldw	r3,-60(fp)
 200d520:	e0bff917 	ldw	r2,-28(fp)
 200d524:	18801f26 	beq	r3,r2,200d5a4 <_malloc_r+0x16c>
    {
      victim_size = chunksize(victim);
 200d528:	e0bff117 	ldw	r2,-60(fp)
 200d52c:	10c00117 	ldw	r3,4(r2)
 200d530:	00bfff04 	movi	r2,-4
 200d534:	1884703a 	and	r2,r3,r2
 200d538:	e0bffb15 	stw	r2,-20(fp)
      unlink(victim, bck, fwd);
 200d53c:	e0bff117 	ldw	r2,-60(fp)
 200d540:	10800317 	ldw	r2,12(r2)
 200d544:	e0bff815 	stw	r2,-32(fp)
 200d548:	e0bff117 	ldw	r2,-60(fp)
 200d54c:	10800217 	ldw	r2,8(r2)
 200d550:	e0bff715 	stw	r2,-36(fp)
 200d554:	e0bff717 	ldw	r2,-36(fp)
 200d558:	e0fff817 	ldw	r3,-32(fp)
 200d55c:	10c00315 	stw	r3,12(r2)
 200d560:	e0bff817 	ldw	r2,-32(fp)
 200d564:	e0fff717 	ldw	r3,-36(fp)
 200d568:	10c00215 	stw	r3,8(r2)
      set_inuse_bit_at_offset(victim, victim_size);
 200d56c:	e0fff117 	ldw	r3,-60(fp)
 200d570:	e0bffb17 	ldw	r2,-20(fp)
 200d574:	1885883a 	add	r2,r3,r2
 200d578:	e13ff117 	ldw	r4,-60(fp)
 200d57c:	e0fffb17 	ldw	r3,-20(fp)
 200d580:	20c7883a 	add	r3,r4,r3
 200d584:	18c00117 	ldw	r3,4(r3)
 200d588:	18c00054 	ori	r3,r3,1
 200d58c:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 200d590:	e13ffe17 	ldw	r4,-8(fp)
 200d594:	20147bc0 	call	20147bc <__malloc_unlock>
      return chunk2mem(victim);
 200d598:	e0bff117 	ldw	r2,-60(fp)
 200d59c:	10800204 	addi	r2,r2,8
 200d5a0:	00027f06 	br	200dfa0 <_malloc_r+0xb68>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
 200d5a4:	e0bff217 	ldw	r2,-56(fp)
 200d5a8:	10800084 	addi	r2,r2,2
 200d5ac:	e0bff215 	stw	r2,-56(fp)
 200d5b0:	00007306 	br	200d780 <_malloc_r+0x348>

  }
  else
  {
    idx = bin_index(nb);
 200d5b4:	e0bffa17 	ldw	r2,-24(fp)
 200d5b8:	1004d27a 	srli	r2,r2,9
 200d5bc:	1000031e 	bne	r2,zero,200d5cc <_malloc_r+0x194>
 200d5c0:	e0bffa17 	ldw	r2,-24(fp)
 200d5c4:	1004d0fa 	srli	r2,r2,3
 200d5c8:	00002906 	br	200d670 <_malloc_r+0x238>
 200d5cc:	e0bffa17 	ldw	r2,-24(fp)
 200d5d0:	1004d27a 	srli	r2,r2,9
 200d5d4:	10800168 	cmpgeui	r2,r2,5
 200d5d8:	1000041e 	bne	r2,zero,200d5ec <_malloc_r+0x1b4>
 200d5dc:	e0bffa17 	ldw	r2,-24(fp)
 200d5e0:	1004d1ba 	srli	r2,r2,6
 200d5e4:	10800e04 	addi	r2,r2,56
 200d5e8:	00002106 	br	200d670 <_malloc_r+0x238>
 200d5ec:	e0bffa17 	ldw	r2,-24(fp)
 200d5f0:	1004d27a 	srli	r2,r2,9
 200d5f4:	10800568 	cmpgeui	r2,r2,21
 200d5f8:	1000041e 	bne	r2,zero,200d60c <_malloc_r+0x1d4>
 200d5fc:	e0bffa17 	ldw	r2,-24(fp)
 200d600:	1004d27a 	srli	r2,r2,9
 200d604:	108016c4 	addi	r2,r2,91
 200d608:	00001906 	br	200d670 <_malloc_r+0x238>
 200d60c:	e0bffa17 	ldw	r2,-24(fp)
 200d610:	1004d27a 	srli	r2,r2,9
 200d614:	10801568 	cmpgeui	r2,r2,85
 200d618:	1000041e 	bne	r2,zero,200d62c <_malloc_r+0x1f4>
 200d61c:	e0bffa17 	ldw	r2,-24(fp)
 200d620:	1004d33a 	srli	r2,r2,12
 200d624:	10801b84 	addi	r2,r2,110
 200d628:	00001106 	br	200d670 <_malloc_r+0x238>
 200d62c:	e0bffa17 	ldw	r2,-24(fp)
 200d630:	1004d27a 	srli	r2,r2,9
 200d634:	10805568 	cmpgeui	r2,r2,341
 200d638:	1000041e 	bne	r2,zero,200d64c <_malloc_r+0x214>
 200d63c:	e0bffa17 	ldw	r2,-24(fp)
 200d640:	1004d3fa 	srli	r2,r2,15
 200d644:	10801dc4 	addi	r2,r2,119
 200d648:	00000906 	br	200d670 <_malloc_r+0x238>
 200d64c:	e0bffa17 	ldw	r2,-24(fp)
 200d650:	1004d27a 	srli	r2,r2,9
 200d654:	10815568 	cmpgeui	r2,r2,1365
 200d658:	1000041e 	bne	r2,zero,200d66c <_malloc_r+0x234>
 200d65c:	e0bffa17 	ldw	r2,-24(fp)
 200d660:	1004d4ba 	srli	r2,r2,18
 200d664:	10801f04 	addi	r2,r2,124
 200d668:	00000106 	br	200d670 <_malloc_r+0x238>
 200d66c:	00801f84 	movi	r2,126
 200d670:	e0bff215 	stw	r2,-56(fp)
    bin = bin_at(idx);
 200d674:	e0bff217 	ldw	r2,-56(fp)
 200d678:	10800044 	addi	r2,r2,1
 200d67c:	1085883a 	add	r2,r2,r2
 200d680:	1085883a 	add	r2,r2,r2
 200d684:	1087883a 	add	r3,r2,r2
 200d688:	008080b4 	movhi	r2,514
 200d68c:	10800504 	addi	r2,r2,20
 200d690:	1885883a 	add	r2,r3,r2
 200d694:	10bffe04 	addi	r2,r2,-8
 200d698:	e0bff315 	stw	r2,-52(fp)

    for (victim = last(bin); victim != bin; victim = victim->bk)
 200d69c:	e0bff317 	ldw	r2,-52(fp)
 200d6a0:	10800317 	ldw	r2,12(r2)
 200d6a4:	e0bff115 	stw	r2,-60(fp)
 200d6a8:	00002f06 	br	200d768 <_malloc_r+0x330>
    {
      victim_size = chunksize(victim);
 200d6ac:	e0bff117 	ldw	r2,-60(fp)
 200d6b0:	10c00117 	ldw	r3,4(r2)
 200d6b4:	00bfff04 	movi	r2,-4
 200d6b8:	1884703a 	and	r2,r3,r2
 200d6bc:	e0bffb15 	stw	r2,-20(fp)
      remainder_size = long_sub_size_t(victim_size, nb);
 200d6c0:	e0fffb17 	ldw	r3,-20(fp)
 200d6c4:	e0bffa17 	ldw	r2,-24(fp)
 200d6c8:	1885c83a 	sub	r2,r3,r2
 200d6cc:	e0bff415 	stw	r2,-48(fp)
      
      if (remainder_size >= (long)MINSIZE) /* too big */
 200d6d0:	e0bff417 	ldw	r2,-48(fp)
 200d6d4:	10800410 	cmplti	r2,r2,16
 200d6d8:	1000041e 	bne	r2,zero,200d6ec <_malloc_r+0x2b4>
      {
        --idx; /* adjust to rescan below after checking last remainder */
 200d6dc:	e0bff217 	ldw	r2,-56(fp)
 200d6e0:	10bfffc4 	addi	r2,r2,-1
 200d6e4:	e0bff215 	stw	r2,-56(fp)
        break;   
 200d6e8:	00002206 	br	200d774 <_malloc_r+0x33c>
      }

      else if (remainder_size >= 0) /* exact fit */
 200d6ec:	e0bff417 	ldw	r2,-48(fp)
 200d6f0:	10001a16 	blt	r2,zero,200d75c <_malloc_r+0x324>
      {
        unlink(victim, bck, fwd);
 200d6f4:	e0bff117 	ldw	r2,-60(fp)
 200d6f8:	10800317 	ldw	r2,12(r2)
 200d6fc:	e0bff815 	stw	r2,-32(fp)
 200d700:	e0bff117 	ldw	r2,-60(fp)
 200d704:	10800217 	ldw	r2,8(r2)
 200d708:	e0bff715 	stw	r2,-36(fp)
 200d70c:	e0bff717 	ldw	r2,-36(fp)
 200d710:	e0fff817 	ldw	r3,-32(fp)
 200d714:	10c00315 	stw	r3,12(r2)
 200d718:	e0bff817 	ldw	r2,-32(fp)
 200d71c:	e0fff717 	ldw	r3,-36(fp)
 200d720:	10c00215 	stw	r3,8(r2)
        set_inuse_bit_at_offset(victim, victim_size);
 200d724:	e0fff117 	ldw	r3,-60(fp)
 200d728:	e0bffb17 	ldw	r2,-20(fp)
 200d72c:	1885883a 	add	r2,r3,r2
 200d730:	e13ff117 	ldw	r4,-60(fp)
 200d734:	e0fffb17 	ldw	r3,-20(fp)
 200d738:	20c7883a 	add	r3,r4,r3
 200d73c:	18c00117 	ldw	r3,4(r3)
 200d740:	18c00054 	ori	r3,r3,1
 200d744:	10c00115 	stw	r3,4(r2)
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
 200d748:	e13ffe17 	ldw	r4,-8(fp)
 200d74c:	20147bc0 	call	20147bc <__malloc_unlock>
        return chunk2mem(victim);
 200d750:	e0bff117 	ldw	r2,-60(fp)
 200d754:	10800204 	addi	r2,r2,8
 200d758:	00021106 	br	200dfa0 <_malloc_r+0xb68>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
 200d75c:	e0bff117 	ldw	r2,-60(fp)
 200d760:	10800317 	ldw	r2,12(r2)
 200d764:	e0bff115 	stw	r2,-60(fp)
 200d768:	e0fff117 	ldw	r3,-60(fp)
 200d76c:	e0bff317 	ldw	r2,-52(fp)
 200d770:	18bfce1e 	bne	r3,r2,200d6ac <_malloc_r+0x274>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
 200d774:	e0bff217 	ldw	r2,-56(fp)
 200d778:	10800044 	addi	r2,r2,1
 200d77c:	e0bff215 	stw	r2,-56(fp)

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
 200d780:	008080b4 	movhi	r2,514
 200d784:	10800704 	addi	r2,r2,28
 200d788:	10800217 	ldw	r2,8(r2)
 200d78c:	e0bff115 	stw	r2,-60(fp)
 200d790:	008080b4 	movhi	r2,514
 200d794:	10800704 	addi	r2,r2,28
 200d798:	e0fff117 	ldw	r3,-60(fp)
 200d79c:	1880e626 	beq	r3,r2,200db38 <_malloc_r+0x700>
  {
    victim_size = chunksize(victim);
 200d7a0:	e0bff117 	ldw	r2,-60(fp)
 200d7a4:	10c00117 	ldw	r3,4(r2)
 200d7a8:	00bfff04 	movi	r2,-4
 200d7ac:	1884703a 	and	r2,r3,r2
 200d7b0:	e0bffb15 	stw	r2,-20(fp)
    remainder_size = long_sub_size_t(victim_size, nb);
 200d7b4:	e0fffb17 	ldw	r3,-20(fp)
 200d7b8:	e0bffa17 	ldw	r2,-24(fp)
 200d7bc:	1885c83a 	sub	r2,r3,r2
 200d7c0:	e0bff415 	stw	r2,-48(fp)

    if (remainder_size >= (long)MINSIZE) /* re-split */
 200d7c4:	e0bff417 	ldw	r2,-48(fp)
 200d7c8:	10800410 	cmplti	r2,r2,16
 200d7cc:	1000271e 	bne	r2,zero,200d86c <_malloc_r+0x434>
    {
      remainder = chunk_at_offset(victim, nb);
 200d7d0:	e0fff117 	ldw	r3,-60(fp)
 200d7d4:	e0bffa17 	ldw	r2,-24(fp)
 200d7d8:	1885883a 	add	r2,r3,r2
 200d7dc:	e0bffc15 	stw	r2,-16(fp)
      set_head(victim, nb | PREV_INUSE);
 200d7e0:	e0bffa17 	ldw	r2,-24(fp)
 200d7e4:	10c00054 	ori	r3,r2,1
 200d7e8:	e0bff117 	ldw	r2,-60(fp)
 200d7ec:	10c00115 	stw	r3,4(r2)
      link_last_remainder(remainder);
 200d7f0:	00c080b4 	movhi	r3,514
 200d7f4:	18c00704 	addi	r3,r3,28
 200d7f8:	008080b4 	movhi	r2,514
 200d7fc:	10800704 	addi	r2,r2,28
 200d800:	e13ffc17 	ldw	r4,-16(fp)
 200d804:	11000315 	stw	r4,12(r2)
 200d808:	10800317 	ldw	r2,12(r2)
 200d80c:	18800215 	stw	r2,8(r3)
 200d810:	008080b4 	movhi	r2,514
 200d814:	10800704 	addi	r2,r2,28
 200d818:	e0fffc17 	ldw	r3,-16(fp)
 200d81c:	18800315 	stw	r2,12(r3)
 200d820:	e0bffc17 	ldw	r2,-16(fp)
 200d824:	10c00317 	ldw	r3,12(r2)
 200d828:	e0bffc17 	ldw	r2,-16(fp)
 200d82c:	10c00215 	stw	r3,8(r2)
      set_head(remainder, remainder_size | PREV_INUSE);
 200d830:	e0bff417 	ldw	r2,-48(fp)
 200d834:	10800054 	ori	r2,r2,1
 200d838:	1007883a 	mov	r3,r2
 200d83c:	e0bffc17 	ldw	r2,-16(fp)
 200d840:	10c00115 	stw	r3,4(r2)
      set_foot(remainder, remainder_size);
 200d844:	e0bff417 	ldw	r2,-48(fp)
 200d848:	e0fffc17 	ldw	r3,-16(fp)
 200d84c:	1885883a 	add	r2,r3,r2
 200d850:	e0fff417 	ldw	r3,-48(fp)
 200d854:	10c00015 	stw	r3,0(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 200d858:	e13ffe17 	ldw	r4,-8(fp)
 200d85c:	20147bc0 	call	20147bc <__malloc_unlock>
      return chunk2mem(victim);
 200d860:	e0bff117 	ldw	r2,-60(fp)
 200d864:	10800204 	addi	r2,r2,8
 200d868:	0001cd06 	br	200dfa0 <_malloc_r+0xb68>
    }

    clear_last_remainder;
 200d86c:	00c080b4 	movhi	r3,514
 200d870:	18c00704 	addi	r3,r3,28
 200d874:	008080b4 	movhi	r2,514
 200d878:	10800704 	addi	r2,r2,28
 200d87c:	010080b4 	movhi	r4,514
 200d880:	21000704 	addi	r4,r4,28
 200d884:	11000315 	stw	r4,12(r2)
 200d888:	10800317 	ldw	r2,12(r2)
 200d88c:	18800215 	stw	r2,8(r3)

    if (remainder_size >= 0)  /* exhaust */
 200d890:	e0bff417 	ldw	r2,-48(fp)
 200d894:	10000e16 	blt	r2,zero,200d8d0 <_malloc_r+0x498>
    {
      set_inuse_bit_at_offset(victim, victim_size);
 200d898:	e0fff117 	ldw	r3,-60(fp)
 200d89c:	e0bffb17 	ldw	r2,-20(fp)
 200d8a0:	1885883a 	add	r2,r3,r2
 200d8a4:	e13ff117 	ldw	r4,-60(fp)
 200d8a8:	e0fffb17 	ldw	r3,-20(fp)
 200d8ac:	20c7883a 	add	r3,r4,r3
 200d8b0:	18c00117 	ldw	r3,4(r3)
 200d8b4:	18c00054 	ori	r3,r3,1
 200d8b8:	10c00115 	stw	r3,4(r2)
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
 200d8bc:	e13ffe17 	ldw	r4,-8(fp)
 200d8c0:	20147bc0 	call	20147bc <__malloc_unlock>
      return chunk2mem(victim);
 200d8c4:	e0bff117 	ldw	r2,-60(fp)
 200d8c8:	10800204 	addi	r2,r2,8
 200d8cc:	0001b406 	br	200dfa0 <_malloc_r+0xb68>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
 200d8d0:	e0bffb17 	ldw	r2,-20(fp)
 200d8d4:	10808028 	cmpgeui	r2,r2,512
 200d8d8:	10002c1e 	bne	r2,zero,200d98c <_malloc_r+0x554>
 200d8dc:	e0bffb17 	ldw	r2,-20(fp)
 200d8e0:	1004d0fa 	srli	r2,r2,3
 200d8e4:	e0bffd15 	stw	r2,-12(fp)
 200d8e8:	00c080b4 	movhi	r3,514
 200d8ec:	18c00504 	addi	r3,r3,20
 200d8f0:	008080b4 	movhi	r2,514
 200d8f4:	10800504 	addi	r2,r2,20
 200d8f8:	11000117 	ldw	r4,4(r2)
 200d8fc:	e0bffd17 	ldw	r2,-12(fp)
 200d900:	1000010e 	bge	r2,zero,200d908 <_malloc_r+0x4d0>
 200d904:	108000c4 	addi	r2,r2,3
 200d908:	1005d0ba 	srai	r2,r2,2
 200d90c:	100b883a 	mov	r5,r2
 200d910:	00800044 	movi	r2,1
 200d914:	1144983a 	sll	r2,r2,r5
 200d918:	2084b03a 	or	r2,r4,r2
 200d91c:	18800115 	stw	r2,4(r3)
 200d920:	e0bffd17 	ldw	r2,-12(fp)
 200d924:	10800044 	addi	r2,r2,1
 200d928:	1085883a 	add	r2,r2,r2
 200d92c:	1085883a 	add	r2,r2,r2
 200d930:	1087883a 	add	r3,r2,r2
 200d934:	008080b4 	movhi	r2,514
 200d938:	10800504 	addi	r2,r2,20
 200d93c:	1885883a 	add	r2,r3,r2
 200d940:	10bffe04 	addi	r2,r2,-8
 200d944:	e0bff815 	stw	r2,-32(fp)
 200d948:	e0bff817 	ldw	r2,-32(fp)
 200d94c:	10800217 	ldw	r2,8(r2)
 200d950:	e0bff715 	stw	r2,-36(fp)
 200d954:	e0bff117 	ldw	r2,-60(fp)
 200d958:	e0fff817 	ldw	r3,-32(fp)
 200d95c:	10c00315 	stw	r3,12(r2)
 200d960:	e0bff117 	ldw	r2,-60(fp)
 200d964:	e0fff717 	ldw	r3,-36(fp)
 200d968:	10c00215 	stw	r3,8(r2)
 200d96c:	e0bff817 	ldw	r2,-32(fp)
 200d970:	e0fff117 	ldw	r3,-60(fp)
 200d974:	10c00215 	stw	r3,8(r2)
 200d978:	e0bff817 	ldw	r2,-32(fp)
 200d97c:	10c00217 	ldw	r3,8(r2)
 200d980:	e0bff717 	ldw	r2,-36(fp)
 200d984:	10c00315 	stw	r3,12(r2)
 200d988:	00006b06 	br	200db38 <_malloc_r+0x700>
 200d98c:	e0bffb17 	ldw	r2,-20(fp)
 200d990:	1004d27a 	srli	r2,r2,9
 200d994:	1000031e 	bne	r2,zero,200d9a4 <_malloc_r+0x56c>
 200d998:	e0bffb17 	ldw	r2,-20(fp)
 200d99c:	1004d0fa 	srli	r2,r2,3
 200d9a0:	00002906 	br	200da48 <_malloc_r+0x610>
 200d9a4:	e0bffb17 	ldw	r2,-20(fp)
 200d9a8:	1004d27a 	srli	r2,r2,9
 200d9ac:	10800168 	cmpgeui	r2,r2,5
 200d9b0:	1000041e 	bne	r2,zero,200d9c4 <_malloc_r+0x58c>
 200d9b4:	e0bffb17 	ldw	r2,-20(fp)
 200d9b8:	1004d1ba 	srli	r2,r2,6
 200d9bc:	10800e04 	addi	r2,r2,56
 200d9c0:	00002106 	br	200da48 <_malloc_r+0x610>
 200d9c4:	e0bffb17 	ldw	r2,-20(fp)
 200d9c8:	1004d27a 	srli	r2,r2,9
 200d9cc:	10800568 	cmpgeui	r2,r2,21
 200d9d0:	1000041e 	bne	r2,zero,200d9e4 <_malloc_r+0x5ac>
 200d9d4:	e0bffb17 	ldw	r2,-20(fp)
 200d9d8:	1004d27a 	srli	r2,r2,9
 200d9dc:	108016c4 	addi	r2,r2,91
 200d9e0:	00001906 	br	200da48 <_malloc_r+0x610>
 200d9e4:	e0bffb17 	ldw	r2,-20(fp)
 200d9e8:	1004d27a 	srli	r2,r2,9
 200d9ec:	10801568 	cmpgeui	r2,r2,85
 200d9f0:	1000041e 	bne	r2,zero,200da04 <_malloc_r+0x5cc>
 200d9f4:	e0bffb17 	ldw	r2,-20(fp)
 200d9f8:	1004d33a 	srli	r2,r2,12
 200d9fc:	10801b84 	addi	r2,r2,110
 200da00:	00001106 	br	200da48 <_malloc_r+0x610>
 200da04:	e0bffb17 	ldw	r2,-20(fp)
 200da08:	1004d27a 	srli	r2,r2,9
 200da0c:	10805568 	cmpgeui	r2,r2,341
 200da10:	1000041e 	bne	r2,zero,200da24 <_malloc_r+0x5ec>
 200da14:	e0bffb17 	ldw	r2,-20(fp)
 200da18:	1004d3fa 	srli	r2,r2,15
 200da1c:	10801dc4 	addi	r2,r2,119
 200da20:	00000906 	br	200da48 <_malloc_r+0x610>
 200da24:	e0bffb17 	ldw	r2,-20(fp)
 200da28:	1004d27a 	srli	r2,r2,9
 200da2c:	10815568 	cmpgeui	r2,r2,1365
 200da30:	1000041e 	bne	r2,zero,200da44 <_malloc_r+0x60c>
 200da34:	e0bffb17 	ldw	r2,-20(fp)
 200da38:	1004d4ba 	srli	r2,r2,18
 200da3c:	10801f04 	addi	r2,r2,124
 200da40:	00000106 	br	200da48 <_malloc_r+0x610>
 200da44:	00801f84 	movi	r2,126
 200da48:	e0bffd15 	stw	r2,-12(fp)
 200da4c:	e0bffd17 	ldw	r2,-12(fp)
 200da50:	10800044 	addi	r2,r2,1
 200da54:	1085883a 	add	r2,r2,r2
 200da58:	1085883a 	add	r2,r2,r2
 200da5c:	1087883a 	add	r3,r2,r2
 200da60:	008080b4 	movhi	r2,514
 200da64:	10800504 	addi	r2,r2,20
 200da68:	1885883a 	add	r2,r3,r2
 200da6c:	10bffe04 	addi	r2,r2,-8
 200da70:	e0bff815 	stw	r2,-32(fp)
 200da74:	e0bff817 	ldw	r2,-32(fp)
 200da78:	10800217 	ldw	r2,8(r2)
 200da7c:	e0bff715 	stw	r2,-36(fp)
 200da80:	e0fff717 	ldw	r3,-36(fp)
 200da84:	e0bff817 	ldw	r2,-32(fp)
 200da88:	1880121e 	bne	r3,r2,200dad4 <_malloc_r+0x69c>
 200da8c:	00c080b4 	movhi	r3,514
 200da90:	18c00504 	addi	r3,r3,20
 200da94:	008080b4 	movhi	r2,514
 200da98:	10800504 	addi	r2,r2,20
 200da9c:	11000117 	ldw	r4,4(r2)
 200daa0:	e0bffd17 	ldw	r2,-12(fp)
 200daa4:	1000010e 	bge	r2,zero,200daac <_malloc_r+0x674>
 200daa8:	108000c4 	addi	r2,r2,3
 200daac:	1005d0ba 	srai	r2,r2,2
 200dab0:	100b883a 	mov	r5,r2
 200dab4:	00800044 	movi	r2,1
 200dab8:	1144983a 	sll	r2,r2,r5
 200dabc:	2084b03a 	or	r2,r4,r2
 200dac0:	18800115 	stw	r2,4(r3)
 200dac4:	00000f06 	br	200db04 <_malloc_r+0x6cc>
 200dac8:	e0bff717 	ldw	r2,-36(fp)
 200dacc:	10800217 	ldw	r2,8(r2)
 200dad0:	e0bff715 	stw	r2,-36(fp)
 200dad4:	e0fff717 	ldw	r3,-36(fp)
 200dad8:	e0bff817 	ldw	r2,-32(fp)
 200dadc:	18800626 	beq	r3,r2,200daf8 <_malloc_r+0x6c0>
 200dae0:	e0bff717 	ldw	r2,-36(fp)
 200dae4:	10c00117 	ldw	r3,4(r2)
 200dae8:	00bfff04 	movi	r2,-4
 200daec:	1884703a 	and	r2,r3,r2
 200daf0:	e0fffb17 	ldw	r3,-20(fp)
 200daf4:	18bff436 	bltu	r3,r2,200dac8 <_malloc_r+0x690>
 200daf8:	e0bff717 	ldw	r2,-36(fp)
 200dafc:	10800317 	ldw	r2,12(r2)
 200db00:	e0bff815 	stw	r2,-32(fp)
 200db04:	e0bff117 	ldw	r2,-60(fp)
 200db08:	e0fff817 	ldw	r3,-32(fp)
 200db0c:	10c00315 	stw	r3,12(r2)
 200db10:	e0bff117 	ldw	r2,-60(fp)
 200db14:	e0fff717 	ldw	r3,-36(fp)
 200db18:	10c00215 	stw	r3,8(r2)
 200db1c:	e0bff817 	ldw	r2,-32(fp)
 200db20:	e0fff117 	ldw	r3,-60(fp)
 200db24:	10c00215 	stw	r3,8(r2)
 200db28:	e0bff817 	ldw	r2,-32(fp)
 200db2c:	10c00217 	ldw	r3,8(r2)
 200db30:	e0bff717 	ldw	r2,-36(fp)
 200db34:	10c00315 	stw	r3,12(r2)
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
 200db38:	e0bff217 	ldw	r2,-56(fp)
 200db3c:	1000010e 	bge	r2,zero,200db44 <_malloc_r+0x70c>
 200db40:	108000c4 	addi	r2,r2,3
 200db44:	1005d0ba 	srai	r2,r2,2
 200db48:	1007883a 	mov	r3,r2
 200db4c:	00800044 	movi	r2,1
 200db50:	10c4983a 	sll	r2,r2,r3
 200db54:	e0bff515 	stw	r2,-44(fp)
 200db58:	008080b4 	movhi	r2,514
 200db5c:	10800504 	addi	r2,r2,20
 200db60:	10c00117 	ldw	r3,4(r2)
 200db64:	e0bff517 	ldw	r2,-44(fp)
 200db68:	1880c636 	bltu	r3,r2,200de84 <_malloc_r+0xa4c>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
 200db6c:	008080b4 	movhi	r2,514
 200db70:	10800504 	addi	r2,r2,20
 200db74:	10c00117 	ldw	r3,4(r2)
 200db78:	e0bff517 	ldw	r2,-44(fp)
 200db7c:	1884703a 	and	r2,r3,r2
 200db80:	1000151e 	bne	r2,zero,200dbd8 <_malloc_r+0x7a0>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
 200db84:	e0fff217 	ldw	r3,-56(fp)
 200db88:	00bfff04 	movi	r2,-4
 200db8c:	1884703a 	and	r2,r3,r2
 200db90:	10800104 	addi	r2,r2,4
 200db94:	e0bff215 	stw	r2,-56(fp)
      block <<= 1;
 200db98:	e0bff517 	ldw	r2,-44(fp)
 200db9c:	1085883a 	add	r2,r2,r2
 200dba0:	e0bff515 	stw	r2,-44(fp)
      while ((block & binblocks) == 0)
 200dba4:	00000606 	br	200dbc0 <_malloc_r+0x788>
      {
        idx += BINBLOCKWIDTH;
 200dba8:	e0bff217 	ldw	r2,-56(fp)
 200dbac:	10800104 	addi	r2,r2,4
 200dbb0:	e0bff215 	stw	r2,-56(fp)
        block <<= 1;
 200dbb4:	e0bff517 	ldw	r2,-44(fp)
 200dbb8:	1085883a 	add	r2,r2,r2
 200dbbc:	e0bff515 	stw	r2,-44(fp)
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
 200dbc0:	008080b4 	movhi	r2,514
 200dbc4:	10800504 	addi	r2,r2,20
 200dbc8:	10c00117 	ldw	r3,4(r2)
 200dbcc:	e0bff517 	ldw	r2,-44(fp)
 200dbd0:	1884703a 	and	r2,r3,r2
 200dbd4:	103ff426 	beq	r2,zero,200dba8 <_malloc_r+0x770>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
 200dbd8:	e0bff217 	ldw	r2,-56(fp)
 200dbdc:	e0bff615 	stw	r2,-40(fp)
      q = bin = bin_at(idx);
 200dbe0:	e0bff217 	ldw	r2,-56(fp)
 200dbe4:	10800044 	addi	r2,r2,1
 200dbe8:	1085883a 	add	r2,r2,r2
 200dbec:	1085883a 	add	r2,r2,r2
 200dbf0:	1087883a 	add	r3,r2,r2
 200dbf4:	008080b4 	movhi	r2,514
 200dbf8:	10800504 	addi	r2,r2,20
 200dbfc:	1885883a 	add	r2,r3,r2
 200dc00:	10bffe04 	addi	r2,r2,-8
 200dc04:	e0bff315 	stw	r2,-52(fp)
 200dc08:	e0bff317 	ldw	r2,-52(fp)
 200dc0c:	e0bff915 	stw	r2,-28(fp)
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 200dc10:	e0bff317 	ldw	r2,-52(fp)
 200dc14:	10800317 	ldw	r2,12(r2)
 200dc18:	e0bff115 	stw	r2,-60(fp)
 200dc1c:	00005e06 	br	200dd98 <_malloc_r+0x960>
        {
          victim_size = chunksize(victim);
 200dc20:	e0bff117 	ldw	r2,-60(fp)
 200dc24:	10c00117 	ldw	r3,4(r2)
 200dc28:	00bfff04 	movi	r2,-4
 200dc2c:	1884703a 	and	r2,r3,r2
 200dc30:	e0bffb15 	stw	r2,-20(fp)
          remainder_size = long_sub_size_t(victim_size, nb);
 200dc34:	e0fffb17 	ldw	r3,-20(fp)
 200dc38:	e0bffa17 	ldw	r2,-24(fp)
 200dc3c:	1885c83a 	sub	r2,r3,r2
 200dc40:	e0bff415 	stw	r2,-48(fp)

          if (remainder_size >= (long)MINSIZE) /* split */
 200dc44:	e0bff417 	ldw	r2,-48(fp)
 200dc48:	10800410 	cmplti	r2,r2,16
 200dc4c:	1000331e 	bne	r2,zero,200dd1c <_malloc_r+0x8e4>
          {
            remainder = chunk_at_offset(victim, nb);
 200dc50:	e0fff117 	ldw	r3,-60(fp)
 200dc54:	e0bffa17 	ldw	r2,-24(fp)
 200dc58:	1885883a 	add	r2,r3,r2
 200dc5c:	e0bffc15 	stw	r2,-16(fp)
            set_head(victim, nb | PREV_INUSE);
 200dc60:	e0bffa17 	ldw	r2,-24(fp)
 200dc64:	10c00054 	ori	r3,r2,1
 200dc68:	e0bff117 	ldw	r2,-60(fp)
 200dc6c:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 200dc70:	e0bff117 	ldw	r2,-60(fp)
 200dc74:	10800317 	ldw	r2,12(r2)
 200dc78:	e0bff815 	stw	r2,-32(fp)
 200dc7c:	e0bff117 	ldw	r2,-60(fp)
 200dc80:	10800217 	ldw	r2,8(r2)
 200dc84:	e0bff715 	stw	r2,-36(fp)
 200dc88:	e0bff717 	ldw	r2,-36(fp)
 200dc8c:	e0fff817 	ldw	r3,-32(fp)
 200dc90:	10c00315 	stw	r3,12(r2)
 200dc94:	e0bff817 	ldw	r2,-32(fp)
 200dc98:	e0fff717 	ldw	r3,-36(fp)
 200dc9c:	10c00215 	stw	r3,8(r2)
            link_last_remainder(remainder);
 200dca0:	00c080b4 	movhi	r3,514
 200dca4:	18c00704 	addi	r3,r3,28
 200dca8:	008080b4 	movhi	r2,514
 200dcac:	10800704 	addi	r2,r2,28
 200dcb0:	e13ffc17 	ldw	r4,-16(fp)
 200dcb4:	11000315 	stw	r4,12(r2)
 200dcb8:	10800317 	ldw	r2,12(r2)
 200dcbc:	18800215 	stw	r2,8(r3)
 200dcc0:	008080b4 	movhi	r2,514
 200dcc4:	10800704 	addi	r2,r2,28
 200dcc8:	e0fffc17 	ldw	r3,-16(fp)
 200dccc:	18800315 	stw	r2,12(r3)
 200dcd0:	e0bffc17 	ldw	r2,-16(fp)
 200dcd4:	10c00317 	ldw	r3,12(r2)
 200dcd8:	e0bffc17 	ldw	r2,-16(fp)
 200dcdc:	10c00215 	stw	r3,8(r2)
            set_head(remainder, remainder_size | PREV_INUSE);
 200dce0:	e0bff417 	ldw	r2,-48(fp)
 200dce4:	10800054 	ori	r2,r2,1
 200dce8:	1007883a 	mov	r3,r2
 200dcec:	e0bffc17 	ldw	r2,-16(fp)
 200dcf0:	10c00115 	stw	r3,4(r2)
            set_foot(remainder, remainder_size);
 200dcf4:	e0bff417 	ldw	r2,-48(fp)
 200dcf8:	e0fffc17 	ldw	r3,-16(fp)
 200dcfc:	1885883a 	add	r2,r3,r2
 200dd00:	e0fff417 	ldw	r3,-48(fp)
 200dd04:	10c00015 	stw	r3,0(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 200dd08:	e13ffe17 	ldw	r4,-8(fp)
 200dd0c:	20147bc0 	call	20147bc <__malloc_unlock>
            return chunk2mem(victim);
 200dd10:	e0bff117 	ldw	r2,-60(fp)
 200dd14:	10800204 	addi	r2,r2,8
 200dd18:	0000a106 	br	200dfa0 <_malloc_r+0xb68>
          }

          else if (remainder_size >= 0)  /* take */
 200dd1c:	e0bff417 	ldw	r2,-48(fp)
 200dd20:	10001a16 	blt	r2,zero,200dd8c <_malloc_r+0x954>
          {
            set_inuse_bit_at_offset(victim, victim_size);
 200dd24:	e0fff117 	ldw	r3,-60(fp)
 200dd28:	e0bffb17 	ldw	r2,-20(fp)
 200dd2c:	1885883a 	add	r2,r3,r2
 200dd30:	e13ff117 	ldw	r4,-60(fp)
 200dd34:	e0fffb17 	ldw	r3,-20(fp)
 200dd38:	20c7883a 	add	r3,r4,r3
 200dd3c:	18c00117 	ldw	r3,4(r3)
 200dd40:	18c00054 	ori	r3,r3,1
 200dd44:	10c00115 	stw	r3,4(r2)
            unlink(victim, bck, fwd);
 200dd48:	e0bff117 	ldw	r2,-60(fp)
 200dd4c:	10800317 	ldw	r2,12(r2)
 200dd50:	e0bff815 	stw	r2,-32(fp)
 200dd54:	e0bff117 	ldw	r2,-60(fp)
 200dd58:	10800217 	ldw	r2,8(r2)
 200dd5c:	e0bff715 	stw	r2,-36(fp)
 200dd60:	e0bff717 	ldw	r2,-36(fp)
 200dd64:	e0fff817 	ldw	r3,-32(fp)
 200dd68:	10c00315 	stw	r3,12(r2)
 200dd6c:	e0bff817 	ldw	r2,-32(fp)
 200dd70:	e0fff717 	ldw	r3,-36(fp)
 200dd74:	10c00215 	stw	r3,8(r2)
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
 200dd78:	e13ffe17 	ldw	r4,-8(fp)
 200dd7c:	20147bc0 	call	20147bc <__malloc_unlock>
            return chunk2mem(victim);
 200dd80:	e0bff117 	ldw	r2,-60(fp)
 200dd84:	10800204 	addi	r2,r2,8
 200dd88:	00008506 	br	200dfa0 <_malloc_r+0xb68>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
 200dd8c:	e0bff117 	ldw	r2,-60(fp)
 200dd90:	10800317 	ldw	r2,12(r2)
 200dd94:	e0bff115 	stw	r2,-60(fp)
 200dd98:	e0fff117 	ldw	r3,-60(fp)
 200dd9c:	e0bff317 	ldw	r2,-52(fp)
 200dda0:	18bf9f1e 	bne	r3,r2,200dc20 <_malloc_r+0x7e8>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
 200dda4:	e0bff317 	ldw	r2,-52(fp)
 200dda8:	10800204 	addi	r2,r2,8
 200ddac:	e0bff315 	stw	r2,-52(fp)
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
 200ddb0:	e0bff217 	ldw	r2,-56(fp)
 200ddb4:	10800044 	addi	r2,r2,1
 200ddb8:	e0bff215 	stw	r2,-56(fp)
 200ddbc:	e0bff217 	ldw	r2,-56(fp)
 200ddc0:	108000cc 	andi	r2,r2,3
 200ddc4:	103f921e 	bne	r2,zero,200dc10 <_malloc_r+0x7d8>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
 200ddc8:	e0bff617 	ldw	r2,-40(fp)
 200ddcc:	108000cc 	andi	r2,r2,3
 200ddd0:	10000a1e 	bne	r2,zero,200ddfc <_malloc_r+0x9c4>
        {
          binblocks &= ~block;
 200ddd4:	008080b4 	movhi	r2,514
 200ddd8:	10800504 	addi	r2,r2,20
 200dddc:	00c080b4 	movhi	r3,514
 200dde0:	18c00504 	addi	r3,r3,20
 200dde4:	19000117 	ldw	r4,4(r3)
 200dde8:	e0fff517 	ldw	r3,-44(fp)
 200ddec:	00c6303a 	nor	r3,zero,r3
 200ddf0:	20c6703a 	and	r3,r4,r3
 200ddf4:	10c00115 	stw	r3,4(r2)
          break;
 200ddf8:	00000a06 	br	200de24 <_malloc_r+0x9ec>
        }
        --startidx;
 200ddfc:	e0bff617 	ldw	r2,-40(fp)
 200de00:	10bfffc4 	addi	r2,r2,-1
 200de04:	e0bff615 	stw	r2,-40(fp)
       q = prev_bin(q);
 200de08:	e0bff917 	ldw	r2,-28(fp)
 200de0c:	10bffe04 	addi	r2,r2,-8
 200de10:	e0bff915 	stw	r2,-28(fp)
      } while (first(q) == q);
 200de14:	e0bff917 	ldw	r2,-28(fp)
 200de18:	10c00217 	ldw	r3,8(r2)
 200de1c:	e0bff917 	ldw	r2,-28(fp)
 200de20:	18bfe926 	beq	r3,r2,200ddc8 <_malloc_r+0x990>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
 200de24:	e0bff517 	ldw	r2,-44(fp)
 200de28:	1085883a 	add	r2,r2,r2
 200de2c:	e0bff515 	stw	r2,-44(fp)
 200de30:	008080b4 	movhi	r2,514
 200de34:	10800504 	addi	r2,r2,20
 200de38:	10c00117 	ldw	r3,4(r2)
 200de3c:	e0bff517 	ldw	r2,-44(fp)
 200de40:	18801036 	bltu	r3,r2,200de84 <_malloc_r+0xa4c>
 200de44:	e0bff517 	ldw	r2,-44(fp)
 200de48:	10000e26 	beq	r2,zero,200de84 <_malloc_r+0xa4c>
      {
        while ((block & binblocks) == 0)
 200de4c:	00000606 	br	200de68 <_malloc_r+0xa30>
        {
          idx += BINBLOCKWIDTH;
 200de50:	e0bff217 	ldw	r2,-56(fp)
 200de54:	10800104 	addi	r2,r2,4
 200de58:	e0bff215 	stw	r2,-56(fp)
          block <<= 1;
 200de5c:	e0bff517 	ldw	r2,-44(fp)
 200de60:	1085883a 	add	r2,r2,r2
 200de64:	e0bff515 	stw	r2,-44(fp)

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
 200de68:	008080b4 	movhi	r2,514
 200de6c:	10800504 	addi	r2,r2,20
 200de70:	10c00117 	ldw	r3,4(r2)
 200de74:	e0bff517 	ldw	r2,-44(fp)
 200de78:	1884703a 	and	r2,r3,r2
 200de7c:	103ff426 	beq	r2,zero,200de50 <_malloc_r+0xa18>
          block <<= 1;
        }
      }
      else
        break;
    }
 200de80:	003f5506 	br	200dbd8 <_malloc_r+0x7a0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  remainder_size = long_sub_size_t(chunksize(top), nb);
 200de84:	008080b4 	movhi	r2,514
 200de88:	10800504 	addi	r2,r2,20
 200de8c:	10800217 	ldw	r2,8(r2)
 200de90:	10c00117 	ldw	r3,4(r2)
 200de94:	00bfff04 	movi	r2,-4
 200de98:	1886703a 	and	r3,r3,r2
 200de9c:	e0bffa17 	ldw	r2,-24(fp)
 200dea0:	1885c83a 	sub	r2,r3,r2
 200dea4:	e0bff415 	stw	r2,-48(fp)
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 200dea8:	008080b4 	movhi	r2,514
 200deac:	10800504 	addi	r2,r2,20
 200deb0:	10800217 	ldw	r2,8(r2)
 200deb4:	10c00117 	ldw	r3,4(r2)
 200deb8:	00bfff04 	movi	r2,-4
 200debc:	1886703a 	and	r3,r3,r2
 200dec0:	e0bffa17 	ldw	r2,-24(fp)
 200dec4:	18800336 	bltu	r3,r2,200ded4 <_malloc_r+0xa9c>
 200dec8:	e0bff417 	ldw	r2,-48(fp)
 200decc:	10800408 	cmpgei	r2,r2,16
 200ded0:	10001b1e 	bne	r2,zero,200df40 <_malloc_r+0xb08>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
 200ded4:	e17ffa17 	ldw	r5,-24(fp)
 200ded8:	e13ffe17 	ldw	r4,-8(fp)
 200dedc:	200d0840 	call	200d084 <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
 200dee0:	008080b4 	movhi	r2,514
 200dee4:	10800504 	addi	r2,r2,20
 200dee8:	10800217 	ldw	r2,8(r2)
 200deec:	10c00117 	ldw	r3,4(r2)
 200def0:	00bfff04 	movi	r2,-4
 200def4:	1886703a 	and	r3,r3,r2
 200def8:	e0bffa17 	ldw	r2,-24(fp)
 200defc:	1885c83a 	sub	r2,r3,r2
 200df00:	e0bff415 	stw	r2,-48(fp)
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
 200df04:	008080b4 	movhi	r2,514
 200df08:	10800504 	addi	r2,r2,20
 200df0c:	10800217 	ldw	r2,8(r2)
 200df10:	10c00117 	ldw	r3,4(r2)
 200df14:	00bfff04 	movi	r2,-4
 200df18:	1886703a 	and	r3,r3,r2
 200df1c:	e0bffa17 	ldw	r2,-24(fp)
 200df20:	18800336 	bltu	r3,r2,200df30 <_malloc_r+0xaf8>
 200df24:	e0bff417 	ldw	r2,-48(fp)
 200df28:	10800408 	cmpgei	r2,r2,16
 200df2c:	1000041e 	bne	r2,zero,200df40 <_malloc_r+0xb08>
    {
      MALLOC_UNLOCK;
 200df30:	e13ffe17 	ldw	r4,-8(fp)
 200df34:	20147bc0 	call	20147bc <__malloc_unlock>
      return 0; /* propagate failure */
 200df38:	0005883a 	mov	r2,zero
 200df3c:	00001806 	br	200dfa0 <_malloc_r+0xb68>
    }
  }

  victim = top;
 200df40:	008080b4 	movhi	r2,514
 200df44:	10800504 	addi	r2,r2,20
 200df48:	10800217 	ldw	r2,8(r2)
 200df4c:	e0bff115 	stw	r2,-60(fp)
  set_head(victim, nb | PREV_INUSE);
 200df50:	e0bffa17 	ldw	r2,-24(fp)
 200df54:	10c00054 	ori	r3,r2,1
 200df58:	e0bff117 	ldw	r2,-60(fp)
 200df5c:	10c00115 	stw	r3,4(r2)
  top = chunk_at_offset(victim, nb);
 200df60:	008080b4 	movhi	r2,514
 200df64:	10800504 	addi	r2,r2,20
 200df68:	e13ff117 	ldw	r4,-60(fp)
 200df6c:	e0fffa17 	ldw	r3,-24(fp)
 200df70:	20c7883a 	add	r3,r4,r3
 200df74:	10c00215 	stw	r3,8(r2)
  set_head(top, remainder_size | PREV_INUSE);
 200df78:	008080b4 	movhi	r2,514
 200df7c:	10800504 	addi	r2,r2,20
 200df80:	10800217 	ldw	r2,8(r2)
 200df84:	e0fff417 	ldw	r3,-48(fp)
 200df88:	18c00054 	ori	r3,r3,1
 200df8c:	10c00115 	stw	r3,4(r2)
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
 200df90:	e13ffe17 	ldw	r4,-8(fp)
 200df94:	20147bc0 	call	20147bc <__malloc_unlock>
  return chunk2mem(victim);
 200df98:	e0bff117 	ldw	r2,-60(fp)
 200df9c:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 200dfa0:	e037883a 	mov	sp,fp
 200dfa4:	dfc00117 	ldw	ra,4(sp)
 200dfa8:	df000017 	ldw	fp,0(sp)
 200dfac:	dec00204 	addi	sp,sp,8
 200dfb0:	f800283a 	ret

0200dfb4 <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
 200dfb4:	defff704 	addi	sp,sp,-36
 200dfb8:	df000815 	stw	fp,32(sp)
 200dfbc:	df000804 	addi	fp,sp,32
 200dfc0:	e13ffd15 	stw	r4,-12(fp)
 200dfc4:	e17ffe15 	stw	r5,-8(fp)
 200dfc8:	e1bfff15 	stw	r6,-4(fp)
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
 200dfcc:	e0bffd17 	ldw	r2,-12(fp)
 200dfd0:	e0bff815 	stw	r2,-32(fp)
  unsigned char d = c;
 200dfd4:	e0bffe17 	ldw	r2,-8(fp)
 200dfd8:	e0bffc05 	stb	r2,-16(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 200dfdc:	00001006 	br	200e020 <memchr+0x6c>
    {
      if (!length--)
 200dfe0:	e0bfff17 	ldw	r2,-4(fp)
 200dfe4:	10ffffc4 	addi	r3,r2,-1
 200dfe8:	e0ffff15 	stw	r3,-4(fp)
 200dfec:	1000021e 	bne	r2,zero,200dff8 <memchr+0x44>
        return NULL;
 200dff0:	0005883a 	mov	r2,zero
 200dff4:	00005a06 	br	200e160 <memchr+0x1ac>
      if (*src == d)
 200dff8:	e0bff817 	ldw	r2,-32(fp)
 200dffc:	10800003 	ldbu	r2,0(r2)
 200e000:	10c03fcc 	andi	r3,r2,255
 200e004:	e0bffc03 	ldbu	r2,-16(fp)
 200e008:	1880021e 	bne	r3,r2,200e014 <memchr+0x60>
        return (void *) src;
 200e00c:	e0bff817 	ldw	r2,-32(fp)
 200e010:	00005306 	br	200e160 <memchr+0x1ac>
      src++;
 200e014:	e0bff817 	ldw	r2,-32(fp)
 200e018:	10800044 	addi	r2,r2,1
 200e01c:	e0bff815 	stw	r2,-32(fp)
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  unsigned int i;

  while (UNALIGNED (src))
 200e020:	e0bff817 	ldw	r2,-32(fp)
 200e024:	108000cc 	andi	r2,r2,3
 200e028:	103fed1e 	bne	r2,zero,200dfe0 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
 200e02c:	e0bfff17 	ldw	r2,-4(fp)
 200e030:	10800130 	cmpltui	r2,r2,4
 200e034:	1000451e 	bne	r2,zero,200e14c <memchr+0x198>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
 200e038:	e0bff817 	ldw	r2,-32(fp)
 200e03c:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
 200e040:	e0bffc03 	ldbu	r2,-16(fp)
 200e044:	1006923a 	slli	r3,r2,8
 200e048:	e0bffc03 	ldbu	r2,-16(fp)
 200e04c:	1884b03a 	or	r2,r3,r2
 200e050:	e0bffa15 	stw	r2,-24(fp)
      mask = mask << 16 | mask;
 200e054:	e0bffa17 	ldw	r2,-24(fp)
 200e058:	1004943a 	slli	r2,r2,16
 200e05c:	e0fffa17 	ldw	r3,-24(fp)
 200e060:	1884b03a 	or	r2,r3,r2
 200e064:	e0bffa15 	stw	r2,-24(fp)
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 200e068:	00800804 	movi	r2,32
 200e06c:	e0bffb15 	stw	r2,-20(fp)
 200e070:	00000906 	br	200e098 <memchr+0xe4>
        mask = (mask << i) | mask;
 200e074:	e0fffa17 	ldw	r3,-24(fp)
 200e078:	e0bffb17 	ldw	r2,-20(fp)
 200e07c:	1884983a 	sll	r2,r3,r2
 200e080:	e0fffa17 	ldw	r3,-24(fp)
 200e084:	1884b03a 	or	r2,r3,r2
 200e088:	e0bffa15 	stw	r2,-24(fp)
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
 200e08c:	e0bffb17 	ldw	r2,-20(fp)
 200e090:	1085883a 	add	r2,r2,r2
 200e094:	e0bffb15 	stw	r2,-20(fp)
 200e098:	e0bffb17 	ldw	r2,-20(fp)
 200e09c:	10800830 	cmpltui	r2,r2,32
 200e0a0:	103ff41e 	bne	r2,zero,200e074 <memchr+0xc0>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 200e0a4:	00001706 	br	200e104 <memchr+0x150>
        {
          if (DETECTCHAR (*asrc, mask))
 200e0a8:	e0bff917 	ldw	r2,-28(fp)
 200e0ac:	10c00017 	ldw	r3,0(r2)
 200e0b0:	e0bffa17 	ldw	r2,-24(fp)
 200e0b4:	1886f03a 	xor	r3,r3,r2
 200e0b8:	00bfbff4 	movhi	r2,65279
 200e0bc:	10bfbfc4 	addi	r2,r2,-257
 200e0c0:	1887883a 	add	r3,r3,r2
 200e0c4:	e0bff917 	ldw	r2,-28(fp)
 200e0c8:	11000017 	ldw	r4,0(r2)
 200e0cc:	e0bffa17 	ldw	r2,-24(fp)
 200e0d0:	2084f03a 	xor	r2,r4,r2
 200e0d4:	0084303a 	nor	r2,zero,r2
 200e0d8:	1886703a 	and	r3,r3,r2
 200e0dc:	00a02074 	movhi	r2,32897
 200e0e0:	10a02004 	addi	r2,r2,-32640
 200e0e4:	1884703a 	and	r2,r3,r2
 200e0e8:	10000a1e 	bne	r2,zero,200e114 <memchr+0x160>
            break;
          length -= LBLOCKSIZE;
 200e0ec:	e0bfff17 	ldw	r2,-4(fp)
 200e0f0:	10bfff04 	addi	r2,r2,-4
 200e0f4:	e0bfff15 	stw	r2,-4(fp)
          asrc++;
 200e0f8:	e0bff917 	ldw	r2,-28(fp)
 200e0fc:	10800104 	addi	r2,r2,4
 200e100:	e0bff915 	stw	r2,-28(fp)
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
 200e104:	e0bfff17 	ldw	r2,-4(fp)
 200e108:	10800128 	cmpgeui	r2,r2,4
 200e10c:	103fe61e 	bne	r2,zero,200e0a8 <memchr+0xf4>
 200e110:	00000106 	br	200e118 <memchr+0x164>
        {
          if (DETECTCHAR (*asrc, mask))
            break;
 200e114:	0001883a 	nop
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
 200e118:	e0bff917 	ldw	r2,-28(fp)
 200e11c:	e0bff815 	stw	r2,-32(fp)
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 200e120:	00000a06 	br	200e14c <memchr+0x198>
    {
      if (*src == d)
 200e124:	e0bff817 	ldw	r2,-32(fp)
 200e128:	10800003 	ldbu	r2,0(r2)
 200e12c:	10c03fcc 	andi	r3,r2,255
 200e130:	e0bffc03 	ldbu	r2,-16(fp)
 200e134:	1880021e 	bne	r3,r2,200e140 <memchr+0x18c>
        return (void *) src;
 200e138:	e0bff817 	ldw	r2,-32(fp)
 200e13c:	00000806 	br	200e160 <memchr+0x1ac>
      src++;
 200e140:	e0bff817 	ldw	r2,-32(fp)
 200e144:	10800044 	addi	r2,r2,1
 200e148:	e0bff815 	stw	r2,-32(fp)
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
 200e14c:	e0bfff17 	ldw	r2,-4(fp)
 200e150:	10ffffc4 	addi	r3,r2,-1
 200e154:	e0ffff15 	stw	r3,-4(fp)
 200e158:	103ff21e 	bne	r2,zero,200e124 <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
 200e15c:	0005883a 	mov	r2,zero
}
 200e160:	e037883a 	mov	sp,fp
 200e164:	df000017 	ldw	fp,0(sp)
 200e168:	dec00104 	addi	sp,sp,4
 200e16c:	f800283a 	ret

0200e170 <memmove>:
__inhibit_loop_to_libcall
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
 200e170:	defff804 	addi	sp,sp,-32
 200e174:	df000715 	stw	fp,28(sp)
 200e178:	df000704 	addi	fp,sp,28
 200e17c:	e13ffd15 	stw	r4,-12(fp)
 200e180:	e17ffe15 	stw	r5,-8(fp)
 200e184:	e1bfff15 	stw	r6,-4(fp)
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
 200e188:	e0bffd17 	ldw	r2,-12(fp)
 200e18c:	e0bff915 	stw	r2,-28(fp)
  _CONST char *src = src_void;
 200e190:	e0bffe17 	ldw	r2,-8(fp)
 200e194:	e0bffa15 	stw	r2,-24(fp)
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 200e198:	e0fffa17 	ldw	r3,-24(fp)
 200e19c:	e0bff917 	ldw	r2,-28(fp)
 200e1a0:	18801d2e 	bgeu	r3,r2,200e218 <memmove+0xa8>
 200e1a4:	e0fffa17 	ldw	r3,-24(fp)
 200e1a8:	e0bfff17 	ldw	r2,-4(fp)
 200e1ac:	1885883a 	add	r2,r3,r2
 200e1b0:	e0fff917 	ldw	r3,-28(fp)
 200e1b4:	1880182e 	bgeu	r3,r2,200e218 <memmove+0xa8>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
 200e1b8:	e0fffa17 	ldw	r3,-24(fp)
 200e1bc:	e0bfff17 	ldw	r2,-4(fp)
 200e1c0:	1885883a 	add	r2,r3,r2
 200e1c4:	e0bffa15 	stw	r2,-24(fp)
      dst += length;
 200e1c8:	e0fff917 	ldw	r3,-28(fp)
 200e1cc:	e0bfff17 	ldw	r2,-4(fp)
 200e1d0:	1885883a 	add	r2,r3,r2
 200e1d4:	e0bff915 	stw	r2,-28(fp)
      while (length--)
 200e1d8:	00000a06 	br	200e204 <memmove+0x94>
	{
	  *--dst = *--src;
 200e1dc:	e0bff917 	ldw	r2,-28(fp)
 200e1e0:	10bfffc4 	addi	r2,r2,-1
 200e1e4:	e0bff915 	stw	r2,-28(fp)
 200e1e8:	e0bffa17 	ldw	r2,-24(fp)
 200e1ec:	10bfffc4 	addi	r2,r2,-1
 200e1f0:	e0bffa15 	stw	r2,-24(fp)
 200e1f4:	e0bffa17 	ldw	r2,-24(fp)
 200e1f8:	10c00003 	ldbu	r3,0(r2)
 200e1fc:	e0bff917 	ldw	r2,-28(fp)
 200e200:	10c00005 	stb	r3,0(r2)
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
 200e204:	e0bfff17 	ldw	r2,-4(fp)
 200e208:	10ffffc4 	addi	r3,r2,-1
 200e20c:	e0ffff15 	stw	r3,-4(fp)
 200e210:	103ff21e 	bne	r2,zero,200e1dc <memmove+0x6c>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
 200e214:	00005306 	br	200e364 <memmove+0x1f4>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
 200e218:	e0bfff17 	ldw	r2,-4(fp)
 200e21c:	10800430 	cmpltui	r2,r2,16
 200e220:	10004c1e 	bne	r2,zero,200e354 <memmove+0x1e4>
 200e224:	e0fffa17 	ldw	r3,-24(fp)
 200e228:	e0bff917 	ldw	r2,-28(fp)
 200e22c:	1884b03a 	or	r2,r3,r2
 200e230:	108000cc 	andi	r2,r2,3
 200e234:	1000471e 	bne	r2,zero,200e354 <memmove+0x1e4>
        {
          aligned_dst = (long*)dst;
 200e238:	e0bff917 	ldw	r2,-28(fp)
 200e23c:	e0bffb15 	stw	r2,-20(fp)
          aligned_src = (long*)src;
 200e240:	e0bffa17 	ldw	r2,-24(fp)
 200e244:	e0bffc15 	stw	r2,-16(fp)

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 200e248:	00002306 	br	200e2d8 <memmove+0x168>
            {
              *aligned_dst++ = *aligned_src++;
 200e24c:	e0bffb17 	ldw	r2,-20(fp)
 200e250:	10c00104 	addi	r3,r2,4
 200e254:	e0fffb15 	stw	r3,-20(fp)
 200e258:	e0fffc17 	ldw	r3,-16(fp)
 200e25c:	19000104 	addi	r4,r3,4
 200e260:	e13ffc15 	stw	r4,-16(fp)
 200e264:	18c00017 	ldw	r3,0(r3)
 200e268:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 200e26c:	e0bffb17 	ldw	r2,-20(fp)
 200e270:	10c00104 	addi	r3,r2,4
 200e274:	e0fffb15 	stw	r3,-20(fp)
 200e278:	e0fffc17 	ldw	r3,-16(fp)
 200e27c:	19000104 	addi	r4,r3,4
 200e280:	e13ffc15 	stw	r4,-16(fp)
 200e284:	18c00017 	ldw	r3,0(r3)
 200e288:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 200e28c:	e0bffb17 	ldw	r2,-20(fp)
 200e290:	10c00104 	addi	r3,r2,4
 200e294:	e0fffb15 	stw	r3,-20(fp)
 200e298:	e0fffc17 	ldw	r3,-16(fp)
 200e29c:	19000104 	addi	r4,r3,4
 200e2a0:	e13ffc15 	stw	r4,-16(fp)
 200e2a4:	18c00017 	ldw	r3,0(r3)
 200e2a8:	10c00015 	stw	r3,0(r2)
              *aligned_dst++ = *aligned_src++;
 200e2ac:	e0bffb17 	ldw	r2,-20(fp)
 200e2b0:	10c00104 	addi	r3,r2,4
 200e2b4:	e0fffb15 	stw	r3,-20(fp)
 200e2b8:	e0fffc17 	ldw	r3,-16(fp)
 200e2bc:	19000104 	addi	r4,r3,4
 200e2c0:	e13ffc15 	stw	r4,-16(fp)
 200e2c4:	18c00017 	ldw	r3,0(r3)
 200e2c8:	10c00015 	stw	r3,0(r2)
              length -= BIGBLOCKSIZE;
 200e2cc:	e0bfff17 	ldw	r2,-4(fp)
 200e2d0:	10bffc04 	addi	r2,r2,-16
 200e2d4:	e0bfff15 	stw	r2,-4(fp)
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
 200e2d8:	e0bfff17 	ldw	r2,-4(fp)
 200e2dc:	10800428 	cmpgeui	r2,r2,16
 200e2e0:	103fda1e 	bne	r2,zero,200e24c <memmove+0xdc>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 200e2e4:	00000b06 	br	200e314 <memmove+0x1a4>
            {
              *aligned_dst++ = *aligned_src++;
 200e2e8:	e0bffb17 	ldw	r2,-20(fp)
 200e2ec:	10c00104 	addi	r3,r2,4
 200e2f0:	e0fffb15 	stw	r3,-20(fp)
 200e2f4:	e0fffc17 	ldw	r3,-16(fp)
 200e2f8:	19000104 	addi	r4,r3,4
 200e2fc:	e13ffc15 	stw	r4,-16(fp)
 200e300:	18c00017 	ldw	r3,0(r3)
 200e304:	10c00015 	stw	r3,0(r2)
              length -= LITTLEBLOCKSIZE;
 200e308:	e0bfff17 	ldw	r2,-4(fp)
 200e30c:	10bfff04 	addi	r2,r2,-4
 200e310:	e0bfff15 	stw	r2,-4(fp)
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
 200e314:	e0bfff17 	ldw	r2,-4(fp)
 200e318:	10800128 	cmpgeui	r2,r2,4
 200e31c:	103ff21e 	bne	r2,zero,200e2e8 <memmove+0x178>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
 200e320:	e0bffb17 	ldw	r2,-20(fp)
 200e324:	e0bff915 	stw	r2,-28(fp)
          src = (char*)aligned_src;
 200e328:	e0bffc17 	ldw	r2,-16(fp)
 200e32c:	e0bffa15 	stw	r2,-24(fp)
        }

      while (length--)
 200e330:	00000806 	br	200e354 <memmove+0x1e4>
        {
          *dst++ = *src++;
 200e334:	e0bff917 	ldw	r2,-28(fp)
 200e338:	10c00044 	addi	r3,r2,1
 200e33c:	e0fff915 	stw	r3,-28(fp)
 200e340:	e0fffa17 	ldw	r3,-24(fp)
 200e344:	19000044 	addi	r4,r3,1
 200e348:	e13ffa15 	stw	r4,-24(fp)
 200e34c:	18c00003 	ldbu	r3,0(r3)
 200e350:	10c00005 	stb	r3,0(r2)
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
 200e354:	e0bfff17 	ldw	r2,-4(fp)
 200e358:	10ffffc4 	addi	r3,r2,-1
 200e35c:	e0ffff15 	stw	r3,-4(fp)
 200e360:	103ff41e 	bne	r2,zero,200e334 <memmove+0x1c4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
 200e364:	e0bffd17 	ldw	r2,-12(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 200e368:	e037883a 	mov	sp,fp
 200e36c:	df000017 	ldw	fp,0(sp)
 200e370:	dec00104 	addi	sp,sp,4
 200e374:	f800283a 	ret

0200e378 <_Balloc>:
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
 200e378:	defffa04 	addi	sp,sp,-24
 200e37c:	dfc00515 	stw	ra,20(sp)
 200e380:	df000415 	stw	fp,16(sp)
 200e384:	df000404 	addi	fp,sp,16
 200e388:	e13ffe15 	stw	r4,-8(fp)
 200e38c:	e17fff15 	stw	r5,-4(fp)
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
 200e390:	e0bffe17 	ldw	r2,-8(fp)
 200e394:	10801317 	ldw	r2,76(r2)
 200e398:	10000c1e 	bne	r2,zero,200e3cc <_Balloc+0x54>
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
 200e39c:	01800844 	movi	r6,33
 200e3a0:	01400104 	movi	r5,4
 200e3a4:	e13ffe17 	ldw	r4,-8(fp)
 200e3a8:	20124040 	call	2012404 <_calloc_r>
 200e3ac:	1007883a 	mov	r3,r2
 200e3b0:	e0bffe17 	ldw	r2,-8(fp)
 200e3b4:	10c01315 	stw	r3,76(r2)
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
 200e3b8:	e0bffe17 	ldw	r2,-8(fp)
 200e3bc:	10801317 	ldw	r2,76(r2)
 200e3c0:	1000021e 	bne	r2,zero,200e3cc <_Balloc+0x54>
	{
	  return NULL;
 200e3c4:	0005883a 	mov	r2,zero
 200e3c8:	00003206 	br	200e494 <_Balloc+0x11c>
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
 200e3cc:	e0bffe17 	ldw	r2,-8(fp)
 200e3d0:	10c01317 	ldw	r3,76(r2)
 200e3d4:	e0bfff17 	ldw	r2,-4(fp)
 200e3d8:	1085883a 	add	r2,r2,r2
 200e3dc:	1085883a 	add	r2,r2,r2
 200e3e0:	1885883a 	add	r2,r3,r2
 200e3e4:	10800017 	ldw	r2,0(r2)
 200e3e8:	e0bffc15 	stw	r2,-16(fp)
 200e3ec:	e0bffc17 	ldw	r2,-16(fp)
 200e3f0:	10000a26 	beq	r2,zero,200e41c <_Balloc+0xa4>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
 200e3f4:	e0bffe17 	ldw	r2,-8(fp)
 200e3f8:	10c01317 	ldw	r3,76(r2)
 200e3fc:	e0bfff17 	ldw	r2,-4(fp)
 200e400:	1085883a 	add	r2,r2,r2
 200e404:	1085883a 	add	r2,r2,r2
 200e408:	1885883a 	add	r2,r3,r2
 200e40c:	e0fffc17 	ldw	r3,-16(fp)
 200e410:	18c00017 	ldw	r3,0(r3)
 200e414:	10c00015 	stw	r3,0(r2)
 200e418:	00001706 	br	200e478 <_Balloc+0x100>
    }
  else
    {
      x = 1 << k;
 200e41c:	00c00044 	movi	r3,1
 200e420:	e0bfff17 	ldw	r2,-4(fp)
 200e424:	1884983a 	sll	r2,r3,r2
 200e428:	e0bffd15 	stw	r2,-12(fp)
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
				  1,
				  sizeof (_Bigint) +
 200e42c:	e0bffd17 	ldw	r2,-12(fp)
    }
  else
    {
      x = 1 << k;
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
 200e430:	10800144 	addi	r2,r2,5
 200e434:	1085883a 	add	r2,r2,r2
 200e438:	1085883a 	add	r2,r2,r2
 200e43c:	100d883a 	mov	r6,r2
 200e440:	01400044 	movi	r5,1
 200e444:	e13ffe17 	ldw	r4,-8(fp)
 200e448:	20124040 	call	2012404 <_calloc_r>
 200e44c:	e0bffc15 	stw	r2,-16(fp)
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
 200e450:	e0bffc17 	ldw	r2,-16(fp)
 200e454:	1000021e 	bne	r2,zero,200e460 <_Balloc+0xe8>
 200e458:	0005883a 	mov	r2,zero
 200e45c:	00000d06 	br	200e494 <_Balloc+0x11c>
      rv->_k = k;
 200e460:	e0bffc17 	ldw	r2,-16(fp)
 200e464:	e0ffff17 	ldw	r3,-4(fp)
 200e468:	10c00115 	stw	r3,4(r2)
      rv->_maxwds = x;
 200e46c:	e0bffc17 	ldw	r2,-16(fp)
 200e470:	e0fffd17 	ldw	r3,-12(fp)
 200e474:	10c00215 	stw	r3,8(r2)
    }
  rv->_sign = rv->_wds = 0;
 200e478:	e0bffc17 	ldw	r2,-16(fp)
 200e47c:	10000415 	stw	zero,16(r2)
 200e480:	e0bffc17 	ldw	r2,-16(fp)
 200e484:	10c00417 	ldw	r3,16(r2)
 200e488:	e0bffc17 	ldw	r2,-16(fp)
 200e48c:	10c00315 	stw	r3,12(r2)
  return rv;
 200e490:	e0bffc17 	ldw	r2,-16(fp)
}
 200e494:	e037883a 	mov	sp,fp
 200e498:	dfc00117 	ldw	ra,4(sp)
 200e49c:	df000017 	ldw	fp,0(sp)
 200e4a0:	dec00204 	addi	sp,sp,8
 200e4a4:	f800283a 	ret

0200e4a8 <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
 200e4a8:	defffd04 	addi	sp,sp,-12
 200e4ac:	df000215 	stw	fp,8(sp)
 200e4b0:	df000204 	addi	fp,sp,8
 200e4b4:	e13ffe15 	stw	r4,-8(fp)
 200e4b8:	e17fff15 	stw	r5,-4(fp)
  _REENT_CHECK_MP(ptr);
  if (v)
 200e4bc:	e0bfff17 	ldw	r2,-4(fp)
 200e4c0:	10001326 	beq	r2,zero,200e510 <_Bfree+0x68>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
 200e4c4:	e0bffe17 	ldw	r2,-8(fp)
 200e4c8:	10c01317 	ldw	r3,76(r2)
 200e4cc:	e0bfff17 	ldw	r2,-4(fp)
 200e4d0:	10800117 	ldw	r2,4(r2)
 200e4d4:	1085883a 	add	r2,r2,r2
 200e4d8:	1085883a 	add	r2,r2,r2
 200e4dc:	1885883a 	add	r2,r3,r2
 200e4e0:	10c00017 	ldw	r3,0(r2)
 200e4e4:	e0bfff17 	ldw	r2,-4(fp)
 200e4e8:	10c00015 	stw	r3,0(r2)
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
 200e4ec:	e0bffe17 	ldw	r2,-8(fp)
 200e4f0:	10c01317 	ldw	r3,76(r2)
 200e4f4:	e0bfff17 	ldw	r2,-4(fp)
 200e4f8:	10800117 	ldw	r2,4(r2)
 200e4fc:	1085883a 	add	r2,r2,r2
 200e500:	1085883a 	add	r2,r2,r2
 200e504:	1885883a 	add	r2,r3,r2
 200e508:	e0ffff17 	ldw	r3,-4(fp)
 200e50c:	10c00015 	stw	r3,0(r2)
    }
}
 200e510:	0001883a 	nop
 200e514:	e037883a 	mov	sp,fp
 200e518:	df000017 	ldw	fp,0(sp)
 200e51c:	dec00104 	addi	sp,sp,4
 200e520:	f800283a 	ret

0200e524 <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
 200e524:	defff304 	addi	sp,sp,-52
 200e528:	dfc00c15 	stw	ra,48(sp)
 200e52c:	df000b15 	stw	fp,44(sp)
 200e530:	df000b04 	addi	fp,sp,44
 200e534:	e13ffc15 	stw	r4,-16(fp)
 200e538:	e17ffd15 	stw	r5,-12(fp)
 200e53c:	e1bffe15 	stw	r6,-8(fp)
 200e540:	e1ffff15 	stw	r7,-4(fp)
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
 200e544:	e0bffd17 	ldw	r2,-12(fp)
 200e548:	10800417 	ldw	r2,16(r2)
 200e54c:	e0bff715 	stw	r2,-36(fp)
  x = b->_x;
 200e550:	e0bffd17 	ldw	r2,-12(fp)
 200e554:	10800504 	addi	r2,r2,20
 200e558:	e0bff615 	stw	r2,-40(fp)
  i = 0;
 200e55c:	e03ff515 	stw	zero,-44(fp)
  do
    {
#ifdef Pack_32
      xi = *x;
 200e560:	e0bff617 	ldw	r2,-40(fp)
 200e564:	10800017 	ldw	r2,0(r2)
 200e568:	e0bff815 	stw	r2,-32(fp)
      y = (xi & 0xffff) * m + a;
 200e56c:	e0bff817 	ldw	r2,-32(fp)
 200e570:	10ffffcc 	andi	r3,r2,65535
 200e574:	e0bffe17 	ldw	r2,-8(fp)
 200e578:	1887383a 	mul	r3,r3,r2
 200e57c:	e0bfff17 	ldw	r2,-4(fp)
 200e580:	1885883a 	add	r2,r3,r2
 200e584:	e0bff915 	stw	r2,-28(fp)
      z = (xi >> 16) * m + (y >> 16);
 200e588:	e0bff817 	ldw	r2,-32(fp)
 200e58c:	1006d43a 	srli	r3,r2,16
 200e590:	e0bffe17 	ldw	r2,-8(fp)
 200e594:	1887383a 	mul	r3,r3,r2
 200e598:	e0bff917 	ldw	r2,-28(fp)
 200e59c:	1004d43a 	srli	r2,r2,16
 200e5a0:	1885883a 	add	r2,r3,r2
 200e5a4:	e0bffa15 	stw	r2,-24(fp)
      a = (int) (z >> 16);
 200e5a8:	e0bffa17 	ldw	r2,-24(fp)
 200e5ac:	1004d43a 	srli	r2,r2,16
 200e5b0:	e0bfff15 	stw	r2,-4(fp)
      *x++ = (z << 16) + (y & 0xffff);
 200e5b4:	e0bff617 	ldw	r2,-40(fp)
 200e5b8:	10c00104 	addi	r3,r2,4
 200e5bc:	e0fff615 	stw	r3,-40(fp)
 200e5c0:	e0fffa17 	ldw	r3,-24(fp)
 200e5c4:	1808943a 	slli	r4,r3,16
 200e5c8:	e0fff917 	ldw	r3,-28(fp)
 200e5cc:	18ffffcc 	andi	r3,r3,65535
 200e5d0:	20c7883a 	add	r3,r4,r3
 200e5d4:	10c00015 	stw	r3,0(r2)
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
 200e5d8:	e0bff517 	ldw	r2,-44(fp)
 200e5dc:	10800044 	addi	r2,r2,1
 200e5e0:	e0bff515 	stw	r2,-44(fp)
 200e5e4:	e0fff517 	ldw	r3,-44(fp)
 200e5e8:	e0bff717 	ldw	r2,-36(fp)
 200e5ec:	18bfdc16 	blt	r3,r2,200e560 <__multadd+0x3c>
  if (a)
 200e5f0:	e0bfff17 	ldw	r2,-4(fp)
 200e5f4:	10002a26 	beq	r2,zero,200e6a0 <__multadd+0x17c>
    {
      if (wds >= b->_maxwds)
 200e5f8:	e0bffd17 	ldw	r2,-12(fp)
 200e5fc:	10800217 	ldw	r2,8(r2)
 200e600:	e0fff717 	ldw	r3,-36(fp)
 200e604:	18801916 	blt	r3,r2,200e66c <__multadd+0x148>
	{
	  b1 = Balloc (ptr, b->_k + 1);
 200e608:	e0bffd17 	ldw	r2,-12(fp)
 200e60c:	10800117 	ldw	r2,4(r2)
 200e610:	10800044 	addi	r2,r2,1
 200e614:	100b883a 	mov	r5,r2
 200e618:	e13ffc17 	ldw	r4,-16(fp)
 200e61c:	200e3780 	call	200e378 <_Balloc>
 200e620:	e0bffb15 	stw	r2,-20(fp)
	  Bcopy (b1, b);
 200e624:	e0bffb17 	ldw	r2,-20(fp)
 200e628:	10c00304 	addi	r3,r2,12
 200e62c:	e0bffd17 	ldw	r2,-12(fp)
 200e630:	11000304 	addi	r4,r2,12
 200e634:	e0bffd17 	ldw	r2,-12(fp)
 200e638:	10800417 	ldw	r2,16(r2)
 200e63c:	10800084 	addi	r2,r2,2
 200e640:	1085883a 	add	r2,r2,r2
 200e644:	1085883a 	add	r2,r2,r2
 200e648:	100d883a 	mov	r6,r2
 200e64c:	200b883a 	mov	r5,r4
 200e650:	1809883a 	mov	r4,r3
 200e654:	20067d00 	call	20067d0 <memcpy>
	  Bfree (ptr, b);
 200e658:	e17ffd17 	ldw	r5,-12(fp)
 200e65c:	e13ffc17 	ldw	r4,-16(fp)
 200e660:	200e4a80 	call	200e4a8 <_Bfree>
	  b = b1;
 200e664:	e0bffb17 	ldw	r2,-20(fp)
 200e668:	e0bffd15 	stw	r2,-12(fp)
	}
      b->_x[wds++] = a;
 200e66c:	e0bff717 	ldw	r2,-36(fp)
 200e670:	10c00044 	addi	r3,r2,1
 200e674:	e0fff715 	stw	r3,-36(fp)
 200e678:	e0ffff17 	ldw	r3,-4(fp)
 200e67c:	e13ffd17 	ldw	r4,-12(fp)
 200e680:	10800144 	addi	r2,r2,5
 200e684:	1085883a 	add	r2,r2,r2
 200e688:	1085883a 	add	r2,r2,r2
 200e68c:	2085883a 	add	r2,r4,r2
 200e690:	10c00015 	stw	r3,0(r2)
      b->_wds = wds;
 200e694:	e0bffd17 	ldw	r2,-12(fp)
 200e698:	e0fff717 	ldw	r3,-36(fp)
 200e69c:	10c00415 	stw	r3,16(r2)
    }
  return b;
 200e6a0:	e0bffd17 	ldw	r2,-12(fp)
}
 200e6a4:	e037883a 	mov	sp,fp
 200e6a8:	dfc00117 	ldw	ra,4(sp)
 200e6ac:	df000017 	ldw	fp,0(sp)
 200e6b0:	dec00204 	addi	sp,sp,8
 200e6b4:	f800283a 	ret

0200e6b8 <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
 200e6b8:	defff504 	addi	sp,sp,-44
 200e6bc:	dfc00a15 	stw	ra,40(sp)
 200e6c0:	df000915 	stw	fp,36(sp)
 200e6c4:	df000904 	addi	fp,sp,36
 200e6c8:	e13ffc15 	stw	r4,-16(fp)
 200e6cc:	e17ffd15 	stw	r5,-12(fp)
 200e6d0:	e1bffe15 	stw	r6,-8(fp)
 200e6d4:	e1ffff15 	stw	r7,-4(fp)
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
 200e6d8:	e0bfff17 	ldw	r2,-4(fp)
 200e6dc:	10800204 	addi	r2,r2,8
 200e6e0:	01400244 	movi	r5,9
 200e6e4:	1009883a 	mov	r4,r2
 200e6e8:	2003ee00 	call	2003ee0 <__divsi3>
 200e6ec:	e0bffb15 	stw	r2,-20(fp)
  for (k = 0, y = 1; x > y; y <<= 1, k++);
 200e6f0:	e03ff915 	stw	zero,-28(fp)
 200e6f4:	00800044 	movi	r2,1
 200e6f8:	e0bffa15 	stw	r2,-24(fp)
 200e6fc:	00000606 	br	200e718 <__s2b+0x60>
 200e700:	e0bffa17 	ldw	r2,-24(fp)
 200e704:	1085883a 	add	r2,r2,r2
 200e708:	e0bffa15 	stw	r2,-24(fp)
 200e70c:	e0bff917 	ldw	r2,-28(fp)
 200e710:	10800044 	addi	r2,r2,1
 200e714:	e0bff915 	stw	r2,-28(fp)
 200e718:	e0bffb17 	ldw	r2,-20(fp)
 200e71c:	e0fffa17 	ldw	r3,-24(fp)
 200e720:	18bff716 	blt	r3,r2,200e700 <__s2b+0x48>
#ifdef Pack_32
  b = Balloc (ptr, k);
 200e724:	e17ff917 	ldw	r5,-28(fp)
 200e728:	e13ffc17 	ldw	r4,-16(fp)
 200e72c:	200e3780 	call	200e378 <_Balloc>
 200e730:	e0bff715 	stw	r2,-36(fp)
  b->_x[0] = y9;
 200e734:	e0bff717 	ldw	r2,-36(fp)
 200e738:	e0c00217 	ldw	r3,8(fp)
 200e73c:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 200e740:	e0bff717 	ldw	r2,-36(fp)
 200e744:	00c00044 	movi	r3,1
 200e748:	10c00415 	stw	r3,16(r2)
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
 200e74c:	00800244 	movi	r2,9
 200e750:	e0bff815 	stw	r2,-32(fp)
  if (9 < nd0)
 200e754:	e0bffe17 	ldw	r2,-8(fp)
 200e758:	10800290 	cmplti	r2,r2,10
 200e75c:	10001b1e 	bne	r2,zero,200e7cc <__s2b+0x114>
    {
      s += 9;
 200e760:	e0bffd17 	ldw	r2,-12(fp)
 200e764:	10800244 	addi	r2,r2,9
 200e768:	e0bffd15 	stw	r2,-12(fp)
      do
	b = multadd (ptr, b, 10, *s++ - '0');
 200e76c:	e0bffd17 	ldw	r2,-12(fp)
 200e770:	10c00044 	addi	r3,r2,1
 200e774:	e0fffd15 	stw	r3,-12(fp)
 200e778:	10800003 	ldbu	r2,0(r2)
 200e77c:	10803fcc 	andi	r2,r2,255
 200e780:	1080201c 	xori	r2,r2,128
 200e784:	10bfe004 	addi	r2,r2,-128
 200e788:	10bff404 	addi	r2,r2,-48
 200e78c:	100f883a 	mov	r7,r2
 200e790:	01800284 	movi	r6,10
 200e794:	e17ff717 	ldw	r5,-36(fp)
 200e798:	e13ffc17 	ldw	r4,-16(fp)
 200e79c:	200e5240 	call	200e524 <__multadd>
 200e7a0:	e0bff715 	stw	r2,-36(fp)
      while (++i < nd0);
 200e7a4:	e0bff817 	ldw	r2,-32(fp)
 200e7a8:	10800044 	addi	r2,r2,1
 200e7ac:	e0bff815 	stw	r2,-32(fp)
 200e7b0:	e0fff817 	ldw	r3,-32(fp)
 200e7b4:	e0bffe17 	ldw	r2,-8(fp)
 200e7b8:	18bfec16 	blt	r3,r2,200e76c <__s2b+0xb4>
      s++;
 200e7bc:	e0bffd17 	ldw	r2,-12(fp)
 200e7c0:	10800044 	addi	r2,r2,1
 200e7c4:	e0bffd15 	stw	r2,-12(fp)
 200e7c8:	00001506 	br	200e820 <__s2b+0x168>
    }
  else
    s += 10;
 200e7cc:	e0bffd17 	ldw	r2,-12(fp)
 200e7d0:	10800284 	addi	r2,r2,10
 200e7d4:	e0bffd15 	stw	r2,-12(fp)
  for (; i < nd; i++)
 200e7d8:	00001106 	br	200e820 <__s2b+0x168>
    b = multadd (ptr, b, 10, *s++ - '0');
 200e7dc:	e0bffd17 	ldw	r2,-12(fp)
 200e7e0:	10c00044 	addi	r3,r2,1
 200e7e4:	e0fffd15 	stw	r3,-12(fp)
 200e7e8:	10800003 	ldbu	r2,0(r2)
 200e7ec:	10803fcc 	andi	r2,r2,255
 200e7f0:	1080201c 	xori	r2,r2,128
 200e7f4:	10bfe004 	addi	r2,r2,-128
 200e7f8:	10bff404 	addi	r2,r2,-48
 200e7fc:	100f883a 	mov	r7,r2
 200e800:	01800284 	movi	r6,10
 200e804:	e17ff717 	ldw	r5,-36(fp)
 200e808:	e13ffc17 	ldw	r4,-16(fp)
 200e80c:	200e5240 	call	200e524 <__multadd>
 200e810:	e0bff715 	stw	r2,-36(fp)
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
 200e814:	e0bff817 	ldw	r2,-32(fp)
 200e818:	10800044 	addi	r2,r2,1
 200e81c:	e0bff815 	stw	r2,-32(fp)
 200e820:	e0fff817 	ldw	r3,-32(fp)
 200e824:	e0bfff17 	ldw	r2,-4(fp)
 200e828:	18bfec16 	blt	r3,r2,200e7dc <__s2b+0x124>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
 200e82c:	e0bff717 	ldw	r2,-36(fp)
}
 200e830:	e037883a 	mov	sp,fp
 200e834:	dfc00117 	ldw	ra,4(sp)
 200e838:	df000017 	ldw	fp,0(sp)
 200e83c:	dec00204 	addi	sp,sp,8
 200e840:	f800283a 	ret

0200e844 <__hi0bits>:

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
 200e844:	defffe04 	addi	sp,sp,-8
 200e848:	df000115 	stw	fp,4(sp)
 200e84c:	dc000015 	stw	r16,0(sp)
 200e850:	df000104 	addi	fp,sp,4
 200e854:	2005883a 	mov	r2,r4
  register int k = 0;
 200e858:	0021883a 	mov	r16,zero

  if (!(x & 0xffff0000))
 200e85c:	10ffffec 	andhi	r3,r2,65535
 200e860:	1800021e 	bne	r3,zero,200e86c <__hi0bits+0x28>
    {
      k = 16;
 200e864:	04000404 	movi	r16,16
      x <<= 16;
 200e868:	1004943a 	slli	r2,r2,16
    }
  if (!(x & 0xff000000))
 200e86c:	10ffc02c 	andhi	r3,r2,65280
 200e870:	1800021e 	bne	r3,zero,200e87c <__hi0bits+0x38>
    {
      k += 8;
 200e874:	84000204 	addi	r16,r16,8
      x <<= 8;
 200e878:	1004923a 	slli	r2,r2,8
    }
  if (!(x & 0xf0000000))
 200e87c:	10fc002c 	andhi	r3,r2,61440
 200e880:	1800021e 	bne	r3,zero,200e88c <__hi0bits+0x48>
    {
      k += 4;
 200e884:	84000104 	addi	r16,r16,4
      x <<= 4;
 200e888:	1004913a 	slli	r2,r2,4
    }
  if (!(x & 0xc0000000))
 200e88c:	10f0002c 	andhi	r3,r2,49152
 200e890:	1800031e 	bne	r3,zero,200e8a0 <__hi0bits+0x5c>
    {
      k += 2;
 200e894:	84000084 	addi	r16,r16,2
      x <<= 2;
 200e898:	1085883a 	add	r2,r2,r2
 200e89c:	1085883a 	add	r2,r2,r2
    }
  if (!(x & 0x80000000))
 200e8a0:	1007883a 	mov	r3,r2
 200e8a4:	18000516 	blt	r3,zero,200e8bc <__hi0bits+0x78>
    {
      k++;
 200e8a8:	84000044 	addi	r16,r16,1
      if (!(x & 0x40000000))
 200e8ac:	1090002c 	andhi	r2,r2,16384
 200e8b0:	1000021e 	bne	r2,zero,200e8bc <__hi0bits+0x78>
	return 32;
 200e8b4:	00800804 	movi	r2,32
 200e8b8:	00000106 	br	200e8c0 <__hi0bits+0x7c>
    }
  return k;
 200e8bc:	8005883a 	mov	r2,r16
}
 200e8c0:	e6ffff04 	addi	sp,fp,-4
 200e8c4:	df000117 	ldw	fp,4(sp)
 200e8c8:	dc000017 	ldw	r16,0(sp)
 200e8cc:	dec00204 	addi	sp,sp,8
 200e8d0:	f800283a 	ret

0200e8d4 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
 200e8d4:	defffc04 	addi	sp,sp,-16
 200e8d8:	df000315 	stw	fp,12(sp)
 200e8dc:	dc400215 	stw	r17,8(sp)
 200e8e0:	dc000115 	stw	r16,4(sp)
 200e8e4:	df000304 	addi	fp,sp,12
 200e8e8:	e13ffd15 	stw	r4,-12(fp)
  register int k;
  register __ULong x = *y;
 200e8ec:	e0bffd17 	ldw	r2,-12(fp)
 200e8f0:	14000017 	ldw	r16,0(r2)

  if (x & 7)
 200e8f4:	808001cc 	andi	r2,r16,7
 200e8f8:	10001026 	beq	r2,zero,200e93c <__lo0bits+0x68>
    {
      if (x & 1)
 200e8fc:	8080004c 	andi	r2,r16,1
 200e900:	10000226 	beq	r2,zero,200e90c <__lo0bits+0x38>
	return 0;
 200e904:	0005883a 	mov	r2,zero
 200e908:	00002706 	br	200e9a8 <__lo0bits+0xd4>
      if (x & 2)
 200e90c:	8080008c 	andi	r2,r16,2
 200e910:	10000526 	beq	r2,zero,200e928 <__lo0bits+0x54>
	{
	  *y = x >> 1;
 200e914:	8006d07a 	srli	r3,r16,1
 200e918:	e0bffd17 	ldw	r2,-12(fp)
 200e91c:	10c00015 	stw	r3,0(r2)
	  return 1;
 200e920:	00800044 	movi	r2,1
 200e924:	00002006 	br	200e9a8 <__lo0bits+0xd4>
	}
      *y = x >> 2;
 200e928:	8006d0ba 	srli	r3,r16,2
 200e92c:	e0bffd17 	ldw	r2,-12(fp)
 200e930:	10c00015 	stw	r3,0(r2)
      return 2;
 200e934:	00800084 	movi	r2,2
 200e938:	00001b06 	br	200e9a8 <__lo0bits+0xd4>
    }
  k = 0;
 200e93c:	0023883a 	mov	r17,zero
  if (!(x & 0xffff))
 200e940:	80bfffcc 	andi	r2,r16,65535
 200e944:	1000021e 	bne	r2,zero,200e950 <__lo0bits+0x7c>
    {
      k = 16;
 200e948:	04400404 	movi	r17,16
      x >>= 16;
 200e94c:	8020d43a 	srli	r16,r16,16
    }
  if (!(x & 0xff))
 200e950:	80803fcc 	andi	r2,r16,255
 200e954:	1000021e 	bne	r2,zero,200e960 <__lo0bits+0x8c>
    {
      k += 8;
 200e958:	8c400204 	addi	r17,r17,8
      x >>= 8;
 200e95c:	8020d23a 	srli	r16,r16,8
    }
  if (!(x & 0xf))
 200e960:	808003cc 	andi	r2,r16,15
 200e964:	1000021e 	bne	r2,zero,200e970 <__lo0bits+0x9c>
    {
      k += 4;
 200e968:	8c400104 	addi	r17,r17,4
      x >>= 4;
 200e96c:	8020d13a 	srli	r16,r16,4
    }
  if (!(x & 0x3))
 200e970:	808000cc 	andi	r2,r16,3
 200e974:	1000021e 	bne	r2,zero,200e980 <__lo0bits+0xac>
    {
      k += 2;
 200e978:	8c400084 	addi	r17,r17,2
      x >>= 2;
 200e97c:	8020d0ba 	srli	r16,r16,2
    }
  if (!(x & 1))
 200e980:	8080004c 	andi	r2,r16,1
 200e984:	1000051e 	bne	r2,zero,200e99c <__lo0bits+0xc8>
    {
      k++;
 200e988:	8c400044 	addi	r17,r17,1
      x >>= 1;
 200e98c:	8020d07a 	srli	r16,r16,1
      if (!x & 1)
 200e990:	8000021e 	bne	r16,zero,200e99c <__lo0bits+0xc8>
	return 32;
 200e994:	00800804 	movi	r2,32
 200e998:	00000306 	br	200e9a8 <__lo0bits+0xd4>
    }
  *y = x;
 200e99c:	e0bffd17 	ldw	r2,-12(fp)
 200e9a0:	14000015 	stw	r16,0(r2)
  return k;
 200e9a4:	8805883a 	mov	r2,r17
}
 200e9a8:	e6fffe04 	addi	sp,fp,-8
 200e9ac:	df000217 	ldw	fp,8(sp)
 200e9b0:	dc400117 	ldw	r17,4(sp)
 200e9b4:	dc000017 	ldw	r16,0(sp)
 200e9b8:	dec00304 	addi	sp,sp,12
 200e9bc:	f800283a 	ret

0200e9c0 <__i2b>:

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
 200e9c0:	defffb04 	addi	sp,sp,-20
 200e9c4:	dfc00415 	stw	ra,16(sp)
 200e9c8:	df000315 	stw	fp,12(sp)
 200e9cc:	df000304 	addi	fp,sp,12
 200e9d0:	e13ffe15 	stw	r4,-8(fp)
 200e9d4:	e17fff15 	stw	r5,-4(fp)
  _Bigint *b;

  b = Balloc (ptr, 1);
 200e9d8:	01400044 	movi	r5,1
 200e9dc:	e13ffe17 	ldw	r4,-8(fp)
 200e9e0:	200e3780 	call	200e378 <_Balloc>
 200e9e4:	e0bffd15 	stw	r2,-12(fp)
  b->_x[0] = i;
 200e9e8:	e0ffff17 	ldw	r3,-4(fp)
 200e9ec:	e0bffd17 	ldw	r2,-12(fp)
 200e9f0:	10c00515 	stw	r3,20(r2)
  b->_wds = 1;
 200e9f4:	e0bffd17 	ldw	r2,-12(fp)
 200e9f8:	00c00044 	movi	r3,1
 200e9fc:	10c00415 	stw	r3,16(r2)
  return b;
 200ea00:	e0bffd17 	ldw	r2,-12(fp)
}
 200ea04:	e037883a 	mov	sp,fp
 200ea08:	dfc00117 	ldw	ra,4(sp)
 200ea0c:	df000017 	ldw	fp,0(sp)
 200ea10:	dec00204 	addi	sp,sp,8
 200ea14:	f800283a 	ret

0200ea18 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
 200ea18:	deffeb04 	addi	sp,sp,-84
 200ea1c:	dfc01415 	stw	ra,80(sp)
 200ea20:	df001315 	stw	fp,76(sp)
 200ea24:	df001304 	addi	fp,sp,76
 200ea28:	e13ffd15 	stw	r4,-12(fp)
 200ea2c:	e17ffe15 	stw	r5,-8(fp)
 200ea30:	e1bfff15 	stw	r6,-4(fp)
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
 200ea34:	e0bffe17 	ldw	r2,-8(fp)
 200ea38:	10c00417 	ldw	r3,16(r2)
 200ea3c:	e0bfff17 	ldw	r2,-4(fp)
 200ea40:	10800417 	ldw	r2,16(r2)
 200ea44:	1880060e 	bge	r3,r2,200ea60 <__multiply+0x48>
    {
      c = a;
 200ea48:	e0bffe17 	ldw	r2,-8(fp)
 200ea4c:	e0bff515 	stw	r2,-44(fp)
      a = b;
 200ea50:	e0bfff17 	ldw	r2,-4(fp)
 200ea54:	e0bffe15 	stw	r2,-8(fp)
      b = c;
 200ea58:	e0bff517 	ldw	r2,-44(fp)
 200ea5c:	e0bfff15 	stw	r2,-4(fp)
    }
  k = a->_k;
 200ea60:	e0bffe17 	ldw	r2,-8(fp)
 200ea64:	10800117 	ldw	r2,4(r2)
 200ea68:	e0bfed15 	stw	r2,-76(fp)
  wa = a->_wds;
 200ea6c:	e0bffe17 	ldw	r2,-8(fp)
 200ea70:	10800417 	ldw	r2,16(r2)
 200ea74:	e0bff615 	stw	r2,-40(fp)
  wb = b->_wds;
 200ea78:	e0bfff17 	ldw	r2,-4(fp)
 200ea7c:	10800417 	ldw	r2,16(r2)
 200ea80:	e0bff715 	stw	r2,-36(fp)
  wc = wa + wb;
 200ea84:	e0fff617 	ldw	r3,-40(fp)
 200ea88:	e0bff717 	ldw	r2,-36(fp)
 200ea8c:	1885883a 	add	r2,r3,r2
 200ea90:	e0bfee15 	stw	r2,-72(fp)
  if (wc > a->_maxwds)
 200ea94:	e0bffe17 	ldw	r2,-8(fp)
 200ea98:	10c00217 	ldw	r3,8(r2)
 200ea9c:	e0bfee17 	ldw	r2,-72(fp)
 200eaa0:	1880030e 	bge	r3,r2,200eab0 <__multiply+0x98>
    k++;
 200eaa4:	e0bfed17 	ldw	r2,-76(fp)
 200eaa8:	10800044 	addi	r2,r2,1
 200eaac:	e0bfed15 	stw	r2,-76(fp)
  c = Balloc (ptr, k);
 200eab0:	e17fed17 	ldw	r5,-76(fp)
 200eab4:	e13ffd17 	ldw	r4,-12(fp)
 200eab8:	200e3780 	call	200e378 <_Balloc>
 200eabc:	e0bff515 	stw	r2,-44(fp)
  for (x = c->_x, xa = x + wc; x < xa; x++)
 200eac0:	e0bff517 	ldw	r2,-44(fp)
 200eac4:	10800504 	addi	r2,r2,20
 200eac8:	e0bff015 	stw	r2,-64(fp)
 200eacc:	e0bfee17 	ldw	r2,-72(fp)
 200ead0:	1085883a 	add	r2,r2,r2
 200ead4:	1085883a 	add	r2,r2,r2
 200ead8:	1007883a 	mov	r3,r2
 200eadc:	e0bff017 	ldw	r2,-64(fp)
 200eae0:	10c5883a 	add	r2,r2,r3
 200eae4:	e0bff815 	stw	r2,-32(fp)
 200eae8:	00000506 	br	200eb00 <__multiply+0xe8>
    *x = 0;
 200eaec:	e0bff017 	ldw	r2,-64(fp)
 200eaf0:	10000015 	stw	zero,0(r2)
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
 200eaf4:	e0bff017 	ldw	r2,-64(fp)
 200eaf8:	10800104 	addi	r2,r2,4
 200eafc:	e0bff015 	stw	r2,-64(fp)
 200eb00:	e0fff017 	ldw	r3,-64(fp)
 200eb04:	e0bff817 	ldw	r2,-32(fp)
 200eb08:	18bff836 	bltu	r3,r2,200eaec <__multiply+0xd4>
    *x = 0;
  xa = a->_x;
 200eb0c:	e0bffe17 	ldw	r2,-8(fp)
 200eb10:	10800504 	addi	r2,r2,20
 200eb14:	e0bff815 	stw	r2,-32(fp)
  xae = xa + wa;
 200eb18:	e0bff617 	ldw	r2,-40(fp)
 200eb1c:	1085883a 	add	r2,r2,r2
 200eb20:	1085883a 	add	r2,r2,r2
 200eb24:	1007883a 	mov	r3,r2
 200eb28:	e0bff817 	ldw	r2,-32(fp)
 200eb2c:	10c5883a 	add	r2,r2,r3
 200eb30:	e0bff915 	stw	r2,-28(fp)
  xb = b->_x;
 200eb34:	e0bfff17 	ldw	r2,-4(fp)
 200eb38:	10800504 	addi	r2,r2,20
 200eb3c:	e0bff115 	stw	r2,-60(fp)
  xbe = xb + wb;
 200eb40:	e0bff717 	ldw	r2,-36(fp)
 200eb44:	1085883a 	add	r2,r2,r2
 200eb48:	1085883a 	add	r2,r2,r2
 200eb4c:	1007883a 	mov	r3,r2
 200eb50:	e0bff117 	ldw	r2,-60(fp)
 200eb54:	10c5883a 	add	r2,r2,r3
 200eb58:	e0bffa15 	stw	r2,-24(fp)
  xc0 = c->_x;
 200eb5c:	e0bff517 	ldw	r2,-44(fp)
 200eb60:	10800504 	addi	r2,r2,20
 200eb64:	e0bff315 	stw	r2,-52(fp)
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
 200eb68:	00007d06 	br	200ed60 <__multiply+0x348>
    {
      if ((y = *xb & 0xffff) != 0)
 200eb6c:	e0bff117 	ldw	r2,-60(fp)
 200eb70:	10800017 	ldw	r2,0(r2)
 200eb74:	10bfffcc 	andi	r2,r2,65535
 200eb78:	e0bffb15 	stw	r2,-20(fp)
 200eb7c:	e0bffb17 	ldw	r2,-20(fp)
 200eb80:	10003426 	beq	r2,zero,200ec54 <__multiply+0x23c>
	{
	  x = xa;
 200eb84:	e0bff817 	ldw	r2,-32(fp)
 200eb88:	e0bff015 	stw	r2,-64(fp)
	  xc = xc0;
 200eb8c:	e0bff317 	ldw	r2,-52(fp)
 200eb90:	e0bff215 	stw	r2,-56(fp)
	  carry = 0;
 200eb94:	e03fef15 	stw	zero,-68(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
 200eb98:	e0bff017 	ldw	r2,-64(fp)
 200eb9c:	10800017 	ldw	r2,0(r2)
 200eba0:	10ffffcc 	andi	r3,r2,65535
 200eba4:	e0bffb17 	ldw	r2,-20(fp)
 200eba8:	1887383a 	mul	r3,r3,r2
 200ebac:	e0bff217 	ldw	r2,-56(fp)
 200ebb0:	10800017 	ldw	r2,0(r2)
 200ebb4:	10bfffcc 	andi	r2,r2,65535
 200ebb8:	1887883a 	add	r3,r3,r2
 200ebbc:	e0bfef17 	ldw	r2,-68(fp)
 200ebc0:	1885883a 	add	r2,r3,r2
 200ebc4:	e0bffc15 	stw	r2,-16(fp)
	      carry = z >> 16;
 200ebc8:	e0bffc17 	ldw	r2,-16(fp)
 200ebcc:	1004d43a 	srli	r2,r2,16
 200ebd0:	e0bfef15 	stw	r2,-68(fp)
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
 200ebd4:	e0bff017 	ldw	r2,-64(fp)
 200ebd8:	10c00104 	addi	r3,r2,4
 200ebdc:	e0fff015 	stw	r3,-64(fp)
 200ebe0:	10800017 	ldw	r2,0(r2)
 200ebe4:	1006d43a 	srli	r3,r2,16
 200ebe8:	e0bffb17 	ldw	r2,-20(fp)
 200ebec:	1887383a 	mul	r3,r3,r2
 200ebf0:	e0bff217 	ldw	r2,-56(fp)
 200ebf4:	10800017 	ldw	r2,0(r2)
 200ebf8:	1004d43a 	srli	r2,r2,16
 200ebfc:	1887883a 	add	r3,r3,r2
 200ec00:	e0bfef17 	ldw	r2,-68(fp)
 200ec04:	1885883a 	add	r2,r3,r2
 200ec08:	e0bff415 	stw	r2,-48(fp)
	      carry = z2 >> 16;
 200ec0c:	e0bff417 	ldw	r2,-48(fp)
 200ec10:	1004d43a 	srli	r2,r2,16
 200ec14:	e0bfef15 	stw	r2,-68(fp)
	      Storeinc (xc, z2, z);
 200ec18:	e0bff217 	ldw	r2,-56(fp)
 200ec1c:	10c00104 	addi	r3,r2,4
 200ec20:	e0fff215 	stw	r3,-56(fp)
 200ec24:	e0fff417 	ldw	r3,-48(fp)
 200ec28:	1808943a 	slli	r4,r3,16
 200ec2c:	e0fffc17 	ldw	r3,-16(fp)
 200ec30:	18ffffcc 	andi	r3,r3,65535
 200ec34:	20c6b03a 	or	r3,r4,r3
 200ec38:	10c00015 	stw	r3,0(r2)
	    }
	  while (x < xae);
 200ec3c:	e0fff017 	ldw	r3,-64(fp)
 200ec40:	e0bff917 	ldw	r2,-28(fp)
 200ec44:	18bfd436 	bltu	r3,r2,200eb98 <__multiply+0x180>
	  *xc = carry;
 200ec48:	e0bff217 	ldw	r2,-56(fp)
 200ec4c:	e0ffef17 	ldw	r3,-68(fp)
 200ec50:	10c00015 	stw	r3,0(r2)
	}
      if ((y = *xb >> 16) != 0)
 200ec54:	e0bff117 	ldw	r2,-60(fp)
 200ec58:	10800017 	ldw	r2,0(r2)
 200ec5c:	1004d43a 	srli	r2,r2,16
 200ec60:	e0bffb15 	stw	r2,-20(fp)
 200ec64:	e0bffb17 	ldw	r2,-20(fp)
 200ec68:	10003726 	beq	r2,zero,200ed48 <__multiply+0x330>
	{
	  x = xa;
 200ec6c:	e0bff817 	ldw	r2,-32(fp)
 200ec70:	e0bff015 	stw	r2,-64(fp)
	  xc = xc0;
 200ec74:	e0bff317 	ldw	r2,-52(fp)
 200ec78:	e0bff215 	stw	r2,-56(fp)
	  carry = 0;
 200ec7c:	e03fef15 	stw	zero,-68(fp)
	  z2 = *xc;
 200ec80:	e0bff217 	ldw	r2,-56(fp)
 200ec84:	10800017 	ldw	r2,0(r2)
 200ec88:	e0bff415 	stw	r2,-48(fp)
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
 200ec8c:	e0bff017 	ldw	r2,-64(fp)
 200ec90:	10800017 	ldw	r2,0(r2)
 200ec94:	10ffffcc 	andi	r3,r2,65535
 200ec98:	e0bffb17 	ldw	r2,-20(fp)
 200ec9c:	1887383a 	mul	r3,r3,r2
 200eca0:	e0bff217 	ldw	r2,-56(fp)
 200eca4:	10800017 	ldw	r2,0(r2)
 200eca8:	1004d43a 	srli	r2,r2,16
 200ecac:	1887883a 	add	r3,r3,r2
 200ecb0:	e0bfef17 	ldw	r2,-68(fp)
 200ecb4:	1885883a 	add	r2,r3,r2
 200ecb8:	e0bffc15 	stw	r2,-16(fp)
	      carry = z >> 16;
 200ecbc:	e0bffc17 	ldw	r2,-16(fp)
 200ecc0:	1004d43a 	srli	r2,r2,16
 200ecc4:	e0bfef15 	stw	r2,-68(fp)
	      Storeinc (xc, z, z2);
 200ecc8:	e0bff217 	ldw	r2,-56(fp)
 200eccc:	10c00104 	addi	r3,r2,4
 200ecd0:	e0fff215 	stw	r3,-56(fp)
 200ecd4:	e0fffc17 	ldw	r3,-16(fp)
 200ecd8:	1808943a 	slli	r4,r3,16
 200ecdc:	e0fff417 	ldw	r3,-48(fp)
 200ece0:	18ffffcc 	andi	r3,r3,65535
 200ece4:	20c6b03a 	or	r3,r4,r3
 200ece8:	10c00015 	stw	r3,0(r2)
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
 200ecec:	e0bff017 	ldw	r2,-64(fp)
 200ecf0:	10c00104 	addi	r3,r2,4
 200ecf4:	e0fff015 	stw	r3,-64(fp)
 200ecf8:	10800017 	ldw	r2,0(r2)
 200ecfc:	1006d43a 	srli	r3,r2,16
 200ed00:	e0bffb17 	ldw	r2,-20(fp)
 200ed04:	1887383a 	mul	r3,r3,r2
 200ed08:	e0bff217 	ldw	r2,-56(fp)
 200ed0c:	10800017 	ldw	r2,0(r2)
 200ed10:	10bfffcc 	andi	r2,r2,65535
 200ed14:	1887883a 	add	r3,r3,r2
 200ed18:	e0bfef17 	ldw	r2,-68(fp)
 200ed1c:	1885883a 	add	r2,r3,r2
 200ed20:	e0bff415 	stw	r2,-48(fp)
	      carry = z2 >> 16;
 200ed24:	e0bff417 	ldw	r2,-48(fp)
 200ed28:	1004d43a 	srli	r2,r2,16
 200ed2c:	e0bfef15 	stw	r2,-68(fp)
	    }
	  while (x < xae);
 200ed30:	e0fff017 	ldw	r3,-64(fp)
 200ed34:	e0bff917 	ldw	r2,-28(fp)
 200ed38:	18bfd436 	bltu	r3,r2,200ec8c <__multiply+0x274>
	  *xc = z2;
 200ed3c:	e0bff217 	ldw	r2,-56(fp)
 200ed40:	e0fff417 	ldw	r3,-48(fp)
 200ed44:	10c00015 	stw	r3,0(r2)
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
 200ed48:	e0bff117 	ldw	r2,-60(fp)
 200ed4c:	10800104 	addi	r2,r2,4
 200ed50:	e0bff115 	stw	r2,-60(fp)
 200ed54:	e0bff317 	ldw	r2,-52(fp)
 200ed58:	10800104 	addi	r2,r2,4
 200ed5c:	e0bff315 	stw	r2,-52(fp)
 200ed60:	e0fff117 	ldw	r3,-60(fp)
 200ed64:	e0bffa17 	ldw	r2,-24(fp)
 200ed68:	18bf8036 	bltu	r3,r2,200eb6c <__multiply+0x154>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
 200ed6c:	e0bff517 	ldw	r2,-44(fp)
 200ed70:	10800504 	addi	r2,r2,20
 200ed74:	e0bff315 	stw	r2,-52(fp)
 200ed78:	e0bfee17 	ldw	r2,-72(fp)
 200ed7c:	1085883a 	add	r2,r2,r2
 200ed80:	1085883a 	add	r2,r2,r2
 200ed84:	1007883a 	mov	r3,r2
 200ed88:	e0bff317 	ldw	r2,-52(fp)
 200ed8c:	10c5883a 	add	r2,r2,r3
 200ed90:	e0bff215 	stw	r2,-56(fp)
 200ed94:	00000306 	br	200eda4 <__multiply+0x38c>
 200ed98:	e0bfee17 	ldw	r2,-72(fp)
 200ed9c:	10bfffc4 	addi	r2,r2,-1
 200eda0:	e0bfee15 	stw	r2,-72(fp)
 200eda4:	e0bfee17 	ldw	r2,-72(fp)
 200eda8:	0080060e 	bge	zero,r2,200edc4 <__multiply+0x3ac>
 200edac:	e0bff217 	ldw	r2,-56(fp)
 200edb0:	10bfff04 	addi	r2,r2,-4
 200edb4:	e0bff215 	stw	r2,-56(fp)
 200edb8:	e0bff217 	ldw	r2,-56(fp)
 200edbc:	10800017 	ldw	r2,0(r2)
 200edc0:	103ff526 	beq	r2,zero,200ed98 <__multiply+0x380>
  c->_wds = wc;
 200edc4:	e0bff517 	ldw	r2,-44(fp)
 200edc8:	e0ffee17 	ldw	r3,-72(fp)
 200edcc:	10c00415 	stw	r3,16(r2)
  return c;
 200edd0:	e0bff517 	ldw	r2,-44(fp)
}
 200edd4:	e037883a 	mov	sp,fp
 200edd8:	dfc00117 	ldw	ra,4(sp)
 200eddc:	df000017 	ldw	fp,0(sp)
 200ede0:	dec00204 	addi	sp,sp,8
 200ede4:	f800283a 	ret

0200ede8 <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
 200ede8:	defff704 	addi	sp,sp,-36
 200edec:	dfc00815 	stw	ra,32(sp)
 200edf0:	df000715 	stw	fp,28(sp)
 200edf4:	df000704 	addi	fp,sp,28
 200edf8:	e13ffd15 	stw	r4,-12(fp)
 200edfc:	e17ffe15 	stw	r5,-8(fp)
 200ee00:	e1bfff15 	stw	r6,-4(fp)
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
 200ee04:	e0bfff17 	ldw	r2,-4(fp)
 200ee08:	108000cc 	andi	r2,r2,3
 200ee0c:	e0bffb15 	stw	r2,-20(fp)
 200ee10:	e0bffb17 	ldw	r2,-20(fp)
 200ee14:	10000e26 	beq	r2,zero,200ee50 <__pow5mult+0x68>
    b = multadd (ptr, b, p05[i - 1], 0);
 200ee18:	e0bffb17 	ldw	r2,-20(fp)
 200ee1c:	10ffffc4 	addi	r3,r2,-1
 200ee20:	008080b4 	movhi	r2,514
 200ee24:	10be5904 	addi	r2,r2,-1692
 200ee28:	18c7883a 	add	r3,r3,r3
 200ee2c:	18c7883a 	add	r3,r3,r3
 200ee30:	10c5883a 	add	r2,r2,r3
 200ee34:	10800017 	ldw	r2,0(r2)
 200ee38:	000f883a 	mov	r7,zero
 200ee3c:	100d883a 	mov	r6,r2
 200ee40:	e17ffe17 	ldw	r5,-8(fp)
 200ee44:	e13ffd17 	ldw	r4,-12(fp)
 200ee48:	200e5240 	call	200e524 <__multadd>
 200ee4c:	e0bffe15 	stw	r2,-8(fp)

  if (!(k >>= 2))
 200ee50:	e0bfff17 	ldw	r2,-4(fp)
 200ee54:	1005d0ba 	srai	r2,r2,2
 200ee58:	e0bfff15 	stw	r2,-4(fp)
 200ee5c:	e0bfff17 	ldw	r2,-4(fp)
 200ee60:	1000021e 	bne	r2,zero,200ee6c <__pow5mult+0x84>
    return b;
 200ee64:	e0bffe17 	ldw	r2,-8(fp)
 200ee68:	00003806 	br	200ef4c <__pow5mult+0x164>
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
 200ee6c:	e0bffd17 	ldw	r2,-12(fp)
 200ee70:	10801217 	ldw	r2,72(r2)
 200ee74:	e0bff915 	stw	r2,-28(fp)
 200ee78:	e0bff917 	ldw	r2,-28(fp)
 200ee7c:	10000b1e 	bne	r2,zero,200eeac <__pow5mult+0xc4>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
 200ee80:	01409c44 	movi	r5,625
 200ee84:	e13ffd17 	ldw	r4,-12(fp)
 200ee88:	200e9c00 	call	200e9c0 <__i2b>
 200ee8c:	1007883a 	mov	r3,r2
 200ee90:	e0bffd17 	ldw	r2,-12(fp)
 200ee94:	10c01215 	stw	r3,72(r2)
 200ee98:	e0bffd17 	ldw	r2,-12(fp)
 200ee9c:	10801217 	ldw	r2,72(r2)
 200eea0:	e0bff915 	stw	r2,-28(fp)
      p5->_next = 0;
 200eea4:	e0bff917 	ldw	r2,-28(fp)
 200eea8:	10000015 	stw	zero,0(r2)
    }
  for (;;)
    {
      if (k & 1)
 200eeac:	e0bfff17 	ldw	r2,-4(fp)
 200eeb0:	1080004c 	andi	r2,r2,1
 200eeb4:	10000a26 	beq	r2,zero,200eee0 <__pow5mult+0xf8>
	{
	  b1 = mult (ptr, b, p5);
 200eeb8:	e1bff917 	ldw	r6,-28(fp)
 200eebc:	e17ffe17 	ldw	r5,-8(fp)
 200eec0:	e13ffd17 	ldw	r4,-12(fp)
 200eec4:	200ea180 	call	200ea18 <__multiply>
 200eec8:	e0bffc15 	stw	r2,-16(fp)
	  Bfree (ptr, b);
 200eecc:	e17ffe17 	ldw	r5,-8(fp)
 200eed0:	e13ffd17 	ldw	r4,-12(fp)
 200eed4:	200e4a80 	call	200e4a8 <_Bfree>
	  b = b1;
 200eed8:	e0bffc17 	ldw	r2,-16(fp)
 200eedc:	e0bffe15 	stw	r2,-8(fp)
	}
      if (!(k >>= 1))
 200eee0:	e0bfff17 	ldw	r2,-4(fp)
 200eee4:	1005d07a 	srai	r2,r2,1
 200eee8:	e0bfff15 	stw	r2,-4(fp)
 200eeec:	e0bfff17 	ldw	r2,-4(fp)
 200eef0:	10001426 	beq	r2,zero,200ef44 <__pow5mult+0x15c>
	break;
      if (!(p51 = p5->_next))
 200eef4:	e0bff917 	ldw	r2,-28(fp)
 200eef8:	10800017 	ldw	r2,0(r2)
 200eefc:	e0bffa15 	stw	r2,-24(fp)
 200ef00:	e0bffa17 	ldw	r2,-24(fp)
 200ef04:	10000c1e 	bne	r2,zero,200ef38 <__pow5mult+0x150>
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
 200ef08:	e1bff917 	ldw	r6,-28(fp)
 200ef0c:	e17ff917 	ldw	r5,-28(fp)
 200ef10:	e13ffd17 	ldw	r4,-12(fp)
 200ef14:	200ea180 	call	200ea18 <__multiply>
 200ef18:	1007883a 	mov	r3,r2
 200ef1c:	e0bff917 	ldw	r2,-28(fp)
 200ef20:	10c00015 	stw	r3,0(r2)
 200ef24:	e0bff917 	ldw	r2,-28(fp)
 200ef28:	10800017 	ldw	r2,0(r2)
 200ef2c:	e0bffa15 	stw	r2,-24(fp)
	  p51->_next = 0;
 200ef30:	e0bffa17 	ldw	r2,-24(fp)
 200ef34:	10000015 	stw	zero,0(r2)
	}
      p5 = p51;
 200ef38:	e0bffa17 	ldw	r2,-24(fp)
 200ef3c:	e0bff915 	stw	r2,-28(fp)
    }
 200ef40:	003fda06 	br	200eeac <__pow5mult+0xc4>
	  b1 = mult (ptr, b, p5);
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
	break;
 200ef44:	0001883a 	nop
	  p51 = p5->_next = mult (ptr, p5, p5);
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
 200ef48:	e0bffe17 	ldw	r2,-8(fp)
}
 200ef4c:	e037883a 	mov	sp,fp
 200ef50:	dfc00117 	ldw	ra,4(sp)
 200ef54:	df000017 	ldw	fp,0(sp)
 200ef58:	dec00204 	addi	sp,sp,8
 200ef5c:	f800283a 	ret

0200ef60 <__lshift>:

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
 200ef60:	defff204 	addi	sp,sp,-56
 200ef64:	dfc00d15 	stw	ra,52(sp)
 200ef68:	df000c15 	stw	fp,48(sp)
 200ef6c:	df000c04 	addi	fp,sp,48
 200ef70:	e13ffd15 	stw	r4,-12(fp)
 200ef74:	e17ffe15 	stw	r5,-8(fp)
 200ef78:	e1bfff15 	stw	r6,-4(fp)
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
 200ef7c:	e0bfff17 	ldw	r2,-4(fp)
 200ef80:	1005d17a 	srai	r2,r2,5
 200ef84:	e0bffa15 	stw	r2,-24(fp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
 200ef88:	e0bffe17 	ldw	r2,-8(fp)
 200ef8c:	10800117 	ldw	r2,4(r2)
 200ef90:	e0bff515 	stw	r2,-44(fp)
  n1 = n + b->_wds + 1;
 200ef94:	e0bffe17 	ldw	r2,-8(fp)
 200ef98:	10c00417 	ldw	r3,16(r2)
 200ef9c:	e0bffa17 	ldw	r2,-24(fp)
 200efa0:	1885883a 	add	r2,r3,r2
 200efa4:	10800044 	addi	r2,r2,1
 200efa8:	e0bff615 	stw	r2,-40(fp)
  for (i = b->_maxwds; n1 > i; i <<= 1)
 200efac:	e0bffe17 	ldw	r2,-8(fp)
 200efb0:	10800217 	ldw	r2,8(r2)
 200efb4:	e0bff415 	stw	r2,-48(fp)
 200efb8:	00000606 	br	200efd4 <__lshift+0x74>
    k1++;
 200efbc:	e0bff517 	ldw	r2,-44(fp)
 200efc0:	10800044 	addi	r2,r2,1
 200efc4:	e0bff515 	stw	r2,-44(fp)
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
 200efc8:	e0bff417 	ldw	r2,-48(fp)
 200efcc:	1085883a 	add	r2,r2,r2
 200efd0:	e0bff415 	stw	r2,-48(fp)
 200efd4:	e0bff617 	ldw	r2,-40(fp)
 200efd8:	e0fff417 	ldw	r3,-48(fp)
 200efdc:	18bff716 	blt	r3,r2,200efbc <__lshift+0x5c>
    k1++;
  b1 = Balloc (ptr, k1);
 200efe0:	e17ff517 	ldw	r5,-44(fp)
 200efe4:	e13ffd17 	ldw	r4,-12(fp)
 200efe8:	200e3780 	call	200e378 <_Balloc>
 200efec:	e0bffb15 	stw	r2,-20(fp)
  x1 = b1->_x;
 200eff0:	e0bffb17 	ldw	r2,-20(fp)
 200eff4:	10800504 	addi	r2,r2,20
 200eff8:	e0bff815 	stw	r2,-32(fp)
  for (i = 0; i < n; i++)
 200effc:	e03ff415 	stw	zero,-48(fp)
 200f000:	00000706 	br	200f020 <__lshift+0xc0>
    *x1++ = 0;
 200f004:	e0bff817 	ldw	r2,-32(fp)
 200f008:	10c00104 	addi	r3,r2,4
 200f00c:	e0fff815 	stw	r3,-32(fp)
 200f010:	10000015 	stw	zero,0(r2)
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
 200f014:	e0bff417 	ldw	r2,-48(fp)
 200f018:	10800044 	addi	r2,r2,1
 200f01c:	e0bff415 	stw	r2,-48(fp)
 200f020:	e0fff417 	ldw	r3,-48(fp)
 200f024:	e0bffa17 	ldw	r2,-24(fp)
 200f028:	18bff616 	blt	r3,r2,200f004 <__lshift+0xa4>
    *x1++ = 0;
  x = b->_x;
 200f02c:	e0bffe17 	ldw	r2,-8(fp)
 200f030:	10800504 	addi	r2,r2,20
 200f034:	e0bff715 	stw	r2,-36(fp)
  xe = x + b->_wds;
 200f038:	e0bffe17 	ldw	r2,-8(fp)
 200f03c:	10800417 	ldw	r2,16(r2)
 200f040:	1085883a 	add	r2,r2,r2
 200f044:	1085883a 	add	r2,r2,r2
 200f048:	1007883a 	mov	r3,r2
 200f04c:	e0bff717 	ldw	r2,-36(fp)
 200f050:	10c5883a 	add	r2,r2,r3
 200f054:	e0bffc15 	stw	r2,-16(fp)
#ifdef Pack_32
  if (k &= 0x1f)
 200f058:	e0bfff17 	ldw	r2,-4(fp)
 200f05c:	108007cc 	andi	r2,r2,31
 200f060:	e0bfff15 	stw	r2,-4(fp)
 200f064:	e0bfff17 	ldw	r2,-4(fp)
 200f068:	10002326 	beq	r2,zero,200f0f8 <__lshift+0x198>
    {
      k1 = 32 - k;
 200f06c:	00c00804 	movi	r3,32
 200f070:	e0bfff17 	ldw	r2,-4(fp)
 200f074:	1885c83a 	sub	r2,r3,r2
 200f078:	e0bff515 	stw	r2,-44(fp)
      z = 0;
 200f07c:	e03ff915 	stw	zero,-28(fp)
      do
	{
	  *x1++ = *x << k | z;
 200f080:	e0bff817 	ldw	r2,-32(fp)
 200f084:	10c00104 	addi	r3,r2,4
 200f088:	e0fff815 	stw	r3,-32(fp)
 200f08c:	e0fff717 	ldw	r3,-36(fp)
 200f090:	19000017 	ldw	r4,0(r3)
 200f094:	e0ffff17 	ldw	r3,-4(fp)
 200f098:	20c8983a 	sll	r4,r4,r3
 200f09c:	e0fff917 	ldw	r3,-28(fp)
 200f0a0:	20c6b03a 	or	r3,r4,r3
 200f0a4:	10c00015 	stw	r3,0(r2)
	  z = *x++ >> k1;
 200f0a8:	e0bff717 	ldw	r2,-36(fp)
 200f0ac:	10c00104 	addi	r3,r2,4
 200f0b0:	e0fff715 	stw	r3,-36(fp)
 200f0b4:	10c00017 	ldw	r3,0(r2)
 200f0b8:	e0bff517 	ldw	r2,-44(fp)
 200f0bc:	1884d83a 	srl	r2,r3,r2
 200f0c0:	e0bff915 	stw	r2,-28(fp)
	}
      while (x < xe);
 200f0c4:	e0fff717 	ldw	r3,-36(fp)
 200f0c8:	e0bffc17 	ldw	r2,-16(fp)
 200f0cc:	18bfec36 	bltu	r3,r2,200f080 <__lshift+0x120>
      if ((*x1 = z) != 0)
 200f0d0:	e0bff817 	ldw	r2,-32(fp)
 200f0d4:	e0fff917 	ldw	r3,-28(fp)
 200f0d8:	10c00015 	stw	r3,0(r2)
 200f0dc:	e0bff817 	ldw	r2,-32(fp)
 200f0e0:	10800017 	ldw	r2,0(r2)
 200f0e4:	10000f26 	beq	r2,zero,200f124 <__lshift+0x1c4>
	++n1;
 200f0e8:	e0bff617 	ldw	r2,-40(fp)
 200f0ec:	10800044 	addi	r2,r2,1
 200f0f0:	e0bff615 	stw	r2,-40(fp)
 200f0f4:	00000b06 	br	200f124 <__lshift+0x1c4>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
 200f0f8:	e0bff817 	ldw	r2,-32(fp)
 200f0fc:	10c00104 	addi	r3,r2,4
 200f100:	e0fff815 	stw	r3,-32(fp)
 200f104:	e0fff717 	ldw	r3,-36(fp)
 200f108:	19000104 	addi	r4,r3,4
 200f10c:	e13ff715 	stw	r4,-36(fp)
 200f110:	18c00017 	ldw	r3,0(r3)
 200f114:	10c00015 	stw	r3,0(r2)
    while (x < xe);
 200f118:	e0fff717 	ldw	r3,-36(fp)
 200f11c:	e0bffc17 	ldw	r2,-16(fp)
 200f120:	18bff536 	bltu	r3,r2,200f0f8 <__lshift+0x198>
  b1->_wds = n1 - 1;
 200f124:	e0bff617 	ldw	r2,-40(fp)
 200f128:	10ffffc4 	addi	r3,r2,-1
 200f12c:	e0bffb17 	ldw	r2,-20(fp)
 200f130:	10c00415 	stw	r3,16(r2)
  Bfree (ptr, b);
 200f134:	e17ffe17 	ldw	r5,-8(fp)
 200f138:	e13ffd17 	ldw	r4,-12(fp)
 200f13c:	200e4a80 	call	200e4a8 <_Bfree>
  return b1;
 200f140:	e0bffb17 	ldw	r2,-20(fp)
}
 200f144:	e037883a 	mov	sp,fp
 200f148:	dfc00117 	ldw	ra,4(sp)
 200f14c:	df000017 	ldw	fp,0(sp)
 200f150:	dec00204 	addi	sp,sp,8
 200f154:	f800283a 	ret

0200f158 <__mcmp>:

int
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
 200f158:	defff704 	addi	sp,sp,-36
 200f15c:	df000815 	stw	fp,32(sp)
 200f160:	df000804 	addi	fp,sp,32
 200f164:	e13ffe15 	stw	r4,-8(fp)
 200f168:	e17fff15 	stw	r5,-4(fp)
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
 200f16c:	e0bffe17 	ldw	r2,-8(fp)
 200f170:	10800417 	ldw	r2,16(r2)
 200f174:	e0bffa15 	stw	r2,-24(fp)
  j = b->_wds;
 200f178:	e0bfff17 	ldw	r2,-4(fp)
 200f17c:	10800417 	ldw	r2,16(r2)
 200f180:	e0bffb15 	stw	r2,-20(fp)
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
 200f184:	e0fffa17 	ldw	r3,-24(fp)
 200f188:	e0bffb17 	ldw	r2,-20(fp)
 200f18c:	1885c83a 	sub	r2,r3,r2
 200f190:	e0bffa15 	stw	r2,-24(fp)
 200f194:	e0bffa17 	ldw	r2,-24(fp)
 200f198:	10000226 	beq	r2,zero,200f1a4 <__mcmp+0x4c>
    return i;
 200f19c:	e0bffa17 	ldw	r2,-24(fp)
 200f1a0:	00002e06 	br	200f25c <__mcmp+0x104>
  xa0 = a->_x;
 200f1a4:	e0bffe17 	ldw	r2,-8(fp)
 200f1a8:	10800504 	addi	r2,r2,20
 200f1ac:	e0bffc15 	stw	r2,-16(fp)
  xa = xa0 + j;
 200f1b0:	e0bffb17 	ldw	r2,-20(fp)
 200f1b4:	1085883a 	add	r2,r2,r2
 200f1b8:	1085883a 	add	r2,r2,r2
 200f1bc:	1007883a 	mov	r3,r2
 200f1c0:	e0bffc17 	ldw	r2,-16(fp)
 200f1c4:	10c5883a 	add	r2,r2,r3
 200f1c8:	e0bff815 	stw	r2,-32(fp)
  xb0 = b->_x;
 200f1cc:	e0bfff17 	ldw	r2,-4(fp)
 200f1d0:	10800504 	addi	r2,r2,20
 200f1d4:	e0bffd15 	stw	r2,-12(fp)
  xb = xb0 + j;
 200f1d8:	e0bffb17 	ldw	r2,-20(fp)
 200f1dc:	1085883a 	add	r2,r2,r2
 200f1e0:	1085883a 	add	r2,r2,r2
 200f1e4:	1007883a 	mov	r3,r2
 200f1e8:	e0bffd17 	ldw	r2,-12(fp)
 200f1ec:	10c5883a 	add	r2,r2,r3
 200f1f0:	e0bff915 	stw	r2,-28(fp)
  for (;;)
    {
      if (*--xa != *--xb)
 200f1f4:	e0bff817 	ldw	r2,-32(fp)
 200f1f8:	10bfff04 	addi	r2,r2,-4
 200f1fc:	e0bff815 	stw	r2,-32(fp)
 200f200:	e0bff817 	ldw	r2,-32(fp)
 200f204:	10c00017 	ldw	r3,0(r2)
 200f208:	e0bff917 	ldw	r2,-28(fp)
 200f20c:	10bfff04 	addi	r2,r2,-4
 200f210:	e0bff915 	stw	r2,-28(fp)
 200f214:	e0bff917 	ldw	r2,-28(fp)
 200f218:	10800017 	ldw	r2,0(r2)
 200f21c:	18800926 	beq	r3,r2,200f244 <__mcmp+0xec>
	return *xa < *xb ? -1 : 1;
 200f220:	e0bff817 	ldw	r2,-32(fp)
 200f224:	10c00017 	ldw	r3,0(r2)
 200f228:	e0bff917 	ldw	r2,-28(fp)
 200f22c:	10800017 	ldw	r2,0(r2)
 200f230:	1880022e 	bgeu	r3,r2,200f23c <__mcmp+0xe4>
 200f234:	00bfffc4 	movi	r2,-1
 200f238:	00000806 	br	200f25c <__mcmp+0x104>
 200f23c:	00800044 	movi	r2,1
 200f240:	00000606 	br	200f25c <__mcmp+0x104>
      if (xa <= xa0)
 200f244:	e0bff817 	ldw	r2,-32(fp)
 200f248:	e0fffc17 	ldw	r3,-16(fp)
 200f24c:	1880012e 	bgeu	r3,r2,200f254 <__mcmp+0xfc>
	break;
    }
 200f250:	003fe806 	br	200f1f4 <__mcmp+0x9c>
  for (;;)
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
 200f254:	0001883a 	nop
    }
  return 0;
 200f258:	0005883a 	mov	r2,zero
}
 200f25c:	e037883a 	mov	sp,fp
 200f260:	df000017 	ldw	fp,0(sp)
 200f264:	dec00104 	addi	sp,sp,4
 200f268:	f800283a 	ret

0200f26c <__mdiff>:

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
 200f26c:	deffef04 	addi	sp,sp,-68
 200f270:	dfc01015 	stw	ra,64(sp)
 200f274:	df000f15 	stw	fp,60(sp)
 200f278:	df000f04 	addi	fp,sp,60
 200f27c:	e13ffd15 	stw	r4,-12(fp)
 200f280:	e17ffe15 	stw	r5,-8(fp)
 200f284:	e1bfff15 	stw	r6,-4(fp)
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
 200f288:	e17fff17 	ldw	r5,-4(fp)
 200f28c:	e13ffe17 	ldw	r4,-8(fp)
 200f290:	200f1580 	call	200f158 <__mcmp>
 200f294:	e0bff115 	stw	r2,-60(fp)
  if (!i)
 200f298:	e0bff117 	ldw	r2,-60(fp)
 200f29c:	10000b1e 	bne	r2,zero,200f2cc <__mdiff+0x60>
    {
      c = Balloc (ptr, 0);
 200f2a0:	000b883a 	mov	r5,zero
 200f2a4:	e13ffd17 	ldw	r4,-12(fp)
 200f2a8:	200e3780 	call	200e378 <_Balloc>
 200f2ac:	e0bff715 	stw	r2,-36(fp)
      c->_wds = 1;
 200f2b0:	e0bff717 	ldw	r2,-36(fp)
 200f2b4:	00c00044 	movi	r3,1
 200f2b8:	10c00415 	stw	r3,16(r2)
      c->_x[0] = 0;
 200f2bc:	e0bff717 	ldw	r2,-36(fp)
 200f2c0:	10000515 	stw	zero,20(r2)
      return c;
 200f2c4:	e0bff717 	ldw	r2,-36(fp)
 200f2c8:	00008c06 	br	200f4fc <__mdiff+0x290>
    }
  if (i < 0)
 200f2cc:	e0bff117 	ldw	r2,-60(fp)
 200f2d0:	1000090e 	bge	r2,zero,200f2f8 <__mdiff+0x8c>
    {
      c = a;
 200f2d4:	e0bffe17 	ldw	r2,-8(fp)
 200f2d8:	e0bff715 	stw	r2,-36(fp)
      a = b;
 200f2dc:	e0bfff17 	ldw	r2,-4(fp)
 200f2e0:	e0bffe15 	stw	r2,-8(fp)
      b = c;
 200f2e4:	e0bff717 	ldw	r2,-36(fp)
 200f2e8:	e0bfff15 	stw	r2,-4(fp)
      i = 1;
 200f2ec:	00800044 	movi	r2,1
 200f2f0:	e0bff115 	stw	r2,-60(fp)
 200f2f4:	00000106 	br	200f2fc <__mdiff+0x90>
    }
  else
    i = 0;
 200f2f8:	e03ff115 	stw	zero,-60(fp)
  c = Balloc (ptr, a->_k);
 200f2fc:	e0bffe17 	ldw	r2,-8(fp)
 200f300:	10800117 	ldw	r2,4(r2)
 200f304:	100b883a 	mov	r5,r2
 200f308:	e13ffd17 	ldw	r4,-12(fp)
 200f30c:	200e3780 	call	200e378 <_Balloc>
 200f310:	e0bff715 	stw	r2,-36(fp)
  c->_sign = i;
 200f314:	e0bff717 	ldw	r2,-36(fp)
 200f318:	e0fff117 	ldw	r3,-60(fp)
 200f31c:	10c00315 	stw	r3,12(r2)
  wa = a->_wds;
 200f320:	e0bffe17 	ldw	r2,-8(fp)
 200f324:	10800417 	ldw	r2,16(r2)
 200f328:	e0bff215 	stw	r2,-56(fp)
  xa = a->_x;
 200f32c:	e0bffe17 	ldw	r2,-8(fp)
 200f330:	10800504 	addi	r2,r2,20
 200f334:	e0bff415 	stw	r2,-48(fp)
  xae = xa + wa;
 200f338:	e0bff217 	ldw	r2,-56(fp)
 200f33c:	1085883a 	add	r2,r2,r2
 200f340:	1085883a 	add	r2,r2,r2
 200f344:	1007883a 	mov	r3,r2
 200f348:	e0bff417 	ldw	r2,-48(fp)
 200f34c:	10c5883a 	add	r2,r2,r3
 200f350:	e0bff815 	stw	r2,-32(fp)
  wb = b->_wds;
 200f354:	e0bfff17 	ldw	r2,-4(fp)
 200f358:	10800417 	ldw	r2,16(r2)
 200f35c:	e0bff915 	stw	r2,-28(fp)
  xb = b->_x;
 200f360:	e0bfff17 	ldw	r2,-4(fp)
 200f364:	10800504 	addi	r2,r2,20
 200f368:	e0bff515 	stw	r2,-44(fp)
  xbe = xb + wb;
 200f36c:	e0bff917 	ldw	r2,-28(fp)
 200f370:	1085883a 	add	r2,r2,r2
 200f374:	1085883a 	add	r2,r2,r2
 200f378:	1007883a 	mov	r3,r2
 200f37c:	e0bff517 	ldw	r2,-44(fp)
 200f380:	10c5883a 	add	r2,r2,r3
 200f384:	e0bffa15 	stw	r2,-24(fp)
  xc = c->_x;
 200f388:	e0bff717 	ldw	r2,-36(fp)
 200f38c:	10800504 	addi	r2,r2,20
 200f390:	e0bff615 	stw	r2,-40(fp)
  borrow = 0;
 200f394:	e03ff315 	stw	zero,-52(fp)
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
 200f398:	e0bff417 	ldw	r2,-48(fp)
 200f39c:	10800017 	ldw	r2,0(r2)
 200f3a0:	10ffffcc 	andi	r3,r2,65535
 200f3a4:	e0bff517 	ldw	r2,-44(fp)
 200f3a8:	10800017 	ldw	r2,0(r2)
 200f3ac:	10bfffcc 	andi	r2,r2,65535
 200f3b0:	1887c83a 	sub	r3,r3,r2
 200f3b4:	e0bff317 	ldw	r2,-52(fp)
 200f3b8:	1885883a 	add	r2,r3,r2
 200f3bc:	e0bffb15 	stw	r2,-20(fp)
      borrow = y >> 16;
 200f3c0:	e0bffb17 	ldw	r2,-20(fp)
 200f3c4:	1005d43a 	srai	r2,r2,16
 200f3c8:	e0bff315 	stw	r2,-52(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
 200f3cc:	e0bff417 	ldw	r2,-48(fp)
 200f3d0:	10c00104 	addi	r3,r2,4
 200f3d4:	e0fff415 	stw	r3,-48(fp)
 200f3d8:	10800017 	ldw	r2,0(r2)
 200f3dc:	1006d43a 	srli	r3,r2,16
 200f3e0:	e0bff517 	ldw	r2,-44(fp)
 200f3e4:	11000104 	addi	r4,r2,4
 200f3e8:	e13ff515 	stw	r4,-44(fp)
 200f3ec:	10800017 	ldw	r2,0(r2)
 200f3f0:	1004d43a 	srli	r2,r2,16
 200f3f4:	1887c83a 	sub	r3,r3,r2
 200f3f8:	e0bff317 	ldw	r2,-52(fp)
 200f3fc:	1885883a 	add	r2,r3,r2
 200f400:	e0bffc15 	stw	r2,-16(fp)
      borrow = z >> 16;
 200f404:	e0bffc17 	ldw	r2,-16(fp)
 200f408:	1005d43a 	srai	r2,r2,16
 200f40c:	e0bff315 	stw	r2,-52(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 200f410:	e0bff617 	ldw	r2,-40(fp)
 200f414:	10c00104 	addi	r3,r2,4
 200f418:	e0fff615 	stw	r3,-40(fp)
 200f41c:	e0fffc17 	ldw	r3,-16(fp)
 200f420:	1808943a 	slli	r4,r3,16
 200f424:	e0fffb17 	ldw	r3,-20(fp)
 200f428:	18ffffcc 	andi	r3,r3,65535
 200f42c:	20c6b03a 	or	r3,r4,r3
 200f430:	10c00015 	stw	r3,0(r2)
    }
  while (xb < xbe);
 200f434:	e0fff517 	ldw	r3,-44(fp)
 200f438:	e0bffa17 	ldw	r2,-24(fp)
 200f43c:	18bfd636 	bltu	r3,r2,200f398 <__mdiff+0x12c>
  while (xa < xae)
 200f440:	00001d06 	br	200f4b8 <__mdiff+0x24c>
    {
      y = (*xa & 0xffff) + borrow;
 200f444:	e0bff417 	ldw	r2,-48(fp)
 200f448:	10800017 	ldw	r2,0(r2)
 200f44c:	10ffffcc 	andi	r3,r2,65535
 200f450:	e0bff317 	ldw	r2,-52(fp)
 200f454:	1885883a 	add	r2,r3,r2
 200f458:	e0bffb15 	stw	r2,-20(fp)
      borrow = y >> 16;
 200f45c:	e0bffb17 	ldw	r2,-20(fp)
 200f460:	1005d43a 	srai	r2,r2,16
 200f464:	e0bff315 	stw	r2,-52(fp)
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
 200f468:	e0bff417 	ldw	r2,-48(fp)
 200f46c:	10c00104 	addi	r3,r2,4
 200f470:	e0fff415 	stw	r3,-48(fp)
 200f474:	10800017 	ldw	r2,0(r2)
 200f478:	1006d43a 	srli	r3,r2,16
 200f47c:	e0bff317 	ldw	r2,-52(fp)
 200f480:	1885883a 	add	r2,r3,r2
 200f484:	e0bffc15 	stw	r2,-16(fp)
      borrow = z >> 16;
 200f488:	e0bffc17 	ldw	r2,-16(fp)
 200f48c:	1005d43a 	srai	r2,r2,16
 200f490:	e0bff315 	stw	r2,-52(fp)
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
 200f494:	e0bff617 	ldw	r2,-40(fp)
 200f498:	10c00104 	addi	r3,r2,4
 200f49c:	e0fff615 	stw	r3,-40(fp)
 200f4a0:	e0fffc17 	ldw	r3,-16(fp)
 200f4a4:	1808943a 	slli	r4,r3,16
 200f4a8:	e0fffb17 	ldw	r3,-20(fp)
 200f4ac:	18ffffcc 	andi	r3,r3,65535
 200f4b0:	20c6b03a 	or	r3,r4,r3
 200f4b4:	10c00015 	stw	r3,0(r2)
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
 200f4b8:	e0fff417 	ldw	r3,-48(fp)
 200f4bc:	e0bff817 	ldw	r2,-32(fp)
 200f4c0:	18bfe036 	bltu	r3,r2,200f444 <__mdiff+0x1d8>
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
 200f4c4:	00000306 	br	200f4d4 <__mdiff+0x268>
    wa--;
 200f4c8:	e0bff217 	ldw	r2,-56(fp)
 200f4cc:	10bfffc4 	addi	r2,r2,-1
 200f4d0:	e0bff215 	stw	r2,-56(fp)
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
 200f4d4:	e0bff617 	ldw	r2,-40(fp)
 200f4d8:	10bfff04 	addi	r2,r2,-4
 200f4dc:	e0bff615 	stw	r2,-40(fp)
 200f4e0:	e0bff617 	ldw	r2,-40(fp)
 200f4e4:	10800017 	ldw	r2,0(r2)
 200f4e8:	103ff726 	beq	r2,zero,200f4c8 <__mdiff+0x25c>
    wa--;
  c->_wds = wa;
 200f4ec:	e0bff717 	ldw	r2,-36(fp)
 200f4f0:	e0fff217 	ldw	r3,-56(fp)
 200f4f4:	10c00415 	stw	r3,16(r2)
  return c;
 200f4f8:	e0bff717 	ldw	r2,-36(fp)
}
 200f4fc:	e037883a 	mov	sp,fp
 200f500:	dfc00117 	ldw	ra,4(sp)
 200f504:	df000017 	ldw	fp,0(sp)
 200f508:	dec00204 	addi	sp,sp,8
 200f50c:	f800283a 	ret

0200f510 <__ulp>:

double
_DEFUN (ulp, (_x), double _x)
{
 200f510:	defff804 	addi	sp,sp,-32
 200f514:	df000715 	stw	fp,28(sp)
 200f518:	dc000615 	stw	r16,24(sp)
 200f51c:	df000704 	addi	fp,sp,28
 200f520:	e13ffd15 	stw	r4,-12(fp)
 200f524:	e17ffe15 	stw	r5,-8(fp)
  union double_union x, a;
  register __Long L;

  x.d = _x;
 200f528:	e0bffd17 	ldw	r2,-12(fp)
 200f52c:	e0bff915 	stw	r2,-28(fp)
 200f530:	e0bffe17 	ldw	r2,-8(fp)
 200f534:	e0bffa15 	stw	r2,-24(fp)

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
 200f538:	e0bffa17 	ldw	r2,-24(fp)
 200f53c:	10dffc2c 	andhi	r3,r2,32752
 200f540:	00bf3034 	movhi	r2,64704
 200f544:	1885883a 	add	r2,r3,r2
 200f548:	1021883a 	mov	r16,r2
#ifndef Sudden_Underflow
  if (L > 0)
 200f54c:	0400040e 	bge	zero,r16,200f560 <__ulp+0x50>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
 200f550:	8005883a 	mov	r2,r16
 200f554:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
 200f558:	e03ffb15 	stw	zero,-20(fp)
 200f55c:	00001406 	br	200f5b0 <__ulp+0xa0>

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
 200f560:	0405c83a 	sub	r2,zero,r16
 200f564:	1021d53a 	srai	r16,r2,20
      if (L < Exp_shift)
 200f568:	80800508 	cmpgei	r2,r16,20
 200f56c:	1000051e 	bne	r2,zero,200f584 <__ulp+0x74>
	{
	  word0 (a) = 0x80000 >> L;
 200f570:	00800234 	movhi	r2,8
 200f574:	1405d83a 	sra	r2,r2,r16
 200f578:	e0bffc15 	stw	r2,-16(fp)
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
 200f57c:	e03ffb15 	stw	zero,-20(fp)
 200f580:	00000b06 	br	200f5b0 <__ulp+0xa0>
#endif
	}
      else
	{
	  word0 (a) = 0;
 200f584:	e03ffc15 	stw	zero,-16(fp)
	  L -= Exp_shift;
 200f588:	843ffb04 	addi	r16,r16,-20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
 200f58c:	808007c8 	cmpgei	r2,r16,31
 200f590:	1000051e 	bne	r2,zero,200f5a8 <__ulp+0x98>
 200f594:	008007c4 	movi	r2,31
 200f598:	1405c83a 	sub	r2,r2,r16
 200f59c:	00c00044 	movi	r3,1
 200f5a0:	1884983a 	sll	r2,r3,r2
 200f5a4:	00000106 	br	200f5ac <__ulp+0x9c>
 200f5a8:	00800044 	movi	r2,1
 200f5ac:	e0bffb15 	stw	r2,-20(fp)
#endif
	}
    }
#endif
  return a.d;
 200f5b0:	e0bffb17 	ldw	r2,-20(fp)
 200f5b4:	e0fffc17 	ldw	r3,-16(fp)
 200f5b8:	1009883a 	mov	r4,r2
 200f5bc:	180b883a 	mov	r5,r3
}
 200f5c0:	2005883a 	mov	r2,r4
 200f5c4:	2807883a 	mov	r3,r5
 200f5c8:	e6ffff04 	addi	sp,fp,-4
 200f5cc:	df000117 	ldw	fp,4(sp)
 200f5d0:	dc000017 	ldw	r16,0(sp)
 200f5d4:	dec00204 	addi	sp,sp,8
 200f5d8:	f800283a 	ret

0200f5dc <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
 200f5dc:	defff404 	addi	sp,sp,-48
 200f5e0:	dfc00b15 	stw	ra,44(sp)
 200f5e4:	df000a15 	stw	fp,40(sp)
 200f5e8:	df000a04 	addi	fp,sp,40
 200f5ec:	e13ffe15 	stw	r4,-8(fp)
 200f5f0:	e17fff15 	stw	r5,-4(fp)
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
 200f5f4:	e0bffe17 	ldw	r2,-8(fp)
 200f5f8:	10800504 	addi	r2,r2,20
 200f5fc:	e0bff715 	stw	r2,-36(fp)
  xa = xa0 + a->_wds;
 200f600:	e0bffe17 	ldw	r2,-8(fp)
 200f604:	10800417 	ldw	r2,16(r2)
 200f608:	1085883a 	add	r2,r2,r2
 200f60c:	1085883a 	add	r2,r2,r2
 200f610:	1007883a 	mov	r3,r2
 200f614:	e0bff717 	ldw	r2,-36(fp)
 200f618:	10c5883a 	add	r2,r2,r3
 200f61c:	e0bff615 	stw	r2,-40(fp)
  y = *--xa;
 200f620:	e0bff617 	ldw	r2,-40(fp)
 200f624:	10bfff04 	addi	r2,r2,-4
 200f628:	e0bff615 	stw	r2,-40(fp)
 200f62c:	e0bff617 	ldw	r2,-40(fp)
 200f630:	10800017 	ldw	r2,0(r2)
 200f634:	e0bff815 	stw	r2,-32(fp)
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
 200f638:	e13ff817 	ldw	r4,-32(fp)
 200f63c:	200e8440 	call	200e844 <__hi0bits>
 200f640:	e0bff915 	stw	r2,-28(fp)
  *e = 32 - k;
 200f644:	00c00804 	movi	r3,32
 200f648:	e0bff917 	ldw	r2,-28(fp)
 200f64c:	1887c83a 	sub	r3,r3,r2
 200f650:	e0bfff17 	ldw	r2,-4(fp)
 200f654:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
  if (k < Ebits)
 200f658:	e0bff917 	ldw	r2,-28(fp)
 200f65c:	108002c8 	cmpgei	r2,r2,11
 200f660:	10001e1e 	bne	r2,zero,200f6dc <__b2d+0x100>
    {
      d0 = Exp_1 | y >> (Ebits - k);
 200f664:	00c002c4 	movi	r3,11
 200f668:	e0bff917 	ldw	r2,-28(fp)
 200f66c:	1885c83a 	sub	r2,r3,r2
 200f670:	e0fff817 	ldw	r3,-32(fp)
 200f674:	1884d83a 	srl	r2,r3,r2
 200f678:	108ffc34 	orhi	r2,r2,16368
 200f67c:	e0bffd15 	stw	r2,-12(fp)
      w = xa > xa0 ? *--xa : 0;
 200f680:	e0bff617 	ldw	r2,-40(fp)
 200f684:	e0fff717 	ldw	r3,-36(fp)
 200f688:	1880062e 	bgeu	r3,r2,200f6a4 <__b2d+0xc8>
 200f68c:	e0bff617 	ldw	r2,-40(fp)
 200f690:	10bfff04 	addi	r2,r2,-4
 200f694:	e0bff615 	stw	r2,-40(fp)
 200f698:	e0bff617 	ldw	r2,-40(fp)
 200f69c:	10800017 	ldw	r2,0(r2)
 200f6a0:	00000106 	br	200f6a8 <__b2d+0xcc>
 200f6a4:	0005883a 	mov	r2,zero
 200f6a8:	e0bffa15 	stw	r2,-24(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
 200f6ac:	e0bff917 	ldw	r2,-28(fp)
 200f6b0:	10800544 	addi	r2,r2,21
 200f6b4:	e0fff817 	ldw	r3,-32(fp)
 200f6b8:	1886983a 	sll	r3,r3,r2
 200f6bc:	010002c4 	movi	r4,11
 200f6c0:	e0bff917 	ldw	r2,-28(fp)
 200f6c4:	2085c83a 	sub	r2,r4,r2
 200f6c8:	e13ffa17 	ldw	r4,-24(fp)
 200f6cc:	2084d83a 	srl	r2,r4,r2
 200f6d0:	1884b03a 	or	r2,r3,r2
 200f6d4:	e0bffc15 	stw	r2,-16(fp)
#endif
      goto ret_d;
 200f6d8:	00003606 	br	200f7b4 <__b2d+0x1d8>
    }
  z = xa > xa0 ? *--xa : 0;
 200f6dc:	e0bff617 	ldw	r2,-40(fp)
 200f6e0:	e0fff717 	ldw	r3,-36(fp)
 200f6e4:	1880062e 	bgeu	r3,r2,200f700 <__b2d+0x124>
 200f6e8:	e0bff617 	ldw	r2,-40(fp)
 200f6ec:	10bfff04 	addi	r2,r2,-4
 200f6f0:	e0bff615 	stw	r2,-40(fp)
 200f6f4:	e0bff617 	ldw	r2,-40(fp)
 200f6f8:	10800017 	ldw	r2,0(r2)
 200f6fc:	00000106 	br	200f704 <__b2d+0x128>
 200f700:	0005883a 	mov	r2,zero
 200f704:	e0bffb15 	stw	r2,-20(fp)
  if (k -= Ebits)
 200f708:	e0bff917 	ldw	r2,-28(fp)
 200f70c:	10bffd44 	addi	r2,r2,-11
 200f710:	e0bff915 	stw	r2,-28(fp)
 200f714:	e0bff917 	ldw	r2,-28(fp)
 200f718:	10002126 	beq	r2,zero,200f7a0 <__b2d+0x1c4>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
 200f71c:	e0fff817 	ldw	r3,-32(fp)
 200f720:	e0bff917 	ldw	r2,-28(fp)
 200f724:	1886983a 	sll	r3,r3,r2
 200f728:	01000804 	movi	r4,32
 200f72c:	e0bff917 	ldw	r2,-28(fp)
 200f730:	2085c83a 	sub	r2,r4,r2
 200f734:	e13ffb17 	ldw	r4,-20(fp)
 200f738:	2084d83a 	srl	r2,r4,r2
 200f73c:	1884b03a 	or	r2,r3,r2
 200f740:	108ffc34 	orhi	r2,r2,16368
 200f744:	e0bffd15 	stw	r2,-12(fp)
      y = xa > xa0 ? *--xa : 0;
 200f748:	e0bff617 	ldw	r2,-40(fp)
 200f74c:	e0fff717 	ldw	r3,-36(fp)
 200f750:	1880062e 	bgeu	r3,r2,200f76c <__b2d+0x190>
 200f754:	e0bff617 	ldw	r2,-40(fp)
 200f758:	10bfff04 	addi	r2,r2,-4
 200f75c:	e0bff615 	stw	r2,-40(fp)
 200f760:	e0bff617 	ldw	r2,-40(fp)
 200f764:	10800017 	ldw	r2,0(r2)
 200f768:	00000106 	br	200f770 <__b2d+0x194>
 200f76c:	0005883a 	mov	r2,zero
 200f770:	e0bff815 	stw	r2,-32(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
 200f774:	e0fffb17 	ldw	r3,-20(fp)
 200f778:	e0bff917 	ldw	r2,-28(fp)
 200f77c:	1886983a 	sll	r3,r3,r2
 200f780:	01000804 	movi	r4,32
 200f784:	e0bff917 	ldw	r2,-28(fp)
 200f788:	2085c83a 	sub	r2,r4,r2
 200f78c:	e13ff817 	ldw	r4,-32(fp)
 200f790:	2084d83a 	srl	r2,r4,r2
 200f794:	1884b03a 	or	r2,r3,r2
 200f798:	e0bffc15 	stw	r2,-16(fp)
 200f79c:	00000506 	br	200f7b4 <__b2d+0x1d8>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
 200f7a0:	e0bff817 	ldw	r2,-32(fp)
 200f7a4:	108ffc34 	orhi	r2,r2,16368
 200f7a8:	e0bffd15 	stw	r2,-12(fp)
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
 200f7ac:	e0bffb17 	ldw	r2,-20(fp)
 200f7b0:	e0bffc15 	stw	r2,-16(fp)
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
 200f7b4:	e0bffc17 	ldw	r2,-16(fp)
 200f7b8:	e0fffd17 	ldw	r3,-12(fp)
 200f7bc:	1009883a 	mov	r4,r2
 200f7c0:	180b883a 	mov	r5,r3
}
 200f7c4:	2005883a 	mov	r2,r4
 200f7c8:	2807883a 	mov	r3,r5
 200f7cc:	e037883a 	mov	sp,fp
 200f7d0:	dfc00117 	ldw	ra,4(sp)
 200f7d4:	df000017 	ldw	fp,0(sp)
 200f7d8:	dec00204 	addi	sp,sp,8
 200f7dc:	f800283a 	ret

0200f7e0 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
 200f7e0:	defff004 	addi	sp,sp,-64
 200f7e4:	dfc00f15 	stw	ra,60(sp)
 200f7e8:	df000e15 	stw	fp,56(sp)
 200f7ec:	dc000d15 	stw	r16,52(sp)
 200f7f0:	df000e04 	addi	fp,sp,56
 200f7f4:	e13ffb15 	stw	r4,-20(fp)
 200f7f8:	e17ffc15 	stw	r5,-16(fp)
 200f7fc:	e1bffd15 	stw	r6,-12(fp)
 200f800:	e1fffe15 	stw	r7,-8(fp)
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
 200f804:	e0bffc17 	ldw	r2,-16(fp)
 200f808:	e0bff715 	stw	r2,-36(fp)
 200f80c:	e0bffd17 	ldw	r2,-12(fp)
 200f810:	e0bff815 	stw	r2,-32(fp)
  d0 = word0 (d) >> 16 | word0 (d) << 16;
  d1 = word1 (d) >> 16 | word1 (d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
  d.d = _d;
 200f814:	e0bffc17 	ldw	r2,-16(fp)
 200f818:	e0bff715 	stw	r2,-36(fp)
 200f81c:	e0bffd17 	ldw	r2,-12(fp)
 200f820:	e0bff815 	stw	r2,-32(fp)
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
 200f824:	01400044 	movi	r5,1
 200f828:	e13ffb17 	ldw	r4,-20(fp)
 200f82c:	200e3780 	call	200e378 <_Balloc>
 200f830:	e0bff415 	stw	r2,-48(fp)
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;
 200f834:	e0bff417 	ldw	r2,-48(fp)
 200f838:	10800504 	addi	r2,r2,20
 200f83c:	e0bff515 	stw	r2,-44(fp)

  z = d0 & Frac_mask;
 200f840:	e0fff817 	ldw	r3,-32(fp)
 200f844:	00800434 	movhi	r2,16
 200f848:	10bfffc4 	addi	r2,r2,-1
 200f84c:	1884703a 	and	r2,r3,r2
 200f850:	e0bffa15 	stw	r2,-24(fp)
  d0 &= 0x7fffffff;		/* clear sign bit, which we ignore */
 200f854:	e0fff817 	ldw	r3,-32(fp)
 200f858:	00a00034 	movhi	r2,32768
 200f85c:	10bfffc4 	addi	r2,r2,-1
 200f860:	1884703a 	and	r2,r3,r2
 200f864:	e0bff815 	stw	r2,-32(fp)
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
 200f868:	e0bff817 	ldw	r2,-32(fp)
 200f86c:	1004d53a 	srli	r2,r2,20
 200f870:	e0bff615 	stw	r2,-40(fp)
 200f874:	e0bff617 	ldw	r2,-40(fp)
 200f878:	10000326 	beq	r2,zero,200f888 <__d2b+0xa8>
    z |= Exp_msk1;
 200f87c:	e0bffa17 	ldw	r2,-24(fp)
 200f880:	10800434 	orhi	r2,r2,16
 200f884:	e0bffa15 	stw	r2,-24(fp)
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
 200f888:	e0bff717 	ldw	r2,-36(fp)
 200f88c:	10002826 	beq	r2,zero,200f930 <__d2b+0x150>
    {
      y = d1;
 200f890:	e0bff717 	ldw	r2,-36(fp)
 200f894:	e0bff915 	stw	r2,-28(fp)
      k = lo0bits (&y);
 200f898:	e0bff904 	addi	r2,fp,-28
 200f89c:	1009883a 	mov	r4,r2
 200f8a0:	200e8d40 	call	200e8d4 <__lo0bits>
 200f8a4:	e0bff315 	stw	r2,-52(fp)
      if (k)
 200f8a8:	e0bff317 	ldw	r2,-52(fp)
 200f8ac:	10000e26 	beq	r2,zero,200f8e8 <__d2b+0x108>
	{
         x[0] = y | z << (32 - k);
 200f8b0:	e0fffa17 	ldw	r3,-24(fp)
 200f8b4:	01000804 	movi	r4,32
 200f8b8:	e0bff317 	ldw	r2,-52(fp)
 200f8bc:	2085c83a 	sub	r2,r4,r2
 200f8c0:	1886983a 	sll	r3,r3,r2
 200f8c4:	e0bff917 	ldw	r2,-28(fp)
 200f8c8:	1886b03a 	or	r3,r3,r2
 200f8cc:	e0bff517 	ldw	r2,-44(fp)
 200f8d0:	10c00015 	stw	r3,0(r2)
	  z >>= k;
 200f8d4:	e0fffa17 	ldw	r3,-24(fp)
 200f8d8:	e0bff317 	ldw	r2,-52(fp)
 200f8dc:	1884d83a 	srl	r2,r3,r2
 200f8e0:	e0bffa15 	stw	r2,-24(fp)
 200f8e4:	00000306 	br	200f8f4 <__d2b+0x114>
	}
      else
	x[0] = y;
 200f8e8:	e0fff917 	ldw	r3,-28(fp)
 200f8ec:	e0bff517 	ldw	r2,-44(fp)
 200f8f0:	10c00015 	stw	r3,0(r2)
      i = b->_wds = (x[1] = z) ? 2 : 1;
 200f8f4:	e0bff517 	ldw	r2,-44(fp)
 200f8f8:	10800104 	addi	r2,r2,4
 200f8fc:	e0fffa17 	ldw	r3,-24(fp)
 200f900:	10c00015 	stw	r3,0(r2)
 200f904:	10800017 	ldw	r2,0(r2)
 200f908:	10000226 	beq	r2,zero,200f914 <__d2b+0x134>
 200f90c:	00800084 	movi	r2,2
 200f910:	00000106 	br	200f918 <__d2b+0x138>
 200f914:	00800044 	movi	r2,1
 200f918:	e0fff417 	ldw	r3,-48(fp)
 200f91c:	18800415 	stw	r2,16(r3)
 200f920:	e0bff417 	ldw	r2,-48(fp)
 200f924:	10800417 	ldw	r2,16(r2)
 200f928:	e0bff215 	stw	r2,-56(fp)
 200f92c:	00001006 	br	200f970 <__d2b+0x190>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
 200f930:	e0bffa04 	addi	r2,fp,-24
 200f934:	1009883a 	mov	r4,r2
 200f938:	200e8d40 	call	200e8d4 <__lo0bits>
 200f93c:	e0bff315 	stw	r2,-52(fp)
      x[0] = z;
 200f940:	e0fffa17 	ldw	r3,-24(fp)
 200f944:	e0bff517 	ldw	r2,-44(fp)
 200f948:	10c00015 	stw	r3,0(r2)
      i = b->_wds = 1;
 200f94c:	e0bff417 	ldw	r2,-48(fp)
 200f950:	00c00044 	movi	r3,1
 200f954:	10c00415 	stw	r3,16(r2)
 200f958:	e0bff417 	ldw	r2,-48(fp)
 200f95c:	10800417 	ldw	r2,16(r2)
 200f960:	e0bff215 	stw	r2,-56(fp)
#ifndef _DOUBLE_IS_32BITS
      k += 32;
 200f964:	e0bff317 	ldw	r2,-52(fp)
 200f968:	10800804 	addi	r2,r2,32
 200f96c:	e0bff315 	stw	r2,-52(fp)
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
 200f970:	e0bff617 	ldw	r2,-40(fp)
 200f974:	10000c26 	beq	r2,zero,200f9a8 <__d2b+0x1c8>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
 200f978:	e0bff617 	ldw	r2,-40(fp)
 200f97c:	10fef344 	addi	r3,r2,-1075
 200f980:	e0bff317 	ldw	r2,-52(fp)
 200f984:	1887883a 	add	r3,r3,r2
 200f988:	e0bffe17 	ldw	r2,-8(fp)
 200f98c:	10c00015 	stw	r3,0(r2)
      *bits = P - k;
 200f990:	00c00d44 	movi	r3,53
 200f994:	e0bff317 	ldw	r2,-52(fp)
 200f998:	1887c83a 	sub	r3,r3,r2
 200f99c:	e0800217 	ldw	r2,8(fp)
 200f9a0:	10c00015 	stw	r3,0(r2)
 200f9a4:	00001706 	br	200fa04 <__d2b+0x224>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
 200f9a8:	e0bff617 	ldw	r2,-40(fp)
 200f9ac:	10fef384 	addi	r3,r2,-1074
 200f9b0:	e0bff317 	ldw	r2,-52(fp)
 200f9b4:	1887883a 	add	r3,r3,r2
 200f9b8:	e0bffe17 	ldw	r2,-8(fp)
 200f9bc:	10c00015 	stw	r3,0(r2)
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
 200f9c0:	e0bff217 	ldw	r2,-56(fp)
 200f9c4:	1020917a 	slli	r16,r2,5
 200f9c8:	e0fff217 	ldw	r3,-56(fp)
 200f9cc:	00900034 	movhi	r2,16384
 200f9d0:	10bfffc4 	addi	r2,r2,-1
 200f9d4:	1885883a 	add	r2,r3,r2
 200f9d8:	1085883a 	add	r2,r2,r2
 200f9dc:	1085883a 	add	r2,r2,r2
 200f9e0:	1007883a 	mov	r3,r2
 200f9e4:	e0bff517 	ldw	r2,-44(fp)
 200f9e8:	10c5883a 	add	r2,r2,r3
 200f9ec:	10800017 	ldw	r2,0(r2)
 200f9f0:	1009883a 	mov	r4,r2
 200f9f4:	200e8440 	call	200e844 <__hi0bits>
 200f9f8:	8087c83a 	sub	r3,r16,r2
 200f9fc:	e0800217 	ldw	r2,8(fp)
 200fa00:	10c00015 	stw	r3,0(r2)
#else
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
 200fa04:	e0bff417 	ldw	r2,-48(fp)
}
 200fa08:	e6ffff04 	addi	sp,fp,-4
 200fa0c:	dfc00217 	ldw	ra,8(sp)
 200fa10:	df000117 	ldw	fp,4(sp)
 200fa14:	dc000017 	ldw	r16,0(sp)
 200fa18:	dec00304 	addi	sp,sp,12
 200fa1c:	f800283a 	ret

0200fa20 <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
 200fa20:	defff504 	addi	sp,sp,-44
 200fa24:	dfc00a15 	stw	ra,40(sp)
 200fa28:	df000915 	stw	fp,36(sp)
 200fa2c:	df000904 	addi	fp,sp,36
 200fa30:	e13ffe15 	stw	r4,-8(fp)
 200fa34:	e17fff15 	stw	r5,-4(fp)
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
 200fa38:	e0bffc04 	addi	r2,fp,-16
 200fa3c:	100b883a 	mov	r5,r2
 200fa40:	e13ffe17 	ldw	r4,-8(fp)
 200fa44:	200f5dc0 	call	200f5dc <__b2d>
 200fa48:	1009883a 	mov	r4,r2
 200fa4c:	180b883a 	mov	r5,r3
 200fa50:	e13ff815 	stw	r4,-32(fp)
 200fa54:	e17ff915 	stw	r5,-28(fp)
  db.d = b2d (b, &kb);
 200fa58:	e0bffd04 	addi	r2,fp,-12
 200fa5c:	100b883a 	mov	r5,r2
 200fa60:	e13fff17 	ldw	r4,-4(fp)
 200fa64:	200f5dc0 	call	200f5dc <__b2d>
 200fa68:	1009883a 	mov	r4,r2
 200fa6c:	180b883a 	mov	r5,r3
 200fa70:	e13ffa15 	stw	r4,-24(fp)
 200fa74:	e17ffb15 	stw	r5,-20(fp)
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
 200fa78:	e0fffc17 	ldw	r3,-16(fp)
 200fa7c:	e0bffd17 	ldw	r2,-12(fp)
 200fa80:	1887c83a 	sub	r3,r3,r2
 200fa84:	e0bffe17 	ldw	r2,-8(fp)
 200fa88:	11000417 	ldw	r4,16(r2)
 200fa8c:	e0bfff17 	ldw	r2,-4(fp)
 200fa90:	10800417 	ldw	r2,16(r2)
 200fa94:	2085c83a 	sub	r2,r4,r2
 200fa98:	1004917a 	slli	r2,r2,5
 200fa9c:	1885883a 	add	r2,r3,r2
 200faa0:	e0bff715 	stw	r2,-36(fp)
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
 200faa4:	e0bff717 	ldw	r2,-36(fp)
 200faa8:	0080060e 	bge	zero,r2,200fac4 <__ratio+0xa4>
    word0 (da) += k * Exp_msk1;
 200faac:	e0fff917 	ldw	r3,-28(fp)
 200fab0:	e0bff717 	ldw	r2,-36(fp)
 200fab4:	1004953a 	slli	r2,r2,20
 200fab8:	1885883a 	add	r2,r3,r2
 200fabc:	e0bff915 	stw	r2,-28(fp)
 200fac0:	00000806 	br	200fae4 <__ratio+0xc4>
  else
    {
      k = -k;
 200fac4:	e0bff717 	ldw	r2,-36(fp)
 200fac8:	0085c83a 	sub	r2,zero,r2
 200facc:	e0bff715 	stw	r2,-36(fp)
      word0 (db) += k * Exp_msk1;
 200fad0:	e0fffb17 	ldw	r3,-20(fp)
 200fad4:	e0bff717 	ldw	r2,-36(fp)
 200fad8:	1004953a 	slli	r2,r2,20
 200fadc:	1885883a 	add	r2,r3,r2
 200fae0:	e0bffb15 	stw	r2,-20(fp)
    }
#endif
  return da.d / db.d;
 200fae4:	e0bff817 	ldw	r2,-32(fp)
 200fae8:	e0fff917 	ldw	r3,-28(fp)
 200faec:	e13ffa17 	ldw	r4,-24(fp)
 200faf0:	e17ffb17 	ldw	r5,-20(fp)
 200faf4:	200d883a 	mov	r6,r4
 200faf8:	280f883a 	mov	r7,r5
 200fafc:	1009883a 	mov	r4,r2
 200fb00:	180b883a 	mov	r5,r3
 200fb04:	20049400 	call	2004940 <__divdf3>
 200fb08:	100f883a 	mov	r7,r2
 200fb0c:	1811883a 	mov	r8,r3
 200fb10:	380b883a 	mov	r5,r7
 200fb14:	400d883a 	mov	r6,r8
 200fb18:	2807883a 	mov	r3,r5
 200fb1c:	3009883a 	mov	r4,r6
}
 200fb20:	1805883a 	mov	r2,r3
 200fb24:	2007883a 	mov	r3,r4
 200fb28:	e037883a 	mov	sp,fp
 200fb2c:	dfc00117 	ldw	ra,4(sp)
 200fb30:	df000017 	ldw	fp,0(sp)
 200fb34:	dec00204 	addi	sp,sp,8
 200fb38:	f800283a 	ret

0200fb3c <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
 200fb3c:	defffb04 	addi	sp,sp,-20
 200fb40:	dfc00415 	stw	ra,16(sp)
 200fb44:	df000315 	stw	fp,12(sp)
 200fb48:	df000304 	addi	fp,sp,12
 200fb4c:	e13fff15 	stw	r4,-4(fp)
  double v = 1.0;
 200fb50:	e03ffd15 	stw	zero,-12(fp)
 200fb54:	008ffc34 	movhi	r2,16368
 200fb58:	e0bffe15 	stw	r2,-8(fp)
  if (dig < 24)
 200fb5c:	e0bfff17 	ldw	r2,-4(fp)
 200fb60:	10800608 	cmpgei	r2,r2,24
 200fb64:	1000141e 	bne	r2,zero,200fbb8 <_mprec_log10+0x7c>
    return tens[dig];
 200fb68:	008080b4 	movhi	r2,514
 200fb6c:	10be1304 	addi	r2,r2,-1972
 200fb70:	e0ffff17 	ldw	r3,-4(fp)
 200fb74:	180690fa 	slli	r3,r3,3
 200fb78:	10c9883a 	add	r4,r2,r3
 200fb7c:	20800017 	ldw	r2,0(r4)
 200fb80:	20c00117 	ldw	r3,4(r4)
 200fb84:	00001006 	br	200fbc8 <_mprec_log10+0x8c>
  while (dig > 0)
    {
      v *= 10;
 200fb88:	000d883a 	mov	r6,zero
 200fb8c:	01d00934 	movhi	r7,16420
 200fb90:	e13ffd17 	ldw	r4,-12(fp)
 200fb94:	e17ffe17 	ldw	r5,-8(fp)
 200fb98:	20054800 	call	2005480 <__muldf3>
 200fb9c:	1009883a 	mov	r4,r2
 200fba0:	180b883a 	mov	r5,r3
 200fba4:	e13ffd15 	stw	r4,-12(fp)
 200fba8:	e17ffe15 	stw	r5,-8(fp)
      dig--;
 200fbac:	e0bfff17 	ldw	r2,-4(fp)
 200fbb0:	10bfffc4 	addi	r2,r2,-1
 200fbb4:	e0bfff15 	stw	r2,-4(fp)
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
 200fbb8:	e0bfff17 	ldw	r2,-4(fp)
 200fbbc:	00bff216 	blt	zero,r2,200fb88 <_mprec_log10+0x4c>
    {
      v *= 10;
      dig--;
    }
  return v;
 200fbc0:	e0bffd17 	ldw	r2,-12(fp)
 200fbc4:	e0fffe17 	ldw	r3,-8(fp)
 200fbc8:	1009883a 	mov	r4,r2
 200fbcc:	180b883a 	mov	r5,r3
}
 200fbd0:	2005883a 	mov	r2,r4
 200fbd4:	2807883a 	mov	r3,r5
 200fbd8:	e037883a 	mov	sp,fp
 200fbdc:	dfc00117 	ldw	ra,4(sp)
 200fbe0:	df000017 	ldw	fp,0(sp)
 200fbe4:	dec00204 	addi	sp,sp,8
 200fbe8:	f800283a 	ret

0200fbec <__copybits>:
void
_DEFUN (copybits, (c, n, b),
	__ULong *c _AND
	int n _AND
	_Bigint *b)
{
 200fbec:	defff904 	addi	sp,sp,-28
 200fbf0:	df000615 	stw	fp,24(sp)
 200fbf4:	df000604 	addi	fp,sp,24
 200fbf8:	e13ffd15 	stw	r4,-12(fp)
 200fbfc:	e17ffe15 	stw	r5,-8(fp)
 200fc00:	e1bfff15 	stw	r6,-4(fp)
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
 200fc04:	e0bffe17 	ldw	r2,-8(fp)
 200fc08:	10bfffc4 	addi	r2,r2,-1
 200fc0c:	1005d17a 	srai	r2,r2,5
 200fc10:	10800044 	addi	r2,r2,1
 200fc14:	1085883a 	add	r2,r2,r2
 200fc18:	1085883a 	add	r2,r2,r2
 200fc1c:	1007883a 	mov	r3,r2
 200fc20:	e0bffd17 	ldw	r2,-12(fp)
 200fc24:	10c5883a 	add	r2,r2,r3
 200fc28:	e0bffb15 	stw	r2,-20(fp)
	x = b->_x;
 200fc2c:	e0bfff17 	ldw	r2,-4(fp)
 200fc30:	10800504 	addi	r2,r2,20
 200fc34:	e0bffa15 	stw	r2,-24(fp)
#ifdef Pack_32
	xe = x + b->_wds;
 200fc38:	e0bfff17 	ldw	r2,-4(fp)
 200fc3c:	10800417 	ldw	r2,16(r2)
 200fc40:	1085883a 	add	r2,r2,r2
 200fc44:	1085883a 	add	r2,r2,r2
 200fc48:	1007883a 	mov	r3,r2
 200fc4c:	e0bffa17 	ldw	r2,-24(fp)
 200fc50:	10c5883a 	add	r2,r2,r3
 200fc54:	e0bffc15 	stw	r2,-16(fp)
	while(x < xe)
 200fc58:	00000806 	br	200fc7c <__copybits+0x90>
		*c++ = *x++;
 200fc5c:	e0bffd17 	ldw	r2,-12(fp)
 200fc60:	10c00104 	addi	r3,r2,4
 200fc64:	e0fffd15 	stw	r3,-12(fp)
 200fc68:	e0fffa17 	ldw	r3,-24(fp)
 200fc6c:	19000104 	addi	r4,r3,4
 200fc70:	e13ffa15 	stw	r4,-24(fp)
 200fc74:	18c00017 	ldw	r3,0(r3)
 200fc78:	10c00015 	stw	r3,0(r2)

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
 200fc7c:	e0fffa17 	ldw	r3,-24(fp)
 200fc80:	e0bffc17 	ldw	r2,-16(fp)
 200fc84:	18bff536 	bltu	r3,r2,200fc5c <__copybits+0x70>
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
 200fc88:	00000406 	br	200fc9c <__copybits+0xb0>
		*c++ = 0;
 200fc8c:	e0bffd17 	ldw	r2,-12(fp)
 200fc90:	10c00104 	addi	r3,r2,4
 200fc94:	e0fffd15 	stw	r3,-12(fp)
 200fc98:	10000015 	stw	zero,0(r2)
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
 200fc9c:	e0fffd17 	ldw	r3,-12(fp)
 200fca0:	e0bffb17 	ldw	r2,-20(fp)
 200fca4:	18bff936 	bltu	r3,r2,200fc8c <__copybits+0xa0>
		*c++ = 0;
}
 200fca8:	0001883a 	nop
 200fcac:	e037883a 	mov	sp,fp
 200fcb0:	df000017 	ldw	fp,0(sp)
 200fcb4:	dec00104 	addi	sp,sp,4
 200fcb8:	f800283a 	ret

0200fcbc <__any_on>:

__ULong
_DEFUN (any_on, (b, k),
	_Bigint *b _AND
	int k)
{
 200fcbc:	defff704 	addi	sp,sp,-36
 200fcc0:	df000815 	stw	fp,32(sp)
 200fcc4:	df000804 	addi	fp,sp,32
 200fcc8:	e13ffe15 	stw	r4,-8(fp)
 200fccc:	e17fff15 	stw	r5,-4(fp)
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
 200fcd0:	e0bffe17 	ldw	r2,-8(fp)
 200fcd4:	10800504 	addi	r2,r2,20
 200fcd8:	e0bff915 	stw	r2,-28(fp)
	nwds = b->_wds;
 200fcdc:	e0bffe17 	ldw	r2,-8(fp)
 200fce0:	10800417 	ldw	r2,16(r2)
 200fce4:	e0bffa15 	stw	r2,-24(fp)
	n = k >> kshift;
 200fce8:	e0bfff17 	ldw	r2,-4(fp)
 200fcec:	1005d17a 	srai	r2,r2,5
 200fcf0:	e0bff815 	stw	r2,-32(fp)
	if (n > nwds)
 200fcf4:	e0bff817 	ldw	r2,-32(fp)
 200fcf8:	e0fffa17 	ldw	r3,-24(fp)
 200fcfc:	1880030e 	bge	r3,r2,200fd0c <__any_on+0x50>
		n = nwds;
 200fd00:	e0bffa17 	ldw	r2,-24(fp)
 200fd04:	e0bff815 	stw	r2,-32(fp)
 200fd08:	00001f06 	br	200fd88 <__any_on+0xcc>
	else if (n < nwds && (k &= kmask)) {
 200fd0c:	e0fff817 	ldw	r3,-32(fp)
 200fd10:	e0bffa17 	ldw	r2,-24(fp)
 200fd14:	18801c0e 	bge	r3,r2,200fd88 <__any_on+0xcc>
 200fd18:	e0bfff17 	ldw	r2,-4(fp)
 200fd1c:	108007cc 	andi	r2,r2,31
 200fd20:	e0bfff15 	stw	r2,-4(fp)
 200fd24:	e0bfff17 	ldw	r2,-4(fp)
 200fd28:	10001726 	beq	r2,zero,200fd88 <__any_on+0xcc>
		x1 = x2 = x[n];
 200fd2c:	e0bff817 	ldw	r2,-32(fp)
 200fd30:	1085883a 	add	r2,r2,r2
 200fd34:	1085883a 	add	r2,r2,r2
 200fd38:	1007883a 	mov	r3,r2
 200fd3c:	e0bff917 	ldw	r2,-28(fp)
 200fd40:	10c5883a 	add	r2,r2,r3
 200fd44:	10800017 	ldw	r2,0(r2)
 200fd48:	e0bffb15 	stw	r2,-20(fp)
 200fd4c:	e0bffb17 	ldw	r2,-20(fp)
 200fd50:	e0bffc15 	stw	r2,-16(fp)
		x1 >>= k;
 200fd54:	e0fffc17 	ldw	r3,-16(fp)
 200fd58:	e0bfff17 	ldw	r2,-4(fp)
 200fd5c:	1884d83a 	srl	r2,r3,r2
 200fd60:	e0bffc15 	stw	r2,-16(fp)
		x1 <<= k;
 200fd64:	e0fffc17 	ldw	r3,-16(fp)
 200fd68:	e0bfff17 	ldw	r2,-4(fp)
 200fd6c:	1884983a 	sll	r2,r3,r2
 200fd70:	e0bffc15 	stw	r2,-16(fp)
		if (x1 != x2)
 200fd74:	e0fffc17 	ldw	r3,-16(fp)
 200fd78:	e0bffb17 	ldw	r2,-20(fp)
 200fd7c:	18800226 	beq	r3,r2,200fd88 <__any_on+0xcc>
			return 1;
 200fd80:	00800044 	movi	r2,1
 200fd84:	00001606 	br	200fde0 <__any_on+0x124>
		}
	x0 = x;
 200fd88:	e0bff917 	ldw	r2,-28(fp)
 200fd8c:	e0bffd15 	stw	r2,-12(fp)
	x += n;
 200fd90:	e0bff817 	ldw	r2,-32(fp)
 200fd94:	1085883a 	add	r2,r2,r2
 200fd98:	1085883a 	add	r2,r2,r2
 200fd9c:	1007883a 	mov	r3,r2
 200fda0:	e0bff917 	ldw	r2,-28(fp)
 200fda4:	10c5883a 	add	r2,r2,r3
 200fda8:	e0bff915 	stw	r2,-28(fp)
	while(x > x0)
 200fdac:	00000806 	br	200fdd0 <__any_on+0x114>
		if (*--x)
 200fdb0:	e0bff917 	ldw	r2,-28(fp)
 200fdb4:	10bfff04 	addi	r2,r2,-4
 200fdb8:	e0bff915 	stw	r2,-28(fp)
 200fdbc:	e0bff917 	ldw	r2,-28(fp)
 200fdc0:	10800017 	ldw	r2,0(r2)
 200fdc4:	10000226 	beq	r2,zero,200fdd0 <__any_on+0x114>
			return 1;
 200fdc8:	00800044 	movi	r2,1
 200fdcc:	00000406 	br	200fde0 <__any_on+0x124>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
 200fdd0:	e0bff917 	ldw	r2,-28(fp)
 200fdd4:	e0fffd17 	ldw	r3,-12(fp)
 200fdd8:	18bff536 	bltu	r3,r2,200fdb0 <__any_on+0xf4>
		if (*--x)
			return 1;
	return 0;
 200fddc:	0005883a 	mov	r2,zero
}
 200fde0:	e037883a 	mov	sp,fp
 200fde4:	df000017 	ldw	fp,0(sp)
 200fde8:	dec00104 	addi	sp,sp,4
 200fdec:	f800283a 	ret

0200fdf0 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
 200fdf0:	deffe104 	addi	sp,sp,-124
 200fdf4:	dfc01e15 	stw	ra,120(sp)
 200fdf8:	df001d15 	stw	fp,116(sp)
 200fdfc:	df001d04 	addi	fp,sp,116
 200fe00:	e13ffd15 	stw	r4,-12(fp)
 200fe04:	e17ffe15 	stw	r5,-8(fp)
 200fe08:	e1bfff15 	stw	r6,-4(fp)
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
 200fe0c:	e0bffe17 	ldw	r2,-8(fp)
 200fe10:	1000041e 	bne	r2,zero,200fe24 <_realloc_r+0x34>
 200fe14:	e17fff17 	ldw	r5,-4(fp)
 200fe18:	e13ffd17 	ldw	r4,-12(fp)
 200fe1c:	200d4380 	call	200d438 <_malloc_r>
 200fe20:	0002ea06 	br	20109cc <_realloc_r+0xbdc>

  MALLOC_LOCK;
 200fe24:	e13ffd17 	ldw	r4,-12(fp)
 200fe28:	201469c0 	call	201469c <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
 200fe2c:	e0bffe17 	ldw	r2,-8(fp)
 200fe30:	10bffe04 	addi	r2,r2,-8
 200fe34:	e0bfef15 	stw	r2,-68(fp)
 200fe38:	e0bfef17 	ldw	r2,-68(fp)
 200fe3c:	e0bfe315 	stw	r2,-116(fp)
  newsize = oldsize = chunksize(oldp);
 200fe40:	e0bfef17 	ldw	r2,-68(fp)
 200fe44:	10c00117 	ldw	r3,4(r2)
 200fe48:	00bfff04 	movi	r2,-4
 200fe4c:	1884703a 	and	r2,r3,r2
 200fe50:	e0bff015 	stw	r2,-64(fp)
 200fe54:	e0bff017 	ldw	r2,-64(fp)
 200fe58:	e0bfe415 	stw	r2,-112(fp)


  nb = request2size(bytes);
 200fe5c:	e0bfff17 	ldw	r2,-4(fp)
 200fe60:	108002c4 	addi	r2,r2,11
 200fe64:	108005f0 	cmpltui	r2,r2,23
 200fe68:	1000051e 	bne	r2,zero,200fe80 <_realloc_r+0x90>
 200fe6c:	e0bfff17 	ldw	r2,-4(fp)
 200fe70:	10c002c4 	addi	r3,r2,11
 200fe74:	00bffe04 	movi	r2,-8
 200fe78:	1884703a 	and	r2,r3,r2
 200fe7c:	00000106 	br	200fe84 <_realloc_r+0x94>
 200fe80:	00800404 	movi	r2,16
 200fe84:	e0bff115 	stw	r2,-60(fp)

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
 200fe88:	e0bff117 	ldw	r2,-60(fp)
 200fe8c:	10000316 	blt	r2,zero,200fe9c <_realloc_r+0xac>
 200fe90:	e0fff117 	ldw	r3,-60(fp)
 200fe94:	e0bfff17 	ldw	r2,-4(fp)
 200fe98:	1880052e 	bgeu	r3,r2,200feb0 <_realloc_r+0xc0>
  {
    RERRNO = ENOMEM;
 200fe9c:	e0bffd17 	ldw	r2,-12(fp)
 200fea0:	00c00304 	movi	r3,12
 200fea4:	10c00015 	stw	r3,0(r2)
    return 0;
 200fea8:	0005883a 	mov	r2,zero
 200feac:	0002c706 	br	20109cc <_realloc_r+0xbdc>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
 200feb0:	e0fff017 	ldw	r3,-64(fp)
 200feb4:	e0bff117 	ldw	r2,-60(fp)
 200feb8:	18828b0e 	bge	r3,r2,20108e8 <_realloc_r+0xaf8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
 200febc:	e0ffef17 	ldw	r3,-68(fp)
 200fec0:	e0bff017 	ldw	r2,-64(fp)
 200fec4:	1885883a 	add	r2,r3,r2
 200fec8:	e0bfe515 	stw	r2,-108(fp)
    if (next == top || !inuse(next)) 
 200fecc:	008080b4 	movhi	r2,514
 200fed0:	10800504 	addi	r2,r2,20
 200fed4:	10c00217 	ldw	r3,8(r2)
 200fed8:	e0bfe517 	ldw	r2,-108(fp)
 200fedc:	18800926 	beq	r3,r2,200ff04 <_realloc_r+0x114>
 200fee0:	e0bfe517 	ldw	r2,-108(fp)
 200fee4:	10c00117 	ldw	r3,4(r2)
 200fee8:	00bfff84 	movi	r2,-2
 200feec:	1884703a 	and	r2,r3,r2
 200fef0:	e0ffe517 	ldw	r3,-108(fp)
 200fef4:	1885883a 	add	r2,r3,r2
 200fef8:	10800117 	ldw	r2,4(r2)
 200fefc:	1080004c 	andi	r2,r2,1
 200ff00:	1000461e 	bne	r2,zero,201001c <_realloc_r+0x22c>
    {
      nextsize = chunksize(next);
 200ff04:	e0bfe517 	ldw	r2,-108(fp)
 200ff08:	10c00117 	ldw	r3,4(r2)
 200ff0c:	00bfff04 	movi	r2,-4
 200ff10:	1884703a 	and	r2,r3,r2
 200ff14:	e0bfe615 	stw	r2,-104(fp)

      /* Forward into top only if a remainder */
      if (next == top)
 200ff18:	008080b4 	movhi	r2,514
 200ff1c:	10800504 	addi	r2,r2,20
 200ff20:	10c00217 	ldw	r3,8(r2)
 200ff24:	e0bfe517 	ldw	r2,-108(fp)
 200ff28:	1880251e 	bne	r3,r2,200ffc0 <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
 200ff2c:	e0ffe617 	ldw	r3,-104(fp)
 200ff30:	e0bfe417 	ldw	r2,-112(fp)
 200ff34:	1885883a 	add	r2,r3,r2
 200ff38:	1007883a 	mov	r3,r2
 200ff3c:	e0bff117 	ldw	r2,-60(fp)
 200ff40:	10800404 	addi	r2,r2,16
 200ff44:	18803816 	blt	r3,r2,2010028 <_realloc_r+0x238>
        {
          newsize += nextsize;
 200ff48:	e0ffe417 	ldw	r3,-112(fp)
 200ff4c:	e0bfe617 	ldw	r2,-104(fp)
 200ff50:	1885883a 	add	r2,r3,r2
 200ff54:	e0bfe415 	stw	r2,-112(fp)
          top = chunk_at_offset(oldp, nb);
 200ff58:	008080b4 	movhi	r2,514
 200ff5c:	10800504 	addi	r2,r2,20
 200ff60:	e13fef17 	ldw	r4,-68(fp)
 200ff64:	e0fff117 	ldw	r3,-60(fp)
 200ff68:	20c7883a 	add	r3,r4,r3
 200ff6c:	10c00215 	stw	r3,8(r2)
          set_head(top, (newsize - nb) | PREV_INUSE);
 200ff70:	008080b4 	movhi	r2,514
 200ff74:	10800504 	addi	r2,r2,20
 200ff78:	10800217 	ldw	r2,8(r2)
 200ff7c:	e13fe417 	ldw	r4,-112(fp)
 200ff80:	e0fff117 	ldw	r3,-60(fp)
 200ff84:	20c7c83a 	sub	r3,r4,r3
 200ff88:	18c00054 	ori	r3,r3,1
 200ff8c:	10c00115 	stw	r3,4(r2)
          set_head_size(oldp, nb);
 200ff90:	e0bfef17 	ldw	r2,-68(fp)
 200ff94:	10800117 	ldw	r2,4(r2)
 200ff98:	10c0004c 	andi	r3,r2,1
 200ff9c:	e0bff117 	ldw	r2,-60(fp)
 200ffa0:	1886b03a 	or	r3,r3,r2
 200ffa4:	e0bfef17 	ldw	r2,-68(fp)
 200ffa8:	10c00115 	stw	r3,4(r2)
	  MALLOC_UNLOCK;
 200ffac:	e13ffd17 	ldw	r4,-12(fp)
 200ffb0:	20147bc0 	call	20147bc <__malloc_unlock>
          return chunk2mem(oldp);
 200ffb4:	e0bfef17 	ldw	r2,-68(fp)
 200ffb8:	10800204 	addi	r2,r2,8
 200ffbc:	00028306 	br	20109cc <_realloc_r+0xbdc>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
 200ffc0:	e0ffe617 	ldw	r3,-104(fp)
 200ffc4:	e0bfe417 	ldw	r2,-112(fp)
 200ffc8:	1885883a 	add	r2,r3,r2
 200ffcc:	1007883a 	mov	r3,r2
 200ffd0:	e0bff117 	ldw	r2,-60(fp)
 200ffd4:	18801416 	blt	r3,r2,2010028 <_realloc_r+0x238>
      { 
        unlink(next, bck, fwd);
 200ffd8:	e0bfe517 	ldw	r2,-108(fp)
 200ffdc:	10800317 	ldw	r2,12(r2)
 200ffe0:	e0bff215 	stw	r2,-56(fp)
 200ffe4:	e0bfe517 	ldw	r2,-108(fp)
 200ffe8:	10800217 	ldw	r2,8(r2)
 200ffec:	e0bff315 	stw	r2,-52(fp)
 200fff0:	e0bff317 	ldw	r2,-52(fp)
 200fff4:	e0fff217 	ldw	r3,-56(fp)
 200fff8:	10c00315 	stw	r3,12(r2)
 200fffc:	e0bff217 	ldw	r2,-56(fp)
 2010000:	e0fff317 	ldw	r3,-52(fp)
 2010004:	10c00215 	stw	r3,8(r2)
        newsize  += nextsize;
 2010008:	e0ffe417 	ldw	r3,-112(fp)
 201000c:	e0bfe617 	ldw	r2,-104(fp)
 2010010:	1885883a 	add	r2,r3,r2
 2010014:	e0bfe415 	stw	r2,-112(fp)
        goto split;
 2010018:	00023306 	br	20108e8 <_realloc_r+0xaf8>
      }
    }
    else
    {
      next = 0;
 201001c:	e03fe515 	stw	zero,-108(fp)
      nextsize = 0;
 2010020:	e03fe615 	stw	zero,-104(fp)
 2010024:	00000106 	br	201002c <_realloc_r+0x23c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
 2010028:	0001883a 	nop
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
 201002c:	e0bfef17 	ldw	r2,-68(fp)
 2010030:	10800117 	ldw	r2,4(r2)
 2010034:	1080004c 	andi	r2,r2,1
 2010038:	1001a91e 	bne	r2,zero,20106e0 <_realloc_r+0x8f0>
    {
      prev = prev_chunk(oldp);
 201003c:	e0bfef17 	ldw	r2,-68(fp)
 2010040:	10800017 	ldw	r2,0(r2)
 2010044:	0085c83a 	sub	r2,zero,r2
 2010048:	e0ffef17 	ldw	r3,-68(fp)
 201004c:	1885883a 	add	r2,r3,r2
 2010050:	e0bff415 	stw	r2,-48(fp)
      prevsize = chunksize(prev);
 2010054:	e0bff417 	ldw	r2,-48(fp)
 2010058:	10c00117 	ldw	r3,4(r2)
 201005c:	00bfff04 	movi	r2,-4
 2010060:	1884703a 	and	r2,r3,r2
 2010064:	e0bff515 	stw	r2,-44(fp)

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
 2010068:	e0bfe517 	ldw	r2,-108(fp)
 201006c:	10012226 	beq	r2,zero,20104f8 <_realloc_r+0x708>
      {
        /* into top */
        if (next == top)
 2010070:	008080b4 	movhi	r2,514
 2010074:	10800504 	addi	r2,r2,20
 2010078:	10c00217 	ldw	r3,8(r2)
 201007c:	e0bfe517 	ldw	r2,-108(fp)
 2010080:	1880951e 	bne	r3,r2,20102d8 <_realloc_r+0x4e8>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
 2010084:	e0ffe617 	ldw	r3,-104(fp)
 2010088:	e0bff517 	ldw	r2,-44(fp)
 201008c:	1887883a 	add	r3,r3,r2
 2010090:	e0bfe417 	ldw	r2,-112(fp)
 2010094:	1885883a 	add	r2,r3,r2
 2010098:	1007883a 	mov	r3,r2
 201009c:	e0bff117 	ldw	r2,-60(fp)
 20100a0:	10800404 	addi	r2,r2,16
 20100a4:	18811416 	blt	r3,r2,20104f8 <_realloc_r+0x708>
          {
            unlink(prev, bck, fwd);
 20100a8:	e0bff417 	ldw	r2,-48(fp)
 20100ac:	10800317 	ldw	r2,12(r2)
 20100b0:	e0bff215 	stw	r2,-56(fp)
 20100b4:	e0bff417 	ldw	r2,-48(fp)
 20100b8:	10800217 	ldw	r2,8(r2)
 20100bc:	e0bff315 	stw	r2,-52(fp)
 20100c0:	e0bff317 	ldw	r2,-52(fp)
 20100c4:	e0fff217 	ldw	r3,-56(fp)
 20100c8:	10c00315 	stw	r3,12(r2)
 20100cc:	e0bff217 	ldw	r2,-56(fp)
 20100d0:	e0fff317 	ldw	r3,-52(fp)
 20100d4:	10c00215 	stw	r3,8(r2)
            newp = prev;
 20100d8:	e0bff417 	ldw	r2,-48(fp)
 20100dc:	e0bfe315 	stw	r2,-116(fp)
            newsize += prevsize + nextsize;
 20100e0:	e0fff517 	ldw	r3,-44(fp)
 20100e4:	e0bfe617 	ldw	r2,-104(fp)
 20100e8:	1885883a 	add	r2,r3,r2
 20100ec:	e0ffe417 	ldw	r3,-112(fp)
 20100f0:	1885883a 	add	r2,r3,r2
 20100f4:	e0bfe415 	stw	r2,-112(fp)
            newmem = chunk2mem(newp);
 20100f8:	e0bfe317 	ldw	r2,-116(fp)
 20100fc:	10800204 	addi	r2,r2,8
 2010100:	e0bff615 	stw	r2,-40(fp)
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 2010104:	e0bff017 	ldw	r2,-64(fp)
 2010108:	10bfff04 	addi	r2,r2,-4
 201010c:	e0bff715 	stw	r2,-36(fp)
 2010110:	e0bff717 	ldw	r2,-36(fp)
 2010114:	10800968 	cmpgeui	r2,r2,37
 2010118:	1000521e 	bne	r2,zero,2010264 <_realloc_r+0x474>
 201011c:	e0bffe17 	ldw	r2,-8(fp)
 2010120:	e0bfe715 	stw	r2,-100(fp)
 2010124:	e0bff617 	ldw	r2,-40(fp)
 2010128:	e0bfe815 	stw	r2,-96(fp)
 201012c:	e0bff717 	ldw	r2,-36(fp)
 2010130:	10800530 	cmpltui	r2,r2,20
 2010134:	1000361e 	bne	r2,zero,2010210 <_realloc_r+0x420>
 2010138:	e0bfe817 	ldw	r2,-96(fp)
 201013c:	10c00104 	addi	r3,r2,4
 2010140:	e0ffe815 	stw	r3,-96(fp)
 2010144:	e0ffe717 	ldw	r3,-100(fp)
 2010148:	19000104 	addi	r4,r3,4
 201014c:	e13fe715 	stw	r4,-100(fp)
 2010150:	18c00017 	ldw	r3,0(r3)
 2010154:	10c00015 	stw	r3,0(r2)
 2010158:	e0bfe817 	ldw	r2,-96(fp)
 201015c:	10c00104 	addi	r3,r2,4
 2010160:	e0ffe815 	stw	r3,-96(fp)
 2010164:	e0ffe717 	ldw	r3,-100(fp)
 2010168:	19000104 	addi	r4,r3,4
 201016c:	e13fe715 	stw	r4,-100(fp)
 2010170:	18c00017 	ldw	r3,0(r3)
 2010174:	10c00015 	stw	r3,0(r2)
 2010178:	e0bff717 	ldw	r2,-36(fp)
 201017c:	10800730 	cmpltui	r2,r2,28
 2010180:	1000231e 	bne	r2,zero,2010210 <_realloc_r+0x420>
 2010184:	e0bfe817 	ldw	r2,-96(fp)
 2010188:	10c00104 	addi	r3,r2,4
 201018c:	e0ffe815 	stw	r3,-96(fp)
 2010190:	e0ffe717 	ldw	r3,-100(fp)
 2010194:	19000104 	addi	r4,r3,4
 2010198:	e13fe715 	stw	r4,-100(fp)
 201019c:	18c00017 	ldw	r3,0(r3)
 20101a0:	10c00015 	stw	r3,0(r2)
 20101a4:	e0bfe817 	ldw	r2,-96(fp)
 20101a8:	10c00104 	addi	r3,r2,4
 20101ac:	e0ffe815 	stw	r3,-96(fp)
 20101b0:	e0ffe717 	ldw	r3,-100(fp)
 20101b4:	19000104 	addi	r4,r3,4
 20101b8:	e13fe715 	stw	r4,-100(fp)
 20101bc:	18c00017 	ldw	r3,0(r3)
 20101c0:	10c00015 	stw	r3,0(r2)
 20101c4:	e0bff717 	ldw	r2,-36(fp)
 20101c8:	10800930 	cmpltui	r2,r2,36
 20101cc:	1000101e 	bne	r2,zero,2010210 <_realloc_r+0x420>
 20101d0:	e0bfe817 	ldw	r2,-96(fp)
 20101d4:	10c00104 	addi	r3,r2,4
 20101d8:	e0ffe815 	stw	r3,-96(fp)
 20101dc:	e0ffe717 	ldw	r3,-100(fp)
 20101e0:	19000104 	addi	r4,r3,4
 20101e4:	e13fe715 	stw	r4,-100(fp)
 20101e8:	18c00017 	ldw	r3,0(r3)
 20101ec:	10c00015 	stw	r3,0(r2)
 20101f0:	e0bfe817 	ldw	r2,-96(fp)
 20101f4:	10c00104 	addi	r3,r2,4
 20101f8:	e0ffe815 	stw	r3,-96(fp)
 20101fc:	e0ffe717 	ldw	r3,-100(fp)
 2010200:	19000104 	addi	r4,r3,4
 2010204:	e13fe715 	stw	r4,-100(fp)
 2010208:	18c00017 	ldw	r3,0(r3)
 201020c:	10c00015 	stw	r3,0(r2)
 2010210:	e0bfe817 	ldw	r2,-96(fp)
 2010214:	10c00104 	addi	r3,r2,4
 2010218:	e0ffe815 	stw	r3,-96(fp)
 201021c:	e0ffe717 	ldw	r3,-100(fp)
 2010220:	19000104 	addi	r4,r3,4
 2010224:	e13fe715 	stw	r4,-100(fp)
 2010228:	18c00017 	ldw	r3,0(r3)
 201022c:	10c00015 	stw	r3,0(r2)
 2010230:	e0bfe817 	ldw	r2,-96(fp)
 2010234:	10c00104 	addi	r3,r2,4
 2010238:	e0ffe815 	stw	r3,-96(fp)
 201023c:	e0ffe717 	ldw	r3,-100(fp)
 2010240:	19000104 	addi	r4,r3,4
 2010244:	e13fe715 	stw	r4,-100(fp)
 2010248:	18c00017 	ldw	r3,0(r3)
 201024c:	10c00015 	stw	r3,0(r2)
 2010250:	e0bfe717 	ldw	r2,-100(fp)
 2010254:	10c00017 	ldw	r3,0(r2)
 2010258:	e0bfe817 	ldw	r2,-96(fp)
 201025c:	10c00015 	stw	r3,0(r2)
 2010260:	00000406 	br	2010274 <_realloc_r+0x484>
 2010264:	e1bff717 	ldw	r6,-36(fp)
 2010268:	e17ffe17 	ldw	r5,-8(fp)
 201026c:	e13ff617 	ldw	r4,-40(fp)
 2010270:	200e1700 	call	200e170 <memmove>
            top = chunk_at_offset(newp, nb);
 2010274:	008080b4 	movhi	r2,514
 2010278:	10800504 	addi	r2,r2,20
 201027c:	e13fe317 	ldw	r4,-116(fp)
 2010280:	e0fff117 	ldw	r3,-60(fp)
 2010284:	20c7883a 	add	r3,r4,r3
 2010288:	10c00215 	stw	r3,8(r2)
            set_head(top, (newsize - nb) | PREV_INUSE);
 201028c:	008080b4 	movhi	r2,514
 2010290:	10800504 	addi	r2,r2,20
 2010294:	10800217 	ldw	r2,8(r2)
 2010298:	e13fe417 	ldw	r4,-112(fp)
 201029c:	e0fff117 	ldw	r3,-60(fp)
 20102a0:	20c7c83a 	sub	r3,r4,r3
 20102a4:	18c00054 	ori	r3,r3,1
 20102a8:	10c00115 	stw	r3,4(r2)
            set_head_size(newp, nb);
 20102ac:	e0bfe317 	ldw	r2,-116(fp)
 20102b0:	10800117 	ldw	r2,4(r2)
 20102b4:	10c0004c 	andi	r3,r2,1
 20102b8:	e0bff117 	ldw	r2,-60(fp)
 20102bc:	1886b03a 	or	r3,r3,r2
 20102c0:	e0bfe317 	ldw	r2,-116(fp)
 20102c4:	10c00115 	stw	r3,4(r2)
	    MALLOC_UNLOCK;
 20102c8:	e13ffd17 	ldw	r4,-12(fp)
 20102cc:	20147bc0 	call	20147bc <__malloc_unlock>
            return newmem;
 20102d0:	e0bff617 	ldw	r2,-40(fp)
 20102d4:	0001bd06 	br	20109cc <_realloc_r+0xbdc>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
 20102d8:	e0ffe617 	ldw	r3,-104(fp)
 20102dc:	e0bff517 	ldw	r2,-44(fp)
 20102e0:	1887883a 	add	r3,r3,r2
 20102e4:	e0bfe417 	ldw	r2,-112(fp)
 20102e8:	1885883a 	add	r2,r3,r2
 20102ec:	1007883a 	mov	r3,r2
 20102f0:	e0bff117 	ldw	r2,-60(fp)
 20102f4:	18808016 	blt	r3,r2,20104f8 <_realloc_r+0x708>
        {
          unlink(next, bck, fwd);
 20102f8:	e0bfe517 	ldw	r2,-108(fp)
 20102fc:	10800317 	ldw	r2,12(r2)
 2010300:	e0bff215 	stw	r2,-56(fp)
 2010304:	e0bfe517 	ldw	r2,-108(fp)
 2010308:	10800217 	ldw	r2,8(r2)
 201030c:	e0bff315 	stw	r2,-52(fp)
 2010310:	e0bff317 	ldw	r2,-52(fp)
 2010314:	e0fff217 	ldw	r3,-56(fp)
 2010318:	10c00315 	stw	r3,12(r2)
 201031c:	e0bff217 	ldw	r2,-56(fp)
 2010320:	e0fff317 	ldw	r3,-52(fp)
 2010324:	10c00215 	stw	r3,8(r2)
          unlink(prev, bck, fwd);
 2010328:	e0bff417 	ldw	r2,-48(fp)
 201032c:	10800317 	ldw	r2,12(r2)
 2010330:	e0bff215 	stw	r2,-56(fp)
 2010334:	e0bff417 	ldw	r2,-48(fp)
 2010338:	10800217 	ldw	r2,8(r2)
 201033c:	e0bff315 	stw	r2,-52(fp)
 2010340:	e0bff317 	ldw	r2,-52(fp)
 2010344:	e0fff217 	ldw	r3,-56(fp)
 2010348:	10c00315 	stw	r3,12(r2)
 201034c:	e0bff217 	ldw	r2,-56(fp)
 2010350:	e0fff317 	ldw	r3,-52(fp)
 2010354:	10c00215 	stw	r3,8(r2)
          newp = prev;
 2010358:	e0bff417 	ldw	r2,-48(fp)
 201035c:	e0bfe315 	stw	r2,-116(fp)
          newsize += nextsize + prevsize;
 2010360:	e0ffe617 	ldw	r3,-104(fp)
 2010364:	e0bff517 	ldw	r2,-44(fp)
 2010368:	1885883a 	add	r2,r3,r2
 201036c:	e0ffe417 	ldw	r3,-112(fp)
 2010370:	1885883a 	add	r2,r3,r2
 2010374:	e0bfe415 	stw	r2,-112(fp)
          newmem = chunk2mem(newp);
 2010378:	e0bfe317 	ldw	r2,-116(fp)
 201037c:	10800204 	addi	r2,r2,8
 2010380:	e0bff615 	stw	r2,-40(fp)
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 2010384:	e0bff017 	ldw	r2,-64(fp)
 2010388:	10bfff04 	addi	r2,r2,-4
 201038c:	e0bff815 	stw	r2,-32(fp)
 2010390:	e0bff817 	ldw	r2,-32(fp)
 2010394:	10800968 	cmpgeui	r2,r2,37
 2010398:	1000521e 	bne	r2,zero,20104e4 <_realloc_r+0x6f4>
 201039c:	e0bffe17 	ldw	r2,-8(fp)
 20103a0:	e0bfe915 	stw	r2,-92(fp)
 20103a4:	e0bff617 	ldw	r2,-40(fp)
 20103a8:	e0bfea15 	stw	r2,-88(fp)
 20103ac:	e0bff817 	ldw	r2,-32(fp)
 20103b0:	10800530 	cmpltui	r2,r2,20
 20103b4:	1000361e 	bne	r2,zero,2010490 <_realloc_r+0x6a0>
 20103b8:	e0bfea17 	ldw	r2,-88(fp)
 20103bc:	10c00104 	addi	r3,r2,4
 20103c0:	e0ffea15 	stw	r3,-88(fp)
 20103c4:	e0ffe917 	ldw	r3,-92(fp)
 20103c8:	19000104 	addi	r4,r3,4
 20103cc:	e13fe915 	stw	r4,-92(fp)
 20103d0:	18c00017 	ldw	r3,0(r3)
 20103d4:	10c00015 	stw	r3,0(r2)
 20103d8:	e0bfea17 	ldw	r2,-88(fp)
 20103dc:	10c00104 	addi	r3,r2,4
 20103e0:	e0ffea15 	stw	r3,-88(fp)
 20103e4:	e0ffe917 	ldw	r3,-92(fp)
 20103e8:	19000104 	addi	r4,r3,4
 20103ec:	e13fe915 	stw	r4,-92(fp)
 20103f0:	18c00017 	ldw	r3,0(r3)
 20103f4:	10c00015 	stw	r3,0(r2)
 20103f8:	e0bff817 	ldw	r2,-32(fp)
 20103fc:	10800730 	cmpltui	r2,r2,28
 2010400:	1000231e 	bne	r2,zero,2010490 <_realloc_r+0x6a0>
 2010404:	e0bfea17 	ldw	r2,-88(fp)
 2010408:	10c00104 	addi	r3,r2,4
 201040c:	e0ffea15 	stw	r3,-88(fp)
 2010410:	e0ffe917 	ldw	r3,-92(fp)
 2010414:	19000104 	addi	r4,r3,4
 2010418:	e13fe915 	stw	r4,-92(fp)
 201041c:	18c00017 	ldw	r3,0(r3)
 2010420:	10c00015 	stw	r3,0(r2)
 2010424:	e0bfea17 	ldw	r2,-88(fp)
 2010428:	10c00104 	addi	r3,r2,4
 201042c:	e0ffea15 	stw	r3,-88(fp)
 2010430:	e0ffe917 	ldw	r3,-92(fp)
 2010434:	19000104 	addi	r4,r3,4
 2010438:	e13fe915 	stw	r4,-92(fp)
 201043c:	18c00017 	ldw	r3,0(r3)
 2010440:	10c00015 	stw	r3,0(r2)
 2010444:	e0bff817 	ldw	r2,-32(fp)
 2010448:	10800930 	cmpltui	r2,r2,36
 201044c:	1000101e 	bne	r2,zero,2010490 <_realloc_r+0x6a0>
 2010450:	e0bfea17 	ldw	r2,-88(fp)
 2010454:	10c00104 	addi	r3,r2,4
 2010458:	e0ffea15 	stw	r3,-88(fp)
 201045c:	e0ffe917 	ldw	r3,-92(fp)
 2010460:	19000104 	addi	r4,r3,4
 2010464:	e13fe915 	stw	r4,-92(fp)
 2010468:	18c00017 	ldw	r3,0(r3)
 201046c:	10c00015 	stw	r3,0(r2)
 2010470:	e0bfea17 	ldw	r2,-88(fp)
 2010474:	10c00104 	addi	r3,r2,4
 2010478:	e0ffea15 	stw	r3,-88(fp)
 201047c:	e0ffe917 	ldw	r3,-92(fp)
 2010480:	19000104 	addi	r4,r3,4
 2010484:	e13fe915 	stw	r4,-92(fp)
 2010488:	18c00017 	ldw	r3,0(r3)
 201048c:	10c00015 	stw	r3,0(r2)
 2010490:	e0bfea17 	ldw	r2,-88(fp)
 2010494:	10c00104 	addi	r3,r2,4
 2010498:	e0ffea15 	stw	r3,-88(fp)
 201049c:	e0ffe917 	ldw	r3,-92(fp)
 20104a0:	19000104 	addi	r4,r3,4
 20104a4:	e13fe915 	stw	r4,-92(fp)
 20104a8:	18c00017 	ldw	r3,0(r3)
 20104ac:	10c00015 	stw	r3,0(r2)
 20104b0:	e0bfea17 	ldw	r2,-88(fp)
 20104b4:	10c00104 	addi	r3,r2,4
 20104b8:	e0ffea15 	stw	r3,-88(fp)
 20104bc:	e0ffe917 	ldw	r3,-92(fp)
 20104c0:	19000104 	addi	r4,r3,4
 20104c4:	e13fe915 	stw	r4,-92(fp)
 20104c8:	18c00017 	ldw	r3,0(r3)
 20104cc:	10c00015 	stw	r3,0(r2)
 20104d0:	e0bfe917 	ldw	r2,-92(fp)
 20104d4:	10c00017 	ldw	r3,0(r2)
 20104d8:	e0bfea17 	ldw	r2,-88(fp)
 20104dc:	10c00015 	stw	r3,0(r2)
          goto split;
 20104e0:	00010106 	br	20108e8 <_realloc_r+0xaf8>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 20104e4:	e1bff817 	ldw	r6,-32(fp)
 20104e8:	e17ffe17 	ldw	r5,-8(fp)
 20104ec:	e13ff617 	ldw	r4,-40(fp)
 20104f0:	200e1700 	call	200e170 <memmove>
          goto split;
 20104f4:	0000fc06 	br	20108e8 <_realloc_r+0xaf8>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
 20104f8:	e0bff417 	ldw	r2,-48(fp)
 20104fc:	10007826 	beq	r2,zero,20106e0 <_realloc_r+0x8f0>
 2010500:	e0fff517 	ldw	r3,-44(fp)
 2010504:	e0bfe417 	ldw	r2,-112(fp)
 2010508:	1885883a 	add	r2,r3,r2
 201050c:	1007883a 	mov	r3,r2
 2010510:	e0bff117 	ldw	r2,-60(fp)
 2010514:	18807216 	blt	r3,r2,20106e0 <_realloc_r+0x8f0>
      {
        unlink(prev, bck, fwd);
 2010518:	e0bff417 	ldw	r2,-48(fp)
 201051c:	10800317 	ldw	r2,12(r2)
 2010520:	e0bff215 	stw	r2,-56(fp)
 2010524:	e0bff417 	ldw	r2,-48(fp)
 2010528:	10800217 	ldw	r2,8(r2)
 201052c:	e0bff315 	stw	r2,-52(fp)
 2010530:	e0bff317 	ldw	r2,-52(fp)
 2010534:	e0fff217 	ldw	r3,-56(fp)
 2010538:	10c00315 	stw	r3,12(r2)
 201053c:	e0bff217 	ldw	r2,-56(fp)
 2010540:	e0fff317 	ldw	r3,-52(fp)
 2010544:	10c00215 	stw	r3,8(r2)
        newp = prev;
 2010548:	e0bff417 	ldw	r2,-48(fp)
 201054c:	e0bfe315 	stw	r2,-116(fp)
        newsize += prevsize;
 2010550:	e0ffe417 	ldw	r3,-112(fp)
 2010554:	e0bff517 	ldw	r2,-44(fp)
 2010558:	1885883a 	add	r2,r3,r2
 201055c:	e0bfe415 	stw	r2,-112(fp)
        newmem = chunk2mem(newp);
 2010560:	e0bfe317 	ldw	r2,-116(fp)
 2010564:	10800204 	addi	r2,r2,8
 2010568:	e0bff615 	stw	r2,-40(fp)
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 201056c:	e0bff017 	ldw	r2,-64(fp)
 2010570:	10bfff04 	addi	r2,r2,-4
 2010574:	e0bff915 	stw	r2,-28(fp)
 2010578:	e0bff917 	ldw	r2,-28(fp)
 201057c:	10800968 	cmpgeui	r2,r2,37
 2010580:	1000521e 	bne	r2,zero,20106cc <_realloc_r+0x8dc>
 2010584:	e0bffe17 	ldw	r2,-8(fp)
 2010588:	e0bfeb15 	stw	r2,-84(fp)
 201058c:	e0bff617 	ldw	r2,-40(fp)
 2010590:	e0bfec15 	stw	r2,-80(fp)
 2010594:	e0bff917 	ldw	r2,-28(fp)
 2010598:	10800530 	cmpltui	r2,r2,20
 201059c:	1000361e 	bne	r2,zero,2010678 <_realloc_r+0x888>
 20105a0:	e0bfec17 	ldw	r2,-80(fp)
 20105a4:	10c00104 	addi	r3,r2,4
 20105a8:	e0ffec15 	stw	r3,-80(fp)
 20105ac:	e0ffeb17 	ldw	r3,-84(fp)
 20105b0:	19000104 	addi	r4,r3,4
 20105b4:	e13feb15 	stw	r4,-84(fp)
 20105b8:	18c00017 	ldw	r3,0(r3)
 20105bc:	10c00015 	stw	r3,0(r2)
 20105c0:	e0bfec17 	ldw	r2,-80(fp)
 20105c4:	10c00104 	addi	r3,r2,4
 20105c8:	e0ffec15 	stw	r3,-80(fp)
 20105cc:	e0ffeb17 	ldw	r3,-84(fp)
 20105d0:	19000104 	addi	r4,r3,4
 20105d4:	e13feb15 	stw	r4,-84(fp)
 20105d8:	18c00017 	ldw	r3,0(r3)
 20105dc:	10c00015 	stw	r3,0(r2)
 20105e0:	e0bff917 	ldw	r2,-28(fp)
 20105e4:	10800730 	cmpltui	r2,r2,28
 20105e8:	1000231e 	bne	r2,zero,2010678 <_realloc_r+0x888>
 20105ec:	e0bfec17 	ldw	r2,-80(fp)
 20105f0:	10c00104 	addi	r3,r2,4
 20105f4:	e0ffec15 	stw	r3,-80(fp)
 20105f8:	e0ffeb17 	ldw	r3,-84(fp)
 20105fc:	19000104 	addi	r4,r3,4
 2010600:	e13feb15 	stw	r4,-84(fp)
 2010604:	18c00017 	ldw	r3,0(r3)
 2010608:	10c00015 	stw	r3,0(r2)
 201060c:	e0bfec17 	ldw	r2,-80(fp)
 2010610:	10c00104 	addi	r3,r2,4
 2010614:	e0ffec15 	stw	r3,-80(fp)
 2010618:	e0ffeb17 	ldw	r3,-84(fp)
 201061c:	19000104 	addi	r4,r3,4
 2010620:	e13feb15 	stw	r4,-84(fp)
 2010624:	18c00017 	ldw	r3,0(r3)
 2010628:	10c00015 	stw	r3,0(r2)
 201062c:	e0bff917 	ldw	r2,-28(fp)
 2010630:	10800930 	cmpltui	r2,r2,36
 2010634:	1000101e 	bne	r2,zero,2010678 <_realloc_r+0x888>
 2010638:	e0bfec17 	ldw	r2,-80(fp)
 201063c:	10c00104 	addi	r3,r2,4
 2010640:	e0ffec15 	stw	r3,-80(fp)
 2010644:	e0ffeb17 	ldw	r3,-84(fp)
 2010648:	19000104 	addi	r4,r3,4
 201064c:	e13feb15 	stw	r4,-84(fp)
 2010650:	18c00017 	ldw	r3,0(r3)
 2010654:	10c00015 	stw	r3,0(r2)
 2010658:	e0bfec17 	ldw	r2,-80(fp)
 201065c:	10c00104 	addi	r3,r2,4
 2010660:	e0ffec15 	stw	r3,-80(fp)
 2010664:	e0ffeb17 	ldw	r3,-84(fp)
 2010668:	19000104 	addi	r4,r3,4
 201066c:	e13feb15 	stw	r4,-84(fp)
 2010670:	18c00017 	ldw	r3,0(r3)
 2010674:	10c00015 	stw	r3,0(r2)
 2010678:	e0bfec17 	ldw	r2,-80(fp)
 201067c:	10c00104 	addi	r3,r2,4
 2010680:	e0ffec15 	stw	r3,-80(fp)
 2010684:	e0ffeb17 	ldw	r3,-84(fp)
 2010688:	19000104 	addi	r4,r3,4
 201068c:	e13feb15 	stw	r4,-84(fp)
 2010690:	18c00017 	ldw	r3,0(r3)
 2010694:	10c00015 	stw	r3,0(r2)
 2010698:	e0bfec17 	ldw	r2,-80(fp)
 201069c:	10c00104 	addi	r3,r2,4
 20106a0:	e0ffec15 	stw	r3,-80(fp)
 20106a4:	e0ffeb17 	ldw	r3,-84(fp)
 20106a8:	19000104 	addi	r4,r3,4
 20106ac:	e13feb15 	stw	r4,-84(fp)
 20106b0:	18c00017 	ldw	r3,0(r3)
 20106b4:	10c00015 	stw	r3,0(r2)
 20106b8:	e0bfeb17 	ldw	r2,-84(fp)
 20106bc:	10c00017 	ldw	r3,0(r2)
 20106c0:	e0bfec17 	ldw	r2,-80(fp)
 20106c4:	10c00015 	stw	r3,0(r2)
        goto split;
 20106c8:	00008706 	br	20108e8 <_realloc_r+0xaf8>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 20106cc:	e1bff917 	ldw	r6,-28(fp)
 20106d0:	e17ffe17 	ldw	r5,-8(fp)
 20106d4:	e13ff617 	ldw	r4,-40(fp)
 20106d8:	200e1700 	call	200e170 <memmove>
        goto split;
 20106dc:	00008206 	br	20108e8 <_realloc_r+0xaf8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
 20106e0:	e17fff17 	ldw	r5,-4(fp)
 20106e4:	e13ffd17 	ldw	r4,-12(fp)
 20106e8:	200d4380 	call	200d438 <_malloc_r>
 20106ec:	e0bff615 	stw	r2,-40(fp)

    if (newmem == 0)  /* propagate failure */
 20106f0:	e0bff617 	ldw	r2,-40(fp)
 20106f4:	1000041e 	bne	r2,zero,2010708 <_realloc_r+0x918>
    {
      MALLOC_UNLOCK;
 20106f8:	e13ffd17 	ldw	r4,-12(fp)
 20106fc:	20147bc0 	call	20147bc <__malloc_unlock>
      return 0;
 2010700:	0005883a 	mov	r2,zero
 2010704:	0000b106 	br	20109cc <_realloc_r+0xbdc>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
 2010708:	e0bff617 	ldw	r2,-40(fp)
 201070c:	10bffe04 	addi	r2,r2,-8
 2010710:	e0bfe315 	stw	r2,-116(fp)
 2010714:	e0bfef17 	ldw	r2,-68(fp)
 2010718:	10c00117 	ldw	r3,4(r2)
 201071c:	00bfff84 	movi	r2,-2
 2010720:	1884703a 	and	r2,r3,r2
 2010724:	e0ffef17 	ldw	r3,-68(fp)
 2010728:	1885883a 	add	r2,r3,r2
 201072c:	e0ffe317 	ldw	r3,-116(fp)
 2010730:	18800a1e 	bne	r3,r2,201075c <_realloc_r+0x96c>
    {
      newsize += chunksize(newp);
 2010734:	e0bfe317 	ldw	r2,-116(fp)
 2010738:	10c00117 	ldw	r3,4(r2)
 201073c:	00bfff04 	movi	r2,-4
 2010740:	1884703a 	and	r2,r3,r2
 2010744:	e0ffe417 	ldw	r3,-112(fp)
 2010748:	1885883a 	add	r2,r3,r2
 201074c:	e0bfe415 	stw	r2,-112(fp)
      newp = oldp;
 2010750:	e0bfef17 	ldw	r2,-68(fp)
 2010754:	e0bfe315 	stw	r2,-116(fp)
      goto split;
 2010758:	00006306 	br	20108e8 <_realloc_r+0xaf8>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
 201075c:	e0bff017 	ldw	r2,-64(fp)
 2010760:	10bfff04 	addi	r2,r2,-4
 2010764:	e0bffa15 	stw	r2,-24(fp)
 2010768:	e0bffa17 	ldw	r2,-24(fp)
 201076c:	10800968 	cmpgeui	r2,r2,37
 2010770:	1000521e 	bne	r2,zero,20108bc <_realloc_r+0xacc>
 2010774:	e0bffe17 	ldw	r2,-8(fp)
 2010778:	e0bfed15 	stw	r2,-76(fp)
 201077c:	e0bff617 	ldw	r2,-40(fp)
 2010780:	e0bfee15 	stw	r2,-72(fp)
 2010784:	e0bffa17 	ldw	r2,-24(fp)
 2010788:	10800530 	cmpltui	r2,r2,20
 201078c:	1000361e 	bne	r2,zero,2010868 <_realloc_r+0xa78>
 2010790:	e0bfee17 	ldw	r2,-72(fp)
 2010794:	10c00104 	addi	r3,r2,4
 2010798:	e0ffee15 	stw	r3,-72(fp)
 201079c:	e0ffed17 	ldw	r3,-76(fp)
 20107a0:	19000104 	addi	r4,r3,4
 20107a4:	e13fed15 	stw	r4,-76(fp)
 20107a8:	18c00017 	ldw	r3,0(r3)
 20107ac:	10c00015 	stw	r3,0(r2)
 20107b0:	e0bfee17 	ldw	r2,-72(fp)
 20107b4:	10c00104 	addi	r3,r2,4
 20107b8:	e0ffee15 	stw	r3,-72(fp)
 20107bc:	e0ffed17 	ldw	r3,-76(fp)
 20107c0:	19000104 	addi	r4,r3,4
 20107c4:	e13fed15 	stw	r4,-76(fp)
 20107c8:	18c00017 	ldw	r3,0(r3)
 20107cc:	10c00015 	stw	r3,0(r2)
 20107d0:	e0bffa17 	ldw	r2,-24(fp)
 20107d4:	10800730 	cmpltui	r2,r2,28
 20107d8:	1000231e 	bne	r2,zero,2010868 <_realloc_r+0xa78>
 20107dc:	e0bfee17 	ldw	r2,-72(fp)
 20107e0:	10c00104 	addi	r3,r2,4
 20107e4:	e0ffee15 	stw	r3,-72(fp)
 20107e8:	e0ffed17 	ldw	r3,-76(fp)
 20107ec:	19000104 	addi	r4,r3,4
 20107f0:	e13fed15 	stw	r4,-76(fp)
 20107f4:	18c00017 	ldw	r3,0(r3)
 20107f8:	10c00015 	stw	r3,0(r2)
 20107fc:	e0bfee17 	ldw	r2,-72(fp)
 2010800:	10c00104 	addi	r3,r2,4
 2010804:	e0ffee15 	stw	r3,-72(fp)
 2010808:	e0ffed17 	ldw	r3,-76(fp)
 201080c:	19000104 	addi	r4,r3,4
 2010810:	e13fed15 	stw	r4,-76(fp)
 2010814:	18c00017 	ldw	r3,0(r3)
 2010818:	10c00015 	stw	r3,0(r2)
 201081c:	e0bffa17 	ldw	r2,-24(fp)
 2010820:	10800930 	cmpltui	r2,r2,36
 2010824:	1000101e 	bne	r2,zero,2010868 <_realloc_r+0xa78>
 2010828:	e0bfee17 	ldw	r2,-72(fp)
 201082c:	10c00104 	addi	r3,r2,4
 2010830:	e0ffee15 	stw	r3,-72(fp)
 2010834:	e0ffed17 	ldw	r3,-76(fp)
 2010838:	19000104 	addi	r4,r3,4
 201083c:	e13fed15 	stw	r4,-76(fp)
 2010840:	18c00017 	ldw	r3,0(r3)
 2010844:	10c00015 	stw	r3,0(r2)
 2010848:	e0bfee17 	ldw	r2,-72(fp)
 201084c:	10c00104 	addi	r3,r2,4
 2010850:	e0ffee15 	stw	r3,-72(fp)
 2010854:	e0ffed17 	ldw	r3,-76(fp)
 2010858:	19000104 	addi	r4,r3,4
 201085c:	e13fed15 	stw	r4,-76(fp)
 2010860:	18c00017 	ldw	r3,0(r3)
 2010864:	10c00015 	stw	r3,0(r2)
 2010868:	e0bfee17 	ldw	r2,-72(fp)
 201086c:	10c00104 	addi	r3,r2,4
 2010870:	e0ffee15 	stw	r3,-72(fp)
 2010874:	e0ffed17 	ldw	r3,-76(fp)
 2010878:	19000104 	addi	r4,r3,4
 201087c:	e13fed15 	stw	r4,-76(fp)
 2010880:	18c00017 	ldw	r3,0(r3)
 2010884:	10c00015 	stw	r3,0(r2)
 2010888:	e0bfee17 	ldw	r2,-72(fp)
 201088c:	10c00104 	addi	r3,r2,4
 2010890:	e0ffee15 	stw	r3,-72(fp)
 2010894:	e0ffed17 	ldw	r3,-76(fp)
 2010898:	19000104 	addi	r4,r3,4
 201089c:	e13fed15 	stw	r4,-76(fp)
 20108a0:	18c00017 	ldw	r3,0(r3)
 20108a4:	10c00015 	stw	r3,0(r2)
 20108a8:	e0bfed17 	ldw	r2,-76(fp)
 20108ac:	10c00017 	ldw	r3,0(r2)
 20108b0:	e0bfee17 	ldw	r2,-72(fp)
 20108b4:	10c00015 	stw	r3,0(r2)
 20108b8:	00000406 	br	20108cc <_realloc_r+0xadc>
 20108bc:	e1bffa17 	ldw	r6,-24(fp)
 20108c0:	e17ffe17 	ldw	r5,-8(fp)
 20108c4:	e13ff617 	ldw	r4,-40(fp)
 20108c8:	200e1700 	call	200e170 <memmove>
    fREe(RCALL oldmem);
 20108cc:	e17ffe17 	ldw	r5,-8(fp)
 20108d0:	e13ffd17 	ldw	r4,-12(fp)
 20108d4:	200bdf80 	call	200bdf8 <_free_r>
    MALLOC_UNLOCK;
 20108d8:	e13ffd17 	ldw	r4,-12(fp)
 20108dc:	20147bc0 	call	20147bc <__malloc_unlock>
    return newmem;
 20108e0:	e0bff617 	ldw	r2,-40(fp)
 20108e4:	00003906 	br	20109cc <_realloc_r+0xbdc>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
 20108e8:	e0ffe417 	ldw	r3,-112(fp)
 20108ec:	e0bff117 	ldw	r2,-60(fp)
 20108f0:	1885c83a 	sub	r2,r3,r2
 20108f4:	e0bffb15 	stw	r2,-20(fp)

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
 20108f8:	e0bffb17 	ldw	r2,-20(fp)
 20108fc:	10800430 	cmpltui	r2,r2,16
 2010900:	10001e1e 	bne	r2,zero,201097c <_realloc_r+0xb8c>
  {
    remainder = chunk_at_offset(newp, nb);
 2010904:	e0ffe317 	ldw	r3,-116(fp)
 2010908:	e0bff117 	ldw	r2,-60(fp)
 201090c:	1885883a 	add	r2,r3,r2
 2010910:	e0bffc15 	stw	r2,-16(fp)
    set_head_size(newp, nb);
 2010914:	e0bfe317 	ldw	r2,-116(fp)
 2010918:	10800117 	ldw	r2,4(r2)
 201091c:	10c0004c 	andi	r3,r2,1
 2010920:	e0bff117 	ldw	r2,-60(fp)
 2010924:	1886b03a 	or	r3,r3,r2
 2010928:	e0bfe317 	ldw	r2,-116(fp)
 201092c:	10c00115 	stw	r3,4(r2)
    set_head(remainder, remainder_size | PREV_INUSE);
 2010930:	e0bffb17 	ldw	r2,-20(fp)
 2010934:	10c00054 	ori	r3,r2,1
 2010938:	e0bffc17 	ldw	r2,-16(fp)
 201093c:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(remainder, remainder_size);
 2010940:	e0fffc17 	ldw	r3,-16(fp)
 2010944:	e0bffb17 	ldw	r2,-20(fp)
 2010948:	1885883a 	add	r2,r3,r2
 201094c:	e13ffc17 	ldw	r4,-16(fp)
 2010950:	e0fffb17 	ldw	r3,-20(fp)
 2010954:	20c7883a 	add	r3,r4,r3
 2010958:	18c00117 	ldw	r3,4(r3)
 201095c:	18c00054 	ori	r3,r3,1
 2010960:	10c00115 	stw	r3,4(r2)
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
 2010964:	e0bffc17 	ldw	r2,-16(fp)
 2010968:	10800204 	addi	r2,r2,8
 201096c:	100b883a 	mov	r5,r2
 2010970:	e13ffd17 	ldw	r4,-12(fp)
 2010974:	200bdf80 	call	200bdf8 <_free_r>
 2010978:	00001006 	br	20109bc <_realloc_r+0xbcc>
  }
  else
  {
    set_head_size(newp, newsize);
 201097c:	e0bfe317 	ldw	r2,-116(fp)
 2010980:	10800117 	ldw	r2,4(r2)
 2010984:	10c0004c 	andi	r3,r2,1
 2010988:	e0bfe417 	ldw	r2,-112(fp)
 201098c:	1886b03a 	or	r3,r3,r2
 2010990:	e0bfe317 	ldw	r2,-116(fp)
 2010994:	10c00115 	stw	r3,4(r2)
    set_inuse_bit_at_offset(newp, newsize);
 2010998:	e0ffe317 	ldw	r3,-116(fp)
 201099c:	e0bfe417 	ldw	r2,-112(fp)
 20109a0:	1885883a 	add	r2,r3,r2
 20109a4:	e13fe317 	ldw	r4,-116(fp)
 20109a8:	e0ffe417 	ldw	r3,-112(fp)
 20109ac:	20c7883a 	add	r3,r4,r3
 20109b0:	18c00117 	ldw	r3,4(r3)
 20109b4:	18c00054 	ori	r3,r3,1
 20109b8:	10c00115 	stw	r3,4(r2)
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
 20109bc:	e13ffd17 	ldw	r4,-12(fp)
 20109c0:	20147bc0 	call	20147bc <__malloc_unlock>
  return chunk2mem(newp);
 20109c4:	e0bfe317 	ldw	r2,-116(fp)
 20109c8:	10800204 	addi	r2,r2,8

#endif /* MALLOC_PROVIDED */
}
 20109cc:	e037883a 	mov	sp,fp
 20109d0:	dfc00117 	ldw	ra,4(sp)
 20109d4:	df000017 	ldw	fp,0(sp)
 20109d8:	dec00204 	addi	sp,sp,8
 20109dc:	f800283a 	ret

020109e0 <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
 20109e0:	defffb04 	addi	sp,sp,-20
 20109e4:	dfc00415 	stw	ra,16(sp)
 20109e8:	df000315 	stw	fp,12(sp)
 20109ec:	df000304 	addi	fp,sp,12
 20109f0:	e13ffe15 	stw	r4,-8(fp)
 20109f4:	e17fff15 	stw	r5,-4(fp)
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
 20109f8:	d0274615 	stw	zero,-25320(gp)
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
 20109fc:	e13fff17 	ldw	r4,-4(fp)
 2010a00:	20143940 	call	2014394 <sbrk>
 2010a04:	e0bffd15 	stw	r2,-12(fp)
 2010a08:	e0bffd17 	ldw	r2,-12(fp)
 2010a0c:	10bfffd8 	cmpnei	r2,r2,-1
 2010a10:	1000051e 	bne	r2,zero,2010a28 <_sbrk_r+0x48>
 2010a14:	d0a74617 	ldw	r2,-25320(gp)
 2010a18:	10000326 	beq	r2,zero,2010a28 <_sbrk_r+0x48>
    ptr->_errno = errno;
 2010a1c:	d0e74617 	ldw	r3,-25320(gp)
 2010a20:	e0bffe17 	ldw	r2,-8(fp)
 2010a24:	10c00015 	stw	r3,0(r2)
  return ret;
 2010a28:	e0bffd17 	ldw	r2,-12(fp)
}
 2010a2c:	e037883a 	mov	sp,fp
 2010a30:	dfc00117 	ldw	ra,4(sp)
 2010a34:	df000017 	ldw	fp,0(sp)
 2010a38:	dec00204 	addi	sp,sp,8
 2010a3c:	f800283a 	ret

02010a40 <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 2010a40:	defff804 	addi	sp,sp,-32
 2010a44:	dfc00715 	stw	ra,28(sp)
 2010a48:	df000615 	stw	fp,24(sp)
 2010a4c:	dc400515 	stw	r17,20(sp)
 2010a50:	dc000415 	stw	r16,16(sp)
 2010a54:	df000604 	addi	fp,sp,24
 2010a58:	e13ffa15 	stw	r4,-24(fp)
 2010a5c:	e17ffb15 	stw	r5,-20(fp)
 2010a60:	e1bffc15 	stw	r6,-16(fp)
 2010a64:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 2010a68:	e43ffb17 	ldw	r16,-20(fp)
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
 2010a6c:	8080038b 	ldhu	r2,14(r16)
 2010a70:	10bfffcc 	andi	r2,r2,65535
 2010a74:	10a0001c 	xori	r2,r2,32768
 2010a78:	10a00004 	addi	r2,r2,-32768
 2010a7c:	e0fffd17 	ldw	r3,-12(fp)
 2010a80:	180f883a 	mov	r7,r3
 2010a84:	e1bffc17 	ldw	r6,-16(fp)
 2010a88:	100b883a 	mov	r5,r2
 2010a8c:	e13ffa17 	ldw	r4,-24(fp)
 2010a90:	2012ae80 	call	2012ae8 <_read_r>
 2010a94:	1023883a 	mov	r17,r2
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
 2010a98:	88000416 	blt	r17,zero,2010aac <__sread+0x6c>
    fp->_offset += ret;
 2010a9c:	80801417 	ldw	r2,80(r16)
 2010aa0:	1445883a 	add	r2,r2,r17
 2010aa4:	80801415 	stw	r2,80(r16)
 2010aa8:	00000406 	br	2010abc <__sread+0x7c>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
 2010aac:	80c0030b 	ldhu	r3,12(r16)
 2010ab0:	00bbffc4 	movi	r2,-4097
 2010ab4:	1884703a 	and	r2,r3,r2
 2010ab8:	8080030d 	sth	r2,12(r16)
  return ret;
 2010abc:	8805883a 	mov	r2,r17
}
 2010ac0:	e6fffe04 	addi	sp,fp,-8
 2010ac4:	dfc00317 	ldw	ra,12(sp)
 2010ac8:	df000217 	ldw	fp,8(sp)
 2010acc:	dc400117 	ldw	r17,4(sp)
 2010ad0:	dc000017 	ldw	r16,0(sp)
 2010ad4:	dec00404 	addi	sp,sp,16
 2010ad8:	f800283a 	ret

02010adc <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       _READ_WRITE_BUFSIZE_TYPE len)
{
 2010adc:	defffb04 	addi	sp,sp,-20
 2010ae0:	df000415 	stw	fp,16(sp)
 2010ae4:	df000404 	addi	fp,sp,16
 2010ae8:	e13ffc15 	stw	r4,-16(fp)
 2010aec:	e17ffd15 	stw	r5,-12(fp)
 2010af0:	e1bffe15 	stw	r6,-8(fp)
 2010af4:	e1ffff15 	stw	r7,-4(fp)
  return 0;
 2010af8:	0005883a 	mov	r2,zero
}
 2010afc:	e037883a 	mov	sp,fp
 2010b00:	df000017 	ldw	fp,0(sp)
 2010b04:	dec00104 	addi	sp,sp,4
 2010b08:	f800283a 	ret

02010b0c <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       _READ_WRITE_BUFSIZE_TYPE n)
{
 2010b0c:	defff804 	addi	sp,sp,-32
 2010b10:	dfc00715 	stw	ra,28(sp)
 2010b14:	df000615 	stw	fp,24(sp)
 2010b18:	dc000515 	stw	r16,20(sp)
 2010b1c:	df000604 	addi	fp,sp,24
 2010b20:	e13ffb15 	stw	r4,-20(fp)
 2010b24:	e17ffc15 	stw	r5,-16(fp)
 2010b28:	e1bffd15 	stw	r6,-12(fp)
 2010b2c:	e1fffe15 	stw	r7,-8(fp)
  register FILE *fp = (FILE *) cookie;
 2010b30:	e43ffc17 	ldw	r16,-16(fp)
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
 2010b34:	8080030b 	ldhu	r2,12(r16)
 2010b38:	10bfffcc 	andi	r2,r2,65535
 2010b3c:	1080400c 	andi	r2,r2,256
 2010b40:	10000926 	beq	r2,zero,2010b68 <__swrite+0x5c>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
 2010b44:	8080038b 	ldhu	r2,14(r16)
 2010b48:	10bfffcc 	andi	r2,r2,65535
 2010b4c:	10a0001c 	xori	r2,r2,32768
 2010b50:	10a00004 	addi	r2,r2,-32768
 2010b54:	01c00084 	movi	r7,2
 2010b58:	000d883a 	mov	r6,zero
 2010b5c:	100b883a 	mov	r5,r2
 2010b60:	e13ffb17 	ldw	r4,-20(fp)
 2010b64:	2012a780 	call	2012a78 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
 2010b68:	80c0030b 	ldhu	r3,12(r16)
 2010b6c:	00bbffc4 	movi	r2,-4097
 2010b70:	1884703a 	and	r2,r3,r2
 2010b74:	8080030d 	sth	r2,12(r16)
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
 2010b78:	8080038b 	ldhu	r2,14(r16)
 2010b7c:	10bfffcc 	andi	r2,r2,65535
 2010b80:	10a0001c 	xori	r2,r2,32768
 2010b84:	10a00004 	addi	r2,r2,-32768
 2010b88:	e0fffe17 	ldw	r3,-8(fp)
 2010b8c:	180f883a 	mov	r7,r3
 2010b90:	e1bffd17 	ldw	r6,-12(fp)
 2010b94:	100b883a 	mov	r5,r2
 2010b98:	e13ffb17 	ldw	r4,-20(fp)
 2010b9c:	20123340 	call	2012334 <_write_r>
 2010ba0:	e0bffa15 	stw	r2,-24(fp)
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
 2010ba4:	e0bffa17 	ldw	r2,-24(fp)
}
 2010ba8:	e6ffff04 	addi	sp,fp,-4
 2010bac:	dfc00217 	ldw	ra,8(sp)
 2010bb0:	df000117 	ldw	fp,4(sp)
 2010bb4:	dc000017 	ldw	r16,0(sp)
 2010bb8:	dec00304 	addi	sp,sp,12
 2010bbc:	f800283a 	ret

02010bc0 <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
 2010bc0:	defff804 	addi	sp,sp,-32
 2010bc4:	dfc00715 	stw	ra,28(sp)
 2010bc8:	df000615 	stw	fp,24(sp)
 2010bcc:	dc400515 	stw	r17,20(sp)
 2010bd0:	dc000415 	stw	r16,16(sp)
 2010bd4:	df000604 	addi	fp,sp,24
 2010bd8:	e13ffa15 	stw	r4,-24(fp)
 2010bdc:	e17ffb15 	stw	r5,-20(fp)
 2010be0:	e1bffc15 	stw	r6,-16(fp)
 2010be4:	e1fffd15 	stw	r7,-12(fp)
  register FILE *fp = (FILE *) cookie;
 2010be8:	e43ffb17 	ldw	r16,-20(fp)
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
 2010bec:	8080038b 	ldhu	r2,14(r16)
 2010bf0:	10bfffcc 	andi	r2,r2,65535
 2010bf4:	10a0001c 	xori	r2,r2,32768
 2010bf8:	10a00004 	addi	r2,r2,-32768
 2010bfc:	e1fffd17 	ldw	r7,-12(fp)
 2010c00:	e1bffc17 	ldw	r6,-16(fp)
 2010c04:	100b883a 	mov	r5,r2
 2010c08:	e13ffa17 	ldw	r4,-24(fp)
 2010c0c:	2012a780 	call	2012a78 <_lseek_r>
 2010c10:	1023883a 	mov	r17,r2
  if (ret == -1L)
 2010c14:	88bfffd8 	cmpnei	r2,r17,-1
 2010c18:	1000051e 	bne	r2,zero,2010c30 <__sseek+0x70>
    fp->_flags &= ~__SOFF;
 2010c1c:	80c0030b 	ldhu	r3,12(r16)
 2010c20:	00bbffc4 	movi	r2,-4097
 2010c24:	1884703a 	and	r2,r3,r2
 2010c28:	8080030d 	sth	r2,12(r16)
 2010c2c:	00000406 	br	2010c40 <__sseek+0x80>
  else
    {
      fp->_flags |= __SOFF;
 2010c30:	8080030b 	ldhu	r2,12(r16)
 2010c34:	10840014 	ori	r2,r2,4096
 2010c38:	8080030d 	sth	r2,12(r16)
      fp->_offset = ret;
 2010c3c:	84401415 	stw	r17,80(r16)
    }
  return ret;
 2010c40:	8805883a 	mov	r2,r17
}
 2010c44:	e6fffe04 	addi	sp,fp,-8
 2010c48:	dfc00317 	ldw	ra,12(sp)
 2010c4c:	df000217 	ldw	fp,8(sp)
 2010c50:	dc400117 	ldw	r17,4(sp)
 2010c54:	dc000017 	ldw	r16,0(sp)
 2010c58:	dec00404 	addi	sp,sp,16
 2010c5c:	f800283a 	ret

02010c60 <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
 2010c60:	defffb04 	addi	sp,sp,-20
 2010c64:	dfc00415 	stw	ra,16(sp)
 2010c68:	df000315 	stw	fp,12(sp)
 2010c6c:	df000304 	addi	fp,sp,12
 2010c70:	e13ffe15 	stw	r4,-8(fp)
 2010c74:	e17fff15 	stw	r5,-4(fp)
  FILE *fp = (FILE *) cookie;
 2010c78:	e0bfff17 	ldw	r2,-4(fp)
 2010c7c:	e0bffd15 	stw	r2,-12(fp)

  return _close_r (ptr, fp->_file);
 2010c80:	e0bffd17 	ldw	r2,-12(fp)
 2010c84:	1080038b 	ldhu	r2,14(r2)
 2010c88:	10bfffcc 	andi	r2,r2,65535
 2010c8c:	10a0001c 	xori	r2,r2,32768
 2010c90:	10a00004 	addi	r2,r2,-32768
 2010c94:	100b883a 	mov	r5,r2
 2010c98:	e13ffe17 	ldw	r4,-8(fp)
 2010c9c:	20123a40 	call	20123a4 <_close_r>
}
 2010ca0:	e037883a 	mov	sp,fp
 2010ca4:	dfc00117 	ldw	ra,4(sp)
 2010ca8:	df000017 	ldw	fp,0(sp)
 2010cac:	dec00204 	addi	sp,sp,8
 2010cb0:	f800283a 	ret

02010cb4 <strcmp>:

int
_DEFUN (strcmp, (s1, s2),
	_CONST char *s1 _AND
	_CONST char *s2)
{ 
 2010cb4:	defffb04 	addi	sp,sp,-20
 2010cb8:	df000415 	stw	fp,16(sp)
 2010cbc:	df000404 	addi	fp,sp,16
 2010cc0:	e13ffe15 	stw	r4,-8(fp)
 2010cc4:	e17fff15 	stw	r5,-4(fp)
#else
  unsigned long *a1;
  unsigned long *a2;

  /* If s1 or s2 are unaligned, then compare bytes. */
  if (!UNALIGNED (s1, s2))
 2010cc8:	e0fffe17 	ldw	r3,-8(fp)
 2010ccc:	e0bfff17 	ldw	r2,-4(fp)
 2010cd0:	1884b03a 	or	r2,r3,r2
 2010cd4:	108000cc 	andi	r2,r2,3
 2010cd8:	10002a1e 	bne	r2,zero,2010d84 <strcmp+0xd0>
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
 2010cdc:	e0bffe17 	ldw	r2,-8(fp)
 2010ce0:	e0bffc15 	stw	r2,-16(fp)
      a2 = (unsigned long*)s2;
 2010ce4:	e0bfff17 	ldw	r2,-4(fp)
 2010ce8:	e0bffd15 	stw	r2,-12(fp)
      while (*a1 == *a2)
 2010cec:	00001506 	br	2010d44 <strcmp+0x90>
        {
          /* To get here, *a1 == *a2, thus if we find a null in *a1,
	     then the strings must be equal, so return zero.  */
          if (DETECTNULL (*a1))
 2010cf0:	e0bffc17 	ldw	r2,-16(fp)
 2010cf4:	10c00017 	ldw	r3,0(r2)
 2010cf8:	00bfbff4 	movhi	r2,65279
 2010cfc:	10bfbfc4 	addi	r2,r2,-257
 2010d00:	1887883a 	add	r3,r3,r2
 2010d04:	e0bffc17 	ldw	r2,-16(fp)
 2010d08:	10800017 	ldw	r2,0(r2)
 2010d0c:	0084303a 	nor	r2,zero,r2
 2010d10:	1886703a 	and	r3,r3,r2
 2010d14:	00a02074 	movhi	r2,32897
 2010d18:	10a02004 	addi	r2,r2,-32640
 2010d1c:	1884703a 	and	r2,r3,r2
 2010d20:	10000226 	beq	r2,zero,2010d2c <strcmp+0x78>
	    return 0;
 2010d24:	0005883a 	mov	r2,zero
 2010d28:	00002e06 	br	2010de4 <strcmp+0x130>

          a1++;
 2010d2c:	e0bffc17 	ldw	r2,-16(fp)
 2010d30:	10800104 	addi	r2,r2,4
 2010d34:	e0bffc15 	stw	r2,-16(fp)
          a2++;
 2010d38:	e0bffd17 	ldw	r2,-12(fp)
 2010d3c:	10800104 	addi	r2,r2,4
 2010d40:	e0bffd15 	stw	r2,-12(fp)
  if (!UNALIGNED (s1, s2))
    {  
      /* If s1 and s2 are word-aligned, compare them a word at a time. */
      a1 = (unsigned long*)s1;
      a2 = (unsigned long*)s2;
      while (*a1 == *a2)
 2010d44:	e0bffc17 	ldw	r2,-16(fp)
 2010d48:	10c00017 	ldw	r3,0(r2)
 2010d4c:	e0bffd17 	ldw	r2,-12(fp)
 2010d50:	10800017 	ldw	r2,0(r2)
 2010d54:	18bfe626 	beq	r3,r2,2010cf0 <strcmp+0x3c>
          a1++;
          a2++;
        }

      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
 2010d58:	e0bffc17 	ldw	r2,-16(fp)
 2010d5c:	e0bffe15 	stw	r2,-8(fp)
      s2 = (char*)a2;
 2010d60:	e0bffd17 	ldw	r2,-12(fp)
 2010d64:	e0bfff15 	stw	r2,-4(fp)
    }

  while (*s1 != '\0' && *s1 == *s2)
 2010d68:	00000606 	br	2010d84 <strcmp+0xd0>
    {
      s1++;
 2010d6c:	e0bffe17 	ldw	r2,-8(fp)
 2010d70:	10800044 	addi	r2,r2,1
 2010d74:	e0bffe15 	stw	r2,-8(fp)
      s2++;
 2010d78:	e0bfff17 	ldw	r2,-4(fp)
 2010d7c:	10800044 	addi	r2,r2,1
 2010d80:	e0bfff15 	stw	r2,-4(fp)
      /* A difference was detected in last few bytes of s1, so search bytewise */
      s1 = (char*)a1;
      s2 = (char*)a2;
    }

  while (*s1 != '\0' && *s1 == *s2)
 2010d84:	e0bffe17 	ldw	r2,-8(fp)
 2010d88:	10800003 	ldbu	r2,0(r2)
 2010d8c:	10803fcc 	andi	r2,r2,255
 2010d90:	1080201c 	xori	r2,r2,128
 2010d94:	10bfe004 	addi	r2,r2,-128
 2010d98:	10000b26 	beq	r2,zero,2010dc8 <strcmp+0x114>
 2010d9c:	e0bffe17 	ldw	r2,-8(fp)
 2010da0:	10c00003 	ldbu	r3,0(r2)
 2010da4:	e0bfff17 	ldw	r2,-4(fp)
 2010da8:	10800003 	ldbu	r2,0(r2)
 2010dac:	18c03fcc 	andi	r3,r3,255
 2010db0:	18c0201c 	xori	r3,r3,128
 2010db4:	18ffe004 	addi	r3,r3,-128
 2010db8:	10803fcc 	andi	r2,r2,255
 2010dbc:	1080201c 	xori	r2,r2,128
 2010dc0:	10bfe004 	addi	r2,r2,-128
 2010dc4:	18bfe926 	beq	r3,r2,2010d6c <strcmp+0xb8>
    {
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 2010dc8:	e0bffe17 	ldw	r2,-8(fp)
 2010dcc:	10800003 	ldbu	r2,0(r2)
 2010dd0:	10c03fcc 	andi	r3,r2,255
 2010dd4:	e0bfff17 	ldw	r2,-4(fp)
 2010dd8:	10800003 	ldbu	r2,0(r2)
 2010ddc:	10803fcc 	andi	r2,r2,255
 2010de0:	1885c83a 	sub	r2,r3,r2
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 2010de4:	e037883a 	mov	sp,fp
 2010de8:	df000017 	ldw	fp,0(sp)
 2010dec:	dec00104 	addi	sp,sp,4
 2010df0:	f800283a 	ret

02010df4 <__sprint_r>:
int
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
 2010df4:	defff604 	addi	sp,sp,-40
 2010df8:	dfc00915 	stw	ra,36(sp)
 2010dfc:	df000815 	stw	fp,32(sp)
 2010e00:	dc400715 	stw	r17,28(sp)
 2010e04:	dc000615 	stw	r16,24(sp)
 2010e08:	df000804 	addi	fp,sp,32
 2010e0c:	e13ffc15 	stw	r4,-16(fp)
 2010e10:	e17ffd15 	stw	r5,-12(fp)
 2010e14:	3021883a 	mov	r16,r6
	register int err = 0;
 2010e18:	0023883a 	mov	r17,zero

	if (uio->uio_resid == 0) {
 2010e1c:	80800217 	ldw	r2,8(r16)
 2010e20:	1000031e 	bne	r2,zero,2010e30 <__sprint_r+0x3c>
		uio->uio_iovcnt = 0;
 2010e24:	80000115 	stw	zero,4(r16)
		return (0);
 2010e28:	0005883a 	mov	r2,zero
 2010e2c:	00003906 	br	2010f14 <__sprint_r+0x120>
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
 2010e30:	e0bffd17 	ldw	r2,-12(fp)
 2010e34:	10801917 	ldw	r2,100(r2)
 2010e38:	1088000c 	andi	r2,r2,8192
 2010e3c:	10002d26 	beq	r2,zero,2010ef4 <__sprint_r+0x100>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
 2010e40:	80800017 	ldw	r2,0(r16)
 2010e44:	e0bff815 	stw	r2,-32(fp)
		for (; uio->uio_resid != 0;
 2010e48:	00002706 	br	2010ee8 <__sprint_r+0xf4>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
 2010e4c:	e0bff817 	ldw	r2,-32(fp)
 2010e50:	10800017 	ldw	r2,0(r2)
 2010e54:	e0bffa15 	stw	r2,-24(fp)
			len = iov->iov_len / sizeof (wchar_t);
 2010e58:	e0bff817 	ldw	r2,-32(fp)
 2010e5c:	10800117 	ldw	r2,4(r2)
 2010e60:	1004d0ba 	srli	r2,r2,2
 2010e64:	e0bffb15 	stw	r2,-20(fp)
			for (i = 0; i < len; i++) {
 2010e68:	e03ff915 	stw	zero,-28(fp)
 2010e6c:	00001206 	br	2010eb8 <__sprint_r+0xc4>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
 2010e70:	e0bff917 	ldw	r2,-28(fp)
 2010e74:	1085883a 	add	r2,r2,r2
 2010e78:	1085883a 	add	r2,r2,r2
 2010e7c:	1007883a 	mov	r3,r2
 2010e80:	e0bffa17 	ldw	r2,-24(fp)
 2010e84:	10c5883a 	add	r2,r2,r3
 2010e88:	10800017 	ldw	r2,0(r2)
 2010e8c:	e1bffd17 	ldw	r6,-12(fp)
 2010e90:	100b883a 	mov	r5,r2
 2010e94:	e13ffc17 	ldw	r4,-16(fp)
 2010e98:	20128c00 	call	20128c0 <_fputwc_r>
 2010e9c:	10bfffd8 	cmpnei	r2,r2,-1
 2010ea0:	1000021e 	bne	r2,zero,2010eac <__sprint_r+0xb8>
					err = -1;
 2010ea4:	047fffc4 	movi	r17,-1
					goto out;
 2010ea8:	00001706 	br	2010f08 <__sprint_r+0x114>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
 2010eac:	e0bff917 	ldw	r2,-28(fp)
 2010eb0:	10800044 	addi	r2,r2,1
 2010eb4:	e0bff915 	stw	r2,-28(fp)
 2010eb8:	e0fff917 	ldw	r3,-28(fp)
 2010ebc:	e0bffb17 	ldw	r2,-20(fp)
 2010ec0:	18bfeb16 	blt	r3,r2,2010e70 <__sprint_r+0x7c>
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
 2010ec4:	80c00217 	ldw	r3,8(r16)
 2010ec8:	e0bffb17 	ldw	r2,-20(fp)
 2010ecc:	1085883a 	add	r2,r2,r2
 2010ed0:	1085883a 	add	r2,r2,r2
 2010ed4:	1885c83a 	sub	r2,r3,r2
 2010ed8:	80800215 	stw	r2,8(r16)
 2010edc:	e0bff817 	ldw	r2,-32(fp)
 2010ee0:	10800204 	addi	r2,r2,8
 2010ee4:	e0bff815 	stw	r2,-32(fp)
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
 2010ee8:	80800217 	ldw	r2,8(r16)
 2010eec:	103fd71e 	bne	r2,zero,2010e4c <__sprint_r+0x58>
 2010ef0:	00000506 	br	2010f08 <__sprint_r+0x114>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
 2010ef4:	800d883a 	mov	r6,r16
 2010ef8:	e17ffd17 	ldw	r5,-12(fp)
 2010efc:	e13ffc17 	ldw	r4,-16(fp)
 2010f00:	200c5240 	call	200c524 <__sfvwrite_r>
 2010f04:	1023883a 	mov	r17,r2
out:
	uio->uio_resid = 0;
 2010f08:	80000215 	stw	zero,8(r16)
	uio->uio_iovcnt = 0;
 2010f0c:	80000115 	stw	zero,4(r16)
	return (err);
 2010f10:	8805883a 	mov	r2,r17
}
 2010f14:	e6fffe04 	addi	sp,fp,-8
 2010f18:	dfc00317 	ldw	ra,12(sp)
 2010f1c:	df000217 	ldw	fp,8(sp)
 2010f20:	dc400117 	ldw	r17,4(sp)
 2010f24:	dc000017 	ldw	r16,0(sp)
 2010f28:	dec00404 	addi	sp,sp,16
 2010f2c:	f800283a 	ret

02010f30 <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
 2010f30:	defedf04 	addi	sp,sp,-1156
 2010f34:	dfc12015 	stw	ra,1152(sp)
 2010f38:	df011f15 	stw	fp,1148(sp)
 2010f3c:	dc011e15 	stw	r16,1144(sp)
 2010f40:	df011f04 	addi	fp,sp,1148
 2010f44:	e13ffc15 	stw	r4,-16(fp)
 2010f48:	2821883a 	mov	r16,r5
 2010f4c:	e1bffd15 	stw	r6,-12(fp)
 2010f50:	e1fffe15 	stw	r7,-8(fp)
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
 2010f54:	80c0030b 	ldhu	r3,12(r16)
 2010f58:	00bfff44 	movi	r2,-3
 2010f5c:	1884703a 	and	r2,r3,r2
 2010f60:	e0bee50d 	sth	r2,-1132(fp)
	fake._flags2 = fp->_flags2;
 2010f64:	80801917 	ldw	r2,100(r16)
 2010f68:	e0befb15 	stw	r2,-1044(fp)
	fake._file = fp->_file;
 2010f6c:	8080038b 	ldhu	r2,14(r16)
 2010f70:	e0bee58d 	sth	r2,-1130(fp)
	fake._cookie = fp->_cookie;
 2010f74:	80800717 	ldw	r2,28(r16)
 2010f78:	e0bee915 	stw	r2,-1116(fp)
	fake._write = fp->_write;
 2010f7c:	80800917 	ldw	r2,36(r16)
 2010f80:	e0beeb15 	stw	r2,-1108(fp)

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
 2010f84:	e0befc04 	addi	r2,fp,-1040
 2010f88:	e0bee215 	stw	r2,-1144(fp)
 2010f8c:	e0bee217 	ldw	r2,-1144(fp)
 2010f90:	e0bee615 	stw	r2,-1128(fp)
	fake._bf._size = fake._w = sizeof (buf);
 2010f94:	00810004 	movi	r2,1024
 2010f98:	e0bee415 	stw	r2,-1136(fp)
 2010f9c:	e0bee417 	ldw	r2,-1136(fp)
 2010fa0:	e0bee715 	stw	r2,-1124(fp)
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
 2010fa4:	e03ee815 	stw	zero,-1120(fp)
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
 2010fa8:	e0bee204 	addi	r2,fp,-1144
 2010fac:	e1fffe17 	ldw	r7,-8(fp)
 2010fb0:	e1bffd17 	ldw	r6,-12(fp)
 2010fb4:	100b883a 	mov	r5,r2
 2010fb8:	e13ffc17 	ldw	r4,-16(fp)
 2010fbc:	20110700 	call	2011070 <___vfiprintf_internal_r>
 2010fc0:	e0bee115 	stw	r2,-1148(fp)
	if (ret >= 0 && _fflush_r (rptr, &fake))
 2010fc4:	e0bee117 	ldw	r2,-1148(fp)
 2010fc8:	10000716 	blt	r2,zero,2010fe8 <__sbprintf+0xb8>
 2010fcc:	e0bee204 	addi	r2,fp,-1144
 2010fd0:	100b883a 	mov	r5,r2
 2010fd4:	e13ffc17 	ldw	r4,-16(fp)
 2010fd8:	200b7580 	call	200b758 <_fflush_r>
 2010fdc:	10000226 	beq	r2,zero,2010fe8 <__sbprintf+0xb8>
		ret = EOF;
 2010fe0:	00bfffc4 	movi	r2,-1
 2010fe4:	e0bee115 	stw	r2,-1148(fp)
	if (fake._flags & __SERR)
 2010fe8:	e0bee50b 	ldhu	r2,-1132(fp)
 2010fec:	10bfffcc 	andi	r2,r2,65535
 2010ff0:	1080100c 	andi	r2,r2,64
 2010ff4:	10000326 	beq	r2,zero,2011004 <__sbprintf+0xd4>
		fp->_flags |= __SERR;
 2010ff8:	8080030b 	ldhu	r2,12(r16)
 2010ffc:	10801014 	ori	r2,r2,64
 2011000:	8080030d 	sth	r2,12(r16)

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
#endif
	return (ret);
 2011004:	e0bee117 	ldw	r2,-1148(fp)
}
 2011008:	e6ffff04 	addi	sp,fp,-4
 201100c:	dfc00217 	ldw	ra,8(sp)
 2011010:	df000117 	ldw	fp,4(sp)
 2011014:	dc000017 	ldw	r16,0(sp)
 2011018:	dec00304 	addi	sp,sp,12
 201101c:	f800283a 	ret

02011020 <__vfiprintf_internal>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
 2011020:	defffa04 	addi	sp,sp,-24
 2011024:	dfc00515 	stw	ra,20(sp)
 2011028:	df000415 	stw	fp,16(sp)
 201102c:	df000404 	addi	fp,sp,16
 2011030:	e13ffd15 	stw	r4,-12(fp)
 2011034:	e17ffe15 	stw	r5,-8(fp)
 2011038:	e1bfff15 	stw	r6,-4(fp)
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
 201103c:	d0a00617 	ldw	r2,-32744(gp)
 2011040:	e1ffff17 	ldw	r7,-4(fp)
 2011044:	e1bffe17 	ldw	r6,-8(fp)
 2011048:	e17ffd17 	ldw	r5,-12(fp)
 201104c:	1009883a 	mov	r4,r2
 2011050:	20110700 	call	2011070 <___vfiprintf_internal_r>
 2011054:	e0bffc15 	stw	r2,-16(fp)
  return result;
 2011058:	e0bffc17 	ldw	r2,-16(fp)
}
 201105c:	e037883a 	mov	sp,fp
 2011060:	dfc00117 	ldw	ra,4(sp)
 2011064:	df000017 	ldw	fp,0(sp)
 2011068:	dec00204 	addi	sp,sp,8
 201106c:	f800283a 	ret

02011070 <___vfiprintf_internal_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
 2011070:	deffb704 	addi	sp,sp,-292
 2011074:	dfc04815 	stw	ra,288(sp)
 2011078:	df004715 	stw	fp,284(sp)
 201107c:	ddc04615 	stw	r23,280(sp)
 2011080:	dd804515 	stw	r22,276(sp)
 2011084:	dd404415 	stw	r21,272(sp)
 2011088:	dd004315 	stw	r20,268(sp)
 201108c:	dcc04215 	stw	r19,264(sp)
 2011090:	dc804115 	stw	r18,260(sp)
 2011094:	dc404015 	stw	r17,256(sp)
 2011098:	dc003f15 	stw	r16,252(sp)
 201109c:	df004704 	addi	fp,sp,284
 20110a0:	e13fe615 	stw	r4,-104(fp)
 20110a4:	e17fe715 	stw	r5,-100(fp)
 20110a8:	e1bfe815 	stw	r6,-96(fp)
 20110ac:	e1ffe915 	stw	r7,-92(fp)
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
 20110b0:	e03fc215 	stw	zero,-248(fp)
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
 20110b4:	e03fc315 	stw	zero,-244(fp)
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
	CHECK_INIT (data, fp);
 20110b8:	e0bfe617 	ldw	r2,-104(fp)
 20110bc:	e0bfc415 	stw	r2,-240(fp)
 20110c0:	e0bfc417 	ldw	r2,-240(fp)
 20110c4:	10000526 	beq	r2,zero,20110dc <___vfiprintf_internal_r+0x6c>
 20110c8:	e0bfc417 	ldw	r2,-240(fp)
 20110cc:	10800e17 	ldw	r2,56(r2)
 20110d0:	1000021e 	bne	r2,zero,20110dc <___vfiprintf_internal_r+0x6c>
 20110d4:	e13fc417 	ldw	r4,-240(fp)
 20110d8:	200bbd80 	call	200bbd8 <__sinit>
	_newlib_flockfile_start (fp);

	ORIENT(fp, -1);
 20110dc:	e0bfe717 	ldw	r2,-100(fp)
 20110e0:	1080030b 	ldhu	r2,12(r2)
 20110e4:	10bfffcc 	andi	r2,r2,65535
 20110e8:	1088000c 	andi	r2,r2,8192
 20110ec:	10000c1e 	bne	r2,zero,2011120 <___vfiprintf_internal_r+0xb0>
 20110f0:	e0bfe717 	ldw	r2,-100(fp)
 20110f4:	1080030b 	ldhu	r2,12(r2)
 20110f8:	10880014 	ori	r2,r2,8192
 20110fc:	1007883a 	mov	r3,r2
 2011100:	e0bfe717 	ldw	r2,-100(fp)
 2011104:	10c0030d 	sth	r3,12(r2)
 2011108:	e0bfe717 	ldw	r2,-100(fp)
 201110c:	10c01917 	ldw	r3,100(r2)
 2011110:	00b7ffc4 	movi	r2,-8193
 2011114:	1886703a 	and	r3,r3,r2
 2011118:	e0bfe717 	ldw	r2,-100(fp)
 201111c:	10c01915 	stw	r3,100(r2)

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
 2011120:	e0bfe717 	ldw	r2,-100(fp)
 2011124:	1080030b 	ldhu	r2,12(r2)
 2011128:	10bfffcc 	andi	r2,r2,65535
 201112c:	1080020c 	andi	r2,r2,8
 2011130:	10000326 	beq	r2,zero,2011140 <___vfiprintf_internal_r+0xd0>
 2011134:	e0bfe717 	ldw	r2,-100(fp)
 2011138:	10800417 	ldw	r2,16(r2)
 201113c:	1000061e 	bne	r2,zero,2011158 <___vfiprintf_internal_r+0xe8>
 2011140:	e17fe717 	ldw	r5,-100(fp)
 2011144:	e13fe617 	ldw	r4,-104(fp)
 2011148:	20093880 	call	2009388 <__swsetup_r>
 201114c:	10000226 	beq	r2,zero,2011158 <___vfiprintf_internal_r+0xe8>
		_newlib_flockfile_exit (fp);
		return (EOF);
 2011150:	00bfffc4 	movi	r2,-1
 2011154:	00046a06 	br	2012300 <___vfiprintf_internal_r+0x1290>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 2011158:	e0bfe717 	ldw	r2,-100(fp)
 201115c:	1080030b 	ldhu	r2,12(r2)
 2011160:	10bfffcc 	andi	r2,r2,65535
 2011164:	1080068c 	andi	r2,r2,26
 2011168:	10800298 	cmpnei	r2,r2,10
 201116c:	10000c1e 	bne	r2,zero,20111a0 <___vfiprintf_internal_r+0x130>
	    fp->_file >= 0) {
 2011170:	e0bfe717 	ldw	r2,-100(fp)
 2011174:	1080038b 	ldhu	r2,14(r2)
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
 2011178:	10bfffcc 	andi	r2,r2,65535
 201117c:	10a0001c 	xori	r2,r2,32768
 2011180:	10a00004 	addi	r2,r2,-32768
 2011184:	10000616 	blt	r2,zero,20111a0 <___vfiprintf_internal_r+0x130>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
		return (__sbprintf (data, fp, fmt0, ap));
 2011188:	e1ffe917 	ldw	r7,-92(fp)
 201118c:	e1bfe817 	ldw	r6,-96(fp)
 2011190:	e17fe717 	ldw	r5,-100(fp)
 2011194:	e13fe617 	ldw	r4,-104(fp)
 2011198:	2010f300 	call	2010f30 <__sbprintf>
 201119c:	00045806 	br	2012300 <___vfiprintf_internal_r+0x1290>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
 20111a0:	e57fe817 	ldw	r21,-96(fp)
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
 20111a4:	e4bfcb04 	addi	r18,fp,-212
 20111a8:	e4bfc815 	stw	r18,-224(fp)
	uio.uio_resid = 0;
 20111ac:	e03fca15 	stw	zero,-216(fp)
	uio.uio_iovcnt = 0;
 20111b0:	e03fc915 	stw	zero,-220(fp)
#endif
	ret = 0;
 20111b4:	e03fb915 	stw	zero,-284(fp)

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
 20111b8:	a829883a 	mov	r20,r21
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 20111bc:	00000106 	br	20111c4 <___vfiprintf_internal_r+0x154>
                    fmt += 1;
 20111c0:	ad400044 	addi	r21,r21,1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
 20111c4:	a8800003 	ldbu	r2,0(r21)
 20111c8:	10803fcc 	andi	r2,r2,255
 20111cc:	1080201c 	xori	r2,r2,128
 20111d0:	10bfe004 	addi	r2,r2,-128
 20111d4:	10000626 	beq	r2,zero,20111f0 <___vfiprintf_internal_r+0x180>
 20111d8:	a8800003 	ldbu	r2,0(r21)
 20111dc:	10803fcc 	andi	r2,r2,255
 20111e0:	1080201c 	xori	r2,r2,128
 20111e4:	10bfe004 	addi	r2,r2,-128
 20111e8:	10800958 	cmpnei	r2,r2,37
 20111ec:	103ff41e 	bne	r2,zero,20111c0 <___vfiprintf_internal_r+0x150>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
 20111f0:	a807883a 	mov	r3,r21
 20111f4:	a005883a 	mov	r2,r20
 20111f8:	18a1c83a 	sub	r16,r3,r2
 20111fc:	80001826 	beq	r16,zero,2011260 <___vfiprintf_internal_r+0x1f0>
			PRINT (cp, m);
 2011200:	95000015 	stw	r20,0(r18)
 2011204:	8005883a 	mov	r2,r16
 2011208:	90800115 	stw	r2,4(r18)
 201120c:	e0bfca17 	ldw	r2,-216(fp)
 2011210:	8007883a 	mov	r3,r16
 2011214:	10c5883a 	add	r2,r2,r3
 2011218:	e0bfca15 	stw	r2,-216(fp)
 201121c:	94800204 	addi	r18,r18,8
 2011220:	e0bfc917 	ldw	r2,-220(fp)
 2011224:	10800044 	addi	r2,r2,1
 2011228:	e0bfc915 	stw	r2,-220(fp)
 201122c:	e0bfc917 	ldw	r2,-220(fp)
 2011230:	10800210 	cmplti	r2,r2,8
 2011234:	1000071e 	bne	r2,zero,2011254 <___vfiprintf_internal_r+0x1e4>
 2011238:	e0bfc804 	addi	r2,fp,-224
 201123c:	100d883a 	mov	r6,r2
 2011240:	e17fe717 	ldw	r5,-100(fp)
 2011244:	e13fe617 	ldw	r4,-104(fp)
 2011248:	2010df40 	call	2010df4 <__sprint_r>
 201124c:	1004031e 	bne	r2,zero,201225c <___vfiprintf_internal_r+0x11ec>
 2011250:	e4bfcb04 	addi	r18,fp,-212
			ret += m;
 2011254:	e0bfb917 	ldw	r2,-284(fp)
 2011258:	1405883a 	add	r2,r2,r16
 201125c:	e0bfb915 	stw	r2,-284(fp)
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
 2011260:	a8800003 	ldbu	r2,0(r21)
 2011264:	10803fcc 	andi	r2,r2,255
 2011268:	1080201c 	xori	r2,r2,128
 201126c:	10bfe004 	addi	r2,r2,-128
 2011270:	1003ec26 	beq	r2,zero,2012224 <___vfiprintf_internal_r+0x11b4>
                    goto done;
#endif
		fmt_anchor = fmt;
 2011274:	e57fc515 	stw	r21,-236(fp)
		fmt++;		/* skip over '%' */
 2011278:	ad400044 	addi	r21,r21,1

		flags = 0;
 201127c:	0027883a 	mov	r19,zero
		dprec = 0;
 2011280:	e03fbf15 	stw	zero,-260(fp)
		width = 0;
 2011284:	e03fba15 	stw	zero,-280(fp)
		prec = -1;
 2011288:	00bfffc4 	movi	r2,-1
 201128c:	e0bfbb15 	stw	r2,-276(fp)
		sign = '\0';
 2011290:	e03fc705 	stb	zero,-228(fp)
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
 2011294:	a805883a 	mov	r2,r21
 2011298:	15400044 	addi	r21,r2,1
 201129c:	10800003 	ldbu	r2,0(r2)
 20112a0:	14403fcc 	andi	r17,r2,255
 20112a4:	8c40201c 	xori	r17,r17,128
 20112a8:	8c7fe004 	addi	r17,r17,-128
reswitch:	switch (ch) {
 20112ac:	88bff804 	addi	r2,r17,-32
 20112b0:	10c01668 	cmpgeui	r3,r2,89
 20112b4:	1802881e 	bne	r3,zero,2011cd8 <___vfiprintf_internal_r+0xc68>
 20112b8:	100690ba 	slli	r3,r2,2
 20112bc:	00808074 	movhi	r2,513
 20112c0:	1084b404 	addi	r2,r2,4816
 20112c4:	1885883a 	add	r2,r3,r2
 20112c8:	10800017 	ldw	r2,0(r2)
 20112cc:	1000683a 	jmp	r2
 20112d0:	02011434 	movhi	r8,1104
 20112d4:	02011cd8 	cmpnei	r8,zero,1139
 20112d8:	02011cd8 	cmpnei	r8,zero,1139
 20112dc:	02011454 	movui	r8,1105
 20112e0:	02011cd8 	cmpnei	r8,zero,1139
 20112e4:	02011cd8 	cmpnei	r8,zero,1139
 20112e8:	02011cd8 	cmpnei	r8,zero,1139
 20112ec:	02011cd8 	cmpnei	r8,zero,1139
 20112f0:	02011cd8 	cmpnei	r8,zero,1139
 20112f4:	02011cd8 	cmpnei	r8,zero,1139
 20112f8:	0201145c 	xori	r8,zero,1105
 20112fc:	02011490 	cmplti	r8,zero,1106
 2011300:	02011cd8 	cmpnei	r8,zero,1139
 2011304:	02011488 	cmpgei	r8,zero,1106
 2011308:	0201149c 	xori	r8,zero,1106
 201130c:	02011cd8 	cmpnei	r8,zero,1139
 2011310:	02011530 	cmpltui	r8,zero,1108
 2011314:	02011538 	rdprs	r8,zero,1108
 2011318:	02011538 	rdprs	r8,zero,1108
 201131c:	02011538 	rdprs	r8,zero,1108
 2011320:	02011538 	rdprs	r8,zero,1108
 2011324:	02011538 	rdprs	r8,zero,1108
 2011328:	02011538 	rdprs	r8,zero,1108
 201132c:	02011538 	rdprs	r8,zero,1108
 2011330:	02011538 	rdprs	r8,zero,1108
 2011334:	02011538 	rdprs	r8,zero,1108
 2011338:	02011cd8 	cmpnei	r8,zero,1139
 201133c:	02011cd8 	cmpnei	r8,zero,1139
 2011340:	02011cd8 	cmpnei	r8,zero,1139
 2011344:	02011cd8 	cmpnei	r8,zero,1139
 2011348:	02011cd8 	cmpnei	r8,zero,1139
 201134c:	02011cd8 	cmpnei	r8,zero,1139
 2011350:	02011cd8 	cmpnei	r8,zero,1139
 2011354:	02011cd8 	cmpnei	r8,zero,1139
 2011358:	02011cd8 	cmpnei	r8,zero,1139
 201135c:	02011cd8 	cmpnei	r8,zero,1139
 2011360:	020115d8 	cmpnei	r8,zero,1111
 2011364:	02011cd8 	cmpnei	r8,zero,1139
 2011368:	02011cd8 	cmpnei	r8,zero,1139
 201136c:	02011cd8 	cmpnei	r8,zero,1139
 2011370:	02011cd8 	cmpnei	r8,zero,1139
 2011374:	02011cd8 	cmpnei	r8,zero,1139
 2011378:	02011cd8 	cmpnei	r8,zero,1139
 201137c:	02011cd8 	cmpnei	r8,zero,1139
 2011380:	02011cd8 	cmpnei	r8,zero,1139
 2011384:	02011cd8 	cmpnei	r8,zero,1139
 2011388:	02011cd8 	cmpnei	r8,zero,1139
 201138c:	02011778 	rdprs	r8,zero,1117
 2011390:	02011cd8 	cmpnei	r8,zero,1139
 2011394:	02011cd8 	cmpnei	r8,zero,1139
 2011398:	02011cd8 	cmpnei	r8,zero,1139
 201139c:	02011cd8 	cmpnei	r8,zero,1139
 20113a0:	02011cd8 	cmpnei	r8,zero,1139
 20113a4:	020118f4 	movhi	r8,1123
 20113a8:	02011cd8 	cmpnei	r8,zero,1139
 20113ac:	02011cd8 	cmpnei	r8,zero,1139
 20113b0:	020119b4 	movhi	r8,1126
 20113b4:	02011cd8 	cmpnei	r8,zero,1139
 20113b8:	02011cd8 	cmpnei	r8,zero,1139
 20113bc:	02011cd8 	cmpnei	r8,zero,1139
 20113c0:	02011cd8 	cmpnei	r8,zero,1139
 20113c4:	02011cd8 	cmpnei	r8,zero,1139
 20113c8:	02011cd8 	cmpnei	r8,zero,1139
 20113cc:	02011cd8 	cmpnei	r8,zero,1139
 20113d0:	02011cd8 	cmpnei	r8,zero,1139
 20113d4:	02011cd8 	cmpnei	r8,zero,1139
 20113d8:	02011cd8 	cmpnei	r8,zero,1139
 20113dc:	020115b0 	cmpltui	r8,zero,1110
 20113e0:	020115dc 	xori	r8,zero,1111
 20113e4:	02011cd8 	cmpnei	r8,zero,1139
 20113e8:	02011cd8 	cmpnei	r8,zero,1139
 20113ec:	02011cd8 	cmpnei	r8,zero,1139
 20113f0:	02011574 	movhi	r8,1109
 20113f4:	020115dc 	xori	r8,zero,1111
 20113f8:	02011cd8 	cmpnei	r8,zero,1139
 20113fc:	02011cd8 	cmpnei	r8,zero,1139
 2011400:	0201157c 	xorhi	r8,zero,1109
 2011404:	02011cd8 	cmpnei	r8,zero,1139
 2011408:	020116d8 	cmpnei	r8,zero,1115
 201140c:	0201177c 	xorhi	r8,zero,1117
 2011410:	0201181c 	xori	r8,zero,1120
 2011414:	020115a8 	cmpgeui	r8,zero,1110
 2011418:	02011cd8 	cmpnei	r8,zero,1139
 201141c:	02011864 	muli	r8,zero,1121
 2011420:	02011cd8 	cmpnei	r8,zero,1139
 2011424:	020118f8 	rdprs	r8,zero,1123
 2011428:	02011cd8 	cmpnei	r8,zero,1139
 201142c:	02011cd8 	cmpnei	r8,zero,1139
 2011430:	020119c4 	movi	r8,1127
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
 2011434:	e0bfc703 	ldbu	r2,-228(fp)
 2011438:	10803fcc 	andi	r2,r2,255
 201143c:	1080201c 	xori	r2,r2,128
 2011440:	10bfe004 	addi	r2,r2,-128
 2011444:	103f931e 	bne	r2,zero,2011294 <___vfiprintf_internal_r+0x224>
				sign = ' ';
 2011448:	00800804 	movi	r2,32
 201144c:	e0bfc705 	stb	r2,-228(fp)
			goto rflag;
 2011450:	003f9006 	br	2011294 <___vfiprintf_internal_r+0x224>
		case '#':
			flags |= ALT;
 2011454:	9cc00054 	ori	r19,r19,1
			goto rflag;
 2011458:	003f8e06 	br	2011294 <___vfiprintf_internal_r+0x224>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
 201145c:	e0bfe917 	ldw	r2,-92(fp)
 2011460:	10c00104 	addi	r3,r2,4
 2011464:	e0ffe915 	stw	r3,-92(fp)
 2011468:	10800017 	ldw	r2,0(r2)
 201146c:	e0bfba15 	stw	r2,-280(fp)
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
 2011470:	e0bfba17 	ldw	r2,-280(fp)
 2011474:	10000116 	blt	r2,zero,201147c <___vfiprintf_internal_r+0x40c>
				goto rflag;
 2011478:	003f8606 	br	2011294 <___vfiprintf_internal_r+0x224>
			width = -width;
 201147c:	e0bfba17 	ldw	r2,-280(fp)
 2011480:	0085c83a 	sub	r2,zero,r2
 2011484:	e0bfba15 	stw	r2,-280(fp)
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
 2011488:	9cc00114 	ori	r19,r19,4
			goto rflag;
 201148c:	003f8106 	br	2011294 <___vfiprintf_internal_r+0x224>
		case '+':
			sign = '+';
 2011490:	00800ac4 	movi	r2,43
 2011494:	e0bfc705 	stb	r2,-228(fp)
			goto rflag;
 2011498:	003f7e06 	br	2011294 <___vfiprintf_internal_r+0x224>
		case '.':
			if ((ch = *fmt++) == '*') {
 201149c:	a805883a 	mov	r2,r21
 20114a0:	15400044 	addi	r21,r2,1
 20114a4:	10800003 	ldbu	r2,0(r2)
 20114a8:	14403fcc 	andi	r17,r2,255
 20114ac:	8c40201c 	xori	r17,r17,128
 20114b0:	8c7fe004 	addi	r17,r17,-128
 20114b4:	88800a98 	cmpnei	r2,r17,42
 20114b8:	10000a1e 	bne	r2,zero,20114e4 <___vfiprintf_internal_r+0x474>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
 20114bc:	e0bfe917 	ldw	r2,-92(fp)
 20114c0:	10c00104 	addi	r3,r2,4
 20114c4:	e0ffe915 	stw	r3,-92(fp)
 20114c8:	10800017 	ldw	r2,0(r2)
 20114cc:	e0bfbb15 	stw	r2,-276(fp)
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
 20114d0:	e0bfbb17 	ldw	r2,-276(fp)
 20114d4:	103f6f0e 	bge	r2,zero,2011294 <___vfiprintf_internal_r+0x224>
					prec = -1;
 20114d8:	00bfffc4 	movi	r2,-1
 20114dc:	e0bfbb15 	stw	r2,-276(fp)
				goto rflag;
 20114e0:	003f6c06 	br	2011294 <___vfiprintf_internal_r+0x224>
			}
			n = 0;
 20114e4:	0021883a 	mov	r16,zero
			while (is_digit (ch)) {
 20114e8:	00000906 	br	2011510 <___vfiprintf_internal_r+0x4a0>
				n = 10 * n + to_digit (ch);
 20114ec:	80c002a4 	muli	r3,r16,10
 20114f0:	88bff404 	addi	r2,r17,-48
 20114f4:	18a1883a 	add	r16,r3,r2
				ch = *fmt++;
 20114f8:	a805883a 	mov	r2,r21
 20114fc:	15400044 	addi	r21,r2,1
 2011500:	10800003 	ldbu	r2,0(r2)
 2011504:	14403fcc 	andi	r17,r2,255
 2011508:	8c40201c 	xori	r17,r17,128
 201150c:	8c7fe004 	addi	r17,r17,-128
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
 2011510:	88bff404 	addi	r2,r17,-48
 2011514:	108002b0 	cmpltui	r2,r2,10
 2011518:	103ff41e 	bne	r2,zero,20114ec <___vfiprintf_internal_r+0x47c>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
 201151c:	8005883a 	mov	r2,r16
 2011520:	1000010e 	bge	r2,zero,2011528 <___vfiprintf_internal_r+0x4b8>
 2011524:	00bfffc4 	movi	r2,-1
 2011528:	e0bfbb15 	stw	r2,-276(fp)
			goto reswitch;
 201152c:	003f5f06 	br	20112ac <___vfiprintf_internal_r+0x23c>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
 2011530:	9cc02014 	ori	r19,r19,128
			goto rflag;
 2011534:	003f5706 	br	2011294 <___vfiprintf_internal_r+0x224>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
 2011538:	0021883a 	mov	r16,zero
			do {
				n = 10 * n + to_digit (ch);
 201153c:	80c002a4 	muli	r3,r16,10
 2011540:	88bff404 	addi	r2,r17,-48
 2011544:	18a1883a 	add	r16,r3,r2
				ch = *fmt++;
 2011548:	a805883a 	mov	r2,r21
 201154c:	15400044 	addi	r21,r2,1
 2011550:	10800003 	ldbu	r2,0(r2)
 2011554:	14403fcc 	andi	r17,r2,255
 2011558:	8c40201c 	xori	r17,r17,128
 201155c:	8c7fe004 	addi	r17,r17,-128
			} while (is_digit (ch));
 2011560:	88bff404 	addi	r2,r17,-48
 2011564:	108002b0 	cmpltui	r2,r2,10
 2011568:	103ff41e 	bne	r2,zero,201153c <___vfiprintf_internal_r+0x4cc>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
 201156c:	e43fba15 	stw	r16,-280(fp)
			goto reswitch;
 2011570:	003f4e06 	br	20112ac <___vfiprintf_internal_r+0x23c>
			if (*fmt == 'h') {
				fmt++;
				flags |= CHARINT;
			} else
#endif
				flags |= SHORTINT;
 2011574:	9cc01014 	ori	r19,r19,64
			goto rflag;
 2011578:	003f4606 	br	2011294 <___vfiprintf_internal_r+0x224>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
 201157c:	a8800003 	ldbu	r2,0(r21)
 2011580:	10803fcc 	andi	r2,r2,255
 2011584:	1080201c 	xori	r2,r2,128
 2011588:	10bfe004 	addi	r2,r2,-128
 201158c:	10801b18 	cmpnei	r2,r2,108
 2011590:	1000031e 	bne	r2,zero,20115a0 <___vfiprintf_internal_r+0x530>
				fmt++;
 2011594:	ad400044 	addi	r21,r21,1
				flags |= QUADINT;
 2011598:	9cc00814 	ori	r19,r19,32
 201159c:	003f3d06 	br	2011294 <___vfiprintf_internal_r+0x224>
			} else
#endif
				flags |= LONGINT;
 20115a0:	9cc00414 	ori	r19,r19,16
			goto rflag;
 20115a4:	003f3b06 	br	2011294 <___vfiprintf_internal_r+0x224>
		case 'q': /* extension */
			flags |= QUADINT;
 20115a8:	9cc00814 	ori	r19,r19,32
			goto rflag;
 20115ac:	003f3906 	br	2011294 <___vfiprintf_internal_r+0x224>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
 20115b0:	e53fdb04 	addi	r20,fp,-148
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
 20115b4:	e0bfe917 	ldw	r2,-92(fp)
 20115b8:	10c00104 	addi	r3,r2,4
 20115bc:	e0ffe915 	stw	r3,-92(fp)
 20115c0:	10800017 	ldw	r2,0(r2)
 20115c4:	a0800005 	stb	r2,0(r20)
				size = 1;
 20115c8:	00800044 	movi	r2,1
 20115cc:	e0bfc115 	stw	r2,-252(fp)
			}
			sign = '\0';
 20115d0:	e03fc705 	stb	zero,-228(fp)
			break;
 20115d4:	0001c806 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
		case 'D':  /* extension */
			flags |= LONGINT;
 20115d8:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
 20115dc:	9880080c 	andi	r2,r19,32
 20115e0:	10000826 	beq	r2,zero,2011604 <___vfiprintf_internal_r+0x594>
 20115e4:	e13fe917 	ldw	r4,-92(fp)
 20115e8:	20800204 	addi	r2,r4,8
 20115ec:	e0bfe915 	stw	r2,-92(fp)
 20115f0:	20800017 	ldw	r2,0(r4)
 20115f4:	20c00117 	ldw	r3,4(r4)
 20115f8:	e0bfea15 	stw	r2,-88(fp)
 20115fc:	e0ffeb15 	stw	r3,-84(fp)
 2011600:	00001e06 	br	201167c <___vfiprintf_internal_r+0x60c>
 2011604:	9880040c 	andi	r2,r19,16
 2011608:	10000826 	beq	r2,zero,201162c <___vfiprintf_internal_r+0x5bc>
 201160c:	e0bfe917 	ldw	r2,-92(fp)
 2011610:	10c00104 	addi	r3,r2,4
 2011614:	e0ffe915 	stw	r3,-92(fp)
 2011618:	10800017 	ldw	r2,0(r2)
 201161c:	e0bfea15 	stw	r2,-88(fp)
 2011620:	1005d7fa 	srai	r2,r2,31
 2011624:	e0bfeb15 	stw	r2,-84(fp)
 2011628:	00001406 	br	201167c <___vfiprintf_internal_r+0x60c>
 201162c:	9880100c 	andi	r2,r19,64
 2011630:	10000b26 	beq	r2,zero,2011660 <___vfiprintf_internal_r+0x5f0>
 2011634:	e0bfe917 	ldw	r2,-92(fp)
 2011638:	10c00104 	addi	r3,r2,4
 201163c:	e0ffe915 	stw	r3,-92(fp)
 2011640:	10800017 	ldw	r2,0(r2)
 2011644:	10bfffcc 	andi	r2,r2,65535
 2011648:	10a0001c 	xori	r2,r2,32768
 201164c:	10a00004 	addi	r2,r2,-32768
 2011650:	e0bfea15 	stw	r2,-88(fp)
 2011654:	1005d7fa 	srai	r2,r2,31
 2011658:	e0bfeb15 	stw	r2,-84(fp)
 201165c:	00000706 	br	201167c <___vfiprintf_internal_r+0x60c>
 2011660:	e0bfe917 	ldw	r2,-92(fp)
 2011664:	10c00104 	addi	r3,r2,4
 2011668:	e0ffe915 	stw	r3,-92(fp)
 201166c:	10800017 	ldw	r2,0(r2)
 2011670:	e0bfea15 	stw	r2,-88(fp)
 2011674:	1005d7fa 	srai	r2,r2,31
 2011678:	e0bfeb15 	stw	r2,-84(fp)
 201167c:	e0bfea17 	ldw	r2,-88(fp)
 2011680:	e0bfbc15 	stw	r2,-272(fp)
 2011684:	e0ffeb17 	ldw	r3,-84(fp)
 2011688:	e0ffbd15 	stw	r3,-268(fp)
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
 201168c:	e0bfbc17 	ldw	r2,-272(fp)
 2011690:	e0ffbd17 	ldw	r3,-268(fp)
 2011694:	18000d0e 	bge	r3,zero,20116cc <___vfiprintf_internal_r+0x65c>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
 2011698:	000d883a 	mov	r6,zero
 201169c:	000f883a 	mov	r7,zero
 20116a0:	e13fbc17 	ldw	r4,-272(fp)
 20116a4:	e17fbd17 	ldw	r5,-268(fp)
 20116a8:	3105c83a 	sub	r2,r6,r4
 20116ac:	3091803a 	cmpltu	r8,r6,r2
 20116b0:	3947c83a 	sub	r3,r7,r5
 20116b4:	1a09c83a 	sub	r4,r3,r8
 20116b8:	2007883a 	mov	r3,r4
 20116bc:	e0bfbc15 	stw	r2,-272(fp)
 20116c0:	e0ffbd15 	stw	r3,-268(fp)
				sign = '-';
 20116c4:	00800b44 	movi	r2,45
 20116c8:	e0bfc705 	stb	r2,-228(fp)
			}
			base = DEC;
 20116cc:	00800044 	movi	r2,1
 20116d0:	e0bfbe05 	stb	r2,-264(fp)
			goto number;
 20116d4:	0000f806 	br	2011ab8 <___vfiprintf_internal_r+0xa48>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
 20116d8:	9880080c 	andi	r2,r19,32
 20116dc:	10000d26 	beq	r2,zero,2011714 <___vfiprintf_internal_r+0x6a4>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
 20116e0:	e0bfe917 	ldw	r2,-92(fp)
 20116e4:	10c00104 	addi	r3,r2,4
 20116e8:	e0ffe915 	stw	r3,-92(fp)
 20116ec:	10800017 	ldw	r2,0(r2)
 20116f0:	e0ffb917 	ldw	r3,-284(fp)
 20116f4:	e0fff015 	stw	r3,-64(fp)
 20116f8:	1807d7fa 	srai	r3,r3,31
 20116fc:	e0fff115 	stw	r3,-60(fp)
 2011700:	e0fff017 	ldw	r3,-64(fp)
 2011704:	10c00015 	stw	r3,0(r2)
 2011708:	e0fff117 	ldw	r3,-60(fp)
 201170c:	10c00115 	stw	r3,4(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2011710:	0002c306 	br	2012220 <___vfiprintf_internal_r+0x11b0>
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
 2011714:	9880040c 	andi	r2,r19,16
 2011718:	10000726 	beq	r2,zero,2011738 <___vfiprintf_internal_r+0x6c8>
				*GET_ARG (N, ap, long_ptr_t) = ret;
 201171c:	e0bfe917 	ldw	r2,-92(fp)
 2011720:	10c00104 	addi	r3,r2,4
 2011724:	e0ffe915 	stw	r3,-92(fp)
 2011728:	10800017 	ldw	r2,0(r2)
 201172c:	e0ffb917 	ldw	r3,-284(fp)
 2011730:	10c00015 	stw	r3,0(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2011734:	0002ba06 	br	2012220 <___vfiprintf_internal_r+0x11b0>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
			else
#endif
			if (flags & LONGINT)
				*GET_ARG (N, ap, long_ptr_t) = ret;
			else if (flags & SHORTINT)
 2011738:	9880100c 	andi	r2,r19,64
 201173c:	10000726 	beq	r2,zero,201175c <___vfiprintf_internal_r+0x6ec>
				*GET_ARG (N, ap, short_ptr_t) = ret;
 2011740:	e0bfe917 	ldw	r2,-92(fp)
 2011744:	10c00104 	addi	r3,r2,4
 2011748:	e0ffe915 	stw	r3,-92(fp)
 201174c:	10800017 	ldw	r2,0(r2)
 2011750:	e0ffb917 	ldw	r3,-284(fp)
 2011754:	10c0000d 	sth	r3,0(r2)
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
			continue;	/* no output */
 2011758:	0002b106 	br	2012220 <___vfiprintf_internal_r+0x11b0>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
				*GET_ARG (N, ap, char_ptr_t) = ret;
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
 201175c:	e0bfe917 	ldw	r2,-92(fp)
 2011760:	10c00104 	addi	r3,r2,4
 2011764:	e0ffe915 	stw	r3,-92(fp)
 2011768:	10800017 	ldw	r2,0(r2)
 201176c:	e0ffb917 	ldw	r3,-284(fp)
 2011770:	10c00015 	stw	r3,0(r2)
			continue;	/* no output */
 2011774:	0002aa06 	br	2012220 <___vfiprintf_internal_r+0x11b0>
		case 'O': /* extension */
			flags |= LONGINT;
 2011778:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
 201177c:	9880080c 	andi	r2,r19,32
 2011780:	10000626 	beq	r2,zero,201179c <___vfiprintf_internal_r+0x72c>
 2011784:	e0bfe917 	ldw	r2,-92(fp)
 2011788:	10c00204 	addi	r3,r2,8
 201178c:	e0ffe915 	stw	r3,-92(fp)
 2011790:	15800017 	ldw	r22,0(r2)
 2011794:	15c00117 	ldw	r23,4(r2)
 2011798:	00001c06 	br	201180c <___vfiprintf_internal_r+0x79c>
 201179c:	9880040c 	andi	r2,r19,16
 20117a0:	10000726 	beq	r2,zero,20117c0 <___vfiprintf_internal_r+0x750>
 20117a4:	e0bfe917 	ldw	r2,-92(fp)
 20117a8:	10c00104 	addi	r3,r2,4
 20117ac:	e0ffe915 	stw	r3,-92(fp)
 20117b0:	10800017 	ldw	r2,0(r2)
 20117b4:	102d883a 	mov	r22,r2
 20117b8:	002f883a 	mov	r23,zero
 20117bc:	00001306 	br	201180c <___vfiprintf_internal_r+0x79c>
 20117c0:	9880100c 	andi	r2,r19,64
 20117c4:	10000b26 	beq	r2,zero,20117f4 <___vfiprintf_internal_r+0x784>
 20117c8:	e0bfe917 	ldw	r2,-92(fp)
 20117cc:	10c00104 	addi	r3,r2,4
 20117d0:	e0ffe915 	stw	r3,-92(fp)
 20117d4:	10800017 	ldw	r2,0(r2)
 20117d8:	e0bff215 	stw	r2,-56(fp)
 20117dc:	e03ff315 	stw	zero,-52(fp)
 20117e0:	e0bff217 	ldw	r2,-56(fp)
 20117e4:	15bfffcc 	andi	r22,r2,65535
 20117e8:	e0fff317 	ldw	r3,-52(fp)
 20117ec:	182e703a 	and	r23,r3,zero
 20117f0:	00000606 	br	201180c <___vfiprintf_internal_r+0x79c>
 20117f4:	e0bfe917 	ldw	r2,-92(fp)
 20117f8:	10c00104 	addi	r3,r2,4
 20117fc:	e0ffe915 	stw	r3,-92(fp)
 2011800:	10800017 	ldw	r2,0(r2)
 2011804:	102d883a 	mov	r22,r2
 2011808:	002f883a 	mov	r23,zero
 201180c:	e5bfbc15 	stw	r22,-272(fp)
 2011810:	e5ffbd15 	stw	r23,-268(fp)
			base = OCT;
 2011814:	e03fbe05 	stb	zero,-264(fp)
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			goto nosign;
 2011818:	0000a606 	br	2011ab4 <___vfiprintf_internal_r+0xa44>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
 201181c:	e0bfe917 	ldw	r2,-92(fp)
 2011820:	10c00104 	addi	r3,r2,4
 2011824:	e0ffe915 	stw	r3,-92(fp)
 2011828:	10800017 	ldw	r2,0(r2)
 201182c:	e0bfbc15 	stw	r2,-272(fp)
 2011830:	e03fbd15 	stw	zero,-268(fp)
			base = HEX;
 2011834:	00800084 	movi	r2,2
 2011838:	e0bfbe05 	stb	r2,-264(fp)
			xdigs = "0123456789abcdef";
 201183c:	008080b4 	movhi	r2,514
 2011840:	10be5c04 	addi	r2,r2,-1680
 2011844:	e0bfc215 	stw	r2,-248(fp)
			flags |= HEXPREFIX;
 2011848:	9cc00094 	ori	r19,r19,2
			ox[0] = '0';
 201184c:	00800c04 	movi	r2,48
 2011850:	e0bfe505 	stb	r2,-108(fp)
			ox[1] = ch = 'x';
 2011854:	04401e04 	movi	r17,120
 2011858:	00801e04 	movi	r2,120
 201185c:	e0bfe545 	stb	r2,-107(fp)
			goto nosign;
 2011860:	00009406 	br	2011ab4 <___vfiprintf_internal_r+0xa44>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
 2011864:	e0bfe917 	ldw	r2,-92(fp)
 2011868:	10c00104 	addi	r3,r2,4
 201186c:	e0ffe915 	stw	r3,-92(fp)
 2011870:	15000017 	ldw	r20,0(r2)
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
 2011874:	e03fc705 	stb	zero,-228(fp)
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
 2011878:	a000081e 	bne	r20,zero,201189c <___vfiprintf_internal_r+0x82c>
				cp = "(null)";
 201187c:	050080b4 	movhi	r20,514
 2011880:	a53e6104 	addi	r20,r20,-1660
				size = ((unsigned) prec > 6U) ? 6 : prec;
 2011884:	e0bfbb17 	ldw	r2,-276(fp)
 2011888:	10c001f0 	cmpltui	r3,r2,7
 201188c:	1800011e 	bne	r3,zero,2011894 <___vfiprintf_internal_r+0x824>
 2011890:	00800184 	movi	r2,6
 2011894:	e0bfc115 	stw	r2,-252(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 2011898:	00011706 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
 201189c:	e0bfbb17 	ldw	r2,-276(fp)
 20118a0:	10001016 	blt	r2,zero,20118e4 <___vfiprintf_internal_r+0x874>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
 20118a4:	e0bfbb17 	ldw	r2,-276(fp)
 20118a8:	100d883a 	mov	r6,r2
 20118ac:	000b883a 	mov	r5,zero
 20118b0:	a009883a 	mov	r4,r20
 20118b4:	200dfb40 	call	200dfb4 <memchr>
 20118b8:	e0bfc615 	stw	r2,-232(fp)

				if (p != NULL)
 20118bc:	e0bfc617 	ldw	r2,-232(fp)
 20118c0:	10000526 	beq	r2,zero,20118d8 <___vfiprintf_internal_r+0x868>
					size = p - cp;
 20118c4:	e0bfc617 	ldw	r2,-232(fp)
 20118c8:	a007883a 	mov	r3,r20
 20118cc:	10c5c83a 	sub	r2,r2,r3
 20118d0:	e0bfc115 	stw	r2,-252(fp)
				else
					size = prec;
			} else
				size = strlen (cp);

			break;
 20118d4:	00010806 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
				char *p = memchr (cp, 0, prec);

				if (p != NULL)
					size = p - cp;
				else
					size = prec;
 20118d8:	e0bfbb17 	ldw	r2,-276(fp)
 20118dc:	e0bfc115 	stw	r2,-252(fp)
			} else
				size = strlen (cp);

			break;
 20118e0:	00010506 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
				if (p != NULL)
					size = p - cp;
				else
					size = prec;
			} else
				size = strlen (cp);
 20118e4:	a009883a 	mov	r4,r20
 20118e8:	2006d380 	call	2006d38 <strlen>
 20118ec:	e0bfc115 	stw	r2,-252(fp)

			break;
 20118f0:	00010106 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
		case 'U': /* extension */
			flags |= LONGINT;
 20118f4:	9cc00414 	ori	r19,r19,16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
 20118f8:	9880080c 	andi	r2,r19,32
 20118fc:	10000826 	beq	r2,zero,2011920 <___vfiprintf_internal_r+0x8b0>
 2011900:	e0bfe917 	ldw	r2,-92(fp)
 2011904:	10c00204 	addi	r3,r2,8
 2011908:	e0ffe915 	stw	r3,-92(fp)
 201190c:	10c00017 	ldw	r3,0(r2)
 2011910:	e0ffec15 	stw	r3,-80(fp)
 2011914:	10c00117 	ldw	r3,4(r2)
 2011918:	e0ffed15 	stw	r3,-76(fp)
 201191c:	00001e06 	br	2011998 <___vfiprintf_internal_r+0x928>
 2011920:	9880040c 	andi	r2,r19,16
 2011924:	10000726 	beq	r2,zero,2011944 <___vfiprintf_internal_r+0x8d4>
 2011928:	e0bfe917 	ldw	r2,-92(fp)
 201192c:	10c00104 	addi	r3,r2,4
 2011930:	e0ffe915 	stw	r3,-92(fp)
 2011934:	10800017 	ldw	r2,0(r2)
 2011938:	e0bfec15 	stw	r2,-80(fp)
 201193c:	e03fed15 	stw	zero,-76(fp)
 2011940:	00001506 	br	2011998 <___vfiprintf_internal_r+0x928>
 2011944:	9880100c 	andi	r2,r19,64
 2011948:	10000d26 	beq	r2,zero,2011980 <___vfiprintf_internal_r+0x910>
 201194c:	e0bfe917 	ldw	r2,-92(fp)
 2011950:	10c00104 	addi	r3,r2,4
 2011954:	e0ffe915 	stw	r3,-92(fp)
 2011958:	10800017 	ldw	r2,0(r2)
 201195c:	e0bff415 	stw	r2,-48(fp)
 2011960:	e03ff515 	stw	zero,-44(fp)
 2011964:	e0bff417 	ldw	r2,-48(fp)
 2011968:	10bfffcc 	andi	r2,r2,65535
 201196c:	e0bfec15 	stw	r2,-80(fp)
 2011970:	e0fff517 	ldw	r3,-44(fp)
 2011974:	1806703a 	and	r3,r3,zero
 2011978:	e0ffed15 	stw	r3,-76(fp)
 201197c:	00000606 	br	2011998 <___vfiprintf_internal_r+0x928>
 2011980:	e0bfe917 	ldw	r2,-92(fp)
 2011984:	10c00104 	addi	r3,r2,4
 2011988:	e0ffe915 	stw	r3,-92(fp)
 201198c:	10800017 	ldw	r2,0(r2)
 2011990:	e0bfec15 	stw	r2,-80(fp)
 2011994:	e03fed15 	stw	zero,-76(fp)
 2011998:	e0bfec17 	ldw	r2,-80(fp)
 201199c:	e0bfbc15 	stw	r2,-272(fp)
 20119a0:	e0ffed17 	ldw	r3,-76(fp)
 20119a4:	e0ffbd15 	stw	r3,-268(fp)
			base = DEC;
 20119a8:	00800044 	movi	r2,1
 20119ac:	e0bfbe05 	stb	r2,-264(fp)
			goto nosign;
 20119b0:	00004006 	br	2011ab4 <___vfiprintf_internal_r+0xa44>
		case 'X':
			xdigs = "0123456789ABCDEF";
 20119b4:	008080b4 	movhi	r2,514
 20119b8:	10be6304 	addi	r2,r2,-1652
 20119bc:	e0bfc215 	stw	r2,-248(fp)
			goto hex;
 20119c0:	00000306 	br	20119d0 <___vfiprintf_internal_r+0x960>
		case 'x':
			xdigs = "0123456789abcdef";
 20119c4:	008080b4 	movhi	r2,514
 20119c8:	10be5c04 	addi	r2,r2,-1680
 20119cc:	e0bfc215 	stw	r2,-248(fp)
hex:			_uquad = UARG ();
 20119d0:	9880080c 	andi	r2,r19,32
 20119d4:	10000826 	beq	r2,zero,20119f8 <___vfiprintf_internal_r+0x988>
 20119d8:	e0bfe917 	ldw	r2,-92(fp)
 20119dc:	10c00204 	addi	r3,r2,8
 20119e0:	e0ffe915 	stw	r3,-92(fp)
 20119e4:	10c00017 	ldw	r3,0(r2)
 20119e8:	e0ffee15 	stw	r3,-72(fp)
 20119ec:	10c00117 	ldw	r3,4(r2)
 20119f0:	e0ffef15 	stw	r3,-68(fp)
 20119f4:	00001e06 	br	2011a70 <___vfiprintf_internal_r+0xa00>
 20119f8:	9880040c 	andi	r2,r19,16
 20119fc:	10000726 	beq	r2,zero,2011a1c <___vfiprintf_internal_r+0x9ac>
 2011a00:	e0bfe917 	ldw	r2,-92(fp)
 2011a04:	10c00104 	addi	r3,r2,4
 2011a08:	e0ffe915 	stw	r3,-92(fp)
 2011a0c:	10800017 	ldw	r2,0(r2)
 2011a10:	e0bfee15 	stw	r2,-72(fp)
 2011a14:	e03fef15 	stw	zero,-68(fp)
 2011a18:	00001506 	br	2011a70 <___vfiprintf_internal_r+0xa00>
 2011a1c:	9880100c 	andi	r2,r19,64
 2011a20:	10000d26 	beq	r2,zero,2011a58 <___vfiprintf_internal_r+0x9e8>
 2011a24:	e0bfe917 	ldw	r2,-92(fp)
 2011a28:	10c00104 	addi	r3,r2,4
 2011a2c:	e0ffe915 	stw	r3,-92(fp)
 2011a30:	10800017 	ldw	r2,0(r2)
 2011a34:	e0bff615 	stw	r2,-40(fp)
 2011a38:	e03ff715 	stw	zero,-36(fp)
 2011a3c:	e0bff617 	ldw	r2,-40(fp)
 2011a40:	10bfffcc 	andi	r2,r2,65535
 2011a44:	e0bfee15 	stw	r2,-72(fp)
 2011a48:	e0fff717 	ldw	r3,-36(fp)
 2011a4c:	1806703a 	and	r3,r3,zero
 2011a50:	e0ffef15 	stw	r3,-68(fp)
 2011a54:	00000606 	br	2011a70 <___vfiprintf_internal_r+0xa00>
 2011a58:	e0bfe917 	ldw	r2,-92(fp)
 2011a5c:	10c00104 	addi	r3,r2,4
 2011a60:	e0ffe915 	stw	r3,-92(fp)
 2011a64:	10800017 	ldw	r2,0(r2)
 2011a68:	e0bfee15 	stw	r2,-72(fp)
 2011a6c:	e03fef15 	stw	zero,-68(fp)
 2011a70:	e0bfee17 	ldw	r2,-72(fp)
 2011a74:	e0bfbc15 	stw	r2,-272(fp)
 2011a78:	e0ffef17 	ldw	r3,-68(fp)
 2011a7c:	e0ffbd15 	stw	r3,-268(fp)
			base = HEX;
 2011a80:	00800084 	movi	r2,2
 2011a84:	e0bfbe05 	stb	r2,-264(fp)
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
 2011a88:	9880004c 	andi	r2,r19,1
 2011a8c:	10000926 	beq	r2,zero,2011ab4 <___vfiprintf_internal_r+0xa44>
 2011a90:	e0bfbc17 	ldw	r2,-272(fp)
 2011a94:	e0ffbd17 	ldw	r3,-268(fp)
 2011a98:	10c4b03a 	or	r2,r2,r3
 2011a9c:	10000526 	beq	r2,zero,2011ab4 <___vfiprintf_internal_r+0xa44>
				ox[0] = '0';
 2011aa0:	00800c04 	movi	r2,48
 2011aa4:	e0bfe505 	stb	r2,-108(fp)
				ox[1] = ch;
 2011aa8:	8805883a 	mov	r2,r17
 2011aac:	e0bfe545 	stb	r2,-107(fp)
				flags |= HEXPREFIX;
 2011ab0:	9cc00094 	ori	r19,r19,2

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
 2011ab4:	e03fc705 	stb	zero,-228(fp)
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
 2011ab8:	e0bfbb17 	ldw	r2,-276(fp)
 2011abc:	e0bfbf15 	stw	r2,-260(fp)
 2011ac0:	e0bfbf17 	ldw	r2,-260(fp)
 2011ac4:	10000216 	blt	r2,zero,2011ad0 <___vfiprintf_internal_r+0xa60>
				flags &= ~ZEROPAD;
 2011ac8:	00bfdfc4 	movi	r2,-129
 2011acc:	98a6703a 	and	r19,r19,r2
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
 2011ad0:	e53fdb04 	addi	r20,fp,-148
 2011ad4:	a5000a04 	addi	r20,r20,40
			if (_uquad != 0 || prec != 0) {
 2011ad8:	e0bfbc17 	ldw	r2,-272(fp)
 2011adc:	e0ffbd17 	ldw	r3,-268(fp)
 2011ae0:	10c4b03a 	or	r2,r2,r3
 2011ae4:	1000021e 	bne	r2,zero,2011af0 <___vfiprintf_internal_r+0xa80>
 2011ae8:	e0bfbb17 	ldw	r2,-276(fp)
 2011aec:	10006c26 	beq	r2,zero,2011ca0 <___vfiprintf_internal_r+0xc30>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
 2011af0:	e0bfbe03 	ldbu	r2,-264(fp)
 2011af4:	10c00060 	cmpeqi	r3,r2,1
 2011af8:	1800211e 	bne	r3,zero,2011b80 <___vfiprintf_internal_r+0xb10>
 2011afc:	10c000a0 	cmpeqi	r3,r2,2
 2011b00:	1800491e 	bne	r3,zero,2011c28 <___vfiprintf_internal_r+0xbb8>
 2011b04:	10005d1e 	bne	r2,zero,2011c7c <___vfiprintf_internal_r+0xc0c>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
 2011b08:	a53fffc4 	addi	r20,r20,-1
 2011b0c:	e0bfbc17 	ldw	r2,-272(fp)
 2011b10:	108001cc 	andi	r2,r2,7
 2011b14:	10800c04 	addi	r2,r2,48
 2011b18:	a0800005 	stb	r2,0(r20)
						_uquad >>= 3;
 2011b1c:	e0bfbd17 	ldw	r2,-268(fp)
 2011b20:	1004977a 	slli	r2,r2,29
 2011b24:	e0ffbc17 	ldw	r3,-272(fp)
 2011b28:	1806d0fa 	srli	r3,r3,3
 2011b2c:	1884b03a 	or	r2,r3,r2
 2011b30:	e0bfbc15 	stw	r2,-272(fp)
 2011b34:	e0bfbd17 	ldw	r2,-268(fp)
 2011b38:	1004d0fa 	srli	r2,r2,3
 2011b3c:	e0bfbd15 	stw	r2,-268(fp)
					} while (_uquad);
 2011b40:	e0bfbc17 	ldw	r2,-272(fp)
 2011b44:	e0ffbd17 	ldw	r3,-268(fp)
 2011b48:	10c4b03a 	or	r2,r2,r3
 2011b4c:	103fee1e 	bne	r2,zero,2011b08 <___vfiprintf_internal_r+0xa98>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
 2011b50:	9880004c 	andi	r2,r19,1
 2011b54:	10005026 	beq	r2,zero,2011c98 <___vfiprintf_internal_r+0xc28>
 2011b58:	a0800003 	ldbu	r2,0(r20)
 2011b5c:	10803fcc 	andi	r2,r2,255
 2011b60:	1080201c 	xori	r2,r2,128
 2011b64:	10bfe004 	addi	r2,r2,-128
 2011b68:	10800c20 	cmpeqi	r2,r2,48
 2011b6c:	10004a1e 	bne	r2,zero,2011c98 <___vfiprintf_internal_r+0xc28>
						*--cp = '0';
 2011b70:	a53fffc4 	addi	r20,r20,-1
 2011b74:	00800c04 	movi	r2,48
 2011b78:	a0800005 	stb	r2,0(r20)
					break;
 2011b7c:	00004606 	br	2011c98 <___vfiprintf_internal_r+0xc28>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
 2011b80:	e0bfbd17 	ldw	r2,-268(fp)
 2011b84:	10000a1e 	bne	r2,zero,2011bb0 <___vfiprintf_internal_r+0xb40>
 2011b88:	e0bfbd17 	ldw	r2,-268(fp)
 2011b8c:	1000031e 	bne	r2,zero,2011b9c <___vfiprintf_internal_r+0xb2c>
 2011b90:	e0bfbc17 	ldw	r2,-272(fp)
 2011b94:	108002a8 	cmpgeui	r2,r2,10
 2011b98:	1000051e 	bne	r2,zero,2011bb0 <___vfiprintf_internal_r+0xb40>
						*--cp = to_char(_uquad);
 2011b9c:	a53fffc4 	addi	r20,r20,-1
 2011ba0:	e0bfbc17 	ldw	r2,-272(fp)
 2011ba4:	10800c04 	addi	r2,r2,48
 2011ba8:	a0800005 	stb	r2,0(r20)
						break;
 2011bac:	00003b06 	br	2011c9c <___vfiprintf_internal_r+0xc2c>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
#endif
					do {
					  *--cp = to_char (_uquad % 10);
 2011bb0:	a53fffc4 	addi	r20,r20,-1
 2011bb4:	e0bfbc17 	ldw	r2,-272(fp)
 2011bb8:	e0ffbd17 	ldw	r3,-268(fp)
 2011bbc:	01800284 	movi	r6,10
 2011bc0:	000f883a 	mov	r7,zero
 2011bc4:	1009883a 	mov	r4,r2
 2011bc8:	180b883a 	mov	r5,r3
 2011bcc:	20135000 	call	2013500 <__umoddi3>
 2011bd0:	1009883a 	mov	r4,r2
 2011bd4:	180b883a 	mov	r5,r3
 2011bd8:	2005883a 	mov	r2,r4
 2011bdc:	2807883a 	mov	r3,r5
 2011be0:	10800c04 	addi	r2,r2,48
 2011be4:	a0800005 	stb	r2,0(r20)
					       next cases. */
					    if (grouping[1] != '\0')
					      grouping++;
					  }
#endif
					  _uquad /= 10;
 2011be8:	e0bfbc17 	ldw	r2,-272(fp)
 2011bec:	e0ffbd17 	ldw	r3,-268(fp)
 2011bf0:	01800284 	movi	r6,10
 2011bf4:	000f883a 	mov	r7,zero
 2011bf8:	1009883a 	mov	r4,r2
 2011bfc:	180b883a 	mov	r5,r3
 2011c00:	2012f880 	call	2012f88 <__udivdi3>
 2011c04:	1009883a 	mov	r4,r2
 2011c08:	180b883a 	mov	r5,r3
 2011c0c:	e13fbc15 	stw	r4,-272(fp)
 2011c10:	e17fbd15 	stw	r5,-268(fp)
					} while (_uquad != 0);
 2011c14:	e0bfbc17 	ldw	r2,-272(fp)
 2011c18:	e0ffbd17 	ldw	r3,-268(fp)
 2011c1c:	10c4b03a 	or	r2,r2,r3
 2011c20:	103fe31e 	bne	r2,zero,2011bb0 <___vfiprintf_internal_r+0xb40>
					break;
 2011c24:	00001d06 	br	2011c9c <___vfiprintf_internal_r+0xc2c>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
 2011c28:	a53fffc4 	addi	r20,r20,-1
 2011c2c:	e0bfbc17 	ldw	r2,-272(fp)
 2011c30:	108003cc 	andi	r2,r2,15
 2011c34:	e0ffc217 	ldw	r3,-248(fp)
 2011c38:	1885883a 	add	r2,r3,r2
 2011c3c:	10800003 	ldbu	r2,0(r2)
 2011c40:	a0800005 	stb	r2,0(r20)
						_uquad >>= 4;
 2011c44:	e0bfbd17 	ldw	r2,-268(fp)
 2011c48:	1004973a 	slli	r2,r2,28
 2011c4c:	e0ffbc17 	ldw	r3,-272(fp)
 2011c50:	1806d13a 	srli	r3,r3,4
 2011c54:	1884b03a 	or	r2,r3,r2
 2011c58:	e0bfbc15 	stw	r2,-272(fp)
 2011c5c:	e0bfbd17 	ldw	r2,-268(fp)
 2011c60:	1004d13a 	srli	r2,r2,4
 2011c64:	e0bfbd15 	stw	r2,-268(fp)
					} while (_uquad);
 2011c68:	e0bfbc17 	ldw	r2,-272(fp)
 2011c6c:	e0ffbd17 	ldw	r3,-268(fp)
 2011c70:	10c4b03a 	or	r2,r2,r3
 2011c74:	103fec1e 	bne	r2,zero,2011c28 <___vfiprintf_internal_r+0xbb8>
					break;
 2011c78:	00000806 	br	2011c9c <___vfiprintf_internal_r+0xc2c>

				default:
					cp = "bug in vfprintf: bad base";
 2011c7c:	050080b4 	movhi	r20,514
 2011c80:	a53e6804 	addi	r20,r20,-1632
					size = strlen (cp);
 2011c84:	a009883a 	mov	r4,r20
 2011c88:	2006d380 	call	2006d38 <strlen>
 2011c8c:	e0bfc115 	stw	r2,-252(fp)
					goto skipsize;
 2011c90:	0001883a 	nop
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
 2011c94:	00001806 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
						_uquad >>= 3;
					} while (_uquad);
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
						*--cp = '0';
					break;
 2011c98:	0001883a 	nop
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
 2011c9c:	00000706 	br	2011cbc <___vfiprintf_internal_r+0xc4c>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
 2011ca0:	e0bfbe03 	ldbu	r2,-264(fp)
 2011ca4:	1000051e 	bne	r2,zero,2011cbc <___vfiprintf_internal_r+0xc4c>
 2011ca8:	9880004c 	andi	r2,r19,1
 2011cac:	10000326 	beq	r2,zero,2011cbc <___vfiprintf_internal_r+0xc4c>
                         *--cp = '0';
 2011cb0:	a53fffc4 	addi	r20,r20,-1
 2011cb4:	00800c04 	movi	r2,48
 2011cb8:	a0800005 	stb	r2,0(r20)

			size = buf + BUF - cp;
 2011cbc:	e0bfdb04 	addi	r2,fp,-148
 2011cc0:	10800a04 	addi	r2,r2,40
 2011cc4:	1007883a 	mov	r3,r2
 2011cc8:	a005883a 	mov	r2,r20
 2011ccc:	1885c83a 	sub	r2,r3,r2
 2011cd0:	e0bfc115 	stw	r2,-252(fp)
		skipsize:
			break;
 2011cd4:	00000806 	br	2011cf8 <___vfiprintf_internal_r+0xc88>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
 2011cd8:	88015426 	beq	r17,zero,201222c <___vfiprintf_internal_r+0x11bc>
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
 2011cdc:	e53fdb04 	addi	r20,fp,-148
			*cp = ch;
 2011ce0:	8805883a 	mov	r2,r17
 2011ce4:	a0800005 	stb	r2,0(r20)
			size = 1;
 2011ce8:	00800044 	movi	r2,1
 2011cec:	e0bfc115 	stw	r2,-252(fp)
			sign = '\0';
 2011cf0:	e03fc705 	stb	zero,-228(fp)
			break;
 2011cf4:	0001883a 	nop
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
 2011cf8:	e0ffbf17 	ldw	r3,-260(fp)
 2011cfc:	e0bfc117 	ldw	r2,-252(fp)
 2011d00:	10c0010e 	bge	r2,r3,2011d08 <___vfiprintf_internal_r+0xc98>
 2011d04:	1805883a 	mov	r2,r3
 2011d08:	e0bfc015 	stw	r2,-256(fp)
		if (sign)
 2011d0c:	e0bfc703 	ldbu	r2,-228(fp)
 2011d10:	10803fcc 	andi	r2,r2,255
 2011d14:	1080201c 	xori	r2,r2,128
 2011d18:	10bfe004 	addi	r2,r2,-128
 2011d1c:	10000326 	beq	r2,zero,2011d2c <___vfiprintf_internal_r+0xcbc>
			realsz++;
 2011d20:	e0bfc017 	ldw	r2,-256(fp)
 2011d24:	10800044 	addi	r2,r2,1
 2011d28:	e0bfc015 	stw	r2,-256(fp)
		if (flags & HEXPREFIX)
 2011d2c:	9880008c 	andi	r2,r19,2
 2011d30:	10000326 	beq	r2,zero,2011d40 <___vfiprintf_internal_r+0xcd0>
			realsz+= 2;
 2011d34:	e0bfc017 	ldw	r2,-256(fp)
 2011d38:	10800084 	addi	r2,r2,2
 2011d3c:	e0bfc015 	stw	r2,-256(fp)

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
 2011d40:	9880210c 	andi	r2,r19,132
 2011d44:	1000351e 	bne	r2,zero,2011e1c <___vfiprintf_internal_r+0xdac>
			PAD (width - realsz, blanks);
 2011d48:	e0ffba17 	ldw	r3,-280(fp)
 2011d4c:	e0bfc017 	ldw	r2,-256(fp)
 2011d50:	18a1c83a 	sub	r16,r3,r2
 2011d54:	0400310e 	bge	zero,r16,2011e1c <___vfiprintf_internal_r+0xdac>
 2011d58:	00001706 	br	2011db8 <___vfiprintf_internal_r+0xd48>
 2011d5c:	008080b4 	movhi	r2,514
 2011d60:	10be6e84 	addi	r2,r2,-1606
 2011d64:	90800015 	stw	r2,0(r18)
 2011d68:	00800404 	movi	r2,16
 2011d6c:	90800115 	stw	r2,4(r18)
 2011d70:	e0bfca17 	ldw	r2,-216(fp)
 2011d74:	10800404 	addi	r2,r2,16
 2011d78:	e0bfca15 	stw	r2,-216(fp)
 2011d7c:	94800204 	addi	r18,r18,8
 2011d80:	e0bfc917 	ldw	r2,-220(fp)
 2011d84:	10800044 	addi	r2,r2,1
 2011d88:	e0bfc915 	stw	r2,-220(fp)
 2011d8c:	e0bfc917 	ldw	r2,-220(fp)
 2011d90:	10800210 	cmplti	r2,r2,8
 2011d94:	1000071e 	bne	r2,zero,2011db4 <___vfiprintf_internal_r+0xd44>
 2011d98:	e0bfc804 	addi	r2,fp,-224
 2011d9c:	100d883a 	mov	r6,r2
 2011da0:	e17fe717 	ldw	r5,-100(fp)
 2011da4:	e13fe617 	ldw	r4,-104(fp)
 2011da8:	2010df40 	call	2010df4 <__sprint_r>
 2011dac:	10012d1e 	bne	r2,zero,2012264 <___vfiprintf_internal_r+0x11f4>
 2011db0:	e4bfcb04 	addi	r18,fp,-212
 2011db4:	843ffc04 	addi	r16,r16,-16
 2011db8:	80800448 	cmpgei	r2,r16,17
 2011dbc:	103fe71e 	bne	r2,zero,2011d5c <___vfiprintf_internal_r+0xcec>
 2011dc0:	008080b4 	movhi	r2,514
 2011dc4:	10be6e84 	addi	r2,r2,-1606
 2011dc8:	90800015 	stw	r2,0(r18)
 2011dcc:	8005883a 	mov	r2,r16
 2011dd0:	90800115 	stw	r2,4(r18)
 2011dd4:	e0bfca17 	ldw	r2,-216(fp)
 2011dd8:	8007883a 	mov	r3,r16
 2011ddc:	10c5883a 	add	r2,r2,r3
 2011de0:	e0bfca15 	stw	r2,-216(fp)
 2011de4:	94800204 	addi	r18,r18,8
 2011de8:	e0bfc917 	ldw	r2,-220(fp)
 2011dec:	10800044 	addi	r2,r2,1
 2011df0:	e0bfc915 	stw	r2,-220(fp)
 2011df4:	e0bfc917 	ldw	r2,-220(fp)
 2011df8:	10800210 	cmplti	r2,r2,8
 2011dfc:	1000071e 	bne	r2,zero,2011e1c <___vfiprintf_internal_r+0xdac>
 2011e00:	e0bfc804 	addi	r2,fp,-224
 2011e04:	100d883a 	mov	r6,r2
 2011e08:	e17fe717 	ldw	r5,-100(fp)
 2011e0c:	e13fe617 	ldw	r4,-104(fp)
 2011e10:	2010df40 	call	2010df4 <__sprint_r>
 2011e14:	1001151e 	bne	r2,zero,201226c <___vfiprintf_internal_r+0x11fc>
 2011e18:	e4bfcb04 	addi	r18,fp,-212

		/* prefix */
		if (sign)
 2011e1c:	e0bfc703 	ldbu	r2,-228(fp)
 2011e20:	10803fcc 	andi	r2,r2,255
 2011e24:	1080201c 	xori	r2,r2,128
 2011e28:	10bfe004 	addi	r2,r2,-128
 2011e2c:	10001526 	beq	r2,zero,2011e84 <___vfiprintf_internal_r+0xe14>
			PRINT (&sign, 1);
 2011e30:	e0bfc704 	addi	r2,fp,-228
 2011e34:	90800015 	stw	r2,0(r18)
 2011e38:	00800044 	movi	r2,1
 2011e3c:	90800115 	stw	r2,4(r18)
 2011e40:	e0bfca17 	ldw	r2,-216(fp)
 2011e44:	10800044 	addi	r2,r2,1
 2011e48:	e0bfca15 	stw	r2,-216(fp)
 2011e4c:	94800204 	addi	r18,r18,8
 2011e50:	e0bfc917 	ldw	r2,-220(fp)
 2011e54:	10800044 	addi	r2,r2,1
 2011e58:	e0bfc915 	stw	r2,-220(fp)
 2011e5c:	e0bfc917 	ldw	r2,-220(fp)
 2011e60:	10800210 	cmplti	r2,r2,8
 2011e64:	1000071e 	bne	r2,zero,2011e84 <___vfiprintf_internal_r+0xe14>
 2011e68:	e0bfc804 	addi	r2,fp,-224
 2011e6c:	100d883a 	mov	r6,r2
 2011e70:	e17fe717 	ldw	r5,-100(fp)
 2011e74:	e13fe617 	ldw	r4,-104(fp)
 2011e78:	2010df40 	call	2010df4 <__sprint_r>
 2011e7c:	1000fd1e 	bne	r2,zero,2012274 <___vfiprintf_internal_r+0x1204>
 2011e80:	e4bfcb04 	addi	r18,fp,-212
		if (flags & HEXPREFIX)
 2011e84:	9880008c 	andi	r2,r19,2
 2011e88:	10001526 	beq	r2,zero,2011ee0 <___vfiprintf_internal_r+0xe70>
			PRINT (ox, 2);
 2011e8c:	e0bfe504 	addi	r2,fp,-108
 2011e90:	90800015 	stw	r2,0(r18)
 2011e94:	00800084 	movi	r2,2
 2011e98:	90800115 	stw	r2,4(r18)
 2011e9c:	e0bfca17 	ldw	r2,-216(fp)
 2011ea0:	10800084 	addi	r2,r2,2
 2011ea4:	e0bfca15 	stw	r2,-216(fp)
 2011ea8:	94800204 	addi	r18,r18,8
 2011eac:	e0bfc917 	ldw	r2,-220(fp)
 2011eb0:	10800044 	addi	r2,r2,1
 2011eb4:	e0bfc915 	stw	r2,-220(fp)
 2011eb8:	e0bfc917 	ldw	r2,-220(fp)
 2011ebc:	10800210 	cmplti	r2,r2,8
 2011ec0:	1000071e 	bne	r2,zero,2011ee0 <___vfiprintf_internal_r+0xe70>
 2011ec4:	e0bfc804 	addi	r2,fp,-224
 2011ec8:	100d883a 	mov	r6,r2
 2011ecc:	e17fe717 	ldw	r5,-100(fp)
 2011ed0:	e13fe617 	ldw	r4,-104(fp)
 2011ed4:	2010df40 	call	2010df4 <__sprint_r>
 2011ed8:	1000e81e 	bne	r2,zero,201227c <___vfiprintf_internal_r+0x120c>
 2011edc:	e4bfcb04 	addi	r18,fp,-212

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
 2011ee0:	9880210c 	andi	r2,r19,132
 2011ee4:	10802018 	cmpnei	r2,r2,128
 2011ee8:	1000351e 	bne	r2,zero,2011fc0 <___vfiprintf_internal_r+0xf50>
			PAD (width - realsz, zeroes);
 2011eec:	e0ffba17 	ldw	r3,-280(fp)
 2011ef0:	e0bfc017 	ldw	r2,-256(fp)
 2011ef4:	18a1c83a 	sub	r16,r3,r2
 2011ef8:	0400310e 	bge	zero,r16,2011fc0 <___vfiprintf_internal_r+0xf50>
 2011efc:	00001706 	br	2011f5c <___vfiprintf_internal_r+0xeec>
 2011f00:	008080b4 	movhi	r2,514
 2011f04:	10be7284 	addi	r2,r2,-1590
 2011f08:	90800015 	stw	r2,0(r18)
 2011f0c:	00800404 	movi	r2,16
 2011f10:	90800115 	stw	r2,4(r18)
 2011f14:	e0bfca17 	ldw	r2,-216(fp)
 2011f18:	10800404 	addi	r2,r2,16
 2011f1c:	e0bfca15 	stw	r2,-216(fp)
 2011f20:	94800204 	addi	r18,r18,8
 2011f24:	e0bfc917 	ldw	r2,-220(fp)
 2011f28:	10800044 	addi	r2,r2,1
 2011f2c:	e0bfc915 	stw	r2,-220(fp)
 2011f30:	e0bfc917 	ldw	r2,-220(fp)
 2011f34:	10800210 	cmplti	r2,r2,8
 2011f38:	1000071e 	bne	r2,zero,2011f58 <___vfiprintf_internal_r+0xee8>
 2011f3c:	e0bfc804 	addi	r2,fp,-224
 2011f40:	100d883a 	mov	r6,r2
 2011f44:	e17fe717 	ldw	r5,-100(fp)
 2011f48:	e13fe617 	ldw	r4,-104(fp)
 2011f4c:	2010df40 	call	2010df4 <__sprint_r>
 2011f50:	1000cc1e 	bne	r2,zero,2012284 <___vfiprintf_internal_r+0x1214>
 2011f54:	e4bfcb04 	addi	r18,fp,-212
 2011f58:	843ffc04 	addi	r16,r16,-16
 2011f5c:	80800448 	cmpgei	r2,r16,17
 2011f60:	103fe71e 	bne	r2,zero,2011f00 <___vfiprintf_internal_r+0xe90>
 2011f64:	008080b4 	movhi	r2,514
 2011f68:	10be7284 	addi	r2,r2,-1590
 2011f6c:	90800015 	stw	r2,0(r18)
 2011f70:	8005883a 	mov	r2,r16
 2011f74:	90800115 	stw	r2,4(r18)
 2011f78:	e0bfca17 	ldw	r2,-216(fp)
 2011f7c:	8007883a 	mov	r3,r16
 2011f80:	10c5883a 	add	r2,r2,r3
 2011f84:	e0bfca15 	stw	r2,-216(fp)
 2011f88:	94800204 	addi	r18,r18,8
 2011f8c:	e0bfc917 	ldw	r2,-220(fp)
 2011f90:	10800044 	addi	r2,r2,1
 2011f94:	e0bfc915 	stw	r2,-220(fp)
 2011f98:	e0bfc917 	ldw	r2,-220(fp)
 2011f9c:	10800210 	cmplti	r2,r2,8
 2011fa0:	1000071e 	bne	r2,zero,2011fc0 <___vfiprintf_internal_r+0xf50>
 2011fa4:	e0bfc804 	addi	r2,fp,-224
 2011fa8:	100d883a 	mov	r6,r2
 2011fac:	e17fe717 	ldw	r5,-100(fp)
 2011fb0:	e13fe617 	ldw	r4,-104(fp)
 2011fb4:	2010df40 	call	2010df4 <__sprint_r>
 2011fb8:	1000b41e 	bne	r2,zero,201228c <___vfiprintf_internal_r+0x121c>
 2011fbc:	e4bfcb04 	addi	r18,fp,-212

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 2011fc0:	e0ffbf17 	ldw	r3,-260(fp)
 2011fc4:	e0bfc117 	ldw	r2,-252(fp)
 2011fc8:	18a1c83a 	sub	r16,r3,r2
 2011fcc:	0400310e 	bge	zero,r16,2012094 <___vfiprintf_internal_r+0x1024>
 2011fd0:	00001706 	br	2012030 <___vfiprintf_internal_r+0xfc0>
 2011fd4:	008080b4 	movhi	r2,514
 2011fd8:	10be7284 	addi	r2,r2,-1590
 2011fdc:	90800015 	stw	r2,0(r18)
 2011fe0:	00800404 	movi	r2,16
 2011fe4:	90800115 	stw	r2,4(r18)
 2011fe8:	e0bfca17 	ldw	r2,-216(fp)
 2011fec:	10800404 	addi	r2,r2,16
 2011ff0:	e0bfca15 	stw	r2,-216(fp)
 2011ff4:	94800204 	addi	r18,r18,8
 2011ff8:	e0bfc917 	ldw	r2,-220(fp)
 2011ffc:	10800044 	addi	r2,r2,1
 2012000:	e0bfc915 	stw	r2,-220(fp)
 2012004:	e0bfc917 	ldw	r2,-220(fp)
 2012008:	10800210 	cmplti	r2,r2,8
 201200c:	1000071e 	bne	r2,zero,201202c <___vfiprintf_internal_r+0xfbc>
 2012010:	e0bfc804 	addi	r2,fp,-224
 2012014:	100d883a 	mov	r6,r2
 2012018:	e17fe717 	ldw	r5,-100(fp)
 201201c:	e13fe617 	ldw	r4,-104(fp)
 2012020:	2010df40 	call	2010df4 <__sprint_r>
 2012024:	10009b1e 	bne	r2,zero,2012294 <___vfiprintf_internal_r+0x1224>
 2012028:	e4bfcb04 	addi	r18,fp,-212
 201202c:	843ffc04 	addi	r16,r16,-16
 2012030:	80800448 	cmpgei	r2,r16,17
 2012034:	103fe71e 	bne	r2,zero,2011fd4 <___vfiprintf_internal_r+0xf64>
 2012038:	008080b4 	movhi	r2,514
 201203c:	10be7284 	addi	r2,r2,-1590
 2012040:	90800015 	stw	r2,0(r18)
 2012044:	8005883a 	mov	r2,r16
 2012048:	90800115 	stw	r2,4(r18)
 201204c:	e0bfca17 	ldw	r2,-216(fp)
 2012050:	8007883a 	mov	r3,r16
 2012054:	10c5883a 	add	r2,r2,r3
 2012058:	e0bfca15 	stw	r2,-216(fp)
 201205c:	94800204 	addi	r18,r18,8
 2012060:	e0bfc917 	ldw	r2,-220(fp)
 2012064:	10800044 	addi	r2,r2,1
 2012068:	e0bfc915 	stw	r2,-220(fp)
 201206c:	e0bfc917 	ldw	r2,-220(fp)
 2012070:	10800210 	cmplti	r2,r2,8
 2012074:	1000071e 	bne	r2,zero,2012094 <___vfiprintf_internal_r+0x1024>
 2012078:	e0bfc804 	addi	r2,fp,-224
 201207c:	100d883a 	mov	r6,r2
 2012080:	e17fe717 	ldw	r5,-100(fp)
 2012084:	e13fe617 	ldw	r4,-104(fp)
 2012088:	2010df40 	call	2010df4 <__sprint_r>
 201208c:	1000831e 	bne	r2,zero,201229c <___vfiprintf_internal_r+0x122c>
 2012090:	e4bfcb04 	addi	r18,fp,-212
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
 2012094:	95000015 	stw	r20,0(r18)
 2012098:	e0bfc117 	ldw	r2,-252(fp)
 201209c:	90800115 	stw	r2,4(r18)
 20120a0:	e0ffca17 	ldw	r3,-216(fp)
 20120a4:	e0bfc117 	ldw	r2,-252(fp)
 20120a8:	1885883a 	add	r2,r3,r2
 20120ac:	e0bfca15 	stw	r2,-216(fp)
 20120b0:	94800204 	addi	r18,r18,8
 20120b4:	e0bfc917 	ldw	r2,-220(fp)
 20120b8:	10800044 	addi	r2,r2,1
 20120bc:	e0bfc915 	stw	r2,-220(fp)
 20120c0:	e0bfc917 	ldw	r2,-220(fp)
 20120c4:	10800210 	cmplti	r2,r2,8
 20120c8:	1000071e 	bne	r2,zero,20120e8 <___vfiprintf_internal_r+0x1078>
 20120cc:	e0bfc804 	addi	r2,fp,-224
 20120d0:	100d883a 	mov	r6,r2
 20120d4:	e17fe717 	ldw	r5,-100(fp)
 20120d8:	e13fe617 	ldw	r4,-104(fp)
 20120dc:	2010df40 	call	2010df4 <__sprint_r>
 20120e0:	1000701e 	bne	r2,zero,20122a4 <___vfiprintf_internal_r+0x1234>
 20120e4:	e4bfcb04 	addi	r18,fp,-212
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
 20120e8:	9880010c 	andi	r2,r19,4
 20120ec:	10003526 	beq	r2,zero,20121c4 <___vfiprintf_internal_r+0x1154>
			PAD (width - realsz, blanks);
 20120f0:	e0ffba17 	ldw	r3,-280(fp)
 20120f4:	e0bfc017 	ldw	r2,-256(fp)
 20120f8:	18a1c83a 	sub	r16,r3,r2
 20120fc:	0400310e 	bge	zero,r16,20121c4 <___vfiprintf_internal_r+0x1154>
 2012100:	00001706 	br	2012160 <___vfiprintf_internal_r+0x10f0>
 2012104:	008080b4 	movhi	r2,514
 2012108:	10be6e84 	addi	r2,r2,-1606
 201210c:	90800015 	stw	r2,0(r18)
 2012110:	00800404 	movi	r2,16
 2012114:	90800115 	stw	r2,4(r18)
 2012118:	e0bfca17 	ldw	r2,-216(fp)
 201211c:	10800404 	addi	r2,r2,16
 2012120:	e0bfca15 	stw	r2,-216(fp)
 2012124:	94800204 	addi	r18,r18,8
 2012128:	e0bfc917 	ldw	r2,-220(fp)
 201212c:	10800044 	addi	r2,r2,1
 2012130:	e0bfc915 	stw	r2,-220(fp)
 2012134:	e0bfc917 	ldw	r2,-220(fp)
 2012138:	10800210 	cmplti	r2,r2,8
 201213c:	1000071e 	bne	r2,zero,201215c <___vfiprintf_internal_r+0x10ec>
 2012140:	e0bfc804 	addi	r2,fp,-224
 2012144:	100d883a 	mov	r6,r2
 2012148:	e17fe717 	ldw	r5,-100(fp)
 201214c:	e13fe617 	ldw	r4,-104(fp)
 2012150:	2010df40 	call	2010df4 <__sprint_r>
 2012154:	1000551e 	bne	r2,zero,20122ac <___vfiprintf_internal_r+0x123c>
 2012158:	e4bfcb04 	addi	r18,fp,-212
 201215c:	843ffc04 	addi	r16,r16,-16
 2012160:	80800448 	cmpgei	r2,r16,17
 2012164:	103fe71e 	bne	r2,zero,2012104 <___vfiprintf_internal_r+0x1094>
 2012168:	008080b4 	movhi	r2,514
 201216c:	10be6e84 	addi	r2,r2,-1606
 2012170:	90800015 	stw	r2,0(r18)
 2012174:	8005883a 	mov	r2,r16
 2012178:	90800115 	stw	r2,4(r18)
 201217c:	e0bfca17 	ldw	r2,-216(fp)
 2012180:	8007883a 	mov	r3,r16
 2012184:	10c5883a 	add	r2,r2,r3
 2012188:	e0bfca15 	stw	r2,-216(fp)
 201218c:	94800204 	addi	r18,r18,8
 2012190:	e0bfc917 	ldw	r2,-220(fp)
 2012194:	10800044 	addi	r2,r2,1
 2012198:	e0bfc915 	stw	r2,-220(fp)
 201219c:	e0bfc917 	ldw	r2,-220(fp)
 20121a0:	10800210 	cmplti	r2,r2,8
 20121a4:	1000071e 	bne	r2,zero,20121c4 <___vfiprintf_internal_r+0x1154>
 20121a8:	e0bfc804 	addi	r2,fp,-224
 20121ac:	100d883a 	mov	r6,r2
 20121b0:	e17fe717 	ldw	r5,-100(fp)
 20121b4:	e13fe617 	ldw	r4,-104(fp)
 20121b8:	2010df40 	call	2010df4 <__sprint_r>
 20121bc:	10003d1e 	bne	r2,zero,20122b4 <___vfiprintf_internal_r+0x1244>
 20121c0:	e4bfcb04 	addi	r18,fp,-212

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
 20121c4:	e0ffba17 	ldw	r3,-280(fp)
 20121c8:	e0bfc017 	ldw	r2,-256(fp)
 20121cc:	10c0010e 	bge	r2,r3,20121d4 <___vfiprintf_internal_r+0x1164>
 20121d0:	1805883a 	mov	r2,r3
 20121d4:	e0ffb917 	ldw	r3,-284(fp)
 20121d8:	1885883a 	add	r2,r3,r2
 20121dc:	e0bfb915 	stw	r2,-284(fp)

		FLUSH ();	/* copy out the I/O vectors */
 20121e0:	e0bfca17 	ldw	r2,-216(fp)
 20121e4:	10000626 	beq	r2,zero,2012200 <___vfiprintf_internal_r+0x1190>
 20121e8:	e0bfc804 	addi	r2,fp,-224
 20121ec:	100d883a 	mov	r6,r2
 20121f0:	e17fe717 	ldw	r5,-100(fp)
 20121f4:	e13fe617 	ldw	r4,-104(fp)
 20121f8:	2010df40 	call	2010df4 <__sprint_r>
 20121fc:	10002f1e 	bne	r2,zero,20122bc <___vfiprintf_internal_r+0x124c>
 2012200:	e03fc915 	stw	zero,-220(fp)
 2012204:	e4bfcb04 	addi	r18,fp,-212

                if (malloc_buf != NULL) {
 2012208:	e0bfc317 	ldw	r2,-244(fp)
 201220c:	103bea26 	beq	r2,zero,20111b8 <___vfiprintf_internal_r+0x148>
			_free_r (data, malloc_buf);
 2012210:	e17fc317 	ldw	r5,-244(fp)
 2012214:	e13fe617 	ldw	r4,-104(fp)
 2012218:	200bdf80 	call	200bdf8 <_free_r>
			malloc_buf = NULL;
 201221c:	e03fc315 	stw	zero,-244(fp)
		}
	}
 2012220:	003be506 	br	20111b8 <___vfiprintf_internal_r+0x148>
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
                    goto done;
 2012224:	0001883a 	nop
 2012228:	00000106 	br	2012230 <___vfiprintf_internal_r+0x11c0>
			size = buf + BUF - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
 201222c:	0001883a 	nop
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
 2012230:	e0bfca17 	ldw	r2,-216(fp)
 2012234:	10000626 	beq	r2,zero,2012250 <___vfiprintf_internal_r+0x11e0>
 2012238:	e0bfc804 	addi	r2,fp,-224
 201223c:	100d883a 	mov	r6,r2
 2012240:	e17fe717 	ldw	r5,-100(fp)
 2012244:	e13fe617 	ldw	r4,-104(fp)
 2012248:	2010df40 	call	2010df4 <__sprint_r>
 201224c:	10001d1e 	bne	r2,zero,20122c4 <___vfiprintf_internal_r+0x1254>
 2012250:	e03fc915 	stw	zero,-220(fp)
 2012254:	e4bfcb04 	addi	r18,fp,-212
 2012258:	00001b06 	br	20122c8 <___vfiprintf_internal_r+0x1258>
#else
                while (*fmt != '\0' && *fmt != '%')
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
			PRINT (cp, m);
 201225c:	0001883a 	nop
 2012260:	00001906 	br	20122c8 <___vfiprintf_internal_r+0x1258>
		if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
			PAD (width - realsz, blanks);
 2012264:	0001883a 	nop
 2012268:	00001706 	br	20122c8 <___vfiprintf_internal_r+0x1258>
 201226c:	0001883a 	nop
 2012270:	00001506 	br	20122c8 <___vfiprintf_internal_r+0x1258>

		/* prefix */
		if (sign)
			PRINT (&sign, 1);
 2012274:	0001883a 	nop
 2012278:	00001306 	br	20122c8 <___vfiprintf_internal_r+0x1258>
		if (flags & HEXPREFIX)
			PRINT (ox, 2);
 201227c:	0001883a 	nop
 2012280:	00001106 	br	20122c8 <___vfiprintf_internal_r+0x1258>

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
			PAD (width - realsz, zeroes);
 2012284:	0001883a 	nop
 2012288:	00000f06 	br	20122c8 <___vfiprintf_internal_r+0x1258>
 201228c:	0001883a 	nop
 2012290:	00000d06 	br	20122c8 <___vfiprintf_internal_r+0x1258>

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
 2012294:	0001883a 	nop
 2012298:	00000b06 	br	20122c8 <___vfiprintf_internal_r+0x1258>
 201229c:	0001883a 	nop
 20122a0:	00000906 	br	20122c8 <___vfiprintf_internal_r+0x1258>
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
 20122a4:	0001883a 	nop
 20122a8:	00000706 	br	20122c8 <___vfiprintf_internal_r+0x1258>
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
			PAD (width - realsz, blanks);
 20122ac:	0001883a 	nop
 20122b0:	00000506 	br	20122c8 <___vfiprintf_internal_r+0x1258>
 20122b4:	0001883a 	nop
 20122b8:	00000306 	br	20122c8 <___vfiprintf_internal_r+0x1258>

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

		FLUSH ();	/* copy out the I/O vectors */
 20122bc:	0001883a 	nop
 20122c0:	00000106 	br	20122c8 <___vfiprintf_internal_r+0x1258>
			_free_r (data, malloc_buf);
			malloc_buf = NULL;
		}
	}
done:
	FLUSH ();
 20122c4:	0001883a 	nop
error:
	if (malloc_buf != NULL)
 20122c8:	e0bfc317 	ldw	r2,-244(fp)
 20122cc:	10000326 	beq	r2,zero,20122dc <___vfiprintf_internal_r+0x126c>
		_free_r (data, malloc_buf);
 20122d0:	e17fc317 	ldw	r5,-244(fp)
 20122d4:	e13fe617 	ldw	r4,-104(fp)
 20122d8:	200bdf80 	call	200bdf8 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
 20122dc:	e0bfe717 	ldw	r2,-100(fp)
 20122e0:	1080030b 	ldhu	r2,12(r2)
 20122e4:	10bfffcc 	andi	r2,r2,65535
 20122e8:	1080100c 	andi	r2,r2,64
 20122ec:	1000021e 	bne	r2,zero,20122f8 <___vfiprintf_internal_r+0x1288>
 20122f0:	e0bfb917 	ldw	r2,-284(fp)
 20122f4:	00000206 	br	2012300 <___vfiprintf_internal_r+0x1290>
 20122f8:	00bfffc4 	movi	r2,-1
 20122fc:	0001883a 	nop
	/* NOTREACHED */
}
 2012300:	e6fff804 	addi	sp,fp,-32
 2012304:	dfc00917 	ldw	ra,36(sp)
 2012308:	df000817 	ldw	fp,32(sp)
 201230c:	ddc00717 	ldw	r23,28(sp)
 2012310:	dd800617 	ldw	r22,24(sp)
 2012314:	dd400517 	ldw	r21,20(sp)
 2012318:	dd000417 	ldw	r20,16(sp)
 201231c:	dcc00317 	ldw	r19,12(sp)
 2012320:	dc800217 	ldw	r18,8(sp)
 2012324:	dc400117 	ldw	r17,4(sp)
 2012328:	dc000017 	ldw	r16,0(sp)
 201232c:	dec00a04 	addi	sp,sp,40
 2012330:	f800283a 	ret

02012334 <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
 2012334:	defff904 	addi	sp,sp,-28
 2012338:	dfc00615 	stw	ra,24(sp)
 201233c:	df000515 	stw	fp,20(sp)
 2012340:	df000504 	addi	fp,sp,20
 2012344:	e13ffc15 	stw	r4,-16(fp)
 2012348:	e17ffd15 	stw	r5,-12(fp)
 201234c:	e1bffe15 	stw	r6,-8(fp)
 2012350:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 2012354:	d0274615 	stw	zero,-25320(gp)
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
 2012358:	e1bfff17 	ldw	r6,-4(fp)
 201235c:	e17ffe17 	ldw	r5,-8(fp)
 2012360:	e13ffd17 	ldw	r4,-12(fp)
 2012364:	20144800 	call	2014480 <write>
 2012368:	e0bffb15 	stw	r2,-20(fp)
 201236c:	e0bffb17 	ldw	r2,-20(fp)
 2012370:	10bfffd8 	cmpnei	r2,r2,-1
 2012374:	1000051e 	bne	r2,zero,201238c <_write_r+0x58>
 2012378:	d0a74617 	ldw	r2,-25320(gp)
 201237c:	10000326 	beq	r2,zero,201238c <_write_r+0x58>
    ptr->_errno = errno;
 2012380:	d0e74617 	ldw	r3,-25320(gp)
 2012384:	e0bffc17 	ldw	r2,-16(fp)
 2012388:	10c00015 	stw	r3,0(r2)
  return ret;
 201238c:	e0bffb17 	ldw	r2,-20(fp)
}
 2012390:	e037883a 	mov	sp,fp
 2012394:	dfc00117 	ldw	ra,4(sp)
 2012398:	df000017 	ldw	fp,0(sp)
 201239c:	dec00204 	addi	sp,sp,8
 20123a0:	f800283a 	ret

020123a4 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 20123a4:	defffb04 	addi	sp,sp,-20
 20123a8:	dfc00415 	stw	ra,16(sp)
 20123ac:	df000315 	stw	fp,12(sp)
 20123b0:	df000304 	addi	fp,sp,12
 20123b4:	e13ffe15 	stw	r4,-8(fp)
 20123b8:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 20123bc:	d0274615 	stw	zero,-25320(gp)
  if ((ret = _close (fd)) == -1 && errno != 0)
 20123c0:	e13fff17 	ldw	r4,-4(fp)
 20123c4:	2013c780 	call	2013c78 <close>
 20123c8:	e0bffd15 	stw	r2,-12(fp)
 20123cc:	e0bffd17 	ldw	r2,-12(fp)
 20123d0:	10bfffd8 	cmpnei	r2,r2,-1
 20123d4:	1000051e 	bne	r2,zero,20123ec <_close_r+0x48>
 20123d8:	d0a74617 	ldw	r2,-25320(gp)
 20123dc:	10000326 	beq	r2,zero,20123ec <_close_r+0x48>
    ptr->_errno = errno;
 20123e0:	d0e74617 	ldw	r3,-25320(gp)
 20123e4:	e0bffe17 	ldw	r2,-8(fp)
 20123e8:	10c00015 	stw	r3,0(r2)
  return ret;
 20123ec:	e0bffd17 	ldw	r2,-12(fp)
}
 20123f0:	e037883a 	mov	sp,fp
 20123f4:	dfc00117 	ldw	ra,4(sp)
 20123f8:	df000017 	ldw	fp,0(sp)
 20123fc:	dec00204 	addi	sp,sp,8
 2012400:	f800283a 	ret

02012404 <_calloc_r>:
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
 2012404:	defff504 	addi	sp,sp,-44
 2012408:	dfc00a15 	stw	ra,40(sp)
 201240c:	df000915 	stw	fp,36(sp)
 2012410:	df000904 	addi	fp,sp,36
 2012414:	e13ffd15 	stw	r4,-12(fp)
 2012418:	e17ffe15 	stw	r5,-8(fp)
 201241c:	e1bfff15 	stw	r6,-4(fp)
  mchunkptr p;
  INTERNAL_SIZE_T csz;

  INTERNAL_SIZE_T sz = n * elem_size;
 2012420:	e0fffe17 	ldw	r3,-8(fp)
 2012424:	e0bfff17 	ldw	r2,-4(fp)
 2012428:	1885383a 	mul	r2,r3,r2
 201242c:	e0bff815 	stw	r2,-32(fp)
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
 2012430:	e17ff817 	ldw	r5,-32(fp)
 2012434:	e13ffd17 	ldw	r4,-12(fp)
 2012438:	200d4380 	call	200d438 <_malloc_r>
 201243c:	e0bff915 	stw	r2,-28(fp)

  if (mem == 0) 
 2012440:	e0bff917 	ldw	r2,-28(fp)
 2012444:	1000021e 	bne	r2,zero,2012450 <_calloc_r+0x4c>
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
 2012448:	0005883a 	mov	r2,zero
 201244c:	00004106 	br	2012554 <_calloc_r+0x150>
  }
  else
  {
    p = mem2chunk(mem);
 2012450:	e0bff917 	ldw	r2,-28(fp)
 2012454:	10bffe04 	addi	r2,r2,-8
 2012458:	e0bffa15 	stw	r2,-24(fp)
#endif
      return mem;
    }
#endif

    csz = chunksize(p);
 201245c:	e0bffa17 	ldw	r2,-24(fp)
 2012460:	10c00117 	ldw	r3,4(r2)
 2012464:	00bfff04 	movi	r2,-4
 2012468:	1884703a 	and	r2,r3,r2
 201246c:	e0bffb15 	stw	r2,-20(fp)
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
 2012470:	e0bffb17 	ldw	r2,-20(fp)
 2012474:	10bfff04 	addi	r2,r2,-4
 2012478:	e0bffc15 	stw	r2,-16(fp)
 201247c:	e0bffc17 	ldw	r2,-16(fp)
 2012480:	10800968 	cmpgeui	r2,r2,37
 2012484:	10002e1e 	bne	r2,zero,2012540 <_calloc_r+0x13c>
 2012488:	e0bff917 	ldw	r2,-28(fp)
 201248c:	e0bff715 	stw	r2,-36(fp)
 2012490:	e0bffc17 	ldw	r2,-16(fp)
 2012494:	10800530 	cmpltui	r2,r2,20
 2012498:	10001e1e 	bne	r2,zero,2012514 <_calloc_r+0x110>
 201249c:	e0bff717 	ldw	r2,-36(fp)
 20124a0:	10c00104 	addi	r3,r2,4
 20124a4:	e0fff715 	stw	r3,-36(fp)
 20124a8:	10000015 	stw	zero,0(r2)
 20124ac:	e0bff717 	ldw	r2,-36(fp)
 20124b0:	10c00104 	addi	r3,r2,4
 20124b4:	e0fff715 	stw	r3,-36(fp)
 20124b8:	10000015 	stw	zero,0(r2)
 20124bc:	e0bffc17 	ldw	r2,-16(fp)
 20124c0:	10800730 	cmpltui	r2,r2,28
 20124c4:	1000131e 	bne	r2,zero,2012514 <_calloc_r+0x110>
 20124c8:	e0bff717 	ldw	r2,-36(fp)
 20124cc:	10c00104 	addi	r3,r2,4
 20124d0:	e0fff715 	stw	r3,-36(fp)
 20124d4:	10000015 	stw	zero,0(r2)
 20124d8:	e0bff717 	ldw	r2,-36(fp)
 20124dc:	10c00104 	addi	r3,r2,4
 20124e0:	e0fff715 	stw	r3,-36(fp)
 20124e4:	10000015 	stw	zero,0(r2)
 20124e8:	e0bffc17 	ldw	r2,-16(fp)
 20124ec:	10800930 	cmpltui	r2,r2,36
 20124f0:	1000081e 	bne	r2,zero,2012514 <_calloc_r+0x110>
 20124f4:	e0bff717 	ldw	r2,-36(fp)
 20124f8:	10c00104 	addi	r3,r2,4
 20124fc:	e0fff715 	stw	r3,-36(fp)
 2012500:	10000015 	stw	zero,0(r2)
 2012504:	e0bff717 	ldw	r2,-36(fp)
 2012508:	10c00104 	addi	r3,r2,4
 201250c:	e0fff715 	stw	r3,-36(fp)
 2012510:	10000015 	stw	zero,0(r2)
 2012514:	e0bff717 	ldw	r2,-36(fp)
 2012518:	10c00104 	addi	r3,r2,4
 201251c:	e0fff715 	stw	r3,-36(fp)
 2012520:	10000015 	stw	zero,0(r2)
 2012524:	e0bff717 	ldw	r2,-36(fp)
 2012528:	10c00104 	addi	r3,r2,4
 201252c:	e0fff715 	stw	r3,-36(fp)
 2012530:	10000015 	stw	zero,0(r2)
 2012534:	e0bff717 	ldw	r2,-36(fp)
 2012538:	10000015 	stw	zero,0(r2)
 201253c:	00000406 	br	2012550 <_calloc_r+0x14c>
 2012540:	e1bffc17 	ldw	r6,-16(fp)
 2012544:	000b883a 	mov	r5,zero
 2012548:	e13ff917 	ldw	r4,-28(fp)
 201254c:	20069580 	call	2006958 <memset>
    return mem;
 2012550:	e0bff917 	ldw	r2,-28(fp)
  }
}
 2012554:	e037883a 	mov	sp,fp
 2012558:	dfc00117 	ldw	ra,4(sp)
 201255c:	df000017 	ldw	fp,0(sp)
 2012560:	dec00204 	addi	sp,sp,8
 2012564:	f800283a 	ret

02012568 <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
 2012568:	defffa04 	addi	sp,sp,-24
 201256c:	dfc00515 	stw	ra,20(sp)
 2012570:	df000415 	stw	fp,16(sp)
 2012574:	dc000315 	stw	r16,12(sp)
 2012578:	df000404 	addi	fp,sp,16
 201257c:	e13ffe15 	stw	r4,-8(fp)
 2012580:	2821883a 	mov	r16,r5
  int r;

  if (fp == NULL)
 2012584:	8000021e 	bne	r16,zero,2012590 <_fclose_r+0x28>
    return (0);			/* on NULL */
 2012588:	0005883a 	mov	r2,zero
 201258c:	00003b06 	br	201267c <_fclose_r+0x114>

  CHECK_INIT (rptr, fp);
 2012590:	e0bffe17 	ldw	r2,-8(fp)
 2012594:	e0bffd15 	stw	r2,-12(fp)
 2012598:	e0bffd17 	ldw	r2,-12(fp)
 201259c:	10000526 	beq	r2,zero,20125b4 <_fclose_r+0x4c>
 20125a0:	e0bffd17 	ldw	r2,-12(fp)
 20125a4:	10800e17 	ldw	r2,56(r2)
 20125a8:	1000021e 	bne	r2,zero,20125b4 <_fclose_r+0x4c>
 20125ac:	e13ffd17 	ldw	r4,-12(fp)
 20125b0:	200bbd80 	call	200bbd8 <__sinit>
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);

  if (fp->_flags == 0)		/* not open! */
 20125b4:	8080030b 	ldhu	r2,12(r16)
 20125b8:	10bfffcc 	andi	r2,r2,65535
 20125bc:	10a0001c 	xori	r2,r2,32768
 20125c0:	10a00004 	addi	r2,r2,-32768
 20125c4:	1000021e 	bne	r2,zero,20125d0 <_fclose_r+0x68>
    {
      _funlockfile (fp);
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
 20125c8:	0005883a 	mov	r2,zero
 20125cc:	00002b06 	br	201267c <_fclose_r+0x114>
  r = (fp->_flags & __SWR) ? __sflush_r (rptr, fp) : 0;
#else
  /* Follow POSIX semantics exactly.  Unconditionally flush to allow
     special handling for seekable read files to reposition file to last
     byte processed as opposed to last byte read ahead into the buffer. */
  r = __sflush_r (rptr, fp);
 20125d0:	800b883a 	mov	r5,r16
 20125d4:	e13ffe17 	ldw	r4,-8(fp)
 20125d8:	200b4540 	call	200b454 <__sflush_r>
 20125dc:	e0bffc15 	stw	r2,-16(fp)
#endif
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
 20125e0:	80800b17 	ldw	r2,44(r16)
 20125e4:	10000826 	beq	r2,zero,2012608 <_fclose_r+0xa0>
 20125e8:	80800b17 	ldw	r2,44(r16)
 20125ec:	80c00717 	ldw	r3,28(r16)
 20125f0:	180b883a 	mov	r5,r3
 20125f4:	e13ffe17 	ldw	r4,-8(fp)
 20125f8:	103ee83a 	callr	r2
 20125fc:	1000020e 	bge	r2,zero,2012608 <_fclose_r+0xa0>
    r = EOF;
 2012600:	00bfffc4 	movi	r2,-1
 2012604:	e0bffc15 	stw	r2,-16(fp)
  if (fp->_flags & __SMBF)
 2012608:	8080030b 	ldhu	r2,12(r16)
 201260c:	10bfffcc 	andi	r2,r2,65535
 2012610:	1080200c 	andi	r2,r2,128
 2012614:	10000426 	beq	r2,zero,2012628 <_fclose_r+0xc0>
    _free_r (rptr, (char *) fp->_bf._base);
 2012618:	80800417 	ldw	r2,16(r16)
 201261c:	100b883a 	mov	r5,r2
 2012620:	e13ffe17 	ldw	r4,-8(fp)
 2012624:	200bdf80 	call	200bdf8 <_free_r>
  if (HASUB (fp))
 2012628:	80800c17 	ldw	r2,48(r16)
 201262c:	10000826 	beq	r2,zero,2012650 <_fclose_r+0xe8>
    FREEUB (rptr, fp);
 2012630:	80c00c17 	ldw	r3,48(r16)
 2012634:	80801004 	addi	r2,r16,64
 2012638:	18800426 	beq	r3,r2,201264c <_fclose_r+0xe4>
 201263c:	80800c17 	ldw	r2,48(r16)
 2012640:	100b883a 	mov	r5,r2
 2012644:	e13ffe17 	ldw	r4,-8(fp)
 2012648:	200bdf80 	call	200bdf8 <_free_r>
 201264c:	80000c15 	stw	zero,48(r16)
  if (HASLB (fp))
 2012650:	80801117 	ldw	r2,68(r16)
 2012654:	10000526 	beq	r2,zero,201266c <_fclose_r+0x104>
    FREELB (rptr, fp);
 2012658:	80801117 	ldw	r2,68(r16)
 201265c:	100b883a 	mov	r5,r2
 2012660:	e13ffe17 	ldw	r4,-8(fp)
 2012664:	200bdf80 	call	200bdf8 <_free_r>
 2012668:	80001115 	stw	zero,68(r16)
  __sfp_lock_acquire ();
 201266c:	200bcb00 	call	200bcb0 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
 2012670:	8000030d 	sth	zero,12(r16)
  _funlockfile (fp);
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
#endif

  __sfp_lock_release ();
 2012674:	200bcd00 	call	200bcd0 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
 2012678:	e0bffc17 	ldw	r2,-16(fp)
}
 201267c:	e6ffff04 	addi	sp,fp,-4
 2012680:	dfc00217 	ldw	ra,8(sp)
 2012684:	df000117 	ldw	fp,4(sp)
 2012688:	dc000017 	ldw	r16,0(sp)
 201268c:	dec00304 	addi	sp,sp,12
 2012690:	f800283a 	ret

02012694 <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
 2012694:	defffe04 	addi	sp,sp,-8
 2012698:	dfc00115 	stw	ra,4(sp)
 201269c:	df000015 	stw	fp,0(sp)
 20126a0:	d839883a 	mov	fp,sp
 20126a4:	2007883a 	mov	r3,r4
  return _fclose_r(_REENT, fp);
 20126a8:	d0a00617 	ldw	r2,-32744(gp)
 20126ac:	180b883a 	mov	r5,r3
 20126b0:	1009883a 	mov	r4,r2
 20126b4:	20125680 	call	2012568 <_fclose_r>
}
 20126b8:	e037883a 	mov	sp,fp
 20126bc:	dfc00117 	ldw	ra,4(sp)
 20126c0:	df000017 	ldw	fp,0(sp)
 20126c4:	dec00204 	addi	sp,sp,8
 20126c8:	f800283a 	ret

020126cc <__fputwc>:
wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
 20126cc:	defff804 	addi	sp,sp,-32
 20126d0:	dfc00715 	stw	ra,28(sp)
 20126d4:	df000615 	stw	fp,24(sp)
 20126d8:	df000604 	addi	fp,sp,24
 20126dc:	e13ffd15 	stw	r4,-12(fp)
 20126e0:	e17ffe15 	stw	r5,-8(fp)
 20126e4:	e1bfff15 	stw	r6,-4(fp)
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
 20126e8:	200cd5c0 	call	200cd5c <__locale_mb_cur_max>
 20126ec:	10800058 	cmpnei	r2,r2,1
 20126f0:	10000a1e 	bne	r2,zero,201271c <__fputwc+0x50>
 20126f4:	e0bffe17 	ldw	r2,-8(fp)
 20126f8:	0080080e 	bge	zero,r2,201271c <__fputwc+0x50>
 20126fc:	e0bffe17 	ldw	r2,-8(fp)
 2012700:	10804008 	cmpgei	r2,r2,256
 2012704:	1000051e 	bne	r2,zero,201271c <__fputwc+0x50>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
 2012708:	e0bffe17 	ldw	r2,-8(fp)
 201270c:	e0bffc05 	stb	r2,-16(fp)
      len = 1;
 2012710:	00800044 	movi	r2,1
 2012714:	e0bffb15 	stw	r2,-20(fp)
 2012718:	00001406 	br	201276c <__fputwc+0xa0>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
 201271c:	e0bfff17 	ldw	r2,-4(fp)
 2012720:	10c01704 	addi	r3,r2,92
 2012724:	e0bffc04 	addi	r2,fp,-16
 2012728:	180f883a 	mov	r7,r3
 201272c:	e1bffe17 	ldw	r6,-8(fp)
 2012730:	100b883a 	mov	r5,r2
 2012734:	e13ffd17 	ldw	r4,-12(fp)
 2012738:	2012d000 	call	2012d00 <_wcrtomb_r>
 201273c:	e0bffb15 	stw	r2,-20(fp)
 2012740:	e0bffb17 	ldw	r2,-20(fp)
 2012744:	10bfffd8 	cmpnei	r2,r2,-1
 2012748:	1000081e 	bne	r2,zero,201276c <__fputwc+0xa0>
	{
	  fp->_flags |= __SERR;
 201274c:	e0bfff17 	ldw	r2,-4(fp)
 2012750:	1080030b 	ldhu	r2,12(r2)
 2012754:	10801014 	ori	r2,r2,64
 2012758:	1007883a 	mov	r3,r2
 201275c:	e0bfff17 	ldw	r2,-4(fp)
 2012760:	10c0030d 	sth	r3,12(r2)
	  return WEOF;
 2012764:	00bfffc4 	movi	r2,-1
 2012768:	00005006 	br	20128ac <__fputwc+0x1e0>
	}
    }

  for (i = 0; i < len; i++)
 201276c:	e03ffa15 	stw	zero,-24(fp)
 2012770:	00004a06 	br	201289c <__fputwc+0x1d0>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
 2012774:	e0bfff17 	ldw	r2,-4(fp)
 2012778:	10800217 	ldw	r2,8(r2)
 201277c:	10ffffc4 	addi	r3,r2,-1
 2012780:	e0bfff17 	ldw	r2,-4(fp)
 2012784:	10c00215 	stw	r3,8(r2)
 2012788:	e0bfff17 	ldw	r2,-4(fp)
 201278c:	10800217 	ldw	r2,8(r2)
 2012790:	10002c0e 	bge	r2,zero,2012844 <__fputwc+0x178>
 2012794:	e0bfff17 	ldw	r2,-4(fp)
 2012798:	10c00217 	ldw	r3,8(r2)
 201279c:	e0bfff17 	ldw	r2,-4(fp)
 20127a0:	10800617 	ldw	r2,24(r2)
 20127a4:	18801c16 	blt	r3,r2,2012818 <__fputwc+0x14c>
 20127a8:	e0bfff17 	ldw	r2,-4(fp)
 20127ac:	10800017 	ldw	r2,0(r2)
 20127b0:	e13ffc04 	addi	r4,fp,-16
 20127b4:	e0fffa17 	ldw	r3,-24(fp)
 20127b8:	20c7883a 	add	r3,r4,r3
 20127bc:	18c00003 	ldbu	r3,0(r3)
 20127c0:	10c00005 	stb	r3,0(r2)
 20127c4:	e0bfff17 	ldw	r2,-4(fp)
 20127c8:	10800017 	ldw	r2,0(r2)
 20127cc:	10800003 	ldbu	r2,0(r2)
 20127d0:	10803fcc 	andi	r2,r2,255
 20127d4:	108002a0 	cmpeqi	r2,r2,10
 20127d8:	1000091e 	bne	r2,zero,2012800 <__fputwc+0x134>
 20127dc:	e0bfff17 	ldw	r2,-4(fp)
 20127e0:	10800017 	ldw	r2,0(r2)
 20127e4:	11000044 	addi	r4,r2,1
 20127e8:	e0ffff17 	ldw	r3,-4(fp)
 20127ec:	19000015 	stw	r4,0(r3)
 20127f0:	10800003 	ldbu	r2,0(r2)
 20127f4:	10803fcc 	andi	r2,r2,255
 20127f8:	10bfffe0 	cmpeqi	r2,r2,-1
 20127fc:	00002006 	br	2012880 <__fputwc+0x1b4>
 2012800:	e1bfff17 	ldw	r6,-4(fp)
 2012804:	01400284 	movi	r5,10
 2012808:	e13ffd17 	ldw	r4,-12(fp)
 201280c:	2012b580 	call	2012b58 <__swbuf_r>
 2012810:	10bfffe0 	cmpeqi	r2,r2,-1
 2012814:	00001a06 	br	2012880 <__fputwc+0x1b4>
 2012818:	e0fffc04 	addi	r3,fp,-16
 201281c:	e0bffa17 	ldw	r2,-24(fp)
 2012820:	1885883a 	add	r2,r3,r2
 2012824:	10800003 	ldbu	r2,0(r2)
 2012828:	10803fcc 	andi	r2,r2,255
 201282c:	e1bfff17 	ldw	r6,-4(fp)
 2012830:	100b883a 	mov	r5,r2
 2012834:	e13ffd17 	ldw	r4,-12(fp)
 2012838:	2012b580 	call	2012b58 <__swbuf_r>
 201283c:	10bfffe0 	cmpeqi	r2,r2,-1
 2012840:	00000f06 	br	2012880 <__fputwc+0x1b4>
 2012844:	e0bfff17 	ldw	r2,-4(fp)
 2012848:	10800017 	ldw	r2,0(r2)
 201284c:	e13ffc04 	addi	r4,fp,-16
 2012850:	e0fffa17 	ldw	r3,-24(fp)
 2012854:	20c7883a 	add	r3,r4,r3
 2012858:	18c00003 	ldbu	r3,0(r3)
 201285c:	10c00005 	stb	r3,0(r2)
 2012860:	e0bfff17 	ldw	r2,-4(fp)
 2012864:	10800017 	ldw	r2,0(r2)
 2012868:	11000044 	addi	r4,r2,1
 201286c:	e0ffff17 	ldw	r3,-4(fp)
 2012870:	19000015 	stw	r4,0(r3)
 2012874:	10800003 	ldbu	r2,0(r2)
 2012878:	10803fcc 	andi	r2,r2,255
 201287c:	10bfffe0 	cmpeqi	r2,r2,-1
 2012880:	10803fcc 	andi	r2,r2,255
 2012884:	10000226 	beq	r2,zero,2012890 <__fputwc+0x1c4>
      return WEOF;
 2012888:	00bfffc4 	movi	r2,-1
 201288c:	00000706 	br	20128ac <__fputwc+0x1e0>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
 2012890:	e0bffa17 	ldw	r2,-24(fp)
 2012894:	10800044 	addi	r2,r2,1
 2012898:	e0bffa15 	stw	r2,-24(fp)
 201289c:	e0fffa17 	ldw	r3,-24(fp)
 20128a0:	e0bffb17 	ldw	r2,-20(fp)
 20128a4:	18bfb336 	bltu	r3,r2,2012774 <__fputwc+0xa8>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
 20128a8:	e0bffe17 	ldw	r2,-8(fp)
}
 20128ac:	e037883a 	mov	sp,fp
 20128b0:	dfc00117 	ldw	ra,4(sp)
 20128b4:	df000017 	ldw	fp,0(sp)
 20128b8:	dec00204 	addi	sp,sp,8
 20128bc:	f800283a 	ret

020128c0 <_fputwc_r>:
wint_t
_DEFUN(_fputwc_r, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
 20128c0:	defffa04 	addi	sp,sp,-24
 20128c4:	dfc00515 	stw	ra,20(sp)
 20128c8:	df000415 	stw	fp,16(sp)
 20128cc:	df000404 	addi	fp,sp,16
 20128d0:	e13ffd15 	stw	r4,-12(fp)
 20128d4:	e17ffe15 	stw	r5,-8(fp)
 20128d8:	e1bfff15 	stw	r6,-4(fp)
  wint_t r;

  _newlib_flockfile_start (fp);
  ORIENT(fp, 1);
 20128dc:	e0bfff17 	ldw	r2,-4(fp)
 20128e0:	1080030b 	ldhu	r2,12(r2)
 20128e4:	10bfffcc 	andi	r2,r2,65535
 20128e8:	1088000c 	andi	r2,r2,8192
 20128ec:	10000b1e 	bne	r2,zero,201291c <_fputwc_r+0x5c>
 20128f0:	e0bfff17 	ldw	r2,-4(fp)
 20128f4:	1080030b 	ldhu	r2,12(r2)
 20128f8:	10880014 	ori	r2,r2,8192
 20128fc:	1007883a 	mov	r3,r2
 2012900:	e0bfff17 	ldw	r2,-4(fp)
 2012904:	10c0030d 	sth	r3,12(r2)
 2012908:	e0bfff17 	ldw	r2,-4(fp)
 201290c:	10801917 	ldw	r2,100(r2)
 2012910:	10c80014 	ori	r3,r2,8192
 2012914:	e0bfff17 	ldw	r2,-4(fp)
 2012918:	10c01915 	stw	r3,100(r2)
  r = __fputwc(ptr, wc, fp);
 201291c:	e1bfff17 	ldw	r6,-4(fp)
 2012920:	e17ffe17 	ldw	r5,-8(fp)
 2012924:	e13ffd17 	ldw	r4,-12(fp)
 2012928:	20126cc0 	call	20126cc <__fputwc>
 201292c:	e0bffc15 	stw	r2,-16(fp)
  _newlib_flockfile_end (fp);
  return r;
 2012930:	e0bffc17 	ldw	r2,-16(fp)
}
 2012934:	e037883a 	mov	sp,fp
 2012938:	dfc00117 	ldw	ra,4(sp)
 201293c:	df000017 	ldw	fp,0(sp)
 2012940:	dec00204 	addi	sp,sp,8
 2012944:	f800283a 	ret

02012948 <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
 2012948:	defffa04 	addi	sp,sp,-24
 201294c:	dfc00515 	stw	ra,20(sp)
 2012950:	df000415 	stw	fp,16(sp)
 2012954:	df000404 	addi	fp,sp,16
 2012958:	e13ffe15 	stw	r4,-8(fp)
 201295c:	e17fff15 	stw	r5,-4(fp)
  struct _reent *reent = _REENT;
 2012960:	d0a00617 	ldw	r2,-32744(gp)
 2012964:	e0bffc15 	stw	r2,-16(fp)

  CHECK_INIT(reent, fp);
 2012968:	e0bffc17 	ldw	r2,-16(fp)
 201296c:	e0bffd15 	stw	r2,-12(fp)
 2012970:	e0bffd17 	ldw	r2,-12(fp)
 2012974:	10000526 	beq	r2,zero,201298c <fputwc+0x44>
 2012978:	e0bffd17 	ldw	r2,-12(fp)
 201297c:	10800e17 	ldw	r2,56(r2)
 2012980:	1000021e 	bne	r2,zero,201298c <fputwc+0x44>
 2012984:	e13ffd17 	ldw	r4,-12(fp)
 2012988:	200bbd80 	call	200bbd8 <__sinit>
  return _fputwc_r (reent, wc, fp);
 201298c:	e1bfff17 	ldw	r6,-4(fp)
 2012990:	e17ffe17 	ldw	r5,-8(fp)
 2012994:	e13ffc17 	ldw	r4,-16(fp)
 2012998:	20128c00 	call	20128c0 <_fputwc_r>
}
 201299c:	e037883a 	mov	sp,fp
 20129a0:	dfc00117 	ldw	ra,4(sp)
 20129a4:	df000017 	ldw	fp,0(sp)
 20129a8:	dec00204 	addi	sp,sp,8
 20129ac:	f800283a 	ret

020129b0 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
 20129b0:	defffa04 	addi	sp,sp,-24
 20129b4:	dfc00515 	stw	ra,20(sp)
 20129b8:	df000415 	stw	fp,16(sp)
 20129bc:	df000404 	addi	fp,sp,16
 20129c0:	e13ffd15 	stw	r4,-12(fp)
 20129c4:	e17ffe15 	stw	r5,-8(fp)
 20129c8:	e1bfff15 	stw	r6,-4(fp)
  int ret;

  errno = 0;
 20129cc:	d0274615 	stw	zero,-25320(gp)
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
 20129d0:	e17fff17 	ldw	r5,-4(fp)
 20129d4:	e13ffe17 	ldw	r4,-8(fp)
 20129d8:	2013db00 	call	2013db0 <fstat>
 20129dc:	e0bffc15 	stw	r2,-16(fp)
 20129e0:	e0bffc17 	ldw	r2,-16(fp)
 20129e4:	10bfffd8 	cmpnei	r2,r2,-1
 20129e8:	1000051e 	bne	r2,zero,2012a00 <_fstat_r+0x50>
 20129ec:	d0a74617 	ldw	r2,-25320(gp)
 20129f0:	10000326 	beq	r2,zero,2012a00 <_fstat_r+0x50>
    ptr->_errno = errno;
 20129f4:	d0e74617 	ldw	r3,-25320(gp)
 20129f8:	e0bffd17 	ldw	r2,-12(fp)
 20129fc:	10c00015 	stw	r3,0(r2)
  return ret;
 2012a00:	e0bffc17 	ldw	r2,-16(fp)
}
 2012a04:	e037883a 	mov	sp,fp
 2012a08:	dfc00117 	ldw	ra,4(sp)
 2012a0c:	df000017 	ldw	fp,0(sp)
 2012a10:	dec00204 	addi	sp,sp,8
 2012a14:	f800283a 	ret

02012a18 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
 2012a18:	defffb04 	addi	sp,sp,-20
 2012a1c:	dfc00415 	stw	ra,16(sp)
 2012a20:	df000315 	stw	fp,12(sp)
 2012a24:	df000304 	addi	fp,sp,12
 2012a28:	e13ffe15 	stw	r4,-8(fp)
 2012a2c:	e17fff15 	stw	r5,-4(fp)
  int ret;

  errno = 0;
 2012a30:	d0274615 	stw	zero,-25320(gp)
  if ((ret = _isatty (fd)) == -1 && errno != 0)
 2012a34:	e13fff17 	ldw	r4,-4(fp)
 2012a38:	2013e9c0 	call	2013e9c <isatty>
 2012a3c:	e0bffd15 	stw	r2,-12(fp)
 2012a40:	e0bffd17 	ldw	r2,-12(fp)
 2012a44:	10bfffd8 	cmpnei	r2,r2,-1
 2012a48:	1000051e 	bne	r2,zero,2012a60 <_isatty_r+0x48>
 2012a4c:	d0a74617 	ldw	r2,-25320(gp)
 2012a50:	10000326 	beq	r2,zero,2012a60 <_isatty_r+0x48>
    ptr->_errno = errno;
 2012a54:	d0e74617 	ldw	r3,-25320(gp)
 2012a58:	e0bffe17 	ldw	r2,-8(fp)
 2012a5c:	10c00015 	stw	r3,0(r2)
  return ret;
 2012a60:	e0bffd17 	ldw	r2,-12(fp)
}
 2012a64:	e037883a 	mov	sp,fp
 2012a68:	dfc00117 	ldw	ra,4(sp)
 2012a6c:	df000017 	ldw	fp,0(sp)
 2012a70:	dec00204 	addi	sp,sp,8
 2012a74:	f800283a 	ret

02012a78 <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
 2012a78:	defff904 	addi	sp,sp,-28
 2012a7c:	dfc00615 	stw	ra,24(sp)
 2012a80:	df000515 	stw	fp,20(sp)
 2012a84:	df000504 	addi	fp,sp,20
 2012a88:	e13ffc15 	stw	r4,-16(fp)
 2012a8c:	e17ffd15 	stw	r5,-12(fp)
 2012a90:	e1bffe15 	stw	r6,-8(fp)
 2012a94:	e1ffff15 	stw	r7,-4(fp)
  _off_t ret;

  errno = 0;
 2012a98:	d0274615 	stw	zero,-25320(gp)
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
 2012a9c:	e1bfff17 	ldw	r6,-4(fp)
 2012aa0:	e17ffe17 	ldw	r5,-8(fp)
 2012aa4:	e13ffd17 	ldw	r4,-12(fp)
 2012aa8:	20140680 	call	2014068 <lseek>
 2012aac:	e0bffb15 	stw	r2,-20(fp)
 2012ab0:	e0bffb17 	ldw	r2,-20(fp)
 2012ab4:	10bfffd8 	cmpnei	r2,r2,-1
 2012ab8:	1000051e 	bne	r2,zero,2012ad0 <_lseek_r+0x58>
 2012abc:	d0a74617 	ldw	r2,-25320(gp)
 2012ac0:	10000326 	beq	r2,zero,2012ad0 <_lseek_r+0x58>
    ptr->_errno = errno;
 2012ac4:	d0e74617 	ldw	r3,-25320(gp)
 2012ac8:	e0bffc17 	ldw	r2,-16(fp)
 2012acc:	10c00015 	stw	r3,0(r2)
  return ret;
 2012ad0:	e0bffb17 	ldw	r2,-20(fp)
}
 2012ad4:	e037883a 	mov	sp,fp
 2012ad8:	dfc00117 	ldw	ra,4(sp)
 2012adc:	df000017 	ldw	fp,0(sp)
 2012ae0:	dec00204 	addi	sp,sp,8
 2012ae4:	f800283a 	ret

02012ae8 <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
 2012ae8:	defff904 	addi	sp,sp,-28
 2012aec:	dfc00615 	stw	ra,24(sp)
 2012af0:	df000515 	stw	fp,20(sp)
 2012af4:	df000504 	addi	fp,sp,20
 2012af8:	e13ffc15 	stw	r4,-16(fp)
 2012afc:	e17ffd15 	stw	r5,-12(fp)
 2012b00:	e1bffe15 	stw	r6,-8(fp)
 2012b04:	e1ffff15 	stw	r7,-4(fp)
  _ssize_t ret;

  errno = 0;
 2012b08:	d0274615 	stw	zero,-25320(gp)
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
 2012b0c:	e1bfff17 	ldw	r6,-4(fp)
 2012b10:	e17ffe17 	ldw	r5,-8(fp)
 2012b14:	e13ffd17 	ldw	r4,-12(fp)
 2012b18:	20142340 	call	2014234 <read>
 2012b1c:	e0bffb15 	stw	r2,-20(fp)
 2012b20:	e0bffb17 	ldw	r2,-20(fp)
 2012b24:	10bfffd8 	cmpnei	r2,r2,-1
 2012b28:	1000051e 	bne	r2,zero,2012b40 <_read_r+0x58>
 2012b2c:	d0a74617 	ldw	r2,-25320(gp)
 2012b30:	10000326 	beq	r2,zero,2012b40 <_read_r+0x58>
    ptr->_errno = errno;
 2012b34:	d0e74617 	ldw	r3,-25320(gp)
 2012b38:	e0bffc17 	ldw	r2,-16(fp)
 2012b3c:	10c00015 	stw	r3,0(r2)
  return ret;
 2012b40:	e0bffb17 	ldw	r2,-20(fp)
}
 2012b44:	e037883a 	mov	sp,fp
 2012b48:	dfc00117 	ldw	ra,4(sp)
 2012b4c:	df000017 	ldw	fp,0(sp)
 2012b50:	dec00204 	addi	sp,sp,8
 2012b54:	f800283a 	ret

02012b58 <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
 2012b58:	defff904 	addi	sp,sp,-28
 2012b5c:	dfc00615 	stw	ra,24(sp)
 2012b60:	df000515 	stw	fp,20(sp)
 2012b64:	dc800415 	stw	r18,16(sp)
 2012b68:	dc400315 	stw	r17,12(sp)
 2012b6c:	dc000215 	stw	r16,8(sp)
 2012b70:	df000504 	addi	fp,sp,20
 2012b74:	e13ffc15 	stw	r4,-16(fp)
 2012b78:	2825883a 	mov	r18,r5
 2012b7c:	3021883a 	mov	r16,r6
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
 2012b80:	e0bffc17 	ldw	r2,-16(fp)
 2012b84:	e0bffb15 	stw	r2,-20(fp)
 2012b88:	e0bffb17 	ldw	r2,-20(fp)
 2012b8c:	10000526 	beq	r2,zero,2012ba4 <__swbuf_r+0x4c>
 2012b90:	e0bffb17 	ldw	r2,-20(fp)
 2012b94:	10800e17 	ldw	r2,56(r2)
 2012b98:	1000021e 	bne	r2,zero,2012ba4 <__swbuf_r+0x4c>
 2012b9c:	e13ffb17 	ldw	r4,-20(fp)
 2012ba0:	200bbd80 	call	200bbd8 <__sinit>
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
 2012ba4:	80800617 	ldw	r2,24(r16)
 2012ba8:	80800215 	stw	r2,8(r16)
  if (cantwrite (ptr, fp))
 2012bac:	8080030b 	ldhu	r2,12(r16)
 2012bb0:	10bfffcc 	andi	r2,r2,65535
 2012bb4:	1080020c 	andi	r2,r2,8
 2012bb8:	10000226 	beq	r2,zero,2012bc4 <__swbuf_r+0x6c>
 2012bbc:	80800417 	ldw	r2,16(r16)
 2012bc0:	1000061e 	bne	r2,zero,2012bdc <__swbuf_r+0x84>
 2012bc4:	800b883a 	mov	r5,r16
 2012bc8:	e13ffc17 	ldw	r4,-16(fp)
 2012bcc:	20093880 	call	2009388 <__swsetup_r>
 2012bd0:	10000226 	beq	r2,zero,2012bdc <__swbuf_r+0x84>
    return EOF;
 2012bd4:	00bfffc4 	movi	r2,-1
 2012bd8:	00003106 	br	2012ca0 <__swbuf_r+0x148>
  c = (unsigned char) c;
 2012bdc:	94803fcc 	andi	r18,r18,255

  ORIENT (fp, -1);
 2012be0:	8080030b 	ldhu	r2,12(r16)
 2012be4:	10bfffcc 	andi	r2,r2,65535
 2012be8:	1088000c 	andi	r2,r2,8192
 2012bec:	1000071e 	bne	r2,zero,2012c0c <__swbuf_r+0xb4>
 2012bf0:	8080030b 	ldhu	r2,12(r16)
 2012bf4:	10880014 	ori	r2,r2,8192
 2012bf8:	8080030d 	sth	r2,12(r16)
 2012bfc:	80c01917 	ldw	r3,100(r16)
 2012c00:	00b7ffc4 	movi	r2,-8193
 2012c04:	1884703a 	and	r2,r3,r2
 2012c08:	80801915 	stw	r2,100(r16)
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
 2012c0c:	80800017 	ldw	r2,0(r16)
 2012c10:	1007883a 	mov	r3,r2
 2012c14:	80800417 	ldw	r2,16(r16)
 2012c18:	18a3c83a 	sub	r17,r3,r2
  if (n >= fp->_bf._size)
 2012c1c:	80800517 	ldw	r2,20(r16)
 2012c20:	88800716 	blt	r17,r2,2012c40 <__swbuf_r+0xe8>
    {
      if (_fflush_r (ptr, fp))
 2012c24:	800b883a 	mov	r5,r16
 2012c28:	e13ffc17 	ldw	r4,-16(fp)
 2012c2c:	200b7580 	call	200b758 <_fflush_r>
 2012c30:	10000226 	beq	r2,zero,2012c3c <__swbuf_r+0xe4>
	return EOF;
 2012c34:	00bfffc4 	movi	r2,-1
 2012c38:	00001906 	br	2012ca0 <__swbuf_r+0x148>
      n = 0;
 2012c3c:	0023883a 	mov	r17,zero
    }
  fp->_w--;
 2012c40:	80800217 	ldw	r2,8(r16)
 2012c44:	10bfffc4 	addi	r2,r2,-1
 2012c48:	80800215 	stw	r2,8(r16)
  *fp->_p++ = c;
 2012c4c:	80800017 	ldw	r2,0(r16)
 2012c50:	10c00044 	addi	r3,r2,1
 2012c54:	80c00015 	stw	r3,0(r16)
 2012c58:	9007883a 	mov	r3,r18
 2012c5c:	10c00005 	stb	r3,0(r2)
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
 2012c60:	8c400044 	addi	r17,r17,1
 2012c64:	80800517 	ldw	r2,20(r16)
 2012c68:	88800626 	beq	r17,r2,2012c84 <__swbuf_r+0x12c>
 2012c6c:	8080030b 	ldhu	r2,12(r16)
 2012c70:	10bfffcc 	andi	r2,r2,65535
 2012c74:	1080004c 	andi	r2,r2,1
 2012c78:	10000826 	beq	r2,zero,2012c9c <__swbuf_r+0x144>
 2012c7c:	90800298 	cmpnei	r2,r18,10
 2012c80:	1000061e 	bne	r2,zero,2012c9c <__swbuf_r+0x144>
    if (_fflush_r (ptr, fp))
 2012c84:	800b883a 	mov	r5,r16
 2012c88:	e13ffc17 	ldw	r4,-16(fp)
 2012c8c:	200b7580 	call	200b758 <_fflush_r>
 2012c90:	10000226 	beq	r2,zero,2012c9c <__swbuf_r+0x144>
      return EOF;
 2012c94:	00bfffc4 	movi	r2,-1
 2012c98:	00000106 	br	2012ca0 <__swbuf_r+0x148>
  return c;
 2012c9c:	9005883a 	mov	r2,r18
}
 2012ca0:	e6fffd04 	addi	sp,fp,-12
 2012ca4:	dfc00417 	ldw	ra,16(sp)
 2012ca8:	df000317 	ldw	fp,12(sp)
 2012cac:	dc800217 	ldw	r18,8(sp)
 2012cb0:	dc400117 	ldw	r17,4(sp)
 2012cb4:	dc000017 	ldw	r16,0(sp)
 2012cb8:	dec00504 	addi	sp,sp,20
 2012cbc:	f800283a 	ret

02012cc0 <__swbuf>:
   earlier dynamically built newlib libraries. */
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
 2012cc0:	defffe04 	addi	sp,sp,-8
 2012cc4:	dfc00115 	stw	ra,4(sp)
 2012cc8:	df000015 	stw	fp,0(sp)
 2012ccc:	d839883a 	mov	fp,sp
 2012cd0:	2007883a 	mov	r3,r4
 2012cd4:	2809883a 	mov	r4,r5
  return __swbuf_r (_REENT, c, fp);
 2012cd8:	d0a00617 	ldw	r2,-32744(gp)
 2012cdc:	200d883a 	mov	r6,r4
 2012ce0:	180b883a 	mov	r5,r3
 2012ce4:	1009883a 	mov	r4,r2
 2012ce8:	2012b580 	call	2012b58 <__swbuf_r>
}
 2012cec:	e037883a 	mov	sp,fp
 2012cf0:	dfc00117 	ldw	ra,4(sp)
 2012cf4:	df000017 	ldw	fp,0(sp)
 2012cf8:	dec00204 	addi	sp,sp,8
 2012cfc:	f800283a 	ret

02012d00 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
 2012d00:	defff404 	addi	sp,sp,-48
 2012d04:	dfc00b15 	stw	ra,44(sp)
 2012d08:	df000a15 	stw	fp,40(sp)
 2012d0c:	dc000915 	stw	r16,36(sp)
 2012d10:	df000a04 	addi	fp,sp,40
 2012d14:	e13ffb15 	stw	r4,-20(fp)
 2012d18:	e17ffc15 	stw	r5,-16(fp)
 2012d1c:	e1bffd15 	stw	r6,-12(fp)
 2012d20:	e1fffe15 	stw	r7,-8(fp)
  int retval = 0;
 2012d24:	e03ff715 	stw	zero,-36(fp)
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
 2012d28:	e0bffc17 	ldw	r2,-16(fp)
 2012d2c:	10000d1e 	bne	r2,zero,2012d64 <_wcrtomb_r+0x64>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
 2012d30:	d4200b17 	ldw	r16,-32724(gp)
 2012d34:	200cd380 	call	200cd38 <__locale_charset>
 2012d38:	1009883a 	mov	r4,r2
 2012d3c:	e0fff804 	addi	r3,fp,-32
 2012d40:	e0bffe17 	ldw	r2,-8(fp)
 2012d44:	d8800015 	stw	r2,0(sp)
 2012d48:	200f883a 	mov	r7,r4
 2012d4c:	000d883a 	mov	r6,zero
 2012d50:	180b883a 	mov	r5,r3
 2012d54:	e13ffb17 	ldw	r4,-20(fp)
 2012d58:	803ee83a 	callr	r16
 2012d5c:	e0bff715 	stw	r2,-36(fp)
 2012d60:	00000b06 	br	2012d90 <_wcrtomb_r+0x90>
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
 2012d64:	d4200b17 	ldw	r16,-32724(gp)
 2012d68:	200cd380 	call	200cd38 <__locale_charset>
 2012d6c:	1007883a 	mov	r3,r2
 2012d70:	e0bffe17 	ldw	r2,-8(fp)
 2012d74:	d8800015 	stw	r2,0(sp)
 2012d78:	180f883a 	mov	r7,r3
 2012d7c:	e1bffd17 	ldw	r6,-12(fp)
 2012d80:	e17ffc17 	ldw	r5,-16(fp)
 2012d84:	e13ffb17 	ldw	r4,-20(fp)
 2012d88:	803ee83a 	callr	r16
 2012d8c:	e0bff715 	stw	r2,-36(fp)

  if (retval == -1)
 2012d90:	e0bff717 	ldw	r2,-36(fp)
 2012d94:	10bfffd8 	cmpnei	r2,r2,-1
 2012d98:	1000071e 	bne	r2,zero,2012db8 <_wcrtomb_r+0xb8>
    {
      ps->__count = 0;
 2012d9c:	e0bffe17 	ldw	r2,-8(fp)
 2012da0:	10000015 	stw	zero,0(r2)
      ptr->_errno = EILSEQ;
 2012da4:	e0bffb17 	ldw	r2,-20(fp)
 2012da8:	00c02284 	movi	r3,138
 2012dac:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 2012db0:	00bfffc4 	movi	r2,-1
 2012db4:	00000106 	br	2012dbc <_wcrtomb_r+0xbc>
    }
  else
    return (size_t)retval;
 2012db8:	e0bff717 	ldw	r2,-36(fp)
}
 2012dbc:	e6ffff04 	addi	sp,fp,-4
 2012dc0:	dfc00217 	ldw	ra,8(sp)
 2012dc4:	df000117 	ldw	fp,4(sp)
 2012dc8:	dc000017 	ldw	r16,0(sp)
 2012dcc:	dec00304 	addi	sp,sp,12
 2012dd0:	f800283a 	ret

02012dd4 <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *__restrict s _AND
	wchar_t wc _AND
	mbstate_t *__restrict ps)
{
 2012dd4:	defff404 	addi	sp,sp,-48
 2012dd8:	dfc00b15 	stw	ra,44(sp)
 2012ddc:	df000a15 	stw	fp,40(sp)
 2012de0:	dc000915 	stw	r16,36(sp)
 2012de4:	df000a04 	addi	fp,sp,40
 2012de8:	e13ffc15 	stw	r4,-16(fp)
 2012dec:	e17ffd15 	stw	r5,-12(fp)
 2012df0:	e1bffe15 	stw	r6,-8(fp)
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
 2012df4:	e03ff715 	stw	zero,-36(fp)
  struct _reent *reent = _REENT;
 2012df8:	d0a00617 	ldw	r2,-32744(gp)
 2012dfc:	e0bff815 	stw	r2,-32(fp)
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
 2012e00:	e0bffc17 	ldw	r2,-16(fp)
 2012e04:	10000d1e 	bne	r2,zero,2012e3c <wcrtomb+0x68>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
 2012e08:	d4200b17 	ldw	r16,-32724(gp)
 2012e0c:	200cd380 	call	200cd38 <__locale_charset>
 2012e10:	1009883a 	mov	r4,r2
 2012e14:	e0fff904 	addi	r3,fp,-28
 2012e18:	e0bffe17 	ldw	r2,-8(fp)
 2012e1c:	d8800015 	stw	r2,0(sp)
 2012e20:	200f883a 	mov	r7,r4
 2012e24:	000d883a 	mov	r6,zero
 2012e28:	180b883a 	mov	r5,r3
 2012e2c:	e13ff817 	ldw	r4,-32(fp)
 2012e30:	803ee83a 	callr	r16
 2012e34:	e0bff715 	stw	r2,-36(fp)
 2012e38:	00000b06 	br	2012e68 <wcrtomb+0x94>
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
 2012e3c:	d4200b17 	ldw	r16,-32724(gp)
 2012e40:	200cd380 	call	200cd38 <__locale_charset>
 2012e44:	1007883a 	mov	r3,r2
 2012e48:	e0bffe17 	ldw	r2,-8(fp)
 2012e4c:	d8800015 	stw	r2,0(sp)
 2012e50:	180f883a 	mov	r7,r3
 2012e54:	e1bffd17 	ldw	r6,-12(fp)
 2012e58:	e17ffc17 	ldw	r5,-16(fp)
 2012e5c:	e13ff817 	ldw	r4,-32(fp)
 2012e60:	803ee83a 	callr	r16
 2012e64:	e0bff715 	stw	r2,-36(fp)

  if (retval == -1)
 2012e68:	e0bff717 	ldw	r2,-36(fp)
 2012e6c:	10bfffd8 	cmpnei	r2,r2,-1
 2012e70:	1000071e 	bne	r2,zero,2012e90 <wcrtomb+0xbc>
    {
      ps->__count = 0;
 2012e74:	e0bffe17 	ldw	r2,-8(fp)
 2012e78:	10000015 	stw	zero,0(r2)
      reent->_errno = EILSEQ;
 2012e7c:	e0bff817 	ldw	r2,-32(fp)
 2012e80:	00c02284 	movi	r3,138
 2012e84:	10c00015 	stw	r3,0(r2)
      return (size_t)(-1);
 2012e88:	00bfffc4 	movi	r2,-1
 2012e8c:	00000106 	br	2012e94 <wcrtomb+0xc0>
    }
  else
    return (size_t)retval;
 2012e90:	e0bff717 	ldw	r2,-36(fp)
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 2012e94:	e6ffff04 	addi	sp,fp,-4
 2012e98:	dfc00217 	ldw	ra,8(sp)
 2012e9c:	df000117 	ldw	fp,4(sp)
 2012ea0:	dc000017 	ldw	r16,0(sp)
 2012ea4:	dec00304 	addi	sp,sp,12
 2012ea8:	f800283a 	ret

02012eac <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
 2012eac:	defff804 	addi	sp,sp,-32
 2012eb0:	dfc00715 	stw	ra,28(sp)
 2012eb4:	df000615 	stw	fp,24(sp)
 2012eb8:	dc000515 	stw	r16,20(sp)
 2012ebc:	df000604 	addi	fp,sp,24
 2012ec0:	e13ffb15 	stw	r4,-20(fp)
 2012ec4:	e17ffc15 	stw	r5,-16(fp)
 2012ec8:	e1bffd15 	stw	r6,-12(fp)
 2012ecc:	e1fffe15 	stw	r7,-8(fp)
  return __wctomb (r, s, _wchar, __locale_charset (), state);
 2012ed0:	d4200b17 	ldw	r16,-32724(gp)
 2012ed4:	200cd380 	call	200cd38 <__locale_charset>
 2012ed8:	1007883a 	mov	r3,r2
 2012edc:	e0bffe17 	ldw	r2,-8(fp)
 2012ee0:	d8800015 	stw	r2,0(sp)
 2012ee4:	180f883a 	mov	r7,r3
 2012ee8:	e1bffd17 	ldw	r6,-12(fp)
 2012eec:	e17ffc17 	ldw	r5,-16(fp)
 2012ef0:	e13ffb17 	ldw	r4,-20(fp)
 2012ef4:	803ee83a 	callr	r16
}
 2012ef8:	e6ffff04 	addi	sp,fp,-4
 2012efc:	dfc00217 	ldw	ra,8(sp)
 2012f00:	df000117 	ldw	fp,4(sp)
 2012f04:	dc000017 	ldw	r16,0(sp)
 2012f08:	dec00304 	addi	sp,sp,12
 2012f0c:	f800283a 	ret

02012f10 <__ascii_wctomb>:
        struct _reent *r       _AND 
        char          *s       _AND
        wchar_t        _wchar  _AND
	const char    *charset _AND
        mbstate_t     *state)
{
 2012f10:	defffa04 	addi	sp,sp,-24
 2012f14:	df000515 	stw	fp,20(sp)
 2012f18:	df000504 	addi	fp,sp,20
 2012f1c:	e13ffc15 	stw	r4,-16(fp)
 2012f20:	e17ffd15 	stw	r5,-12(fp)
 2012f24:	e1bffe15 	stw	r6,-8(fp)
 2012f28:	e1ffff15 	stw	r7,-4(fp)
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;
 2012f2c:	e0bffe17 	ldw	r2,-8(fp)
 2012f30:	e0bffb15 	stw	r2,-20(fp)

  if (s == NULL)
 2012f34:	e0bffd17 	ldw	r2,-12(fp)
 2012f38:	1000021e 	bne	r2,zero,2012f44 <__ascii_wctomb+0x34>
    return 0;
 2012f3c:	0005883a 	mov	r2,zero
 2012f40:	00000d06 	br	2012f78 <__ascii_wctomb+0x68>
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
 2012f44:	e0bffb17 	ldw	r2,-20(fp)
 2012f48:	10804030 	cmpltui	r2,r2,256
 2012f4c:	1000051e 	bne	r2,zero,2012f64 <__ascii_wctomb+0x54>
#endif
    {
      r->_errno = EILSEQ;
 2012f50:	e0bffc17 	ldw	r2,-16(fp)
 2012f54:	00c02284 	movi	r3,138
 2012f58:	10c00015 	stw	r3,0(r2)
      return -1;
 2012f5c:	00bfffc4 	movi	r2,-1
 2012f60:	00000506 	br	2012f78 <__ascii_wctomb+0x68>
    }

  *s = (char) wchar;
 2012f64:	e0bffb17 	ldw	r2,-20(fp)
 2012f68:	1007883a 	mov	r3,r2
 2012f6c:	e0bffd17 	ldw	r2,-12(fp)
 2012f70:	10c00005 	stb	r3,0(r2)
  return 1;
 2012f74:	00800044 	movi	r2,1
}
 2012f78:	e037883a 	mov	sp,fp
 2012f7c:	df000017 	ldw	fp,0(sp)
 2012f80:	dec00104 	addi	sp,sp,4
 2012f84:	f800283a 	ret

02012f88 <__udivdi3>:
 2012f88:	defff504 	addi	sp,sp,-44
 2012f8c:	dcc00415 	stw	r19,16(sp)
 2012f90:	dc000115 	stw	r16,4(sp)
 2012f94:	dfc00a15 	stw	ra,40(sp)
 2012f98:	df000915 	stw	fp,36(sp)
 2012f9c:	ddc00815 	stw	r23,32(sp)
 2012fa0:	dd800715 	stw	r22,28(sp)
 2012fa4:	dd400615 	stw	r21,24(sp)
 2012fa8:	dd000515 	stw	r20,20(sp)
 2012fac:	dc800315 	stw	r18,12(sp)
 2012fb0:	dc400215 	stw	r17,8(sp)
 2012fb4:	2027883a 	mov	r19,r4
 2012fb8:	2821883a 	mov	r16,r5
 2012fbc:	3800411e 	bne	r7,zero,20130c4 <__udivdi3+0x13c>
 2012fc0:	3023883a 	mov	r17,r6
 2012fc4:	2025883a 	mov	r18,r4
 2012fc8:	2980522e 	bgeu	r5,r6,2013114 <__udivdi3+0x18c>
 2012fcc:	00bfffd4 	movui	r2,65535
 2012fd0:	282d883a 	mov	r22,r5
 2012fd4:	1180a836 	bltu	r2,r6,2013278 <__udivdi3+0x2f0>
 2012fd8:	00803fc4 	movi	r2,255
 2012fdc:	1185803a 	cmpltu	r2,r2,r6
 2012fe0:	100490fa 	slli	r2,r2,3
 2012fe4:	3086d83a 	srl	r3,r6,r2
 2012fe8:	010080b4 	movhi	r4,514
 2012fec:	213da644 	addi	r4,r4,-2407
 2012ff0:	20c7883a 	add	r3,r4,r3
 2012ff4:	18c00003 	ldbu	r3,0(r3)
 2012ff8:	1885883a 	add	r2,r3,r2
 2012ffc:	00c00804 	movi	r3,32
 2013000:	1887c83a 	sub	r3,r3,r2
 2013004:	18000526 	beq	r3,zero,201301c <__udivdi3+0x94>
 2013008:	80e0983a 	sll	r16,r16,r3
 201300c:	9884d83a 	srl	r2,r19,r2
 2013010:	30e2983a 	sll	r17,r6,r3
 2013014:	98e4983a 	sll	r18,r19,r3
 2013018:	142cb03a 	or	r22,r2,r16
 201301c:	882ad43a 	srli	r21,r17,16
 2013020:	b009883a 	mov	r4,r22
 2013024:	8d3fffcc 	andi	r20,r17,65535
 2013028:	a80b883a 	mov	r5,r21
 201302c:	200403c0 	call	200403c <__umodsi3>
 2013030:	b009883a 	mov	r4,r22
 2013034:	a80b883a 	mov	r5,r21
 2013038:	1027883a 	mov	r19,r2
 201303c:	2003fd80 	call	2003fd8 <__udivsi3>
 2013040:	102d883a 	mov	r22,r2
 2013044:	9826943a 	slli	r19,r19,16
 2013048:	9004d43a 	srli	r2,r18,16
 201304c:	a5a1383a 	mul	r16,r20,r22
 2013050:	14c4b03a 	or	r2,r2,r19
 2013054:	1400052e 	bgeu	r2,r16,201306c <__udivdi3+0xe4>
 2013058:	1445883a 	add	r2,r2,r17
 201305c:	b0ffffc4 	addi	r3,r22,-1
 2013060:	14400136 	bltu	r2,r17,2013068 <__udivdi3+0xe0>
 2013064:	14012336 	bltu	r2,r16,20134f4 <__udivdi3+0x56c>
 2013068:	182d883a 	mov	r22,r3
 201306c:	1421c83a 	sub	r16,r2,r16
 2013070:	a80b883a 	mov	r5,r21
 2013074:	8009883a 	mov	r4,r16
 2013078:	200403c0 	call	200403c <__umodsi3>
 201307c:	1027883a 	mov	r19,r2
 2013080:	a80b883a 	mov	r5,r21
 2013084:	8009883a 	mov	r4,r16
 2013088:	2003fd80 	call	2003fd8 <__udivsi3>
 201308c:	9826943a 	slli	r19,r19,16
 2013090:	a0a9383a 	mul	r20,r20,r2
 2013094:	94bfffcc 	andi	r18,r18,65535
 2013098:	94e4b03a 	or	r18,r18,r19
 201309c:	9500052e 	bgeu	r18,r20,20130b4 <__udivdi3+0x12c>
 20130a0:	8ca5883a 	add	r18,r17,r18
 20130a4:	10ffffc4 	addi	r3,r2,-1
 20130a8:	9440f136 	bltu	r18,r17,2013470 <__udivdi3+0x4e8>
 20130ac:	9500f02e 	bgeu	r18,r20,2013470 <__udivdi3+0x4e8>
 20130b0:	10bfff84 	addi	r2,r2,-2
 20130b4:	b00c943a 	slli	r6,r22,16
 20130b8:	0007883a 	mov	r3,zero
 20130bc:	3084b03a 	or	r2,r6,r2
 20130c0:	00005906 	br	2013228 <__udivdi3+0x2a0>
 20130c4:	29c05636 	bltu	r5,r7,2013220 <__udivdi3+0x298>
 20130c8:	00bfffd4 	movui	r2,65535
 20130cc:	11c0622e 	bgeu	r2,r7,2013258 <__udivdi3+0x2d0>
 20130d0:	00804034 	movhi	r2,256
 20130d4:	10bfffc4 	addi	r2,r2,-1
 20130d8:	11c0ee36 	bltu	r2,r7,2013494 <__udivdi3+0x50c>
 20130dc:	00800404 	movi	r2,16
 20130e0:	3886d83a 	srl	r3,r7,r2
 20130e4:	010080b4 	movhi	r4,514
 20130e8:	213da644 	addi	r4,r4,-2407
 20130ec:	20c7883a 	add	r3,r4,r3
 20130f0:	18c00003 	ldbu	r3,0(r3)
 20130f4:	05400804 	movi	r21,32
 20130f8:	1885883a 	add	r2,r3,r2
 20130fc:	a8abc83a 	sub	r21,r21,r2
 2013100:	a800621e 	bne	r21,zero,201328c <__udivdi3+0x304>
 2013104:	3c00e936 	bltu	r7,r16,20134ac <__udivdi3+0x524>
 2013108:	9985403a 	cmpgeu	r2,r19,r6
 201310c:	0007883a 	mov	r3,zero
 2013110:	00004506 	br	2013228 <__udivdi3+0x2a0>
 2013114:	3000041e 	bne	r6,zero,2013128 <__udivdi3+0x1a0>
 2013118:	000b883a 	mov	r5,zero
 201311c:	01000044 	movi	r4,1
 2013120:	2003fd80 	call	2003fd8 <__udivsi3>
 2013124:	1023883a 	mov	r17,r2
 2013128:	00bfffd4 	movui	r2,65535
 201312c:	14404e2e 	bgeu	r2,r17,2013268 <__udivdi3+0x2e0>
 2013130:	00804034 	movhi	r2,256
 2013134:	10bfffc4 	addi	r2,r2,-1
 2013138:	1440d836 	bltu	r2,r17,201349c <__udivdi3+0x514>
 201313c:	00800404 	movi	r2,16
 2013140:	8886d83a 	srl	r3,r17,r2
 2013144:	010080b4 	movhi	r4,514
 2013148:	213da644 	addi	r4,r4,-2407
 201314c:	20c7883a 	add	r3,r4,r3
 2013150:	18c00003 	ldbu	r3,0(r3)
 2013154:	1885883a 	add	r2,r3,r2
 2013158:	00c00804 	movi	r3,32
 201315c:	1887c83a 	sub	r3,r3,r2
 2013160:	18008f1e 	bne	r3,zero,20133a0 <__udivdi3+0x418>
 2013164:	882ad43a 	srli	r21,r17,16
 2013168:	8461c83a 	sub	r16,r16,r17
 201316c:	8d3fffcc 	andi	r20,r17,65535
 2013170:	00c00044 	movi	r3,1
 2013174:	8009883a 	mov	r4,r16
 2013178:	a80b883a 	mov	r5,r21
 201317c:	d8c00015 	stw	r3,0(sp)
 2013180:	200403c0 	call	200403c <__umodsi3>
 2013184:	8009883a 	mov	r4,r16
 2013188:	a80b883a 	mov	r5,r21
 201318c:	1027883a 	mov	r19,r2
 2013190:	2003fd80 	call	2003fd8 <__udivsi3>
 2013194:	9826943a 	slli	r19,r19,16
 2013198:	9008d43a 	srli	r4,r18,16
 201319c:	1521383a 	mul	r16,r2,r20
 20131a0:	102d883a 	mov	r22,r2
 20131a4:	24c8b03a 	or	r4,r4,r19
 20131a8:	d8c00017 	ldw	r3,0(sp)
 20131ac:	2400052e 	bgeu	r4,r16,20131c4 <__udivdi3+0x23c>
 20131b0:	2449883a 	add	r4,r4,r17
 20131b4:	b0bfffc4 	addi	r2,r22,-1
 20131b8:	24400136 	bltu	r4,r17,20131c0 <__udivdi3+0x238>
 20131bc:	2400ca36 	bltu	r4,r16,20134e8 <__udivdi3+0x560>
 20131c0:	102d883a 	mov	r22,r2
 20131c4:	2421c83a 	sub	r16,r4,r16
 20131c8:	a80b883a 	mov	r5,r21
 20131cc:	8009883a 	mov	r4,r16
 20131d0:	d8c00015 	stw	r3,0(sp)
 20131d4:	200403c0 	call	200403c <__umodsi3>
 20131d8:	1027883a 	mov	r19,r2
 20131dc:	a80b883a 	mov	r5,r21
 20131e0:	8009883a 	mov	r4,r16
 20131e4:	2003fd80 	call	2003fd8 <__udivsi3>
 20131e8:	9826943a 	slli	r19,r19,16
 20131ec:	1529383a 	mul	r20,r2,r20
 20131f0:	94bfffcc 	andi	r18,r18,65535
 20131f4:	94e4b03a 	or	r18,r18,r19
 20131f8:	d8c00017 	ldw	r3,0(sp)
 20131fc:	9500052e 	bgeu	r18,r20,2013214 <__udivdi3+0x28c>
 2013200:	8ca5883a 	add	r18,r17,r18
 2013204:	113fffc4 	addi	r4,r2,-1
 2013208:	94409736 	bltu	r18,r17,2013468 <__udivdi3+0x4e0>
 201320c:	9500962e 	bgeu	r18,r20,2013468 <__udivdi3+0x4e0>
 2013210:	10bfff84 	addi	r2,r2,-2
 2013214:	b00c943a 	slli	r6,r22,16
 2013218:	3084b03a 	or	r2,r6,r2
 201321c:	00000206 	br	2013228 <__udivdi3+0x2a0>
 2013220:	0007883a 	mov	r3,zero
 2013224:	0005883a 	mov	r2,zero
 2013228:	dfc00a17 	ldw	ra,40(sp)
 201322c:	df000917 	ldw	fp,36(sp)
 2013230:	ddc00817 	ldw	r23,32(sp)
 2013234:	dd800717 	ldw	r22,28(sp)
 2013238:	dd400617 	ldw	r21,24(sp)
 201323c:	dd000517 	ldw	r20,20(sp)
 2013240:	dcc00417 	ldw	r19,16(sp)
 2013244:	dc800317 	ldw	r18,12(sp)
 2013248:	dc400217 	ldw	r17,8(sp)
 201324c:	dc000117 	ldw	r16,4(sp)
 2013250:	dec00b04 	addi	sp,sp,44
 2013254:	f800283a 	ret
 2013258:	00803fc4 	movi	r2,255
 201325c:	11c5803a 	cmpltu	r2,r2,r7
 2013260:	100490fa 	slli	r2,r2,3
 2013264:	003f9e06 	br	20130e0 <__udivdi3+0x158>
 2013268:	00803fc4 	movi	r2,255
 201326c:	1445803a 	cmpltu	r2,r2,r17
 2013270:	100490fa 	slli	r2,r2,3
 2013274:	003fb206 	br	2013140 <__udivdi3+0x1b8>
 2013278:	00804034 	movhi	r2,256
 201327c:	10bfffc4 	addi	r2,r2,-1
 2013280:	11808836 	bltu	r2,r6,20134a4 <__udivdi3+0x51c>
 2013284:	00800404 	movi	r2,16
 2013288:	003f5606 	br	2012fe4 <__udivdi3+0x5c>
 201328c:	30aed83a 	srl	r23,r6,r2
 2013290:	3d4e983a 	sll	r7,r7,r21
 2013294:	80acd83a 	srl	r22,r16,r2
 2013298:	9884d83a 	srl	r2,r19,r2
 201329c:	3deeb03a 	or	r23,r7,r23
 20132a0:	b824d43a 	srli	r18,r23,16
 20132a4:	8560983a 	sll	r16,r16,r21
 20132a8:	b009883a 	mov	r4,r22
 20132ac:	900b883a 	mov	r5,r18
 20132b0:	3568983a 	sll	r20,r6,r21
 20132b4:	1420b03a 	or	r16,r2,r16
 20132b8:	200403c0 	call	200403c <__umodsi3>
 20132bc:	b009883a 	mov	r4,r22
 20132c0:	900b883a 	mov	r5,r18
 20132c4:	1023883a 	mov	r17,r2
 20132c8:	2003fd80 	call	2003fd8 <__udivsi3>
 20132cc:	8808943a 	slli	r4,r17,16
 20132d0:	bf3fffcc 	andi	fp,r23,65535
 20132d4:	8006d43a 	srli	r3,r16,16
 20132d8:	e0a3383a 	mul	r17,fp,r2
 20132dc:	100d883a 	mov	r6,r2
 20132e0:	1906b03a 	or	r3,r3,r4
 20132e4:	1c40042e 	bgeu	r3,r17,20132f8 <__udivdi3+0x370>
 20132e8:	1dc7883a 	add	r3,r3,r23
 20132ec:	10bfffc4 	addi	r2,r2,-1
 20132f0:	1dc0752e 	bgeu	r3,r23,20134c8 <__udivdi3+0x540>
 20132f4:	100d883a 	mov	r6,r2
 20132f8:	1c63c83a 	sub	r17,r3,r17
 20132fc:	900b883a 	mov	r5,r18
 2013300:	8809883a 	mov	r4,r17
 2013304:	d9800015 	stw	r6,0(sp)
 2013308:	200403c0 	call	200403c <__umodsi3>
 201330c:	102d883a 	mov	r22,r2
 2013310:	8809883a 	mov	r4,r17
 2013314:	900b883a 	mov	r5,r18
 2013318:	2003fd80 	call	2003fd8 <__udivsi3>
 201331c:	b02c943a 	slli	r22,r22,16
 2013320:	e089383a 	mul	r4,fp,r2
 2013324:	843fffcc 	andi	r16,r16,65535
 2013328:	85a0b03a 	or	r16,r16,r22
 201332c:	d9800017 	ldw	r6,0(sp)
 2013330:	8100042e 	bgeu	r16,r4,2013344 <__udivdi3+0x3bc>
 2013334:	85e1883a 	add	r16,r16,r23
 2013338:	10ffffc4 	addi	r3,r2,-1
 201333c:	85c05e2e 	bgeu	r16,r23,20134b8 <__udivdi3+0x530>
 2013340:	1805883a 	mov	r2,r3
 2013344:	300c943a 	slli	r6,r6,16
 2013348:	a17fffcc 	andi	r5,r20,65535
 201334c:	a028d43a 	srli	r20,r20,16
 2013350:	3084b03a 	or	r2,r6,r2
 2013354:	10ffffcc 	andi	r3,r2,65535
 2013358:	100cd43a 	srli	r6,r2,16
 201335c:	194f383a 	mul	r7,r3,r5
 2013360:	1d07383a 	mul	r3,r3,r20
 2013364:	314b383a 	mul	r5,r6,r5
 2013368:	3810d43a 	srli	r8,r7,16
 201336c:	8121c83a 	sub	r16,r16,r4
 2013370:	1947883a 	add	r3,r3,r5
 2013374:	40c7883a 	add	r3,r8,r3
 2013378:	350d383a 	mul	r6,r6,r20
 201337c:	1940022e 	bgeu	r3,r5,2013388 <__udivdi3+0x400>
 2013380:	01000074 	movhi	r4,1
 2013384:	310d883a 	add	r6,r6,r4
 2013388:	1828d43a 	srli	r20,r3,16
 201338c:	a18d883a 	add	r6,r20,r6
 2013390:	81803e36 	bltu	r16,r6,201348c <__udivdi3+0x504>
 2013394:	81803826 	beq	r16,r6,2013478 <__udivdi3+0x4f0>
 2013398:	0007883a 	mov	r3,zero
 201339c:	003fa206 	br	2013228 <__udivdi3+0x2a0>
 20133a0:	88e2983a 	sll	r17,r17,r3
 20133a4:	80a8d83a 	srl	r20,r16,r2
 20133a8:	80e0983a 	sll	r16,r16,r3
 20133ac:	882ad43a 	srli	r21,r17,16
 20133b0:	9884d83a 	srl	r2,r19,r2
 20133b4:	a009883a 	mov	r4,r20
 20133b8:	a80b883a 	mov	r5,r21
 20133bc:	142eb03a 	or	r23,r2,r16
 20133c0:	98e4983a 	sll	r18,r19,r3
 20133c4:	200403c0 	call	200403c <__umodsi3>
 20133c8:	a009883a 	mov	r4,r20
 20133cc:	a80b883a 	mov	r5,r21
 20133d0:	1021883a 	mov	r16,r2
 20133d4:	2003fd80 	call	2003fd8 <__udivsi3>
 20133d8:	1039883a 	mov	fp,r2
 20133dc:	8d3fffcc 	andi	r20,r17,65535
 20133e0:	8020943a 	slli	r16,r16,16
 20133e4:	b804d43a 	srli	r2,r23,16
 20133e8:	a72d383a 	mul	r22,r20,fp
 20133ec:	1404b03a 	or	r2,r2,r16
 20133f0:	1580062e 	bgeu	r2,r22,201340c <__udivdi3+0x484>
 20133f4:	1445883a 	add	r2,r2,r17
 20133f8:	e0ffffc4 	addi	r3,fp,-1
 20133fc:	14403836 	bltu	r2,r17,20134e0 <__udivdi3+0x558>
 2013400:	1580372e 	bgeu	r2,r22,20134e0 <__udivdi3+0x558>
 2013404:	e73fff84 	addi	fp,fp,-2
 2013408:	1445883a 	add	r2,r2,r17
 201340c:	15adc83a 	sub	r22,r2,r22
 2013410:	a80b883a 	mov	r5,r21
 2013414:	b009883a 	mov	r4,r22
 2013418:	200403c0 	call	200403c <__umodsi3>
 201341c:	1027883a 	mov	r19,r2
 2013420:	b009883a 	mov	r4,r22
 2013424:	a80b883a 	mov	r5,r21
 2013428:	2003fd80 	call	2003fd8 <__udivsi3>
 201342c:	9826943a 	slli	r19,r19,16
 2013430:	a0a1383a 	mul	r16,r20,r2
 2013434:	b93fffcc 	andi	r4,r23,65535
 2013438:	24c8b03a 	or	r4,r4,r19
 201343c:	2400062e 	bgeu	r4,r16,2013458 <__udivdi3+0x4d0>
 2013440:	2449883a 	add	r4,r4,r17
 2013444:	10ffffc4 	addi	r3,r2,-1
 2013448:	24402336 	bltu	r4,r17,20134d8 <__udivdi3+0x550>
 201344c:	2400222e 	bgeu	r4,r16,20134d8 <__udivdi3+0x550>
 2013450:	10bfff84 	addi	r2,r2,-2
 2013454:	2449883a 	add	r4,r4,r17
 2013458:	e038943a 	slli	fp,fp,16
 201345c:	2421c83a 	sub	r16,r4,r16
 2013460:	e086b03a 	or	r3,fp,r2
 2013464:	003f4306 	br	2013174 <__udivdi3+0x1ec>
 2013468:	2005883a 	mov	r2,r4
 201346c:	003f6906 	br	2013214 <__udivdi3+0x28c>
 2013470:	1805883a 	mov	r2,r3
 2013474:	003f0f06 	br	20130b4 <__udivdi3+0x12c>
 2013478:	1806943a 	slli	r3,r3,16
 201347c:	9d66983a 	sll	r19,r19,r21
 2013480:	39ffffcc 	andi	r7,r7,65535
 2013484:	19c7883a 	add	r3,r3,r7
 2013488:	98ffc32e 	bgeu	r19,r3,2013398 <__udivdi3+0x410>
 201348c:	10bfffc4 	addi	r2,r2,-1
 2013490:	003fc106 	br	2013398 <__udivdi3+0x410>
 2013494:	00800604 	movi	r2,24
 2013498:	003f1106 	br	20130e0 <__udivdi3+0x158>
 201349c:	00800604 	movi	r2,24
 20134a0:	003f2706 	br	2013140 <__udivdi3+0x1b8>
 20134a4:	00800604 	movi	r2,24
 20134a8:	003ece06 	br	2012fe4 <__udivdi3+0x5c>
 20134ac:	0007883a 	mov	r3,zero
 20134b0:	00800044 	movi	r2,1
 20134b4:	003f5c06 	br	2013228 <__udivdi3+0x2a0>
 20134b8:	813fa12e 	bgeu	r16,r4,2013340 <__udivdi3+0x3b8>
 20134bc:	10bfff84 	addi	r2,r2,-2
 20134c0:	85e1883a 	add	r16,r16,r23
 20134c4:	003f9f06 	br	2013344 <__udivdi3+0x3bc>
 20134c8:	1c7f8a2e 	bgeu	r3,r17,20132f4 <__udivdi3+0x36c>
 20134cc:	31bfff84 	addi	r6,r6,-2
 20134d0:	1dc7883a 	add	r3,r3,r23
 20134d4:	003f8806 	br	20132f8 <__udivdi3+0x370>
 20134d8:	1805883a 	mov	r2,r3
 20134dc:	003fde06 	br	2013458 <__udivdi3+0x4d0>
 20134e0:	1839883a 	mov	fp,r3
 20134e4:	003fc906 	br	201340c <__udivdi3+0x484>
 20134e8:	b5bfff84 	addi	r22,r22,-2
 20134ec:	2449883a 	add	r4,r4,r17
 20134f0:	003f3406 	br	20131c4 <__udivdi3+0x23c>
 20134f4:	b5bfff84 	addi	r22,r22,-2
 20134f8:	1445883a 	add	r2,r2,r17
 20134fc:	003edb06 	br	201306c <__udivdi3+0xe4>

02013500 <__umoddi3>:
 2013500:	defff404 	addi	sp,sp,-48
 2013504:	df000a15 	stw	fp,40(sp)
 2013508:	dc400315 	stw	r17,12(sp)
 201350c:	dc000215 	stw	r16,8(sp)
 2013510:	dfc00b15 	stw	ra,44(sp)
 2013514:	ddc00915 	stw	r23,36(sp)
 2013518:	dd800815 	stw	r22,32(sp)
 201351c:	dd400715 	stw	r21,28(sp)
 2013520:	dd000615 	stw	r20,24(sp)
 2013524:	dcc00515 	stw	r19,20(sp)
 2013528:	dc800415 	stw	r18,16(sp)
 201352c:	2021883a 	mov	r16,r4
 2013530:	2823883a 	mov	r17,r5
 2013534:	2839883a 	mov	fp,r5
 2013538:	38003c1e 	bne	r7,zero,201362c <__umoddi3+0x12c>
 201353c:	3027883a 	mov	r19,r6
 2013540:	2029883a 	mov	r20,r4
 2013544:	2980512e 	bgeu	r5,r6,201368c <__umoddi3+0x18c>
 2013548:	00bfffd4 	movui	r2,65535
 201354c:	11809a36 	bltu	r2,r6,20137b8 <__umoddi3+0x2b8>
 2013550:	01003fc4 	movi	r4,255
 2013554:	2189803a 	cmpltu	r4,r4,r6
 2013558:	200890fa 	slli	r4,r4,3
 201355c:	3104d83a 	srl	r2,r6,r4
 2013560:	00c080b4 	movhi	r3,514
 2013564:	18fda644 	addi	r3,r3,-2407
 2013568:	1885883a 	add	r2,r3,r2
 201356c:	10c00003 	ldbu	r3,0(r2)
 2013570:	00800804 	movi	r2,32
 2013574:	1909883a 	add	r4,r3,r4
 2013578:	1125c83a 	sub	r18,r2,r4
 201357c:	90000526 	beq	r18,zero,2013594 <__umoddi3+0x94>
 2013580:	8ca2983a 	sll	r17,r17,r18
 2013584:	8108d83a 	srl	r4,r16,r4
 2013588:	34a6983a 	sll	r19,r6,r18
 201358c:	84a8983a 	sll	r20,r16,r18
 2013590:	2478b03a 	or	fp,r4,r17
 2013594:	982ed43a 	srli	r23,r19,16
 2013598:	e009883a 	mov	r4,fp
 201359c:	9dbfffcc 	andi	r22,r19,65535
 20135a0:	b80b883a 	mov	r5,r23
 20135a4:	200403c0 	call	200403c <__umodsi3>
 20135a8:	e009883a 	mov	r4,fp
 20135ac:	b80b883a 	mov	r5,r23
 20135b0:	102b883a 	mov	r21,r2
 20135b4:	2003fd80 	call	2003fd8 <__udivsi3>
 20135b8:	a806943a 	slli	r3,r21,16
 20135bc:	a008d43a 	srli	r4,r20,16
 20135c0:	b085383a 	mul	r2,r22,r2
 20135c4:	20c8b03a 	or	r4,r4,r3
 20135c8:	2080032e 	bgeu	r4,r2,20135d8 <__umoddi3+0xd8>
 20135cc:	24c9883a 	add	r4,r4,r19
 20135d0:	24c00136 	bltu	r4,r19,20135d8 <__umoddi3+0xd8>
 20135d4:	20811036 	bltu	r4,r2,2013a18 <__umoddi3+0x518>
 20135d8:	20abc83a 	sub	r21,r4,r2
 20135dc:	b80b883a 	mov	r5,r23
 20135e0:	a809883a 	mov	r4,r21
 20135e4:	200403c0 	call	200403c <__umodsi3>
 20135e8:	1023883a 	mov	r17,r2
 20135ec:	b80b883a 	mov	r5,r23
 20135f0:	a809883a 	mov	r4,r21
 20135f4:	2003fd80 	call	2003fd8 <__udivsi3>
 20135f8:	8822943a 	slli	r17,r17,16
 20135fc:	b085383a 	mul	r2,r22,r2
 2013600:	a0ffffcc 	andi	r3,r20,65535
 2013604:	1c46b03a 	or	r3,r3,r17
 2013608:	1880042e 	bgeu	r3,r2,201361c <__umoddi3+0x11c>
 201360c:	1cc7883a 	add	r3,r3,r19
 2013610:	1cc00236 	bltu	r3,r19,201361c <__umoddi3+0x11c>
 2013614:	1880012e 	bgeu	r3,r2,201361c <__umoddi3+0x11c>
 2013618:	1cc7883a 	add	r3,r3,r19
 201361c:	1885c83a 	sub	r2,r3,r2
 2013620:	1484d83a 	srl	r2,r2,r18
 2013624:	0007883a 	mov	r3,zero
 2013628:	00004f06 	br	2013768 <__umoddi3+0x268>
 201362c:	29c04c36 	bltu	r5,r7,2013760 <__umoddi3+0x260>
 2013630:	00bfffd4 	movui	r2,65535
 2013634:	11c0582e 	bgeu	r2,r7,2013798 <__umoddi3+0x298>
 2013638:	00804034 	movhi	r2,256
 201363c:	10bfffc4 	addi	r2,r2,-1
 2013640:	11c0e736 	bltu	r2,r7,20139e0 <__umoddi3+0x4e0>
 2013644:	01000404 	movi	r4,16
 2013648:	3904d83a 	srl	r2,r7,r4
 201364c:	00c080b4 	movhi	r3,514
 2013650:	18fda644 	addi	r3,r3,-2407
 2013654:	1885883a 	add	r2,r3,r2
 2013658:	14c00003 	ldbu	r19,0(r2)
 201365c:	00c00804 	movi	r3,32
 2013660:	9927883a 	add	r19,r19,r4
 2013664:	1ce9c83a 	sub	r20,r3,r19
 2013668:	a000581e 	bne	r20,zero,20137cc <__umoddi3+0x2cc>
 201366c:	3c400136 	bltu	r7,r17,2013674 <__umoddi3+0x174>
 2013670:	8180eb36 	bltu	r16,r6,2013a20 <__umoddi3+0x520>
 2013674:	8185c83a 	sub	r2,r16,r6
 2013678:	89e3c83a 	sub	r17,r17,r7
 201367c:	8089803a 	cmpltu	r4,r16,r2
 2013680:	8939c83a 	sub	fp,r17,r4
 2013684:	e007883a 	mov	r3,fp
 2013688:	00003706 	br	2013768 <__umoddi3+0x268>
 201368c:	3000041e 	bne	r6,zero,20136a0 <__umoddi3+0x1a0>
 2013690:	000b883a 	mov	r5,zero
 2013694:	01000044 	movi	r4,1
 2013698:	2003fd80 	call	2003fd8 <__udivsi3>
 201369c:	1027883a 	mov	r19,r2
 20136a0:	00bfffd4 	movui	r2,65535
 20136a4:	14c0402e 	bgeu	r2,r19,20137a8 <__umoddi3+0x2a8>
 20136a8:	00804034 	movhi	r2,256
 20136ac:	10bfffc4 	addi	r2,r2,-1
 20136b0:	14c0cd36 	bltu	r2,r19,20139e8 <__umoddi3+0x4e8>
 20136b4:	00800404 	movi	r2,16
 20136b8:	9886d83a 	srl	r3,r19,r2
 20136bc:	010080b4 	movhi	r4,514
 20136c0:	213da644 	addi	r4,r4,-2407
 20136c4:	20c7883a 	add	r3,r4,r3
 20136c8:	18c00003 	ldbu	r3,0(r3)
 20136cc:	1887883a 	add	r3,r3,r2
 20136d0:	00800804 	movi	r2,32
 20136d4:	10e5c83a 	sub	r18,r2,r3
 20136d8:	9000901e 	bne	r18,zero,201391c <__umoddi3+0x41c>
 20136dc:	982cd43a 	srli	r22,r19,16
 20136e0:	8ce3c83a 	sub	r17,r17,r19
 20136e4:	9d7fffcc 	andi	r21,r19,65535
 20136e8:	b00b883a 	mov	r5,r22
 20136ec:	8809883a 	mov	r4,r17
 20136f0:	200403c0 	call	200403c <__umodsi3>
 20136f4:	8809883a 	mov	r4,r17
 20136f8:	b00b883a 	mov	r5,r22
 20136fc:	1021883a 	mov	r16,r2
 2013700:	2003fd80 	call	2003fd8 <__udivsi3>
 2013704:	8006943a 	slli	r3,r16,16
 2013708:	a008d43a 	srli	r4,r20,16
 201370c:	1545383a 	mul	r2,r2,r21
 2013710:	20c8b03a 	or	r4,r4,r3
 2013714:	2080042e 	bgeu	r4,r2,2013728 <__umoddi3+0x228>
 2013718:	24c9883a 	add	r4,r4,r19
 201371c:	24c00236 	bltu	r4,r19,2013728 <__umoddi3+0x228>
 2013720:	2080012e 	bgeu	r4,r2,2013728 <__umoddi3+0x228>
 2013724:	24c9883a 	add	r4,r4,r19
 2013728:	20a1c83a 	sub	r16,r4,r2
 201372c:	b00b883a 	mov	r5,r22
 2013730:	8009883a 	mov	r4,r16
 2013734:	200403c0 	call	200403c <__umodsi3>
 2013738:	1023883a 	mov	r17,r2
 201373c:	b00b883a 	mov	r5,r22
 2013740:	8009883a 	mov	r4,r16
 2013744:	2003fd80 	call	2003fd8 <__udivsi3>
 2013748:	8822943a 	slli	r17,r17,16
 201374c:	1545383a 	mul	r2,r2,r21
 2013750:	a53fffcc 	andi	r20,r20,65535
 2013754:	a446b03a 	or	r3,r20,r17
 2013758:	18bfb02e 	bgeu	r3,r2,201361c <__umoddi3+0x11c>
 201375c:	003fab06 	br	201360c <__umoddi3+0x10c>
 2013760:	2005883a 	mov	r2,r4
 2013764:	2807883a 	mov	r3,r5
 2013768:	dfc00b17 	ldw	ra,44(sp)
 201376c:	df000a17 	ldw	fp,40(sp)
 2013770:	ddc00917 	ldw	r23,36(sp)
 2013774:	dd800817 	ldw	r22,32(sp)
 2013778:	dd400717 	ldw	r21,28(sp)
 201377c:	dd000617 	ldw	r20,24(sp)
 2013780:	dcc00517 	ldw	r19,20(sp)
 2013784:	dc800417 	ldw	r18,16(sp)
 2013788:	dc400317 	ldw	r17,12(sp)
 201378c:	dc000217 	ldw	r16,8(sp)
 2013790:	dec00c04 	addi	sp,sp,48
 2013794:	f800283a 	ret
 2013798:	04c03fc4 	movi	r19,255
 201379c:	99c9803a 	cmpltu	r4,r19,r7
 20137a0:	200890fa 	slli	r4,r4,3
 20137a4:	003fa806 	br	2013648 <__umoddi3+0x148>
 20137a8:	00803fc4 	movi	r2,255
 20137ac:	14c5803a 	cmpltu	r2,r2,r19
 20137b0:	100490fa 	slli	r2,r2,3
 20137b4:	003fc006 	br	20136b8 <__umoddi3+0x1b8>
 20137b8:	00804034 	movhi	r2,256
 20137bc:	10bfffc4 	addi	r2,r2,-1
 20137c0:	11808b36 	bltu	r2,r6,20139f0 <__umoddi3+0x4f0>
 20137c4:	01000404 	movi	r4,16
 20137c8:	003f6406 	br	201355c <__umoddi3+0x5c>
 20137cc:	34c4d83a 	srl	r2,r6,r19
 20137d0:	3d0e983a 	sll	r7,r7,r20
 20137d4:	8cf8d83a 	srl	fp,r17,r19
 20137d8:	8d10983a 	sll	r8,r17,r20
 20137dc:	38aab03a 	or	r21,r7,r2
 20137e0:	a82cd43a 	srli	r22,r21,16
 20137e4:	84e2d83a 	srl	r17,r16,r19
 20137e8:	e009883a 	mov	r4,fp
 20137ec:	b00b883a 	mov	r5,r22
 20137f0:	8a22b03a 	or	r17,r17,r8
 20137f4:	3524983a 	sll	r18,r6,r20
 20137f8:	200403c0 	call	200403c <__umodsi3>
 20137fc:	e009883a 	mov	r4,fp
 2013800:	b00b883a 	mov	r5,r22
 2013804:	102f883a 	mov	r23,r2
 2013808:	2003fd80 	call	2003fd8 <__udivsi3>
 201380c:	100d883a 	mov	r6,r2
 2013810:	b808943a 	slli	r4,r23,16
 2013814:	aa3fffcc 	andi	r8,r21,65535
 2013818:	8804d43a 	srli	r2,r17,16
 201381c:	41af383a 	mul	r23,r8,r6
 2013820:	8520983a 	sll	r16,r16,r20
 2013824:	1104b03a 	or	r2,r2,r4
 2013828:	15c0042e 	bgeu	r2,r23,201383c <__umoddi3+0x33c>
 201382c:	1545883a 	add	r2,r2,r21
 2013830:	30ffffc4 	addi	r3,r6,-1
 2013834:	1540742e 	bgeu	r2,r21,2013a08 <__umoddi3+0x508>
 2013838:	180d883a 	mov	r6,r3
 201383c:	15efc83a 	sub	r23,r2,r23
 2013840:	b00b883a 	mov	r5,r22
 2013844:	b809883a 	mov	r4,r23
 2013848:	d9800115 	stw	r6,4(sp)
 201384c:	da000015 	stw	r8,0(sp)
 2013850:	200403c0 	call	200403c <__umodsi3>
 2013854:	b00b883a 	mov	r5,r22
 2013858:	b809883a 	mov	r4,r23
 201385c:	1039883a 	mov	fp,r2
 2013860:	2003fd80 	call	2003fd8 <__udivsi3>
 2013864:	da000017 	ldw	r8,0(sp)
 2013868:	e038943a 	slli	fp,fp,16
 201386c:	100b883a 	mov	r5,r2
 2013870:	4089383a 	mul	r4,r8,r2
 2013874:	8a3fffcc 	andi	r8,r17,65535
 2013878:	4710b03a 	or	r8,r8,fp
 201387c:	d9800117 	ldw	r6,4(sp)
 2013880:	4100042e 	bgeu	r8,r4,2013894 <__umoddi3+0x394>
 2013884:	4551883a 	add	r8,r8,r21
 2013888:	10bfffc4 	addi	r2,r2,-1
 201388c:	45405a2e 	bgeu	r8,r21,20139f8 <__umoddi3+0x4f8>
 2013890:	100b883a 	mov	r5,r2
 2013894:	300c943a 	slli	r6,r6,16
 2013898:	91ffffcc 	andi	r7,r18,65535
 201389c:	9004d43a 	srli	r2,r18,16
 20138a0:	314cb03a 	or	r6,r6,r5
 20138a4:	317fffcc 	andi	r5,r6,65535
 20138a8:	300cd43a 	srli	r6,r6,16
 20138ac:	29d3383a 	mul	r9,r5,r7
 20138b0:	288b383a 	mul	r5,r5,r2
 20138b4:	31cf383a 	mul	r7,r6,r7
 20138b8:	4806d43a 	srli	r3,r9,16
 20138bc:	4111c83a 	sub	r8,r8,r4
 20138c0:	29cb883a 	add	r5,r5,r7
 20138c4:	194b883a 	add	r5,r3,r5
 20138c8:	3085383a 	mul	r2,r6,r2
 20138cc:	29c0022e 	bgeu	r5,r7,20138d8 <__umoddi3+0x3d8>
 20138d0:	00c00074 	movhi	r3,1
 20138d4:	10c5883a 	add	r2,r2,r3
 20138d8:	2808d43a 	srli	r4,r5,16
 20138dc:	280a943a 	slli	r5,r5,16
 20138e0:	4a7fffcc 	andi	r9,r9,65535
 20138e4:	2085883a 	add	r2,r4,r2
 20138e8:	2a4b883a 	add	r5,r5,r9
 20138ec:	40803636 	bltu	r8,r2,20139c8 <__umoddi3+0x4c8>
 20138f0:	40804d26 	beq	r8,r2,2013a28 <__umoddi3+0x528>
 20138f4:	4089c83a 	sub	r4,r8,r2
 20138f8:	280f883a 	mov	r7,r5
 20138fc:	81cfc83a 	sub	r7,r16,r7
 2013900:	81c7803a 	cmpltu	r3,r16,r7
 2013904:	20c7c83a 	sub	r3,r4,r3
 2013908:	1cc4983a 	sll	r2,r3,r19
 201390c:	3d0ed83a 	srl	r7,r7,r20
 2013910:	1d06d83a 	srl	r3,r3,r20
 2013914:	11c4b03a 	or	r2,r2,r7
 2013918:	003f9306 	br	2013768 <__umoddi3+0x268>
 201391c:	9ca6983a 	sll	r19,r19,r18
 2013920:	88e8d83a 	srl	r20,r17,r3
 2013924:	80c4d83a 	srl	r2,r16,r3
 2013928:	982cd43a 	srli	r22,r19,16
 201392c:	8ca2983a 	sll	r17,r17,r18
 2013930:	a009883a 	mov	r4,r20
 2013934:	b00b883a 	mov	r5,r22
 2013938:	1478b03a 	or	fp,r2,r17
 201393c:	200403c0 	call	200403c <__umodsi3>
 2013940:	a009883a 	mov	r4,r20
 2013944:	b00b883a 	mov	r5,r22
 2013948:	1023883a 	mov	r17,r2
 201394c:	2003fd80 	call	2003fd8 <__udivsi3>
 2013950:	9d7fffcc 	andi	r21,r19,65535
 2013954:	880a943a 	slli	r5,r17,16
 2013958:	e008d43a 	srli	r4,fp,16
 201395c:	a885383a 	mul	r2,r21,r2
 2013960:	84a8983a 	sll	r20,r16,r18
 2013964:	2148b03a 	or	r4,r4,r5
 2013968:	2080042e 	bgeu	r4,r2,201397c <__umoddi3+0x47c>
 201396c:	24c9883a 	add	r4,r4,r19
 2013970:	24c00236 	bltu	r4,r19,201397c <__umoddi3+0x47c>
 2013974:	2080012e 	bgeu	r4,r2,201397c <__umoddi3+0x47c>
 2013978:	24c9883a 	add	r4,r4,r19
 201397c:	20a3c83a 	sub	r17,r4,r2
 2013980:	b00b883a 	mov	r5,r22
 2013984:	8809883a 	mov	r4,r17
 2013988:	200403c0 	call	200403c <__umodsi3>
 201398c:	102f883a 	mov	r23,r2
 2013990:	8809883a 	mov	r4,r17
 2013994:	b00b883a 	mov	r5,r22
 2013998:	2003fd80 	call	2003fd8 <__udivsi3>
 201399c:	b82e943a 	slli	r23,r23,16
 20139a0:	a885383a 	mul	r2,r21,r2
 20139a4:	e13fffcc 	andi	r4,fp,65535
 20139a8:	25c8b03a 	or	r4,r4,r23
 20139ac:	2080042e 	bgeu	r4,r2,20139c0 <__umoddi3+0x4c0>
 20139b0:	24c9883a 	add	r4,r4,r19
 20139b4:	24c00236 	bltu	r4,r19,20139c0 <__umoddi3+0x4c0>
 20139b8:	2080012e 	bgeu	r4,r2,20139c0 <__umoddi3+0x4c0>
 20139bc:	24c9883a 	add	r4,r4,r19
 20139c0:	20a3c83a 	sub	r17,r4,r2
 20139c4:	003f4806 	br	20136e8 <__umoddi3+0x1e8>
 20139c8:	2c8fc83a 	sub	r7,r5,r18
 20139cc:	1545c83a 	sub	r2,r2,r21
 20139d0:	29cb803a 	cmpltu	r5,r5,r7
 20139d4:	1145c83a 	sub	r2,r2,r5
 20139d8:	4089c83a 	sub	r4,r8,r2
 20139dc:	003fc706 	br	20138fc <__umoddi3+0x3fc>
 20139e0:	01000604 	movi	r4,24
 20139e4:	003f1806 	br	2013648 <__umoddi3+0x148>
 20139e8:	00800604 	movi	r2,24
 20139ec:	003f3206 	br	20136b8 <__umoddi3+0x1b8>
 20139f0:	01000604 	movi	r4,24
 20139f4:	003ed906 	br	201355c <__umoddi3+0x5c>
 20139f8:	413fa52e 	bgeu	r8,r4,2013890 <__umoddi3+0x390>
 20139fc:	297fff84 	addi	r5,r5,-2
 2013a00:	4551883a 	add	r8,r8,r21
 2013a04:	003fa306 	br	2013894 <__umoddi3+0x394>
 2013a08:	15ff8b2e 	bgeu	r2,r23,2013838 <__umoddi3+0x338>
 2013a0c:	31bfff84 	addi	r6,r6,-2
 2013a10:	1545883a 	add	r2,r2,r21
 2013a14:	003f8906 	br	201383c <__umoddi3+0x33c>
 2013a18:	24c9883a 	add	r4,r4,r19
 2013a1c:	003eee06 	br	20135d8 <__umoddi3+0xd8>
 2013a20:	8005883a 	mov	r2,r16
 2013a24:	003f1706 	br	2013684 <__umoddi3+0x184>
 2013a28:	817fe736 	bltu	r16,r5,20139c8 <__umoddi3+0x4c8>
 2013a2c:	280f883a 	mov	r7,r5
 2013a30:	0009883a 	mov	r4,zero
 2013a34:	003fb106 	br	20138fc <__umoddi3+0x3fc>

02013a38 <__fixdfsi>:
 2013a38:	280cd53a 	srli	r6,r5,20
 2013a3c:	00c00434 	movhi	r3,16
 2013a40:	18ffffc4 	addi	r3,r3,-1
 2013a44:	3181ffcc 	andi	r6,r6,2047
 2013a48:	01c0ff84 	movi	r7,1022
 2013a4c:	28c6703a 	and	r3,r5,r3
 2013a50:	280ad7fa 	srli	r5,r5,31
 2013a54:	3980120e 	bge	r7,r6,2013aa0 <__fixdfsi+0x68>
 2013a58:	00810744 	movi	r2,1053
 2013a5c:	11800c16 	blt	r2,r6,2013a90 <__fixdfsi+0x58>
 2013a60:	00810cc4 	movi	r2,1075
 2013a64:	1185c83a 	sub	r2,r2,r6
 2013a68:	01c007c4 	movi	r7,31
 2013a6c:	18c00434 	orhi	r3,r3,16
 2013a70:	38800d16 	blt	r7,r2,2013aa8 <__fixdfsi+0x70>
 2013a74:	31befb44 	addi	r6,r6,-1043
 2013a78:	2084d83a 	srl	r2,r4,r2
 2013a7c:	1986983a 	sll	r3,r3,r6
 2013a80:	1884b03a 	or	r2,r3,r2
 2013a84:	28000726 	beq	r5,zero,2013aa4 <__fixdfsi+0x6c>
 2013a88:	0085c83a 	sub	r2,zero,r2
 2013a8c:	f800283a 	ret
 2013a90:	00a00034 	movhi	r2,32768
 2013a94:	10bfffc4 	addi	r2,r2,-1
 2013a98:	2885883a 	add	r2,r5,r2
 2013a9c:	f800283a 	ret
 2013aa0:	0005883a 	mov	r2,zero
 2013aa4:	f800283a 	ret
 2013aa8:	008104c4 	movi	r2,1043
 2013aac:	1185c83a 	sub	r2,r2,r6
 2013ab0:	1884d83a 	srl	r2,r3,r2
 2013ab4:	003ff306 	br	2013a84 <__fixdfsi+0x4c>

02013ab8 <__floatsidf>:
 2013ab8:	defffd04 	addi	sp,sp,-12
 2013abc:	dfc00215 	stw	ra,8(sp)
 2013ac0:	dc400115 	stw	r17,4(sp)
 2013ac4:	dc000015 	stw	r16,0(sp)
 2013ac8:	20002b26 	beq	r4,zero,2013b78 <__floatsidf+0xc0>
 2013acc:	2023883a 	mov	r17,r4
 2013ad0:	2020d7fa 	srli	r16,r4,31
 2013ad4:	20002d16 	blt	r4,zero,2013b8c <__floatsidf+0xd4>
 2013ad8:	8809883a 	mov	r4,r17
 2013adc:	200674c0 	call	200674c <__clzsi2>
 2013ae0:	01410784 	movi	r5,1054
 2013ae4:	288bc83a 	sub	r5,r5,r2
 2013ae8:	01010cc4 	movi	r4,1075
 2013aec:	2149c83a 	sub	r4,r4,r5
 2013af0:	00c007c4 	movi	r3,31
 2013af4:	1900160e 	bge	r3,r4,2013b50 <__floatsidf+0x98>
 2013af8:	00c104c4 	movi	r3,1043
 2013afc:	1947c83a 	sub	r3,r3,r5
 2013b00:	88c6983a 	sll	r3,r17,r3
 2013b04:	00800434 	movhi	r2,16
 2013b08:	10bfffc4 	addi	r2,r2,-1
 2013b0c:	1886703a 	and	r3,r3,r2
 2013b10:	2941ffcc 	andi	r5,r5,2047
 2013b14:	800d883a 	mov	r6,r16
 2013b18:	0005883a 	mov	r2,zero
 2013b1c:	280a953a 	slli	r5,r5,20
 2013b20:	31803fcc 	andi	r6,r6,255
 2013b24:	01000434 	movhi	r4,16
 2013b28:	300c97fa 	slli	r6,r6,31
 2013b2c:	213fffc4 	addi	r4,r4,-1
 2013b30:	1906703a 	and	r3,r3,r4
 2013b34:	1946b03a 	or	r3,r3,r5
 2013b38:	1986b03a 	or	r3,r3,r6
 2013b3c:	dfc00217 	ldw	ra,8(sp)
 2013b40:	dc400117 	ldw	r17,4(sp)
 2013b44:	dc000017 	ldw	r16,0(sp)
 2013b48:	dec00304 	addi	sp,sp,12
 2013b4c:	f800283a 	ret
 2013b50:	00c002c4 	movi	r3,11
 2013b54:	1887c83a 	sub	r3,r3,r2
 2013b58:	88c6d83a 	srl	r3,r17,r3
 2013b5c:	8904983a 	sll	r2,r17,r4
 2013b60:	01000434 	movhi	r4,16
 2013b64:	213fffc4 	addi	r4,r4,-1
 2013b68:	2941ffcc 	andi	r5,r5,2047
 2013b6c:	1906703a 	and	r3,r3,r4
 2013b70:	800d883a 	mov	r6,r16
 2013b74:	003fe906 	br	2013b1c <__floatsidf+0x64>
 2013b78:	000d883a 	mov	r6,zero
 2013b7c:	000b883a 	mov	r5,zero
 2013b80:	0007883a 	mov	r3,zero
 2013b84:	0005883a 	mov	r2,zero
 2013b88:	003fe406 	br	2013b1c <__floatsidf+0x64>
 2013b8c:	0123c83a 	sub	r17,zero,r4
 2013b90:	003fd106 	br	2013ad8 <__floatsidf+0x20>

02013b94 <__floatunsidf>:
 2013b94:	defffe04 	addi	sp,sp,-8
 2013b98:	dc000015 	stw	r16,0(sp)
 2013b9c:	dfc00115 	stw	ra,4(sp)
 2013ba0:	2021883a 	mov	r16,r4
 2013ba4:	20002226 	beq	r4,zero,2013c30 <__floatunsidf+0x9c>
 2013ba8:	200674c0 	call	200674c <__clzsi2>
 2013bac:	01010784 	movi	r4,1054
 2013bb0:	2089c83a 	sub	r4,r4,r2
 2013bb4:	01810cc4 	movi	r6,1075
 2013bb8:	310dc83a 	sub	r6,r6,r4
 2013bbc:	00c007c4 	movi	r3,31
 2013bc0:	1980120e 	bge	r3,r6,2013c0c <__floatunsidf+0x78>
 2013bc4:	00c104c4 	movi	r3,1043
 2013bc8:	1907c83a 	sub	r3,r3,r4
 2013bcc:	80ca983a 	sll	r5,r16,r3
 2013bd0:	00800434 	movhi	r2,16
 2013bd4:	10bfffc4 	addi	r2,r2,-1
 2013bd8:	2101ffcc 	andi	r4,r4,2047
 2013bdc:	0021883a 	mov	r16,zero
 2013be0:	288a703a 	and	r5,r5,r2
 2013be4:	2008953a 	slli	r4,r4,20
 2013be8:	00c00434 	movhi	r3,16
 2013bec:	18ffffc4 	addi	r3,r3,-1
 2013bf0:	28c6703a 	and	r3,r5,r3
 2013bf4:	8005883a 	mov	r2,r16
 2013bf8:	1906b03a 	or	r3,r3,r4
 2013bfc:	dfc00117 	ldw	ra,4(sp)
 2013c00:	dc000017 	ldw	r16,0(sp)
 2013c04:	dec00204 	addi	sp,sp,8
 2013c08:	f800283a 	ret
 2013c0c:	00c002c4 	movi	r3,11
 2013c10:	188bc83a 	sub	r5,r3,r2
 2013c14:	814ad83a 	srl	r5,r16,r5
 2013c18:	00c00434 	movhi	r3,16
 2013c1c:	18ffffc4 	addi	r3,r3,-1
 2013c20:	81a0983a 	sll	r16,r16,r6
 2013c24:	2101ffcc 	andi	r4,r4,2047
 2013c28:	28ca703a 	and	r5,r5,r3
 2013c2c:	003fed06 	br	2013be4 <__floatunsidf+0x50>
 2013c30:	0009883a 	mov	r4,zero
 2013c34:	000b883a 	mov	r5,zero
 2013c38:	003fea06 	br	2013be4 <__floatunsidf+0x50>

02013c3c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2013c3c:	defffe04 	addi	sp,sp,-8
 2013c40:	dfc00115 	stw	ra,4(sp)
 2013c44:	df000015 	stw	fp,0(sp)
 2013c48:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2013c4c:	d0a01117 	ldw	r2,-32700(gp)
 2013c50:	10000326 	beq	r2,zero,2013c60 <alt_get_errno+0x24>
 2013c54:	d0a01117 	ldw	r2,-32700(gp)
 2013c58:	103ee83a 	callr	r2
 2013c5c:	00000106 	br	2013c64 <alt_get_errno+0x28>
 2013c60:	d0a74604 	addi	r2,gp,-25320
}
 2013c64:	e037883a 	mov	sp,fp
 2013c68:	dfc00117 	ldw	ra,4(sp)
 2013c6c:	df000017 	ldw	fp,0(sp)
 2013c70:	dec00204 	addi	sp,sp,8
 2013c74:	f800283a 	ret

02013c78 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 2013c78:	defffb04 	addi	sp,sp,-20
 2013c7c:	dfc00415 	stw	ra,16(sp)
 2013c80:	df000315 	stw	fp,12(sp)
 2013c84:	df000304 	addi	fp,sp,12
 2013c88:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 2013c8c:	e0bfff17 	ldw	r2,-4(fp)
 2013c90:	10000616 	blt	r2,zero,2013cac <close+0x34>
 2013c94:	e0bfff17 	ldw	r2,-4(fp)
 2013c98:	10c00324 	muli	r3,r2,12
 2013c9c:	008080b4 	movhi	r2,514
 2013ca0:	10811104 	addi	r2,r2,1092
 2013ca4:	1885883a 	add	r2,r3,r2
 2013ca8:	00000106 	br	2013cb0 <close+0x38>
 2013cac:	0005883a 	mov	r2,zero
 2013cb0:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 2013cb4:	e0bffd17 	ldw	r2,-12(fp)
 2013cb8:	10001926 	beq	r2,zero,2013d20 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 2013cbc:	e0bffd17 	ldw	r2,-12(fp)
 2013cc0:	10800017 	ldw	r2,0(r2)
 2013cc4:	10800417 	ldw	r2,16(r2)
 2013cc8:	10000626 	beq	r2,zero,2013ce4 <close+0x6c>
 2013ccc:	e0bffd17 	ldw	r2,-12(fp)
 2013cd0:	10800017 	ldw	r2,0(r2)
 2013cd4:	10800417 	ldw	r2,16(r2)
 2013cd8:	e13ffd17 	ldw	r4,-12(fp)
 2013cdc:	103ee83a 	callr	r2
 2013ce0:	00000106 	br	2013ce8 <close+0x70>
 2013ce4:	0005883a 	mov	r2,zero
 2013ce8:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 2013cec:	e13fff17 	ldw	r4,-4(fp)
 2013cf0:	20143300 	call	2014330 <alt_release_fd>
    if (rval < 0)
 2013cf4:	e0bffe17 	ldw	r2,-8(fp)
 2013cf8:	1000070e 	bge	r2,zero,2013d18 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 2013cfc:	2013c3c0 	call	2013c3c <alt_get_errno>
 2013d00:	1007883a 	mov	r3,r2
 2013d04:	e0bffe17 	ldw	r2,-8(fp)
 2013d08:	0085c83a 	sub	r2,zero,r2
 2013d0c:	18800015 	stw	r2,0(r3)
      return -1;
 2013d10:	00bfffc4 	movi	r2,-1
 2013d14:	00000706 	br	2013d34 <close+0xbc>
    }
    return 0;
 2013d18:	0005883a 	mov	r2,zero
 2013d1c:	00000506 	br	2013d34 <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2013d20:	2013c3c0 	call	2013c3c <alt_get_errno>
 2013d24:	1007883a 	mov	r3,r2
 2013d28:	00801444 	movi	r2,81
 2013d2c:	18800015 	stw	r2,0(r3)
    return -1;
 2013d30:	00bfffc4 	movi	r2,-1
  }
}
 2013d34:	e037883a 	mov	sp,fp
 2013d38:	dfc00117 	ldw	ra,4(sp)
 2013d3c:	df000017 	ldw	fp,0(sp)
 2013d40:	dec00204 	addi	sp,sp,8
 2013d44:	f800283a 	ret

02013d48 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 2013d48:	defffc04 	addi	sp,sp,-16
 2013d4c:	df000315 	stw	fp,12(sp)
 2013d50:	df000304 	addi	fp,sp,12
 2013d54:	e13ffd15 	stw	r4,-12(fp)
 2013d58:	e17ffe15 	stw	r5,-8(fp)
 2013d5c:	e1bfff15 	stw	r6,-4(fp)
  return len;
 2013d60:	e0bfff17 	ldw	r2,-4(fp)
}
 2013d64:	e037883a 	mov	sp,fp
 2013d68:	df000017 	ldw	fp,0(sp)
 2013d6c:	dec00104 	addi	sp,sp,4
 2013d70:	f800283a 	ret

02013d74 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2013d74:	defffe04 	addi	sp,sp,-8
 2013d78:	dfc00115 	stw	ra,4(sp)
 2013d7c:	df000015 	stw	fp,0(sp)
 2013d80:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2013d84:	d0a01117 	ldw	r2,-32700(gp)
 2013d88:	10000326 	beq	r2,zero,2013d98 <alt_get_errno+0x24>
 2013d8c:	d0a01117 	ldw	r2,-32700(gp)
 2013d90:	103ee83a 	callr	r2
 2013d94:	00000106 	br	2013d9c <alt_get_errno+0x28>
 2013d98:	d0a74604 	addi	r2,gp,-25320
}
 2013d9c:	e037883a 	mov	sp,fp
 2013da0:	dfc00117 	ldw	ra,4(sp)
 2013da4:	df000017 	ldw	fp,0(sp)
 2013da8:	dec00204 	addi	sp,sp,8
 2013dac:	f800283a 	ret

02013db0 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 2013db0:	defffb04 	addi	sp,sp,-20
 2013db4:	dfc00415 	stw	ra,16(sp)
 2013db8:	df000315 	stw	fp,12(sp)
 2013dbc:	df000304 	addi	fp,sp,12
 2013dc0:	e13ffe15 	stw	r4,-8(fp)
 2013dc4:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2013dc8:	e0bffe17 	ldw	r2,-8(fp)
 2013dcc:	10000616 	blt	r2,zero,2013de8 <fstat+0x38>
 2013dd0:	e0bffe17 	ldw	r2,-8(fp)
 2013dd4:	10c00324 	muli	r3,r2,12
 2013dd8:	008080b4 	movhi	r2,514
 2013ddc:	10811104 	addi	r2,r2,1092
 2013de0:	1885883a 	add	r2,r3,r2
 2013de4:	00000106 	br	2013dec <fstat+0x3c>
 2013de8:	0005883a 	mov	r2,zero
 2013dec:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 2013df0:	e0bffd17 	ldw	r2,-12(fp)
 2013df4:	10001026 	beq	r2,zero,2013e38 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 2013df8:	e0bffd17 	ldw	r2,-12(fp)
 2013dfc:	10800017 	ldw	r2,0(r2)
 2013e00:	10800817 	ldw	r2,32(r2)
 2013e04:	10000726 	beq	r2,zero,2013e24 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 2013e08:	e0bffd17 	ldw	r2,-12(fp)
 2013e0c:	10800017 	ldw	r2,0(r2)
 2013e10:	10800817 	ldw	r2,32(r2)
 2013e14:	e17fff17 	ldw	r5,-4(fp)
 2013e18:	e13ffd17 	ldw	r4,-12(fp)
 2013e1c:	103ee83a 	callr	r2
 2013e20:	00000a06 	br	2013e4c <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 2013e24:	e0bfff17 	ldw	r2,-4(fp)
 2013e28:	00c80004 	movi	r3,8192
 2013e2c:	10c00115 	stw	r3,4(r2)
      return 0;
 2013e30:	0005883a 	mov	r2,zero
 2013e34:	00000506 	br	2013e4c <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2013e38:	2013d740 	call	2013d74 <alt_get_errno>
 2013e3c:	1007883a 	mov	r3,r2
 2013e40:	00801444 	movi	r2,81
 2013e44:	18800015 	stw	r2,0(r3)
    return -1;
 2013e48:	00bfffc4 	movi	r2,-1
  }
}
 2013e4c:	e037883a 	mov	sp,fp
 2013e50:	dfc00117 	ldw	ra,4(sp)
 2013e54:	df000017 	ldw	fp,0(sp)
 2013e58:	dec00204 	addi	sp,sp,8
 2013e5c:	f800283a 	ret

02013e60 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2013e60:	defffe04 	addi	sp,sp,-8
 2013e64:	dfc00115 	stw	ra,4(sp)
 2013e68:	df000015 	stw	fp,0(sp)
 2013e6c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2013e70:	d0a01117 	ldw	r2,-32700(gp)
 2013e74:	10000326 	beq	r2,zero,2013e84 <alt_get_errno+0x24>
 2013e78:	d0a01117 	ldw	r2,-32700(gp)
 2013e7c:	103ee83a 	callr	r2
 2013e80:	00000106 	br	2013e88 <alt_get_errno+0x28>
 2013e84:	d0a74604 	addi	r2,gp,-25320
}
 2013e88:	e037883a 	mov	sp,fp
 2013e8c:	dfc00117 	ldw	ra,4(sp)
 2013e90:	df000017 	ldw	fp,0(sp)
 2013e94:	dec00204 	addi	sp,sp,8
 2013e98:	f800283a 	ret

02013e9c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 2013e9c:	deffed04 	addi	sp,sp,-76
 2013ea0:	dfc01215 	stw	ra,72(sp)
 2013ea4:	df001115 	stw	fp,68(sp)
 2013ea8:	df001104 	addi	fp,sp,68
 2013eac:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2013eb0:	e0bfff17 	ldw	r2,-4(fp)
 2013eb4:	10000616 	blt	r2,zero,2013ed0 <isatty+0x34>
 2013eb8:	e0bfff17 	ldw	r2,-4(fp)
 2013ebc:	10c00324 	muli	r3,r2,12
 2013ec0:	008080b4 	movhi	r2,514
 2013ec4:	10811104 	addi	r2,r2,1092
 2013ec8:	1885883a 	add	r2,r3,r2
 2013ecc:	00000106 	br	2013ed4 <isatty+0x38>
 2013ed0:	0005883a 	mov	r2,zero
 2013ed4:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 2013ed8:	e0bfef17 	ldw	r2,-68(fp)
 2013edc:	10000e26 	beq	r2,zero,2013f18 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 2013ee0:	e0bfef17 	ldw	r2,-68(fp)
 2013ee4:	10800017 	ldw	r2,0(r2)
 2013ee8:	10800817 	ldw	r2,32(r2)
 2013eec:	1000021e 	bne	r2,zero,2013ef8 <isatty+0x5c>
    {
      return 1;
 2013ef0:	00800044 	movi	r2,1
 2013ef4:	00000d06 	br	2013f2c <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 2013ef8:	e0bff004 	addi	r2,fp,-64
 2013efc:	100b883a 	mov	r5,r2
 2013f00:	e13fff17 	ldw	r4,-4(fp)
 2013f04:	2013db00 	call	2013db0 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 2013f08:	e0bff117 	ldw	r2,-60(fp)
 2013f0c:	10880020 	cmpeqi	r2,r2,8192
 2013f10:	10803fcc 	andi	r2,r2,255
 2013f14:	00000506 	br	2013f2c <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2013f18:	2013e600 	call	2013e60 <alt_get_errno>
 2013f1c:	1007883a 	mov	r3,r2
 2013f20:	00801444 	movi	r2,81
 2013f24:	18800015 	stw	r2,0(r3)
    return 0;
 2013f28:	0005883a 	mov	r2,zero
  }
}
 2013f2c:	e037883a 	mov	sp,fp
 2013f30:	dfc00117 	ldw	ra,4(sp)
 2013f34:	df000017 	ldw	fp,0(sp)
 2013f38:	dec00204 	addi	sp,sp,8
 2013f3c:	f800283a 	ret

02013f40 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 2013f40:	defffc04 	addi	sp,sp,-16
 2013f44:	df000315 	stw	fp,12(sp)
 2013f48:	df000304 	addi	fp,sp,12
 2013f4c:	e13ffd15 	stw	r4,-12(fp)
 2013f50:	e17ffe15 	stw	r5,-8(fp)
 2013f54:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 2013f58:	e0fffe17 	ldw	r3,-8(fp)
 2013f5c:	e0bffd17 	ldw	r2,-12(fp)
 2013f60:	18800c26 	beq	r3,r2,2013f94 <alt_load_section+0x54>
  {
    while( to != end )
 2013f64:	00000806 	br	2013f88 <alt_load_section+0x48>
    {
      *to++ = *from++;
 2013f68:	e0bffe17 	ldw	r2,-8(fp)
 2013f6c:	10c00104 	addi	r3,r2,4
 2013f70:	e0fffe15 	stw	r3,-8(fp)
 2013f74:	e0fffd17 	ldw	r3,-12(fp)
 2013f78:	19000104 	addi	r4,r3,4
 2013f7c:	e13ffd15 	stw	r4,-12(fp)
 2013f80:	18c00017 	ldw	r3,0(r3)
 2013f84:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 2013f88:	e0fffe17 	ldw	r3,-8(fp)
 2013f8c:	e0bfff17 	ldw	r2,-4(fp)
 2013f90:	18bff51e 	bne	r3,r2,2013f68 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
 2013f94:	0001883a 	nop
 2013f98:	e037883a 	mov	sp,fp
 2013f9c:	df000017 	ldw	fp,0(sp)
 2013fa0:	dec00104 	addi	sp,sp,4
 2013fa4:	f800283a 	ret

02013fa8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 2013fa8:	defffe04 	addi	sp,sp,-8
 2013fac:	dfc00115 	stw	ra,4(sp)
 2013fb0:	df000015 	stw	fp,0(sp)
 2013fb4:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 2013fb8:	018080b4 	movhi	r6,514
 2013fbc:	3185cc04 	addi	r6,r6,5936
 2013fc0:	014080b4 	movhi	r5,514
 2013fc4:	297ed204 	addi	r5,r5,-1208
 2013fc8:	010080b4 	movhi	r4,514
 2013fcc:	2105cc04 	addi	r4,r4,5936
 2013fd0:	2013f400 	call	2013f40 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 2013fd4:	01808034 	movhi	r6,512
 2013fd8:	31809204 	addi	r6,r6,584
 2013fdc:	01408034 	movhi	r5,512
 2013fe0:	29400804 	addi	r5,r5,32
 2013fe4:	01008034 	movhi	r4,512
 2013fe8:	21000804 	addi	r4,r4,32
 2013fec:	2013f400 	call	2013f40 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 2013ff0:	018080b4 	movhi	r6,514
 2013ff4:	31bed204 	addi	r6,r6,-1208
 2013ff8:	014080b4 	movhi	r5,514
 2013ffc:	297d0504 	addi	r5,r5,-3052
 2014000:	010080b4 	movhi	r4,514
 2014004:	213d0504 	addi	r4,r4,-3052
 2014008:	2013f400 	call	2013f40 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 201400c:	201dedc0 	call	201dedc <alt_dcache_flush_all>
  alt_icache_flush_all();
 2014010:	201e1540 	call	201e154 <alt_icache_flush_all>
}
 2014014:	0001883a 	nop
 2014018:	e037883a 	mov	sp,fp
 201401c:	dfc00117 	ldw	ra,4(sp)
 2014020:	df000017 	ldw	fp,0(sp)
 2014024:	dec00204 	addi	sp,sp,8
 2014028:	f800283a 	ret

0201402c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 201402c:	defffe04 	addi	sp,sp,-8
 2014030:	dfc00115 	stw	ra,4(sp)
 2014034:	df000015 	stw	fp,0(sp)
 2014038:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 201403c:	d0a01117 	ldw	r2,-32700(gp)
 2014040:	10000326 	beq	r2,zero,2014050 <alt_get_errno+0x24>
 2014044:	d0a01117 	ldw	r2,-32700(gp)
 2014048:	103ee83a 	callr	r2
 201404c:	00000106 	br	2014054 <alt_get_errno+0x28>
 2014050:	d0a74604 	addi	r2,gp,-25320
}
 2014054:	e037883a 	mov	sp,fp
 2014058:	dfc00117 	ldw	ra,4(sp)
 201405c:	df000017 	ldw	fp,0(sp)
 2014060:	dec00204 	addi	sp,sp,8
 2014064:	f800283a 	ret

02014068 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 2014068:	defff904 	addi	sp,sp,-28
 201406c:	dfc00615 	stw	ra,24(sp)
 2014070:	df000515 	stw	fp,20(sp)
 2014074:	df000504 	addi	fp,sp,20
 2014078:	e13ffd15 	stw	r4,-12(fp)
 201407c:	e17ffe15 	stw	r5,-8(fp)
 2014080:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 2014084:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2014088:	e0bffd17 	ldw	r2,-12(fp)
 201408c:	10000616 	blt	r2,zero,20140a8 <lseek+0x40>
 2014090:	e0bffd17 	ldw	r2,-12(fp)
 2014094:	10c00324 	muli	r3,r2,12
 2014098:	008080b4 	movhi	r2,514
 201409c:	10811104 	addi	r2,r2,1092
 20140a0:	1885883a 	add	r2,r3,r2
 20140a4:	00000106 	br	20140ac <lseek+0x44>
 20140a8:	0005883a 	mov	r2,zero
 20140ac:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 20140b0:	e0bffc17 	ldw	r2,-16(fp)
 20140b4:	10001026 	beq	r2,zero,20140f8 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 20140b8:	e0bffc17 	ldw	r2,-16(fp)
 20140bc:	10800017 	ldw	r2,0(r2)
 20140c0:	10800717 	ldw	r2,28(r2)
 20140c4:	10000926 	beq	r2,zero,20140ec <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 20140c8:	e0bffc17 	ldw	r2,-16(fp)
 20140cc:	10800017 	ldw	r2,0(r2)
 20140d0:	10800717 	ldw	r2,28(r2)
 20140d4:	e1bfff17 	ldw	r6,-4(fp)
 20140d8:	e17ffe17 	ldw	r5,-8(fp)
 20140dc:	e13ffc17 	ldw	r4,-16(fp)
 20140e0:	103ee83a 	callr	r2
 20140e4:	e0bffb15 	stw	r2,-20(fp)
 20140e8:	00000506 	br	2014100 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 20140ec:	00bfde84 	movi	r2,-134
 20140f0:	e0bffb15 	stw	r2,-20(fp)
 20140f4:	00000206 	br	2014100 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 20140f8:	00bfebc4 	movi	r2,-81
 20140fc:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 2014100:	e0bffb17 	ldw	r2,-20(fp)
 2014104:	1000070e 	bge	r2,zero,2014124 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 2014108:	201402c0 	call	201402c <alt_get_errno>
 201410c:	1007883a 	mov	r3,r2
 2014110:	e0bffb17 	ldw	r2,-20(fp)
 2014114:	0085c83a 	sub	r2,zero,r2
 2014118:	18800015 	stw	r2,0(r3)
    rc = -1;
 201411c:	00bfffc4 	movi	r2,-1
 2014120:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 2014124:	e0bffb17 	ldw	r2,-20(fp)
}
 2014128:	e037883a 	mov	sp,fp
 201412c:	dfc00117 	ldw	ra,4(sp)
 2014130:	df000017 	ldw	fp,0(sp)
 2014134:	dec00204 	addi	sp,sp,8
 2014138:	f800283a 	ret

0201413c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 201413c:	defff904 	addi	sp,sp,-28
 2014140:	dfc00615 	stw	ra,24(sp)
 2014144:	df000515 	stw	fp,20(sp)
 2014148:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 201414c:	0009883a 	mov	r4,zero
 2014150:	201cb480 	call	201cb48 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 2014154:	20150f80 	call	20150f8 <OSInit>
 2014158:	01000044 	movi	r4,1
 201415c:	201a5100 	call	201a510 <OSSemCreate>
 2014160:	d0a74c15 	stw	r2,-25296(gp)
 2014164:	01000044 	movi	r4,1
 2014168:	201a5100 	call	201a510 <OSSemCreate>
 201416c:	d0a74e15 	stw	r2,-25288(gp)
 2014170:	d0a74704 	addi	r2,gp,-25316
 2014174:	e0bffc15 	stw	r2,-16(fp)
 2014178:	00800044 	movi	r2,1
 201417c:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 2014180:	e0bffd0b 	ldhu	r2,-12(fp)
 2014184:	1009883a 	mov	r4,r2
 2014188:	201a5100 	call	201a510 <OSSemCreate>
 201418c:	1007883a 	mov	r3,r2
 2014190:	e0bffc17 	ldw	r2,-16(fp)
 2014194:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 2014198:	201cb800 	call	201cb80 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 201419c:	018080b4 	movhi	r6,514
 20141a0:	31be7a04 	addi	r6,r6,-1560
 20141a4:	014080b4 	movhi	r5,514
 20141a8:	297e7a04 	addi	r5,r5,-1560
 20141ac:	010080b4 	movhi	r4,514
 20141b0:	213e7a04 	addi	r4,r4,-1560
 20141b4:	201e24c0 	call	201e24c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 20141b8:	201e0040 	call	201e004 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 20141bc:	010080b4 	movhi	r4,514
 20141c0:	21381904 	addi	r4,r4,-8092
 20141c4:	201eecc0 	call	201eecc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 20141c8:	d0a74817 	ldw	r2,-25312(gp)
 20141cc:	d0e74917 	ldw	r3,-25308(gp)
 20141d0:	d1274a17 	ldw	r4,-25304(gp)
 20141d4:	200d883a 	mov	r6,r4
 20141d8:	180b883a 	mov	r5,r3
 20141dc:	1009883a 	mov	r4,r2
 20141e0:	20028ec0 	call	20028ec <main>
 20141e4:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 20141e8:	01000044 	movi	r4,1
 20141ec:	2013c780 	call	2013c78 <close>
  exit (result);
 20141f0:	e13ffb17 	ldw	r4,-20(fp)
 20141f4:	201ef080 	call	201ef08 <exit>

020141f8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20141f8:	defffe04 	addi	sp,sp,-8
 20141fc:	dfc00115 	stw	ra,4(sp)
 2014200:	df000015 	stw	fp,0(sp)
 2014204:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2014208:	d0a01117 	ldw	r2,-32700(gp)
 201420c:	10000326 	beq	r2,zero,201421c <alt_get_errno+0x24>
 2014210:	d0a01117 	ldw	r2,-32700(gp)
 2014214:	103ee83a 	callr	r2
 2014218:	00000106 	br	2014220 <alt_get_errno+0x28>
 201421c:	d0a74604 	addi	r2,gp,-25320
}
 2014220:	e037883a 	mov	sp,fp
 2014224:	dfc00117 	ldw	ra,4(sp)
 2014228:	df000017 	ldw	fp,0(sp)
 201422c:	dec00204 	addi	sp,sp,8
 2014230:	f800283a 	ret

02014234 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 2014234:	defff904 	addi	sp,sp,-28
 2014238:	dfc00615 	stw	ra,24(sp)
 201423c:	df000515 	stw	fp,20(sp)
 2014240:	df000504 	addi	fp,sp,20
 2014244:	e13ffd15 	stw	r4,-12(fp)
 2014248:	e17ffe15 	stw	r5,-8(fp)
 201424c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2014250:	e0bffd17 	ldw	r2,-12(fp)
 2014254:	10000616 	blt	r2,zero,2014270 <read+0x3c>
 2014258:	e0bffd17 	ldw	r2,-12(fp)
 201425c:	10c00324 	muli	r3,r2,12
 2014260:	008080b4 	movhi	r2,514
 2014264:	10811104 	addi	r2,r2,1092
 2014268:	1885883a 	add	r2,r3,r2
 201426c:	00000106 	br	2014274 <read+0x40>
 2014270:	0005883a 	mov	r2,zero
 2014274:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 2014278:	e0bffb17 	ldw	r2,-20(fp)
 201427c:	10002226 	beq	r2,zero,2014308 <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 2014280:	e0bffb17 	ldw	r2,-20(fp)
 2014284:	10800217 	ldw	r2,8(r2)
 2014288:	108000cc 	andi	r2,r2,3
 201428c:	10800060 	cmpeqi	r2,r2,1
 2014290:	1000181e 	bne	r2,zero,20142f4 <read+0xc0>
        (fd->dev->read))
 2014294:	e0bffb17 	ldw	r2,-20(fp)
 2014298:	10800017 	ldw	r2,0(r2)
 201429c:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 20142a0:	10001426 	beq	r2,zero,20142f4 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 20142a4:	e0bffb17 	ldw	r2,-20(fp)
 20142a8:	10800017 	ldw	r2,0(r2)
 20142ac:	10800517 	ldw	r2,20(r2)
 20142b0:	e0ffff17 	ldw	r3,-4(fp)
 20142b4:	180d883a 	mov	r6,r3
 20142b8:	e17ffe17 	ldw	r5,-8(fp)
 20142bc:	e13ffb17 	ldw	r4,-20(fp)
 20142c0:	103ee83a 	callr	r2
 20142c4:	e0bffc15 	stw	r2,-16(fp)
 20142c8:	e0bffc17 	ldw	r2,-16(fp)
 20142cc:	1000070e 	bge	r2,zero,20142ec <read+0xb8>
        {
          ALT_ERRNO = -rval;
 20142d0:	20141f80 	call	20141f8 <alt_get_errno>
 20142d4:	1007883a 	mov	r3,r2
 20142d8:	e0bffc17 	ldw	r2,-16(fp)
 20142dc:	0085c83a 	sub	r2,zero,r2
 20142e0:	18800015 	stw	r2,0(r3)
          return -1;
 20142e4:	00bfffc4 	movi	r2,-1
 20142e8:	00000c06 	br	201431c <read+0xe8>
        }
        return rval;
 20142ec:	e0bffc17 	ldw	r2,-16(fp)
 20142f0:	00000a06 	br	201431c <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 20142f4:	20141f80 	call	20141f8 <alt_get_errno>
 20142f8:	1007883a 	mov	r3,r2
 20142fc:	00800344 	movi	r2,13
 2014300:	18800015 	stw	r2,0(r3)
 2014304:	00000406 	br	2014318 <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 2014308:	20141f80 	call	20141f8 <alt_get_errno>
 201430c:	1007883a 	mov	r3,r2
 2014310:	00801444 	movi	r2,81
 2014314:	18800015 	stw	r2,0(r3)
  }
  return -1;
 2014318:	00bfffc4 	movi	r2,-1
}
 201431c:	e037883a 	mov	sp,fp
 2014320:	dfc00117 	ldw	ra,4(sp)
 2014324:	df000017 	ldw	fp,0(sp)
 2014328:	dec00204 	addi	sp,sp,8
 201432c:	f800283a 	ret

02014330 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 2014330:	defffe04 	addi	sp,sp,-8
 2014334:	df000115 	stw	fp,4(sp)
 2014338:	df000104 	addi	fp,sp,4
 201433c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 2014340:	e0bfff17 	ldw	r2,-4(fp)
 2014344:	108000d0 	cmplti	r2,r2,3
 2014348:	10000d1e 	bne	r2,zero,2014380 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 201434c:	008080b4 	movhi	r2,514
 2014350:	10811104 	addi	r2,r2,1092
 2014354:	e0ffff17 	ldw	r3,-4(fp)
 2014358:	18c00324 	muli	r3,r3,12
 201435c:	10c5883a 	add	r2,r2,r3
 2014360:	10800204 	addi	r2,r2,8
 2014364:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 2014368:	008080b4 	movhi	r2,514
 201436c:	10811104 	addi	r2,r2,1092
 2014370:	e0ffff17 	ldw	r3,-4(fp)
 2014374:	18c00324 	muli	r3,r3,12
 2014378:	10c5883a 	add	r2,r2,r3
 201437c:	10000015 	stw	zero,0(r2)
  }
}
 2014380:	0001883a 	nop
 2014384:	e037883a 	mov	sp,fp
 2014388:	df000017 	ldw	fp,0(sp)
 201438c:	dec00104 	addi	sp,sp,4
 2014390:	f800283a 	ret

02014394 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 2014394:	defff904 	addi	sp,sp,-28
 2014398:	df000615 	stw	fp,24(sp)
 201439c:	df000604 	addi	fp,sp,24
 20143a0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20143a4:	0005303a 	rdctl	r2,status
 20143a8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20143ac:	e0fffe17 	ldw	r3,-8(fp)
 20143b0:	00bfff84 	movi	r2,-2
 20143b4:	1884703a 	and	r2,r3,r2
 20143b8:	1001703a 	wrctl	status,r2
  
  return context;
 20143bc:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 20143c0:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 20143c4:	d0a01217 	ldw	r2,-32696(gp)
 20143c8:	10c000c4 	addi	r3,r2,3
 20143cc:	00bfff04 	movi	r2,-4
 20143d0:	1884703a 	and	r2,r3,r2
 20143d4:	d0a01215 	stw	r2,-32696(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 20143d8:	d0e01217 	ldw	r3,-32696(gp)
 20143dc:	e0bfff17 	ldw	r2,-4(fp)
 20143e0:	1887883a 	add	r3,r3,r2
 20143e4:	00810034 	movhi	r2,1024
 20143e8:	10800004 	addi	r2,r2,0
 20143ec:	10c0062e 	bgeu	r2,r3,2014408 <sbrk+0x74>
 20143f0:	e0bffb17 	ldw	r2,-20(fp)
 20143f4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20143f8:	e0bffa17 	ldw	r2,-24(fp)
 20143fc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 2014400:	00bfffc4 	movi	r2,-1
 2014404:	00000b06 	br	2014434 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 2014408:	d0a01217 	ldw	r2,-32696(gp)
 201440c:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 2014410:	d0e01217 	ldw	r3,-32696(gp)
 2014414:	e0bfff17 	ldw	r2,-4(fp)
 2014418:	1885883a 	add	r2,r3,r2
 201441c:	d0a01215 	stw	r2,-32696(gp)
 2014420:	e0bffb17 	ldw	r2,-20(fp)
 2014424:	e0bffc15 	stw	r2,-16(fp)
 2014428:	e0bffc17 	ldw	r2,-16(fp)
 201442c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 2014430:	e0bffd17 	ldw	r2,-12(fp)
} 
 2014434:	e037883a 	mov	sp,fp
 2014438:	df000017 	ldw	fp,0(sp)
 201443c:	dec00104 	addi	sp,sp,4
 2014440:	f800283a 	ret

02014444 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2014444:	defffe04 	addi	sp,sp,-8
 2014448:	dfc00115 	stw	ra,4(sp)
 201444c:	df000015 	stw	fp,0(sp)
 2014450:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2014454:	d0a01117 	ldw	r2,-32700(gp)
 2014458:	10000326 	beq	r2,zero,2014468 <alt_get_errno+0x24>
 201445c:	d0a01117 	ldw	r2,-32700(gp)
 2014460:	103ee83a 	callr	r2
 2014464:	00000106 	br	201446c <alt_get_errno+0x28>
 2014468:	d0a74604 	addi	r2,gp,-25320
}
 201446c:	e037883a 	mov	sp,fp
 2014470:	dfc00117 	ldw	ra,4(sp)
 2014474:	df000017 	ldw	fp,0(sp)
 2014478:	dec00204 	addi	sp,sp,8
 201447c:	f800283a 	ret

02014480 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 2014480:	defff904 	addi	sp,sp,-28
 2014484:	dfc00615 	stw	ra,24(sp)
 2014488:	df000515 	stw	fp,20(sp)
 201448c:	df000504 	addi	fp,sp,20
 2014490:	e13ffd15 	stw	r4,-12(fp)
 2014494:	e17ffe15 	stw	r5,-8(fp)
 2014498:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 201449c:	e0bffd17 	ldw	r2,-12(fp)
 20144a0:	10000616 	blt	r2,zero,20144bc <write+0x3c>
 20144a4:	e0bffd17 	ldw	r2,-12(fp)
 20144a8:	10c00324 	muli	r3,r2,12
 20144ac:	008080b4 	movhi	r2,514
 20144b0:	10811104 	addi	r2,r2,1092
 20144b4:	1885883a 	add	r2,r3,r2
 20144b8:	00000106 	br	20144c0 <write+0x40>
 20144bc:	0005883a 	mov	r2,zero
 20144c0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 20144c4:	e0bffb17 	ldw	r2,-20(fp)
 20144c8:	10002126 	beq	r2,zero,2014550 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 20144cc:	e0bffb17 	ldw	r2,-20(fp)
 20144d0:	10800217 	ldw	r2,8(r2)
 20144d4:	108000cc 	andi	r2,r2,3
 20144d8:	10001826 	beq	r2,zero,201453c <write+0xbc>
 20144dc:	e0bffb17 	ldw	r2,-20(fp)
 20144e0:	10800017 	ldw	r2,0(r2)
 20144e4:	10800617 	ldw	r2,24(r2)
 20144e8:	10001426 	beq	r2,zero,201453c <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 20144ec:	e0bffb17 	ldw	r2,-20(fp)
 20144f0:	10800017 	ldw	r2,0(r2)
 20144f4:	10800617 	ldw	r2,24(r2)
 20144f8:	e0ffff17 	ldw	r3,-4(fp)
 20144fc:	180d883a 	mov	r6,r3
 2014500:	e17ffe17 	ldw	r5,-8(fp)
 2014504:	e13ffb17 	ldw	r4,-20(fp)
 2014508:	103ee83a 	callr	r2
 201450c:	e0bffc15 	stw	r2,-16(fp)
 2014510:	e0bffc17 	ldw	r2,-16(fp)
 2014514:	1000070e 	bge	r2,zero,2014534 <write+0xb4>
      {
        ALT_ERRNO = -rval;
 2014518:	20144440 	call	2014444 <alt_get_errno>
 201451c:	1007883a 	mov	r3,r2
 2014520:	e0bffc17 	ldw	r2,-16(fp)
 2014524:	0085c83a 	sub	r2,zero,r2
 2014528:	18800015 	stw	r2,0(r3)
        return -1;
 201452c:	00bfffc4 	movi	r2,-1
 2014530:	00000c06 	br	2014564 <write+0xe4>
      }
      return rval;
 2014534:	e0bffc17 	ldw	r2,-16(fp)
 2014538:	00000a06 	br	2014564 <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 201453c:	20144440 	call	2014444 <alt_get_errno>
 2014540:	1007883a 	mov	r3,r2
 2014544:	00800344 	movi	r2,13
 2014548:	18800015 	stw	r2,0(r3)
 201454c:	00000406 	br	2014560 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 2014550:	20144440 	call	2014444 <alt_get_errno>
 2014554:	1007883a 	mov	r3,r2
 2014558:	00801444 	movi	r2,81
 201455c:	18800015 	stw	r2,0(r3)
  }
  return -1;
 2014560:	00bfffc4 	movi	r2,-1
}
 2014564:	e037883a 	mov	sp,fp
 2014568:	dfc00117 	ldw	ra,4(sp)
 201456c:	df000017 	ldw	fp,0(sp)
 2014570:	dec00204 	addi	sp,sp,8
 2014574:	f800283a 	ret

02014578 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 2014578:	deffdf04 	addi	sp,sp,-132
 201457c:	dfc02015 	stw	ra,128(sp)
 2014580:	df001f15 	stw	fp,124(sp)
 2014584:	df001f04 	addi	fp,sp,124
 2014588:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 201458c:	e0bfe204 	addi	r2,fp,-120
 2014590:	100b883a 	mov	r5,r2
 2014594:	01003fc4 	movi	r4,255
 2014598:	201c4980 	call	201c498 <OSTaskQuery>
 201459c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 20145a0:	e0bffe83 	ldbu	r2,-6(fp)
 20145a4:	10803fcc 	andi	r2,r2,255
 20145a8:	10001e1e 	bne	r2,zero,2014624 <__env_lock+0xac>
    return;

  id = tcb.OSTCBPrio;
 20145ac:	e0bfee83 	ldbu	r2,-70(fp)
 20145b0:	10803fcc 	andi	r2,r2,255
 20145b4:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 20145b8:	d0a74c17 	ldw	r2,-25296(gp)
 20145bc:	e0fffd04 	addi	r3,fp,-12
 20145c0:	180b883a 	mov	r5,r3
 20145c4:	1009883a 	mov	r4,r2
 20145c8:	201acb00 	call	201acb0 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 20145cc:	e0bffe43 	ldbu	r2,-7(fp)
 20145d0:	10803fcc 	andi	r2,r2,255
 20145d4:	10000726 	beq	r2,zero,20145f4 <__env_lock+0x7c>
 20145d8:	d0a01317 	ldw	r2,-32692(gp)
 20145dc:	e0ffe117 	ldw	r3,-124(fp)
 20145e0:	1880041e 	bne	r3,r2,20145f4 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 20145e4:	d0a74b17 	ldw	r2,-25300(gp)
 20145e8:	10800044 	addi	r2,r2,1
 20145ec:	d0a74b15 	stw	r2,-25300(gp)
 20145f0:	00000a06 	br	201461c <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 20145f4:	d0a74c17 	ldw	r2,-25296(gp)
 20145f8:	e0fffe84 	addi	r3,fp,-6
 20145fc:	180d883a 	mov	r6,r3
 2014600:	000b883a 	mov	r5,zero
 2014604:	1009883a 	mov	r4,r2
 2014608:	201a8280 	call	201a828 <OSSemPend>
    locks  = 1;
 201460c:	00800044 	movi	r2,1
 2014610:	d0a74b15 	stw	r2,-25300(gp)
    lockid = id;
 2014614:	e0bfe117 	ldw	r2,-124(fp)
 2014618:	d0a01315 	stw	r2,-32692(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 201461c:	0001883a 	nop
 2014620:	00000106 	br	2014628 <__env_lock+0xb0>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 2014624:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 2014628:	e037883a 	mov	sp,fp
 201462c:	dfc00117 	ldw	ra,4(sp)
 2014630:	df000017 	ldw	fp,0(sp)
 2014634:	dec00204 	addi	sp,sp,8
 2014638:	f800283a 	ret

0201463c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 201463c:	defffd04 	addi	sp,sp,-12
 2014640:	dfc00215 	stw	ra,8(sp)
 2014644:	df000115 	stw	fp,4(sp)
 2014648:	df000104 	addi	fp,sp,4
 201464c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 2014650:	d0a74b17 	ldw	r2,-25300(gp)
 2014654:	10000b26 	beq	r2,zero,2014684 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 2014658:	d0a74b17 	ldw	r2,-25300(gp)
 201465c:	10bfffc4 	addi	r2,r2,-1
 2014660:	d0a74b15 	stw	r2,-25300(gp)
 2014664:	d0a74b17 	ldw	r2,-25300(gp)
 2014668:	1000071e 	bne	r2,zero,2014688 <__env_unlock+0x4c>
  {
    lockid = -1;
 201466c:	00bfffc4 	movi	r2,-1
 2014670:	d0a01315 	stw	r2,-32692(gp)
    OSSemPost( alt_envsem );
 2014674:	d0a74c17 	ldw	r2,-25296(gp)
 2014678:	1009883a 	mov	r4,r2
 201467c:	201aba00 	call	201aba0 <OSSemPost>
 2014680:	00000106 	br	2014688 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 2014684:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 2014688:	e037883a 	mov	sp,fp
 201468c:	dfc00117 	ldw	ra,4(sp)
 2014690:	df000017 	ldw	fp,0(sp)
 2014694:	dec00204 	addi	sp,sp,8
 2014698:	f800283a 	ret

0201469c <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 201469c:	deffdb04 	addi	sp,sp,-148
 20146a0:	dfc02415 	stw	ra,144(sp)
 20146a4:	df002315 	stw	fp,140(sp)
 20146a8:	df002304 	addi	fp,sp,140
 20146ac:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20146b0:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 20146b4:	d0a74f43 	ldbu	r2,-25283(gp)
 20146b8:	10803fcc 	andi	r2,r2,255
 20146bc:	10800060 	cmpeqi	r2,r2,1
 20146c0:	10003626 	beq	r2,zero,201479c <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 20146c4:	e0bfe204 	addi	r2,fp,-120
 20146c8:	100b883a 	mov	r5,r2
 20146cc:	01003fc4 	movi	r4,255
 20146d0:	201c4980 	call	201c498 <OSTaskQuery>
 20146d4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 20146d8:	e0bffe83 	ldbu	r2,-6(fp)
 20146dc:	10803fcc 	andi	r2,r2,255
 20146e0:	1000301e 	bne	r2,zero,20147a4 <__malloc_lock+0x108>
    return;

  id = tcb.OSTCBPrio;
 20146e4:	e0bfee83 	ldbu	r2,-70(fp)
 20146e8:	10803fcc 	andi	r2,r2,255
 20146ec:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 20146f0:	d0a74e17 	ldw	r2,-25288(gp)
 20146f4:	e0fffd04 	addi	r3,fp,-12
 20146f8:	180b883a 	mov	r5,r3
 20146fc:	1009883a 	mov	r4,r2
 2014700:	201acb00 	call	201acb0 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2014704:	0005303a 	rdctl	r2,status
 2014708:	e0bfe115 	stw	r2,-124(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201470c:	e0ffe117 	ldw	r3,-124(fp)
 2014710:	00bfff84 	movi	r2,-2
 2014714:	1884703a 	and	r2,r3,r2
 2014718:	1001703a 	wrctl	status,r2
  
  return context;
 201471c:	e0bfe117 	ldw	r2,-124(fp)
  
  OS_ENTER_CRITICAL();
 2014720:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 2014724:	e0bffd0b 	ldhu	r2,-12(fp)
 2014728:	10bfffcc 	andi	r2,r2,65535
 201472c:	10000b1e 	bne	r2,zero,201475c <__malloc_lock+0xc0>
 2014730:	d0a01417 	ldw	r2,-32688(gp)
 2014734:	e0ffde17 	ldw	r3,-136(fp)
 2014738:	1880081e 	bne	r3,r2,201475c <__malloc_lock+0xc0>
  {
    /* we do; just count the recursion */
    locks++;
 201473c:	d0a74d17 	ldw	r2,-25292(gp)
 2014740:	10800044 	addi	r2,r2,1
 2014744:	d0a74d15 	stw	r2,-25292(gp)
 2014748:	e0bfdd17 	ldw	r2,-140(fp)
 201474c:	e0bfdf15 	stw	r2,-132(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2014750:	e0bfdf17 	ldw	r2,-132(fp)
 2014754:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 2014758:	00000e06 	br	2014794 <__malloc_lock+0xf8>
 201475c:	e0bfdd17 	ldw	r2,-140(fp)
 2014760:	e0bfe015 	stw	r2,-128(fp)
 2014764:	e0bfe017 	ldw	r2,-128(fp)
 2014768:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 201476c:	d0a74e17 	ldw	r2,-25288(gp)
 2014770:	e0fffe84 	addi	r3,fp,-6
 2014774:	180d883a 	mov	r6,r3
 2014778:	000b883a 	mov	r5,zero
 201477c:	1009883a 	mov	r4,r2
 2014780:	201a8280 	call	201a828 <OSSemPend>
    locks  = 1;
 2014784:	00800044 	movi	r2,1
 2014788:	d0a74d15 	stw	r2,-25292(gp)
    lockid = id;
 201478c:	e0bfde17 	ldw	r2,-136(fp)
 2014790:	d0a01415 	stw	r2,-32688(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
 2014794:	0001883a 	nop
 2014798:	00000306 	br	20147a8 <__malloc_lock+0x10c>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
 201479c:	0001883a 	nop
 20147a0:	00000106 	br	20147a8 <__malloc_lock+0x10c>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
 20147a4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 20147a8:	e037883a 	mov	sp,fp
 20147ac:	dfc00117 	ldw	ra,4(sp)
 20147b0:	df000017 	ldw	fp,0(sp)
 20147b4:	dec00204 	addi	sp,sp,8
 20147b8:	f800283a 	ret

020147bc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 20147bc:	defff804 	addi	sp,sp,-32
 20147c0:	dfc00715 	stw	ra,28(sp)
 20147c4:	df000615 	stw	fp,24(sp)
 20147c8:	df000604 	addi	fp,sp,24
 20147cc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20147d0:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 20147d4:	d0a74f43 	ldbu	r2,-25283(gp)
 20147d8:	10803fcc 	andi	r2,r2,255
 20147dc:	10800060 	cmpeqi	r2,r2,1
 20147e0:	10002326 	beq	r2,zero,2014870 <__malloc_unlock+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20147e4:	0005303a 	rdctl	r2,status
 20147e8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20147ec:	e0fffe17 	ldw	r3,-8(fp)
 20147f0:	00bfff84 	movi	r2,-2
 20147f4:	1884703a 	and	r2,r3,r2
 20147f8:	1001703a 	wrctl	status,r2
  
  return context;
 20147fc:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
 2014800:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 2014804:	d0a74d17 	ldw	r2,-25292(gp)
 2014808:	1000051e 	bne	r2,zero,2014820 <__malloc_unlock+0x64>
 201480c:	e0bffa17 	ldw	r2,-24(fp)
 2014810:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2014814:	e0bffb17 	ldw	r2,-20(fp)
 2014818:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 201481c:	00001506 	br	2014874 <__malloc_unlock+0xb8>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 2014820:	d0a74d17 	ldw	r2,-25292(gp)
 2014824:	10bfffc4 	addi	r2,r2,-1
 2014828:	d0a74d15 	stw	r2,-25292(gp)
 201482c:	d0a74d17 	ldw	r2,-25292(gp)
 2014830:	10000a1e 	bne	r2,zero,201485c <__malloc_unlock+0xa0>
  {
    lockid = -1;
 2014834:	00bfffc4 	movi	r2,-1
 2014838:	d0a01415 	stw	r2,-32688(gp)
 201483c:	e0bffa17 	ldw	r2,-24(fp)
 2014840:	e0bffc15 	stw	r2,-16(fp)
 2014844:	e0bffc17 	ldw	r2,-16(fp)
 2014848:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 201484c:	d0a74e17 	ldw	r2,-25288(gp)
 2014850:	1009883a 	mov	r4,r2
 2014854:	201aba00 	call	201aba0 <OSSemPost>
 2014858:	00000606 	br	2014874 <__malloc_unlock+0xb8>
 201485c:	e0bffa17 	ldw	r2,-24(fp)
 2014860:	e0bffd15 	stw	r2,-12(fp)
 2014864:	e0bffd17 	ldw	r2,-12(fp)
 2014868:	1001703a 	wrctl	status,r2
 201486c:	00000106 	br	2014874 <__malloc_unlock+0xb8>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 2014870:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 2014874:	e037883a 	mov	sp,fp
 2014878:	dfc00117 	ldw	ra,4(sp)
 201487c:	df000017 	ldw	fp,0(sp)
 2014880:	dec00204 	addi	sp,sp,8
 2014884:	f800283a 	ret

02014888 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 2014888:	defff704 	addi	sp,sp,-36
 201488c:	dfc00815 	stw	ra,32(sp)
 2014890:	df000715 	stw	fp,28(sp)
 2014894:	df000704 	addi	fp,sp,28
 2014898:	e13ffd15 	stw	r4,-12(fp)
 201489c:	e17ffe15 	stw	r5,-8(fp)
 20148a0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20148a4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 20148a8:	e0bfff17 	ldw	r2,-4(fp)
 20148ac:	1000021e 	bne	r2,zero,20148b8 <OSEventNameGet+0x30>
        return (0);
 20148b0:	0005883a 	mov	r2,zero
 20148b4:	00003706 	br	2014994 <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 20148b8:	e0bffd17 	ldw	r2,-12(fp)
 20148bc:	1000051e 	bne	r2,zero,20148d4 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 20148c0:	e0bfff17 	ldw	r2,-4(fp)
 20148c4:	00c00104 	movi	r3,4
 20148c8:	10c00005 	stb	r3,0(r2)
        return (0);
 20148cc:	0005883a 	mov	r2,zero
 20148d0:	00003006 	br	2014994 <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 20148d4:	e0bffe17 	ldw	r2,-8(fp)
 20148d8:	1000051e 	bne	r2,zero,20148f0 <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 20148dc:	e0bfff17 	ldw	r2,-4(fp)
 20148e0:	00c00304 	movi	r3,12
 20148e4:	10c00005 	stb	r3,0(r2)
        return (0);
 20148e8:	0005883a 	mov	r2,zero
 20148ec:	00002906 	br	2014994 <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 20148f0:	d0a75d03 	ldbu	r2,-25228(gp)
 20148f4:	10803fcc 	andi	r2,r2,255
 20148f8:	10000526 	beq	r2,zero,2014910 <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 20148fc:	e0bfff17 	ldw	r2,-4(fp)
 2014900:	00c00444 	movi	r3,17
 2014904:	10c00005 	stb	r3,0(r2)
        return (0);
 2014908:	0005883a 	mov	r2,zero
 201490c:	00002106 	br	2014994 <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 2014910:	e0bffd17 	ldw	r2,-12(fp)
 2014914:	10800003 	ldbu	r2,0(r2)
 2014918:	10803fcc 	andi	r2,r2,255
 201491c:	10bfffc4 	addi	r2,r2,-1
 2014920:	10800128 	cmpgeui	r2,r2,4
 2014924:	10000526 	beq	r2,zero,201493c <OSEventNameGet+0xb4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 2014928:	e0bfff17 	ldw	r2,-4(fp)
 201492c:	00c00044 	movi	r3,1
 2014930:	10c00005 	stb	r3,0(r2)
             return (0);
 2014934:	0005883a 	mov	r2,zero
 2014938:	00001606 	br	2014994 <OSEventNameGet+0x10c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 201493c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2014940:	0005303a 	rdctl	r2,status
 2014944:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2014948:	e0fffb17 	ldw	r3,-20(fp)
 201494c:	00bfff84 	movi	r2,-2
 2014950:	1884703a 	and	r2,r3,r2
 2014954:	1001703a 	wrctl	status,r2
  
  return context;
 2014958:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 201495c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 2014960:	e0bffd17 	ldw	r2,-12(fp)
 2014964:	10800384 	addi	r2,r2,14
 2014968:	100b883a 	mov	r5,r2
 201496c:	e13ffe17 	ldw	r4,-8(fp)
 2014970:	201630c0 	call	201630c <OS_StrCopy>
 2014974:	e0bffa05 	stb	r2,-24(fp)
 2014978:	e0bff917 	ldw	r2,-28(fp)
 201497c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2014980:	e0bffc17 	ldw	r2,-16(fp)
 2014984:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2014988:	e0bfff17 	ldw	r2,-4(fp)
 201498c:	10000005 	stb	zero,0(r2)
    return (len);
 2014990:	e0bffa03 	ldbu	r2,-24(fp)
}
 2014994:	e037883a 	mov	sp,fp
 2014998:	dfc00117 	ldw	ra,4(sp)
 201499c:	df000017 	ldw	fp,0(sp)
 20149a0:	dec00204 	addi	sp,sp,8
 20149a4:	f800283a 	ret

020149a8 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 20149a8:	defff604 	addi	sp,sp,-40
 20149ac:	dfc00915 	stw	ra,36(sp)
 20149b0:	df000815 	stw	fp,32(sp)
 20149b4:	df000804 	addi	fp,sp,32
 20149b8:	e13ffd15 	stw	r4,-12(fp)
 20149bc:	e17ffe15 	stw	r5,-8(fp)
 20149c0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20149c4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 20149c8:	e0bfff17 	ldw	r2,-4(fp)
 20149cc:	10004026 	beq	r2,zero,2014ad0 <OSEventNameSet+0x128>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 20149d0:	e0bffd17 	ldw	r2,-12(fp)
 20149d4:	1000041e 	bne	r2,zero,20149e8 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 20149d8:	e0bfff17 	ldw	r2,-4(fp)
 20149dc:	00c00104 	movi	r3,4
 20149e0:	10c00005 	stb	r3,0(r2)
        return;
 20149e4:	00003b06 	br	2014ad4 <OSEventNameSet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 20149e8:	e0bffe17 	ldw	r2,-8(fp)
 20149ec:	1000041e 	bne	r2,zero,2014a00 <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 20149f0:	e0bfff17 	ldw	r2,-4(fp)
 20149f4:	00c00304 	movi	r3,12
 20149f8:	10c00005 	stb	r3,0(r2)
        return;
 20149fc:	00003506 	br	2014ad4 <OSEventNameSet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2014a00:	d0a75d03 	ldbu	r2,-25228(gp)
 2014a04:	10803fcc 	andi	r2,r2,255
 2014a08:	10000426 	beq	r2,zero,2014a1c <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 2014a0c:	e0bfff17 	ldw	r2,-4(fp)
 2014a10:	00c00484 	movi	r3,18
 2014a14:	10c00005 	stb	r3,0(r2)
        return;
 2014a18:	00002e06 	br	2014ad4 <OSEventNameSet+0x12c>
    }
    switch (pevent->OSEventType) {
 2014a1c:	e0bffd17 	ldw	r2,-12(fp)
 2014a20:	10800003 	ldbu	r2,0(r2)
 2014a24:	10803fcc 	andi	r2,r2,255
 2014a28:	10bfffc4 	addi	r2,r2,-1
 2014a2c:	10800128 	cmpgeui	r2,r2,4
 2014a30:	10000426 	beq	r2,zero,2014a44 <OSEventNameSet+0x9c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 2014a34:	e0bfff17 	ldw	r2,-4(fp)
 2014a38:	00c00044 	movi	r3,1
 2014a3c:	10c00005 	stb	r3,0(r2)
             return;
 2014a40:	00002406 	br	2014ad4 <OSEventNameSet+0x12c>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 2014a44:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2014a48:	0005303a 	rdctl	r2,status
 2014a4c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2014a50:	e0fffc17 	ldw	r3,-16(fp)
 2014a54:	00bfff84 	movi	r2,-2
 2014a58:	1884703a 	and	r2,r3,r2
 2014a5c:	1001703a 	wrctl	status,r2
  
  return context;
 2014a60:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 2014a64:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 2014a68:	e13ffe17 	ldw	r4,-8(fp)
 2014a6c:	20163800 	call	2016380 <OS_StrLen>
 2014a70:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 2014a74:	e0bffa03 	ldbu	r2,-24(fp)
 2014a78:	10800830 	cmpltui	r2,r2,32
 2014a7c:	1000081e 	bne	r2,zero,2014aa0 <OSEventNameSet+0xf8>
 2014a80:	e0bff817 	ldw	r2,-32(fp)
 2014a84:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2014a88:	e0bff917 	ldw	r2,-28(fp)
 2014a8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 2014a90:	e0bfff17 	ldw	r2,-4(fp)
 2014a94:	00c002c4 	movi	r3,11
 2014a98:	10c00005 	stb	r3,0(r2)
        return;
 2014a9c:	00000d06 	br	2014ad4 <OSEventNameSet+0x12c>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 2014aa0:	e0bffd17 	ldw	r2,-12(fp)
 2014aa4:	10800384 	addi	r2,r2,14
 2014aa8:	e17ffe17 	ldw	r5,-8(fp)
 2014aac:	1009883a 	mov	r4,r2
 2014ab0:	201630c0 	call	201630c <OS_StrCopy>
 2014ab4:	e0bff817 	ldw	r2,-32(fp)
 2014ab8:	e0bffb15 	stw	r2,-20(fp)
 2014abc:	e0bffb17 	ldw	r2,-20(fp)
 2014ac0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2014ac4:	e0bfff17 	ldw	r2,-4(fp)
 2014ac8:	10000005 	stb	zero,0(r2)
 2014acc:	00000106 	br	2014ad4 <OSEventNameSet+0x12c>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 2014ad0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 2014ad4:	e037883a 	mov	sp,fp
 2014ad8:	dfc00117 	ldw	ra,4(sp)
 2014adc:	df000017 	ldw	fp,0(sp)
 2014ae0:	dec00204 	addi	sp,sp,8
 2014ae4:	f800283a 	ret

02014ae8 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 2014ae8:	deffed04 	addi	sp,sp,-76
 2014aec:	dfc01215 	stw	ra,72(sp)
 2014af0:	df001115 	stw	fp,68(sp)
 2014af4:	df001104 	addi	fp,sp,68
 2014af8:	e13ffc15 	stw	r4,-16(fp)
 2014afc:	e17ffd15 	stw	r5,-12(fp)
 2014b00:	e1bffe15 	stw	r6,-8(fp)
 2014b04:	3805883a 	mov	r2,r7
 2014b08:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 2014b0c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 2014b10:	e0800217 	ldw	r2,8(fp)
 2014b14:	1000021e 	bne	r2,zero,2014b20 <OSEventPendMulti+0x38>
        return (0);
 2014b18:	0005883a 	mov	r2,zero
 2014b1c:	00017106 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 2014b20:	e0bffc17 	ldw	r2,-16(fp)
 2014b24:	1000051e 	bne	r2,zero,2014b3c <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 2014b28:	e0800217 	ldw	r2,8(fp)
 2014b2c:	00c00104 	movi	r3,4
 2014b30:	10c00005 	stb	r3,0(r2)
        return (0);
 2014b34:	0005883a 	mov	r2,zero
 2014b38:	00016a06 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 2014b3c:	e0bffd17 	ldw	r2,-12(fp)
 2014b40:	1000051e 	bne	r2,zero,2014b58 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 2014b44:	e0800217 	ldw	r2,8(fp)
 2014b48:	00c00104 	movi	r3,4
 2014b4c:	10c00005 	stb	r3,0(r2)
        return (0);
 2014b50:	0005883a 	mov	r2,zero
 2014b54:	00016306 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 2014b58:	e0bffe17 	ldw	r2,-8(fp)
 2014b5c:	1000051e 	bne	r2,zero,2014b74 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 2014b60:	e0800217 	ldw	r2,8(fp)
 2014b64:	00c00104 	movi	r3,4
 2014b68:	10c00005 	stb	r3,0(r2)
        return (0);
 2014b6c:	0005883a 	mov	r2,zero
 2014b70:	00015c06 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 2014b74:	e0bffd17 	ldw	r2,-12(fp)
 2014b78:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 2014b7c:	e0bffc17 	ldw	r2,-16(fp)
 2014b80:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 2014b84:	e0bfef17 	ldw	r2,-68(fp)
 2014b88:	10800017 	ldw	r2,0(r2)
 2014b8c:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 2014b90:	00001906 	br	2014bf8 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 2014b94:	e0bff017 	ldw	r2,-64(fp)
 2014b98:	10800003 	ldbu	r2,0(r2)
 2014b9c:	10803fcc 	andi	r2,r2,255
 2014ba0:	10c000a0 	cmpeqi	r3,r2,2
 2014ba4:	1800091e 	bne	r3,zero,2014bcc <OSEventPendMulti+0xe4>
 2014ba8:	10c000e0 	cmpeqi	r3,r2,3
 2014bac:	1800091e 	bne	r3,zero,2014bd4 <OSEventPendMulti+0xec>
 2014bb0:	10800060 	cmpeqi	r2,r2,1
 2014bb4:	1000091e 	bne	r2,zero,2014bdc <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 2014bb8:	e0800217 	ldw	r2,8(fp)
 2014bbc:	00c00044 	movi	r3,1
 2014bc0:	10c00005 	stb	r3,0(r2)
                 return (0);
 2014bc4:	0005883a 	mov	r2,zero
 2014bc8:	00014606 	br	20150e4 <OSEventPendMulti+0x5fc>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 2014bcc:	0001883a 	nop
 2014bd0:	00000306 	br	2014be0 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 2014bd4:	0001883a 	nop
 2014bd8:	00000106 	br	2014be0 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 2014bdc:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 2014be0:	e0bfef17 	ldw	r2,-68(fp)
 2014be4:	10800104 	addi	r2,r2,4
 2014be8:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 2014bec:	e0bfef17 	ldw	r2,-68(fp)
 2014bf0:	10800017 	ldw	r2,0(r2)
 2014bf4:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 2014bf8:	e0bff017 	ldw	r2,-64(fp)
 2014bfc:	103fe51e 	bne	r2,zero,2014b94 <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 2014c00:	d0a75d03 	ldbu	r2,-25228(gp)
 2014c04:	10803fcc 	andi	r2,r2,255
 2014c08:	10000526 	beq	r2,zero,2014c20 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 2014c0c:	e0800217 	ldw	r2,8(fp)
 2014c10:	00c00084 	movi	r3,2
 2014c14:	10c00005 	stb	r3,0(r2)
        return (0);
 2014c18:	0005883a 	mov	r2,zero
 2014c1c:	00013106 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 2014c20:	d0a74f03 	ldbu	r2,-25284(gp)
 2014c24:	10803fcc 	andi	r2,r2,255
 2014c28:	10000526 	beq	r2,zero,2014c40 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 2014c2c:	e0800217 	ldw	r2,8(fp)
 2014c30:	00c00344 	movi	r3,13
 2014c34:	10c00005 	stb	r3,0(r2)
        return (0);
 2014c38:	0005883a 	mov	r2,zero
 2014c3c:	00012906 	br	20150e4 <OSEventPendMulti+0x5fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2014c40:	0005303a 	rdctl	r2,status
 2014c44:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2014c48:	e0fffb17 	ldw	r3,-20(fp)
 2014c4c:	00bfff84 	movi	r2,-2
 2014c50:	1884703a 	and	r2,r3,r2
 2014c54:	1001703a 	wrctl	status,r2
  
  return context;
 2014c58:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 2014c5c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 2014c60:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 2014c64:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 2014c68:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 2014c6c:	e0bffc17 	ldw	r2,-16(fp)
 2014c70:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 2014c74:	e0bfef17 	ldw	r2,-68(fp)
 2014c78:	10800017 	ldw	r2,0(r2)
 2014c7c:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 2014c80:	00008106 	br	2014e88 <OSEventPendMulti+0x3a0>
        switch (pevent->OSEventType) {
 2014c84:	e0bff017 	ldw	r2,-64(fp)
 2014c88:	10800003 	ldbu	r2,0(r2)
 2014c8c:	10803fcc 	andi	r2,r2,255
 2014c90:	10c000a0 	cmpeqi	r3,r2,2
 2014c94:	18003c1e 	bne	r3,zero,2014d88 <OSEventPendMulti+0x2a0>
 2014c98:	10c000e0 	cmpeqi	r3,r2,3
 2014c9c:	1800031e 	bne	r3,zero,2014cac <OSEventPendMulti+0x1c4>
 2014ca0:	10800060 	cmpeqi	r2,r2,1
 2014ca4:	10001e1e 	bne	r2,zero,2014d20 <OSEventPendMulti+0x238>
 2014ca8:	00006606 	br	2014e44 <OSEventPendMulti+0x35c>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 2014cac:	e0bff017 	ldw	r2,-64(fp)
 2014cb0:	1080020b 	ldhu	r2,8(r2)
 2014cb4:	10bfffcc 	andi	r2,r2,65535
 2014cb8:	10001526 	beq	r2,zero,2014d10 <OSEventPendMulti+0x228>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 2014cbc:	e0bff017 	ldw	r2,-64(fp)
 2014cc0:	1080020b 	ldhu	r2,8(r2)
 2014cc4:	10bfffc4 	addi	r2,r2,-1
 2014cc8:	1007883a 	mov	r3,r2
 2014ccc:	e0bff017 	ldw	r2,-64(fp)
 2014cd0:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 2014cd4:	e0bffd17 	ldw	r2,-12(fp)
 2014cd8:	10c00104 	addi	r3,r2,4
 2014cdc:	e0fffd15 	stw	r3,-12(fp)
 2014ce0:	e0fff017 	ldw	r3,-64(fp)
 2014ce4:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
 2014ce8:	00800044 	movi	r2,1
 2014cec:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 2014cf0:	e0bffe17 	ldw	r2,-8(fp)
 2014cf4:	10c00104 	addi	r3,r2,4
 2014cf8:	e0fffe15 	stw	r3,-8(fp)
 2014cfc:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
 2014d00:	e0bff18b 	ldhu	r2,-58(fp)
 2014d04:	10800044 	addi	r2,r2,1
 2014d08:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 2014d0c:	00005806 	br	2014e70 <OSEventPendMulti+0x388>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 2014d10:	e0bff203 	ldbu	r2,-56(fp)
 2014d14:	10800054 	ori	r2,r2,1
 2014d18:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 2014d1c:	00005406 	br	2014e70 <OSEventPendMulti+0x388>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 2014d20:	e0bff017 	ldw	r2,-64(fp)
 2014d24:	10800117 	ldw	r2,4(r2)
 2014d28:	10001326 	beq	r2,zero,2014d78 <OSEventPendMulti+0x290>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 2014d2c:	e0bffe17 	ldw	r2,-8(fp)
 2014d30:	10c00104 	addi	r3,r2,4
 2014d34:	e0fffe15 	stw	r3,-8(fp)
 2014d38:	e0fff017 	ldw	r3,-64(fp)
 2014d3c:	18c00117 	ldw	r3,4(r3)
 2014d40:	10c00015 	stw	r3,0(r2)
                     pevent->OSEventPtr  = (void *)0;
 2014d44:	e0bff017 	ldw	r2,-64(fp)
 2014d48:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 2014d4c:	e0bffd17 	ldw	r2,-12(fp)
 2014d50:	10c00104 	addi	r3,r2,4
 2014d54:	e0fffd15 	stw	r3,-12(fp)
 2014d58:	e0fff017 	ldw	r3,-64(fp)
 2014d5c:	10c00015 	stw	r3,0(r2)
                      events_rdy         =  OS_TRUE;
 2014d60:	00800044 	movi	r2,1
 2014d64:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 2014d68:	e0bff18b 	ldhu	r2,-58(fp)
 2014d6c:	10800044 	addi	r2,r2,1
 2014d70:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 2014d74:	00003e06 	br	2014e70 <OSEventPendMulti+0x388>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 2014d78:	e0bff203 	ldbu	r2,-56(fp)
 2014d7c:	10800094 	ori	r2,r2,2
 2014d80:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 2014d84:	00003a06 	br	2014e70 <OSEventPendMulti+0x388>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 2014d88:	e0bff017 	ldw	r2,-64(fp)
 2014d8c:	10800117 	ldw	r2,4(r2)
 2014d90:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 2014d94:	e0bff517 	ldw	r2,-44(fp)
 2014d98:	1080058b 	ldhu	r2,22(r2)
 2014d9c:	10bfffcc 	andi	r2,r2,65535
 2014da0:	10002426 	beq	r2,zero,2014e34 <OSEventPendMulti+0x34c>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 2014da4:	e0bffe17 	ldw	r2,-8(fp)
 2014da8:	10c00104 	addi	r3,r2,4
 2014dac:	e0fffe15 	stw	r3,-8(fp)
 2014db0:	e0fff517 	ldw	r3,-44(fp)
 2014db4:	18c00417 	ldw	r3,16(r3)
 2014db8:	19400104 	addi	r5,r3,4
 2014dbc:	e13ff517 	ldw	r4,-44(fp)
 2014dc0:	21400415 	stw	r5,16(r4)
 2014dc4:	18c00017 	ldw	r3,0(r3)
 2014dc8:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 2014dcc:	e0bff517 	ldw	r2,-44(fp)
 2014dd0:	10c00417 	ldw	r3,16(r2)
 2014dd4:	e0bff517 	ldw	r2,-44(fp)
 2014dd8:	10800217 	ldw	r2,8(r2)
 2014ddc:	1880041e 	bne	r3,r2,2014df0 <OSEventPendMulti+0x308>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 2014de0:	e0bff517 	ldw	r2,-44(fp)
 2014de4:	10c00117 	ldw	r3,4(r2)
 2014de8:	e0bff517 	ldw	r2,-44(fp)
 2014dec:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 2014df0:	e0bff517 	ldw	r2,-44(fp)
 2014df4:	1080058b 	ldhu	r2,22(r2)
 2014df8:	10bfffc4 	addi	r2,r2,-1
 2014dfc:	1007883a 	mov	r3,r2
 2014e00:	e0bff517 	ldw	r2,-44(fp)
 2014e04:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 2014e08:	e0bffd17 	ldw	r2,-12(fp)
 2014e0c:	10c00104 	addi	r3,r2,4
 2014e10:	e0fffd15 	stw	r3,-12(fp)
 2014e14:	e0fff017 	ldw	r3,-64(fp)
 2014e18:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
 2014e1c:	00800044 	movi	r2,1
 2014e20:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 2014e24:	e0bff18b 	ldhu	r2,-58(fp)
 2014e28:	10800044 	addi	r2,r2,1
 2014e2c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 2014e30:	00000f06 	br	2014e70 <OSEventPendMulti+0x388>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 2014e34:	e0bff203 	ldbu	r2,-56(fp)
 2014e38:	10800114 	ori	r2,r2,4
 2014e3c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 2014e40:	00000b06 	br	2014e70 <OSEventPendMulti+0x388>
 2014e44:	e0bff317 	ldw	r2,-52(fp)
 2014e48:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2014e4c:	e0bff417 	ldw	r2,-48(fp)
 2014e50:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 2014e54:	e0bffd17 	ldw	r2,-12(fp)
 2014e58:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 2014e5c:	e0800217 	ldw	r2,8(fp)
 2014e60:	00c00044 	movi	r3,1
 2014e64:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 2014e68:	e0bff18b 	ldhu	r2,-58(fp)
 2014e6c:	00009d06 	br	20150e4 <OSEventPendMulti+0x5fc>
        }
        pevents++;
 2014e70:	e0bfef17 	ldw	r2,-68(fp)
 2014e74:	10800104 	addi	r2,r2,4
 2014e78:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 2014e7c:	e0bfef17 	ldw	r2,-68(fp)
 2014e80:	10800017 	ldw	r2,0(r2)
 2014e84:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 2014e88:	e0bff017 	ldw	r2,-64(fp)
 2014e8c:	103f7d1e 	bne	r2,zero,2014c84 <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 2014e90:	e0bff103 	ldbu	r2,-60(fp)
 2014e94:	10800058 	cmpnei	r2,r2,1
 2014e98:	10000a1e 	bne	r2,zero,2014ec4 <OSEventPendMulti+0x3dc>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 2014e9c:	e0bffd17 	ldw	r2,-12(fp)
 2014ea0:	10000015 	stw	zero,0(r2)
 2014ea4:	e0bff317 	ldw	r2,-52(fp)
 2014ea8:	e0bff615 	stw	r2,-40(fp)
 2014eac:	e0bff617 	ldw	r2,-40(fp)
 2014eb0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 2014eb4:	e0800217 	ldw	r2,8(fp)
 2014eb8:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 2014ebc:	e0bff18b 	ldhu	r2,-58(fp)
 2014ec0:	00008806 	br	20150e4 <OSEventPendMulti+0x5fc>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 2014ec4:	d0a75e17 	ldw	r2,-25224(gp)
 2014ec8:	d0e75e17 	ldw	r3,-25224(gp)
 2014ecc:	19000c03 	ldbu	r4,48(r3)
 2014ed0:	e0fff203 	ldbu	r3,-56(fp)
 2014ed4:	20c6b03a 	or	r3,r4,r3
 2014ed8:	1809883a 	mov	r4,r3
 2014edc:	00ffe004 	movi	r3,-128
 2014ee0:	20c6b03a 	or	r3,r4,r3
 2014ee4:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2014ee8:	d0a75e17 	ldw	r2,-25224(gp)
 2014eec:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 2014ef0:	d0a75e17 	ldw	r2,-25224(gp)
 2014ef4:	e0ffff0b 	ldhu	r3,-4(fp)
 2014ef8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 2014efc:	e13ffc17 	ldw	r4,-16(fp)
 2014f00:	2015a240 	call	2015a24 <OS_EventTaskWaitMulti>
 2014f04:	e0bff317 	ldw	r2,-52(fp)
 2014f08:	e0bff915 	stw	r2,-28(fp)
 2014f0c:	e0bff917 	ldw	r2,-28(fp)
 2014f10:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 2014f14:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2014f18:	0005303a 	rdctl	r2,status
 2014f1c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2014f20:	e0fff717 	ldw	r3,-36(fp)
 2014f24:	00bfff84 	movi	r2,-2
 2014f28:	1884703a 	and	r2,r3,r2
 2014f2c:	1001703a 	wrctl	status,r2
  
  return context;
 2014f30:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 2014f34:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 2014f38:	d0a75e17 	ldw	r2,-25224(gp)
 2014f3c:	10800c43 	ldbu	r2,49(r2)
 2014f40:	10803fcc 	andi	r2,r2,255
 2014f44:	10000226 	beq	r2,zero,2014f50 <OSEventPendMulti+0x468>
 2014f48:	108000a0 	cmpeqi	r2,r2,2
 2014f4c:	10001826 	beq	r2,zero,2014fb0 <OSEventPendMulti+0x4c8>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 2014f50:	d0a75e17 	ldw	r2,-25224(gp)
 2014f54:	10800717 	ldw	r2,28(r2)
 2014f58:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 2014f5c:	e0bff017 	ldw	r2,-64(fp)
 2014f60:	10000b26 	beq	r2,zero,2014f90 <OSEventPendMulti+0x4a8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 2014f64:	e0bffd17 	ldw	r2,-12(fp)
 2014f68:	10c00104 	addi	r3,r2,4
 2014f6c:	e0fffd15 	stw	r3,-12(fp)
 2014f70:	e0fff017 	ldw	r3,-64(fp)
 2014f74:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 2014f78:	e0bffd17 	ldw	r2,-12(fp)
 2014f7c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 2014f80:	e0bff18b 	ldhu	r2,-58(fp)
 2014f84:	10800044 	addi	r2,r2,1
 2014f88:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 2014f8c:	00000d06 	br	2014fc4 <OSEventPendMulti+0x4dc>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 2014f90:	d0a75e17 	ldw	r2,-25224(gp)
 2014f94:	00c00044 	movi	r3,1
 2014f98:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 2014f9c:	d0a75e17 	ldw	r2,-25224(gp)
 2014fa0:	e17ffc17 	ldw	r5,-16(fp)
 2014fa4:	1009883a 	mov	r4,r2
 2014fa8:	2015c2c0 	call	2015c2c <OS_EventTaskRemoveMulti>
             }
			 break;
 2014fac:	00000506 	br	2014fc4 <OSEventPendMulti+0x4dc>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 2014fb0:	d0a75e17 	ldw	r2,-25224(gp)
 2014fb4:	e17ffc17 	ldw	r5,-16(fp)
 2014fb8:	1009883a 	mov	r4,r2
 2014fbc:	2015c2c0 	call	2015c2c <OS_EventTaskRemoveMulti>
             break;
 2014fc0:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 2014fc4:	d0a75e17 	ldw	r2,-25224(gp)
 2014fc8:	10800c43 	ldbu	r2,49(r2)
 2014fcc:	10803fcc 	andi	r2,r2,255
 2014fd0:	10000326 	beq	r2,zero,2014fe0 <OSEventPendMulti+0x4f8>
 2014fd4:	108000a0 	cmpeqi	r2,r2,2
 2014fd8:	1000231e 	bne	r2,zero,2015068 <OSEventPendMulti+0x580>
 2014fdc:	00002a06 	br	2015088 <OSEventPendMulti+0x5a0>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 2014fe0:	e0bff017 	ldw	r2,-64(fp)
 2014fe4:	10800003 	ldbu	r2,0(r2)
 2014fe8:	10803fcc 	andi	r2,r2,255
 2014fec:	0080100e 	bge	zero,r2,2015030 <OSEventPendMulti+0x548>
 2014ff0:	10c000d0 	cmplti	r3,r2,3
 2014ff4:	1800071e 	bne	r3,zero,2015014 <OSEventPendMulti+0x52c>
 2014ff8:	108000e0 	cmpeqi	r2,r2,3
 2014ffc:	10000c26 	beq	r2,zero,2015030 <OSEventPendMulti+0x548>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 2015000:	e0bffe17 	ldw	r2,-8(fp)
 2015004:	10c00104 	addi	r3,r2,4
 2015008:	e0fffe15 	stw	r3,-8(fp)
 201500c:	10000015 	stw	zero,0(r2)
                      break;
 2015010:	00001206 	br	201505c <OSEventPendMulti+0x574>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 2015014:	e0bffe17 	ldw	r2,-8(fp)
 2015018:	10c00104 	addi	r3,r2,4
 201501c:	e0fffe15 	stw	r3,-8(fp)
 2015020:	d0e75e17 	ldw	r3,-25224(gp)
 2015024:	18c00917 	ldw	r3,36(r3)
 2015028:	10c00015 	stw	r3,0(r2)
                      break;
 201502c:	00000b06 	br	201505c <OSEventPendMulti+0x574>
 2015030:	e0bff317 	ldw	r2,-52(fp)
 2015034:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015038:	e0bff817 	ldw	r2,-32(fp)
 201503c:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 2015040:	e0bffd17 	ldw	r2,-12(fp)
 2015044:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 2015048:	e0800217 	ldw	r2,8(fp)
 201504c:	00c00044 	movi	r3,1
 2015050:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 2015054:	e0bff18b 	ldhu	r2,-58(fp)
 2015058:	00002206 	br	20150e4 <OSEventPendMulti+0x5fc>
             }
            *perr = OS_ERR_NONE;
 201505c:	e0800217 	ldw	r2,8(fp)
 2015060:	10000005 	stb	zero,0(r2)
             break;
 2015064:	00001006 	br	20150a8 <OSEventPendMulti+0x5c0>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 2015068:	e0bffe17 	ldw	r2,-8(fp)
 201506c:	10c00104 	addi	r3,r2,4
 2015070:	e0fffe15 	stw	r3,-8(fp)
 2015074:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 2015078:	e0800217 	ldw	r2,8(fp)
 201507c:	00c00384 	movi	r3,14
 2015080:	10c00005 	stb	r3,0(r2)
             break;
 2015084:	00000806 	br	20150a8 <OSEventPendMulti+0x5c0>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 2015088:	e0bffe17 	ldw	r2,-8(fp)
 201508c:	10c00104 	addi	r3,r2,4
 2015090:	e0fffe15 	stw	r3,-8(fp)
 2015094:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 2015098:	e0800217 	ldw	r2,8(fp)
 201509c:	00c00284 	movi	r3,10
 20150a0:	10c00005 	stb	r3,0(r2)
             break;
 20150a4:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 20150a8:	d0a75e17 	ldw	r2,-25224(gp)
 20150ac:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 20150b0:	d0a75e17 	ldw	r2,-25224(gp)
 20150b4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 20150b8:	d0a75e17 	ldw	r2,-25224(gp)
 20150bc:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 20150c0:	d0a75e17 	ldw	r2,-25224(gp)
 20150c4:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 20150c8:	d0a75e17 	ldw	r2,-25224(gp)
 20150cc:	10000915 	stw	zero,36(r2)
 20150d0:	e0bff317 	ldw	r2,-52(fp)
 20150d4:	e0bffa15 	stw	r2,-24(fp)
 20150d8:	e0bffa17 	ldw	r2,-24(fp)
 20150dc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 20150e0:	e0bff18b 	ldhu	r2,-58(fp)
}
 20150e4:	e037883a 	mov	sp,fp
 20150e8:	dfc00117 	ldw	ra,4(sp)
 20150ec:	df000017 	ldw	fp,0(sp)
 20150f0:	dec00204 	addi	sp,sp,8
 20150f4:	f800283a 	ret

020150f8 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 20150f8:	defffe04 	addi	sp,sp,-8
 20150fc:	dfc00115 	stw	ra,4(sp)
 2015100:	df000015 	stw	fp,0(sp)
 2015104:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 2015108:	201eb380 	call	201eb38 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 201510c:	2015e740 	call	2015e74 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 2015110:	2015ebc0 	call	2015ebc <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 2015114:	20160280 	call	2016028 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 2015118:	2015d940 	call	2015d94 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 201511c:	2017ec80 	call	2017ec8 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 2015120:	20192900 	call	2019290 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 2015124:	201a3b80 	call	201a3b8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 2015128:	2015f280 	call	2015f28 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 201512c:	2015fa80 	call	2015fa8 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 2015130:	201eb580 	call	201eb58 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 2015134:	201689c0 	call	201689c <OSDebugInit>
#endif
}
 2015138:	0001883a 	nop
 201513c:	e037883a 	mov	sp,fp
 2015140:	dfc00117 	ldw	ra,4(sp)
 2015144:	df000017 	ldw	fp,0(sp)
 2015148:	dec00204 	addi	sp,sp,8
 201514c:	f800283a 	ret

02015150 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 2015150:	deffff04 	addi	sp,sp,-4
 2015154:	df000015 	stw	fp,0(sp)
 2015158:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
 201515c:	d0a74f43 	ldbu	r2,-25283(gp)
 2015160:	10803fcc 	andi	r2,r2,255
 2015164:	10800058 	cmpnei	r2,r2,1
 2015168:	1000071e 	bne	r2,zero,2015188 <OSIntEnter+0x38>
        if (OSIntNesting < 255u) {
 201516c:	d0a75d03 	ldbu	r2,-25228(gp)
 2015170:	10803fcc 	andi	r2,r2,255
 2015174:	10803fe0 	cmpeqi	r2,r2,255
 2015178:	1000031e 	bne	r2,zero,2015188 <OSIntEnter+0x38>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 201517c:	d0a75d03 	ldbu	r2,-25228(gp)
 2015180:	10800044 	addi	r2,r2,1
 2015184:	d0a75d05 	stb	r2,-25228(gp)
        }
    }
}
 2015188:	0001883a 	nop
 201518c:	e037883a 	mov	sp,fp
 2015190:	df000017 	ldw	fp,0(sp)
 2015194:	dec00104 	addi	sp,sp,4
 2015198:	f800283a 	ret

0201519c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 201519c:	defffb04 	addi	sp,sp,-20
 20151a0:	dfc00415 	stw	ra,16(sp)
 20151a4:	df000315 	stw	fp,12(sp)
 20151a8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 20151ac:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 20151b0:	d0a74f43 	ldbu	r2,-25283(gp)
 20151b4:	10803fcc 	andi	r2,r2,255
 20151b8:	10800058 	cmpnei	r2,r2,1
 20151bc:	10002f1e 	bne	r2,zero,201527c <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20151c0:	0005303a 	rdctl	r2,status
 20151c4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20151c8:	e0ffff17 	ldw	r3,-4(fp)
 20151cc:	00bfff84 	movi	r2,-2
 20151d0:	1884703a 	and	r2,r3,r2
 20151d4:	1001703a 	wrctl	status,r2
  
  return context;
 20151d8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 20151dc:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 20151e0:	d0a75d03 	ldbu	r2,-25228(gp)
 20151e4:	10803fcc 	andi	r2,r2,255
 20151e8:	10000326 	beq	r2,zero,20151f8 <OSIntExit+0x5c>
            OSIntNesting--;
 20151ec:	d0a75d03 	ldbu	r2,-25228(gp)
 20151f0:	10bfffc4 	addi	r2,r2,-1
 20151f4:	d0a75d05 	stb	r2,-25228(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 20151f8:	d0a75d03 	ldbu	r2,-25228(gp)
 20151fc:	10803fcc 	andi	r2,r2,255
 2015200:	10001a1e 	bne	r2,zero,201526c <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 2015204:	d0a74f03 	ldbu	r2,-25284(gp)
 2015208:	10803fcc 	andi	r2,r2,255
 201520c:	1000171e 	bne	r2,zero,201526c <OSIntExit+0xd0>
                OS_SchedNew();
 2015210:	20162980 	call	2016298 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 2015214:	d0e75103 	ldbu	r3,-25276(gp)
 2015218:	d0a75143 	ldbu	r2,-25275(gp)
 201521c:	18c03fcc 	andi	r3,r3,255
 2015220:	10803fcc 	andi	r2,r2,255
 2015224:	18801126 	beq	r3,r2,201526c <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 2015228:	d0a75103 	ldbu	r2,-25276(gp)
 201522c:	10c03fcc 	andi	r3,r2,255
 2015230:	008080f4 	movhi	r2,515
 2015234:	10b97d04 	addi	r2,r2,-6668
 2015238:	18c7883a 	add	r3,r3,r3
 201523c:	18c7883a 	add	r3,r3,r3
 2015240:	10c5883a 	add	r2,r2,r3
 2015244:	10800017 	ldw	r2,0(r2)
 2015248:	d0a75915 	stw	r2,-25244(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 201524c:	d0a75917 	ldw	r2,-25244(gp)
 2015250:	10c00e17 	ldw	r3,56(r2)
 2015254:	18c00044 	addi	r3,r3,1
 2015258:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 201525c:	d0a75417 	ldw	r2,-25264(gp)
 2015260:	10800044 	addi	r2,r2,1
 2015264:	d0a75415 	stw	r2,-25264(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 2015268:	201e8640 	call	201e864 <OSCtxSw>
 201526c:	e0bffd17 	ldw	r2,-12(fp)
 2015270:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015274:	e0bffe17 	ldw	r2,-8(fp)
 2015278:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 201527c:	0001883a 	nop
 2015280:	e037883a 	mov	sp,fp
 2015284:	dfc00117 	ldw	ra,4(sp)
 2015288:	df000017 	ldw	fp,0(sp)
 201528c:	dec00204 	addi	sp,sp,8
 2015290:	f800283a 	ret

02015294 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 2015294:	defffc04 	addi	sp,sp,-16
 2015298:	df000315 	stw	fp,12(sp)
 201529c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20152a0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 20152a4:	d0a74f43 	ldbu	r2,-25283(gp)
 20152a8:	10803fcc 	andi	r2,r2,255
 20152ac:	10800058 	cmpnei	r2,r2,1
 20152b0:	1000161e 	bne	r2,zero,201530c <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20152b4:	0005303a 	rdctl	r2,status
 20152b8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20152bc:	e0ffff17 	ldw	r3,-4(fp)
 20152c0:	00bfff84 	movi	r2,-2
 20152c4:	1884703a 	and	r2,r3,r2
 20152c8:	1001703a 	wrctl	status,r2
  
  return context;
 20152cc:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 20152d0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 20152d4:	d0a75d03 	ldbu	r2,-25228(gp)
 20152d8:	10803fcc 	andi	r2,r2,255
 20152dc:	1000071e 	bne	r2,zero,20152fc <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 20152e0:	d0a74f03 	ldbu	r2,-25284(gp)
 20152e4:	10803fcc 	andi	r2,r2,255
 20152e8:	10803fe0 	cmpeqi	r2,r2,255
 20152ec:	1000031e 	bne	r2,zero,20152fc <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 20152f0:	d0a74f03 	ldbu	r2,-25284(gp)
 20152f4:	10800044 	addi	r2,r2,1
 20152f8:	d0a74f05 	stb	r2,-25284(gp)
 20152fc:	e0bffd17 	ldw	r2,-12(fp)
 2015300:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015304:	e0bffe17 	ldw	r2,-8(fp)
 2015308:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 201530c:	0001883a 	nop
 2015310:	e037883a 	mov	sp,fp
 2015314:	df000017 	ldw	fp,0(sp)
 2015318:	dec00104 	addi	sp,sp,4
 201531c:	f800283a 	ret

02015320 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 2015320:	defff804 	addi	sp,sp,-32
 2015324:	dfc00715 	stw	ra,28(sp)
 2015328:	df000615 	stw	fp,24(sp)
 201532c:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2015330:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 2015334:	d0a74f43 	ldbu	r2,-25283(gp)
 2015338:	10803fcc 	andi	r2,r2,255
 201533c:	10800058 	cmpnei	r2,r2,1
 2015340:	1000281e 	bne	r2,zero,20153e4 <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015344:	0005303a 	rdctl	r2,status
 2015348:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201534c:	e0ffff17 	ldw	r3,-4(fp)
 2015350:	00bfff84 	movi	r2,-2
 2015354:	1884703a 	and	r2,r3,r2
 2015358:	1001703a 	wrctl	status,r2
  
  return context;
 201535c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
 2015360:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 2015364:	d0a74f03 	ldbu	r2,-25284(gp)
 2015368:	10803fcc 	andi	r2,r2,255
 201536c:	10001926 	beq	r2,zero,20153d4 <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 2015370:	d0a74f03 	ldbu	r2,-25284(gp)
 2015374:	10bfffc4 	addi	r2,r2,-1
 2015378:	d0a74f05 	stb	r2,-25284(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 201537c:	d0a74f03 	ldbu	r2,-25284(gp)
 2015380:	10803fcc 	andi	r2,r2,255
 2015384:	10000e1e 	bne	r2,zero,20153c0 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 2015388:	d0a75d03 	ldbu	r2,-25228(gp)
 201538c:	10803fcc 	andi	r2,r2,255
 2015390:	1000061e 	bne	r2,zero,20153ac <OSSchedUnlock+0x8c>
 2015394:	e0bffa17 	ldw	r2,-24(fp)
 2015398:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201539c:	e0bffb17 	ldw	r2,-20(fp)
 20153a0:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 20153a4:	20161c80 	call	20161c8 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 20153a8:	00000e06 	br	20153e4 <OSSchedUnlock+0xc4>
 20153ac:	e0bffa17 	ldw	r2,-24(fp)
 20153b0:	e0bffc15 	stw	r2,-16(fp)
 20153b4:	e0bffc17 	ldw	r2,-16(fp)
 20153b8:	1001703a 	wrctl	status,r2
 20153bc:	00000906 	br	20153e4 <OSSchedUnlock+0xc4>
 20153c0:	e0bffa17 	ldw	r2,-24(fp)
 20153c4:	e0bffd15 	stw	r2,-12(fp)
 20153c8:	e0bffd17 	ldw	r2,-12(fp)
 20153cc:	1001703a 	wrctl	status,r2
 20153d0:	00000406 	br	20153e4 <OSSchedUnlock+0xc4>
 20153d4:	e0bffa17 	ldw	r2,-24(fp)
 20153d8:	e0bffe15 	stw	r2,-8(fp)
 20153dc:	e0bffe17 	ldw	r2,-8(fp)
 20153e0:	1001703a 	wrctl	status,r2
 20153e4:	0001883a 	nop
 20153e8:	e037883a 	mov	sp,fp
 20153ec:	dfc00117 	ldw	ra,4(sp)
 20153f0:	df000017 	ldw	fp,0(sp)
 20153f4:	dec00204 	addi	sp,sp,8
 20153f8:	f800283a 	ret

020153fc <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 20153fc:	defffe04 	addi	sp,sp,-8
 2015400:	dfc00115 	stw	ra,4(sp)
 2015404:	df000015 	stw	fp,0(sp)
 2015408:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 201540c:	d0a74f43 	ldbu	r2,-25283(gp)
 2015410:	10803fcc 	andi	r2,r2,255
 2015414:	10000f1e 	bne	r2,zero,2015454 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 2015418:	20162980 	call	2016298 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 201541c:	d0a75103 	ldbu	r2,-25276(gp)
 2015420:	d0a75145 	stb	r2,-25275(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 2015424:	d0a75103 	ldbu	r2,-25276(gp)
 2015428:	10c03fcc 	andi	r3,r2,255
 201542c:	008080f4 	movhi	r2,515
 2015430:	10b97d04 	addi	r2,r2,-6668
 2015434:	18c7883a 	add	r3,r3,r3
 2015438:	18c7883a 	add	r3,r3,r3
 201543c:	10c5883a 	add	r2,r2,r3
 2015440:	10800017 	ldw	r2,0(r2)
 2015444:	d0a75915 	stw	r2,-25244(gp)
        OSTCBCur      = OSTCBHighRdy;
 2015448:	d0a75917 	ldw	r2,-25244(gp)
 201544c:	d0a75e15 	stw	r2,-25224(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 2015450:	201e8f00 	call	201e8f0 <OSStartHighRdy>
    }
}
 2015454:	0001883a 	nop
 2015458:	e037883a 	mov	sp,fp
 201545c:	dfc00117 	ldw	ra,4(sp)
 2015460:	df000017 	ldw	fp,0(sp)
 2015464:	dec00204 	addi	sp,sp,8
 2015468:	f800283a 	ret

0201546c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 201546c:	defff904 	addi	sp,sp,-28
 2015470:	dfc00615 	stw	ra,24(sp)
 2015474:	df000515 	stw	fp,20(sp)
 2015478:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201547c:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 2015480:	01000084 	movi	r4,2
 2015484:	201c62c0 	call	201c62c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015488:	0005303a 	rdctl	r2,status
 201548c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015490:	e0fffc17 	ldw	r3,-16(fp)
 2015494:	00bfff84 	movi	r2,-2
 2015498:	1884703a 	and	r2,r3,r2
 201549c:	1001703a 	wrctl	status,r2
  
  return context;
 20154a0:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 20154a4:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 20154a8:	d0275015 	stw	zero,-25280(gp)
 20154ac:	e0bffb17 	ldw	r2,-20(fp)
 20154b0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20154b4:	e0bffd17 	ldw	r2,-12(fp)
 20154b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 20154bc:	01001904 	movi	r4,100
 20154c0:	201c62c0 	call	201c62c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20154c4:	0005303a 	rdctl	r2,status
 20154c8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20154cc:	e0fffe17 	ldw	r3,-8(fp)
 20154d0:	00bfff84 	movi	r2,-2
 20154d4:	1884703a 	and	r2,r3,r2
 20154d8:	1001703a 	wrctl	status,r2
  
  return context;
 20154dc:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 20154e0:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 20154e4:	d0a75017 	ldw	r2,-25280(gp)
 20154e8:	d0a75515 	stw	r2,-25260(gp)
    OSStatRdy    = OS_TRUE;
 20154ec:	00800044 	movi	r2,1
 20154f0:	d0a76105 	stb	r2,-25212(gp)
 20154f4:	e0bffb17 	ldw	r2,-20(fp)
 20154f8:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20154fc:	e0bfff17 	ldw	r2,-4(fp)
 2015500:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 2015504:	0001883a 	nop
 2015508:	e037883a 	mov	sp,fp
 201550c:	dfc00117 	ldw	ra,4(sp)
 2015510:	df000017 	ldw	fp,0(sp)
 2015514:	dec00204 	addi	sp,sp,8
 2015518:	f800283a 	ret

0201551c <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 201551c:	defff704 	addi	sp,sp,-36
 2015520:	dfc00815 	stw	ra,32(sp)
 2015524:	df000715 	stw	fp,28(sp)
 2015528:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201552c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 2015530:	201eb180 	call	201eb18 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015534:	0005303a 	rdctl	r2,status
 2015538:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201553c:	e0fffd17 	ldw	r3,-12(fp)
 2015540:	00bfff84 	movi	r2,-2
 2015544:	1884703a 	and	r2,r3,r2
 2015548:	1001703a 	wrctl	status,r2
  
  return context;
 201554c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 2015550:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 2015554:	d0a75f17 	ldw	r2,-25220(gp)
 2015558:	10800044 	addi	r2,r2,1
 201555c:	d0a75f15 	stw	r2,-25220(gp)
 2015560:	e0bffb17 	ldw	r2,-20(fp)
 2015564:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015568:	e0bfff17 	ldw	r2,-4(fp)
 201556c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 2015570:	d0a74f43 	ldbu	r2,-25283(gp)
 2015574:	10803fcc 	andi	r2,r2,255
 2015578:	10800058 	cmpnei	r2,r2,1
 201557c:	10006a1e 	bne	r2,zero,2015728 <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 2015580:	d0a75303 	ldbu	r2,-25268(gp)
 2015584:	10803fcc 	andi	r2,r2,255
 2015588:	10c00060 	cmpeqi	r3,r2,1
 201558c:	1800061e 	bne	r3,zero,20155a8 <OSTimeTick+0x8c>
 2015590:	10c000a0 	cmpeqi	r3,r2,2
 2015594:	1800061e 	bne	r3,zero,20155b0 <OSTimeTick+0x94>
 2015598:	10000a1e 	bne	r2,zero,20155c4 <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 201559c:	00800044 	movi	r2,1
 20155a0:	e0bffa05 	stb	r2,-24(fp)
                 break;
 20155a4:	00000b06 	br	20155d4 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 20155a8:	e03ffa05 	stb	zero,-24(fp)
                 break;
 20155ac:	00000906 	br	20155d4 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 20155b0:	00800044 	movi	r2,1
 20155b4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 20155b8:	00800044 	movi	r2,1
 20155bc:	d0a75305 	stb	r2,-25268(gp)
                 break;
 20155c0:	00000406 	br	20155d4 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 20155c4:	00800044 	movi	r2,1
 20155c8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 20155cc:	d0275305 	stb	zero,-25268(gp)
                 break;
 20155d0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 20155d4:	e0bffa03 	ldbu	r2,-24(fp)
 20155d8:	10005226 	beq	r2,zero,2015724 <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 20155dc:	d0a75217 	ldw	r2,-25272(gp)
 20155e0:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 20155e4:	00004906 	br	201570c <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20155e8:	0005303a 	rdctl	r2,status
 20155ec:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20155f0:	e0fffc17 	ldw	r3,-16(fp)
 20155f4:	00bfff84 	movi	r2,-2
 20155f8:	1884703a 	and	r2,r3,r2
 20155fc:	1001703a 	wrctl	status,r2
  
  return context;
 2015600:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
 2015604:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 2015608:	e0bff917 	ldw	r2,-28(fp)
 201560c:	10800b8b 	ldhu	r2,46(r2)
 2015610:	10bfffcc 	andi	r2,r2,65535
 2015614:	10003626 	beq	r2,zero,20156f0 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 2015618:	e0bff917 	ldw	r2,-28(fp)
 201561c:	10800b8b 	ldhu	r2,46(r2)
 2015620:	10bfffc4 	addi	r2,r2,-1
 2015624:	1007883a 	mov	r3,r2
 2015628:	e0bff917 	ldw	r2,-28(fp)
 201562c:	10c00b8d 	sth	r3,46(r2)
 2015630:	e0bff917 	ldw	r2,-28(fp)
 2015634:	10800b8b 	ldhu	r2,46(r2)
 2015638:	10bfffcc 	andi	r2,r2,65535
 201563c:	10002c1e 	bne	r2,zero,20156f0 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 2015640:	e0bff917 	ldw	r2,-28(fp)
 2015644:	10800c03 	ldbu	r2,48(r2)
 2015648:	10803fcc 	andi	r2,r2,255
 201564c:	10800dcc 	andi	r2,r2,55
 2015650:	10000b26 	beq	r2,zero,2015680 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 2015654:	e0bff917 	ldw	r2,-28(fp)
 2015658:	10c00c03 	ldbu	r3,48(r2)
 201565c:	00bff204 	movi	r2,-56
 2015660:	1884703a 	and	r2,r3,r2
 2015664:	1007883a 	mov	r3,r2
 2015668:	e0bff917 	ldw	r2,-28(fp)
 201566c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 2015670:	e0bff917 	ldw	r2,-28(fp)
 2015674:	00c00044 	movi	r3,1
 2015678:	10c00c45 	stb	r3,49(r2)
 201567c:	00000206 	br	2015688 <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 2015680:	e0bff917 	ldw	r2,-28(fp)
 2015684:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 2015688:	e0bff917 	ldw	r2,-28(fp)
 201568c:	10800c03 	ldbu	r2,48(r2)
 2015690:	10803fcc 	andi	r2,r2,255
 2015694:	1080020c 	andi	r2,r2,8
 2015698:	1000151e 	bne	r2,zero,20156f0 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 201569c:	e0bff917 	ldw	r2,-28(fp)
 20156a0:	10c00d83 	ldbu	r3,54(r2)
 20156a4:	d0a75b03 	ldbu	r2,-25236(gp)
 20156a8:	1884b03a 	or	r2,r3,r2
 20156ac:	d0a75b05 	stb	r2,-25236(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 20156b0:	e0bff917 	ldw	r2,-28(fp)
 20156b4:	10800d03 	ldbu	r2,52(r2)
 20156b8:	10c03fcc 	andi	r3,r2,255
 20156bc:	e0bff917 	ldw	r2,-28(fp)
 20156c0:	10800d03 	ldbu	r2,52(r2)
 20156c4:	11003fcc 	andi	r4,r2,255
 20156c8:	d0a75b44 	addi	r2,gp,-25235
 20156cc:	2085883a 	add	r2,r4,r2
 20156d0:	11000003 	ldbu	r4,0(r2)
 20156d4:	e0bff917 	ldw	r2,-28(fp)
 20156d8:	10800d43 	ldbu	r2,53(r2)
 20156dc:	2084b03a 	or	r2,r4,r2
 20156e0:	1009883a 	mov	r4,r2
 20156e4:	d0a75b44 	addi	r2,gp,-25235
 20156e8:	1885883a 	add	r2,r3,r2
 20156ec:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 20156f0:	e0bff917 	ldw	r2,-28(fp)
 20156f4:	10800517 	ldw	r2,20(r2)
 20156f8:	e0bff915 	stw	r2,-28(fp)
 20156fc:	e0bffb17 	ldw	r2,-20(fp)
 2015700:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015704:	e0bffe17 	ldw	r2,-8(fp)
 2015708:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 201570c:	e0bff917 	ldw	r2,-28(fp)
 2015710:	10800c83 	ldbu	r2,50(r2)
 2015714:	10803fcc 	andi	r2,r2,255
 2015718:	10800518 	cmpnei	r2,r2,20
 201571c:	103fb21e 	bne	r2,zero,20155e8 <OSTimeTick+0xcc>
 2015720:	00000106 	br	2015728 <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 2015724:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 2015728:	e037883a 	mov	sp,fp
 201572c:	dfc00117 	ldw	ra,4(sp)
 2015730:	df000017 	ldw	fp,0(sp)
 2015734:	dec00204 	addi	sp,sp,8
 2015738:	f800283a 	ret

0201573c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 201573c:	deffff04 	addi	sp,sp,-4
 2015740:	df000015 	stw	fp,0(sp)
 2015744:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 2015748:	00804784 	movi	r2,286
}
 201574c:	e037883a 	mov	sp,fp
 2015750:	df000017 	ldw	fp,0(sp)
 2015754:	dec00104 	addi	sp,sp,4
 2015758:	f800283a 	ret

0201575c <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 201575c:	deffff04 	addi	sp,sp,-4
 2015760:	df000015 	stw	fp,0(sp)
 2015764:	d839883a 	mov	fp,sp
}
 2015768:	0001883a 	nop
 201576c:	e037883a 	mov	sp,fp
 2015770:	df000017 	ldw	fp,0(sp)
 2015774:	dec00104 	addi	sp,sp,4
 2015778:	f800283a 	ret

0201577c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 201577c:	defff804 	addi	sp,sp,-32
 2015780:	dfc00715 	stw	ra,28(sp)
 2015784:	df000615 	stw	fp,24(sp)
 2015788:	df000604 	addi	fp,sp,24
 201578c:	e13ffc15 	stw	r4,-16(fp)
 2015790:	e17ffd15 	stw	r5,-12(fp)
 2015794:	3007883a 	mov	r3,r6
 2015798:	3805883a 	mov	r2,r7
 201579c:	e0fffe05 	stb	r3,-8(fp)
 20157a0:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 20157a4:	e0bffc17 	ldw	r2,-16(fp)
 20157a8:	10800283 	ldbu	r2,10(r2)
 20157ac:	10c03fcc 	andi	r3,r2,255
 20157b0:	008080b4 	movhi	r2,514
 20157b4:	10be7e04 	addi	r2,r2,-1544
 20157b8:	10c5883a 	add	r2,r2,r3
 20157bc:	10800003 	ldbu	r2,0(r2)
 20157c0:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 20157c4:	e0bffa03 	ldbu	r2,-24(fp)
 20157c8:	e0fffc17 	ldw	r3,-16(fp)
 20157cc:	1885883a 	add	r2,r3,r2
 20157d0:	108002c4 	addi	r2,r2,11
 20157d4:	10800003 	ldbu	r2,0(r2)
 20157d8:	10c03fcc 	andi	r3,r2,255
 20157dc:	008080b4 	movhi	r2,514
 20157e0:	10be7e04 	addi	r2,r2,-1544
 20157e4:	10c5883a 	add	r2,r2,r3
 20157e8:	10800003 	ldbu	r2,0(r2)
 20157ec:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 20157f0:	e0bffa03 	ldbu	r2,-24(fp)
 20157f4:	100490fa 	slli	r2,r2,3
 20157f8:	1007883a 	mov	r3,r2
 20157fc:	e0bffa43 	ldbu	r2,-23(fp)
 2015800:	1885883a 	add	r2,r3,r2
 2015804:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 2015808:	e0fffa83 	ldbu	r3,-22(fp)
 201580c:	008080f4 	movhi	r2,515
 2015810:	10b97d04 	addi	r2,r2,-6668
 2015814:	18c7883a 	add	r3,r3,r3
 2015818:	18c7883a 	add	r3,r3,r3
 201581c:	10c5883a 	add	r2,r2,r3
 2015820:	10800017 	ldw	r2,0(r2)
 2015824:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 2015828:	e0bffb17 	ldw	r2,-20(fp)
 201582c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 2015830:	e0bffb17 	ldw	r2,-20(fp)
 2015834:	e0fffd17 	ldw	r3,-12(fp)
 2015838:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 201583c:	e0bffb17 	ldw	r2,-20(fp)
 2015840:	10800c03 	ldbu	r2,48(r2)
 2015844:	1007883a 	mov	r3,r2
 2015848:	e0bffe03 	ldbu	r2,-8(fp)
 201584c:	0084303a 	nor	r2,zero,r2
 2015850:	1884703a 	and	r2,r3,r2
 2015854:	1007883a 	mov	r3,r2
 2015858:	e0bffb17 	ldw	r2,-20(fp)
 201585c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 2015860:	e0bffb17 	ldw	r2,-20(fp)
 2015864:	e0ffff03 	ldbu	r3,-4(fp)
 2015868:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 201586c:	e0bffb17 	ldw	r2,-20(fp)
 2015870:	10800c03 	ldbu	r2,48(r2)
 2015874:	10803fcc 	andi	r2,r2,255
 2015878:	1080020c 	andi	r2,r2,8
 201587c:	1000111e 	bne	r2,zero,20158c4 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 2015880:	e0bffb17 	ldw	r2,-20(fp)
 2015884:	10c00d83 	ldbu	r3,54(r2)
 2015888:	d0a75b03 	ldbu	r2,-25236(gp)
 201588c:	1884b03a 	or	r2,r3,r2
 2015890:	d0a75b05 	stb	r2,-25236(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 2015894:	e0fffa03 	ldbu	r3,-24(fp)
 2015898:	e13ffa03 	ldbu	r4,-24(fp)
 201589c:	d0a75b44 	addi	r2,gp,-25235
 20158a0:	2085883a 	add	r2,r4,r2
 20158a4:	11000003 	ldbu	r4,0(r2)
 20158a8:	e0bffb17 	ldw	r2,-20(fp)
 20158ac:	10800d43 	ldbu	r2,53(r2)
 20158b0:	2084b03a 	or	r2,r4,r2
 20158b4:	1009883a 	mov	r4,r2
 20158b8:	d0a75b44 	addi	r2,gp,-25235
 20158bc:	1885883a 	add	r2,r3,r2
 20158c0:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 20158c4:	e17ffc17 	ldw	r5,-16(fp)
 20158c8:	e13ffb17 	ldw	r4,-20(fp)
 20158cc:	2015b740 	call	2015b74 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 20158d0:	e0bffb17 	ldw	r2,-20(fp)
 20158d4:	10800817 	ldw	r2,32(r2)
 20158d8:	10000826 	beq	r2,zero,20158fc <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 20158dc:	e0bffb17 	ldw	r2,-20(fp)
 20158e0:	10800817 	ldw	r2,32(r2)
 20158e4:	100b883a 	mov	r5,r2
 20158e8:	e13ffb17 	ldw	r4,-20(fp)
 20158ec:	2015c2c0 	call	2015c2c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 20158f0:	e0bffb17 	ldw	r2,-20(fp)
 20158f4:	e0fffc17 	ldw	r3,-16(fp)
 20158f8:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 20158fc:	e0bffa83 	ldbu	r2,-22(fp)
}
 2015900:	e037883a 	mov	sp,fp
 2015904:	dfc00117 	ldw	ra,4(sp)
 2015908:	df000017 	ldw	fp,0(sp)
 201590c:	dec00204 	addi	sp,sp,8
 2015910:	f800283a 	ret

02015914 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 2015914:	defffd04 	addi	sp,sp,-12
 2015918:	df000215 	stw	fp,8(sp)
 201591c:	df000204 	addi	fp,sp,8
 2015920:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 2015924:	d0a75e17 	ldw	r2,-25224(gp)
 2015928:	e0ffff17 	ldw	r3,-4(fp)
 201592c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 2015930:	d0a75e17 	ldw	r2,-25224(gp)
 2015934:	10800d03 	ldbu	r2,52(r2)
 2015938:	10803fcc 	andi	r2,r2,255
 201593c:	d0e75e17 	ldw	r3,-25224(gp)
 2015940:	18c00d03 	ldbu	r3,52(r3)
 2015944:	18c03fcc 	andi	r3,r3,255
 2015948:	e13fff17 	ldw	r4,-4(fp)
 201594c:	20c7883a 	add	r3,r4,r3
 2015950:	18c002c4 	addi	r3,r3,11
 2015954:	19000003 	ldbu	r4,0(r3)
 2015958:	d0e75e17 	ldw	r3,-25224(gp)
 201595c:	18c00d43 	ldbu	r3,53(r3)
 2015960:	20c6b03a 	or	r3,r4,r3
 2015964:	1809883a 	mov	r4,r3
 2015968:	e0ffff17 	ldw	r3,-4(fp)
 201596c:	1885883a 	add	r2,r3,r2
 2015970:	108002c4 	addi	r2,r2,11
 2015974:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 2015978:	e0bfff17 	ldw	r2,-4(fp)
 201597c:	10c00283 	ldbu	r3,10(r2)
 2015980:	d0a75e17 	ldw	r2,-25224(gp)
 2015984:	10800d83 	ldbu	r2,54(r2)
 2015988:	1884b03a 	or	r2,r3,r2
 201598c:	1007883a 	mov	r3,r2
 2015990:	e0bfff17 	ldw	r2,-4(fp)
 2015994:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 2015998:	d0a75e17 	ldw	r2,-25224(gp)
 201599c:	10800d03 	ldbu	r2,52(r2)
 20159a0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 20159a4:	e0fffe03 	ldbu	r3,-8(fp)
 20159a8:	e13ffe03 	ldbu	r4,-8(fp)
 20159ac:	d0a75b44 	addi	r2,gp,-25235
 20159b0:	2085883a 	add	r2,r4,r2
 20159b4:	10800003 	ldbu	r2,0(r2)
 20159b8:	1009883a 	mov	r4,r2
 20159bc:	d0a75e17 	ldw	r2,-25224(gp)
 20159c0:	10800d43 	ldbu	r2,53(r2)
 20159c4:	0084303a 	nor	r2,zero,r2
 20159c8:	2084703a 	and	r2,r4,r2
 20159cc:	1009883a 	mov	r4,r2
 20159d0:	d0a75b44 	addi	r2,gp,-25235
 20159d4:	1885883a 	add	r2,r3,r2
 20159d8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 20159dc:	e0fffe03 	ldbu	r3,-8(fp)
 20159e0:	d0a75b44 	addi	r2,gp,-25235
 20159e4:	1885883a 	add	r2,r3,r2
 20159e8:	10800003 	ldbu	r2,0(r2)
 20159ec:	10803fcc 	andi	r2,r2,255
 20159f0:	1000071e 	bne	r2,zero,2015a10 <OS_EventTaskWait+0xfc>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 20159f4:	d0a75e17 	ldw	r2,-25224(gp)
 20159f8:	10800d83 	ldbu	r2,54(r2)
 20159fc:	0084303a 	nor	r2,zero,r2
 2015a00:	1007883a 	mov	r3,r2
 2015a04:	d0a75b03 	ldbu	r2,-25236(gp)
 2015a08:	1884703a 	and	r2,r3,r2
 2015a0c:	d0a75b05 	stb	r2,-25236(gp)
    }
}
 2015a10:	0001883a 	nop
 2015a14:	e037883a 	mov	sp,fp
 2015a18:	df000017 	ldw	fp,0(sp)
 2015a1c:	dec00104 	addi	sp,sp,4
 2015a20:	f800283a 	ret

02015a24 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 2015a24:	defffb04 	addi	sp,sp,-20
 2015a28:	df000415 	stw	fp,16(sp)
 2015a2c:	df000404 	addi	fp,sp,16
 2015a30:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 2015a34:	d0a75e17 	ldw	r2,-25224(gp)
 2015a38:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 2015a3c:	d0a75e17 	ldw	r2,-25224(gp)
 2015a40:	e0ffff17 	ldw	r3,-4(fp)
 2015a44:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 2015a48:	e0bfff17 	ldw	r2,-4(fp)
 2015a4c:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 2015a50:	e0bffc17 	ldw	r2,-16(fp)
 2015a54:	10800017 	ldw	r2,0(r2)
 2015a58:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 2015a5c:	00002006 	br	2015ae0 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 2015a60:	d0a75e17 	ldw	r2,-25224(gp)
 2015a64:	10800d03 	ldbu	r2,52(r2)
 2015a68:	10803fcc 	andi	r2,r2,255
 2015a6c:	d0e75e17 	ldw	r3,-25224(gp)
 2015a70:	18c00d03 	ldbu	r3,52(r3)
 2015a74:	18c03fcc 	andi	r3,r3,255
 2015a78:	e13ffd17 	ldw	r4,-12(fp)
 2015a7c:	20c7883a 	add	r3,r4,r3
 2015a80:	18c002c4 	addi	r3,r3,11
 2015a84:	19000003 	ldbu	r4,0(r3)
 2015a88:	d0e75e17 	ldw	r3,-25224(gp)
 2015a8c:	18c00d43 	ldbu	r3,53(r3)
 2015a90:	20c6b03a 	or	r3,r4,r3
 2015a94:	1809883a 	mov	r4,r3
 2015a98:	e0fffd17 	ldw	r3,-12(fp)
 2015a9c:	1885883a 	add	r2,r3,r2
 2015aa0:	108002c4 	addi	r2,r2,11
 2015aa4:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 2015aa8:	e0bffd17 	ldw	r2,-12(fp)
 2015aac:	10c00283 	ldbu	r3,10(r2)
 2015ab0:	d0a75e17 	ldw	r2,-25224(gp)
 2015ab4:	10800d83 	ldbu	r2,54(r2)
 2015ab8:	1884b03a 	or	r2,r3,r2
 2015abc:	1007883a 	mov	r3,r2
 2015ac0:	e0bffd17 	ldw	r2,-12(fp)
 2015ac4:	10c00285 	stb	r3,10(r2)
        pevents++;
 2015ac8:	e0bffc17 	ldw	r2,-16(fp)
 2015acc:	10800104 	addi	r2,r2,4
 2015ad0:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 2015ad4:	e0bffc17 	ldw	r2,-16(fp)
 2015ad8:	10800017 	ldw	r2,0(r2)
 2015adc:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 2015ae0:	e0bffd17 	ldw	r2,-12(fp)
 2015ae4:	103fde1e 	bne	r2,zero,2015a60 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 2015ae8:	d0a75e17 	ldw	r2,-25224(gp)
 2015aec:	10800d03 	ldbu	r2,52(r2)
 2015af0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 2015af4:	e0fffe03 	ldbu	r3,-8(fp)
 2015af8:	e13ffe03 	ldbu	r4,-8(fp)
 2015afc:	d0a75b44 	addi	r2,gp,-25235
 2015b00:	2085883a 	add	r2,r4,r2
 2015b04:	10800003 	ldbu	r2,0(r2)
 2015b08:	1009883a 	mov	r4,r2
 2015b0c:	d0a75e17 	ldw	r2,-25224(gp)
 2015b10:	10800d43 	ldbu	r2,53(r2)
 2015b14:	0084303a 	nor	r2,zero,r2
 2015b18:	2084703a 	and	r2,r4,r2
 2015b1c:	1009883a 	mov	r4,r2
 2015b20:	d0a75b44 	addi	r2,gp,-25235
 2015b24:	1885883a 	add	r2,r3,r2
 2015b28:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 2015b2c:	e0fffe03 	ldbu	r3,-8(fp)
 2015b30:	d0a75b44 	addi	r2,gp,-25235
 2015b34:	1885883a 	add	r2,r3,r2
 2015b38:	10800003 	ldbu	r2,0(r2)
 2015b3c:	10803fcc 	andi	r2,r2,255
 2015b40:	1000071e 	bne	r2,zero,2015b60 <OS_EventTaskWaitMulti+0x13c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 2015b44:	d0a75e17 	ldw	r2,-25224(gp)
 2015b48:	10800d83 	ldbu	r2,54(r2)
 2015b4c:	0084303a 	nor	r2,zero,r2
 2015b50:	1007883a 	mov	r3,r2
 2015b54:	d0a75b03 	ldbu	r2,-25236(gp)
 2015b58:	1884703a 	and	r2,r3,r2
 2015b5c:	d0a75b05 	stb	r2,-25236(gp)
    }
}
 2015b60:	0001883a 	nop
 2015b64:	e037883a 	mov	sp,fp
 2015b68:	df000017 	ldw	fp,0(sp)
 2015b6c:	dec00104 	addi	sp,sp,4
 2015b70:	f800283a 	ret

02015b74 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 2015b74:	defffc04 	addi	sp,sp,-16
 2015b78:	df000315 	stw	fp,12(sp)
 2015b7c:	df000304 	addi	fp,sp,12
 2015b80:	e13ffe15 	stw	r4,-8(fp)
 2015b84:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 2015b88:	e0bffe17 	ldw	r2,-8(fp)
 2015b8c:	10800d03 	ldbu	r2,52(r2)
 2015b90:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 2015b94:	e0bffd03 	ldbu	r2,-12(fp)
 2015b98:	e0fffd03 	ldbu	r3,-12(fp)
 2015b9c:	e13fff17 	ldw	r4,-4(fp)
 2015ba0:	20c7883a 	add	r3,r4,r3
 2015ba4:	18c002c4 	addi	r3,r3,11
 2015ba8:	18c00003 	ldbu	r3,0(r3)
 2015bac:	1809883a 	mov	r4,r3
 2015bb0:	e0fffe17 	ldw	r3,-8(fp)
 2015bb4:	18c00d43 	ldbu	r3,53(r3)
 2015bb8:	00c6303a 	nor	r3,zero,r3
 2015bbc:	20c6703a 	and	r3,r4,r3
 2015bc0:	1809883a 	mov	r4,r3
 2015bc4:	e0ffff17 	ldw	r3,-4(fp)
 2015bc8:	1885883a 	add	r2,r3,r2
 2015bcc:	108002c4 	addi	r2,r2,11
 2015bd0:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
 2015bd4:	e0bffd03 	ldbu	r2,-12(fp)
 2015bd8:	e0ffff17 	ldw	r3,-4(fp)
 2015bdc:	1885883a 	add	r2,r3,r2
 2015be0:	108002c4 	addi	r2,r2,11
 2015be4:	10800003 	ldbu	r2,0(r2)
 2015be8:	10803fcc 	andi	r2,r2,255
 2015bec:	10000a1e 	bne	r2,zero,2015c18 <OS_EventTaskRemove+0xa4>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 2015bf0:	e0bfff17 	ldw	r2,-4(fp)
 2015bf4:	10800283 	ldbu	r2,10(r2)
 2015bf8:	1007883a 	mov	r3,r2
 2015bfc:	e0bffe17 	ldw	r2,-8(fp)
 2015c00:	10800d83 	ldbu	r2,54(r2)
 2015c04:	0084303a 	nor	r2,zero,r2
 2015c08:	1884703a 	and	r2,r3,r2
 2015c0c:	1007883a 	mov	r3,r2
 2015c10:	e0bfff17 	ldw	r2,-4(fp)
 2015c14:	10c00285 	stb	r3,10(r2)
    }
}
 2015c18:	0001883a 	nop
 2015c1c:	e037883a 	mov	sp,fp
 2015c20:	df000017 	ldw	fp,0(sp)
 2015c24:	dec00104 	addi	sp,sp,4
 2015c28:	f800283a 	ret

02015c2c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 2015c2c:	defffa04 	addi	sp,sp,-24
 2015c30:	df000515 	stw	fp,20(sp)
 2015c34:	df000504 	addi	fp,sp,20
 2015c38:	e13ffe15 	stw	r4,-8(fp)
 2015c3c:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 2015c40:	e0bffe17 	ldw	r2,-8(fp)
 2015c44:	10800d03 	ldbu	r2,52(r2)
 2015c48:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 2015c4c:	e0bffe17 	ldw	r2,-8(fp)
 2015c50:	10800d83 	ldbu	r2,54(r2)
 2015c54:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 2015c58:	e0bffe17 	ldw	r2,-8(fp)
 2015c5c:	10800d43 	ldbu	r2,53(r2)
 2015c60:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 2015c64:	e0bfff17 	ldw	r2,-4(fp)
 2015c68:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 2015c6c:	e0bffb17 	ldw	r2,-20(fp)
 2015c70:	10800017 	ldw	r2,0(r2)
 2015c74:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 2015c78:	00002506 	br	2015d10 <OS_EventTaskRemoveMulti+0xe4>
        pevent->OSEventTbl[y]  &= ~bitx;
 2015c7c:	e0bffd03 	ldbu	r2,-12(fp)
 2015c80:	e0fffd03 	ldbu	r3,-12(fp)
 2015c84:	e13ffc17 	ldw	r4,-16(fp)
 2015c88:	20c7883a 	add	r3,r4,r3
 2015c8c:	18c002c4 	addi	r3,r3,11
 2015c90:	18c00003 	ldbu	r3,0(r3)
 2015c94:	1809883a 	mov	r4,r3
 2015c98:	e0fffd83 	ldbu	r3,-10(fp)
 2015c9c:	00c6303a 	nor	r3,zero,r3
 2015ca0:	20c6703a 	and	r3,r4,r3
 2015ca4:	1809883a 	mov	r4,r3
 2015ca8:	e0fffc17 	ldw	r3,-16(fp)
 2015cac:	1885883a 	add	r2,r3,r2
 2015cb0:	108002c4 	addi	r2,r2,11
 2015cb4:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
 2015cb8:	e0bffd03 	ldbu	r2,-12(fp)
 2015cbc:	e0fffc17 	ldw	r3,-16(fp)
 2015cc0:	1885883a 	add	r2,r3,r2
 2015cc4:	108002c4 	addi	r2,r2,11
 2015cc8:	10800003 	ldbu	r2,0(r2)
 2015ccc:	10803fcc 	andi	r2,r2,255
 2015cd0:	1000091e 	bne	r2,zero,2015cf8 <OS_EventTaskRemoveMulti+0xcc>
            pevent->OSEventGrp &= ~bity;
 2015cd4:	e0bffc17 	ldw	r2,-16(fp)
 2015cd8:	10800283 	ldbu	r2,10(r2)
 2015cdc:	1007883a 	mov	r3,r2
 2015ce0:	e0bffd43 	ldbu	r2,-11(fp)
 2015ce4:	0084303a 	nor	r2,zero,r2
 2015ce8:	1884703a 	and	r2,r3,r2
 2015cec:	1007883a 	mov	r3,r2
 2015cf0:	e0bffc17 	ldw	r2,-16(fp)
 2015cf4:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 2015cf8:	e0bffb17 	ldw	r2,-20(fp)
 2015cfc:	10800104 	addi	r2,r2,4
 2015d00:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 2015d04:	e0bffb17 	ldw	r2,-20(fp)
 2015d08:	10800017 	ldw	r2,0(r2)
 2015d0c:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 2015d10:	e0bffc17 	ldw	r2,-16(fp)
 2015d14:	103fd91e 	bne	r2,zero,2015c7c <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 2015d18:	0001883a 	nop
 2015d1c:	e037883a 	mov	sp,fp
 2015d20:	df000017 	ldw	fp,0(sp)
 2015d24:	dec00104 	addi	sp,sp,4
 2015d28:	f800283a 	ret

02015d2c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 2015d2c:	defffc04 	addi	sp,sp,-16
 2015d30:	df000315 	stw	fp,12(sp)
 2015d34:	df000304 	addi	fp,sp,12
 2015d38:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 2015d3c:	e0bfff17 	ldw	r2,-4(fp)
 2015d40:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 2015d44:	e0bfff17 	ldw	r2,-4(fp)
 2015d48:	108002c4 	addi	r2,r2,11
 2015d4c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 2015d50:	e03ffe05 	stb	zero,-8(fp)
 2015d54:	00000706 	br	2015d74 <OS_EventWaitListInit+0x48>
        *ptbl++ = 0;
 2015d58:	e0bffd17 	ldw	r2,-12(fp)
 2015d5c:	10c00044 	addi	r3,r2,1
 2015d60:	e0fffd15 	stw	r3,-12(fp)
 2015d64:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 2015d68:	e0bffe03 	ldbu	r2,-8(fp)
 2015d6c:	10800044 	addi	r2,r2,1
 2015d70:	e0bffe05 	stb	r2,-8(fp)
 2015d74:	e0bffe03 	ldbu	r2,-8(fp)
 2015d78:	108000f0 	cmpltui	r2,r2,3
 2015d7c:	103ff61e 	bne	r2,zero,2015d58 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 2015d80:	0001883a 	nop
 2015d84:	e037883a 	mov	sp,fp
 2015d88:	df000017 	ldw	fp,0(sp)
 2015d8c:	dec00104 	addi	sp,sp,4
 2015d90:	f800283a 	ret

02015d94 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 2015d94:	defffb04 	addi	sp,sp,-20
 2015d98:	dfc00415 	stw	ra,16(sp)
 2015d9c:	df000315 	stw	fp,12(sp)
 2015da0:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 2015da4:	0142d004 	movi	r5,2880
 2015da8:	010080f4 	movhi	r4,515
 2015dac:	21356904 	addi	r4,r4,-10844
 2015db0:	201610c0 	call	201610c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 2015db4:	008080f4 	movhi	r2,515
 2015db8:	10b56904 	addi	r2,r2,-10844
 2015dbc:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 2015dc0:	008080f4 	movhi	r2,515
 2015dc4:	10b57504 	addi	r2,r2,-10796
 2015dc8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 2015dcc:	e03ffd0d 	sth	zero,-12(fp)
 2015dd0:	00001306 	br	2015e20 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2015dd4:	e0bffe17 	ldw	r2,-8(fp)
 2015dd8:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 2015ddc:	e0bffe17 	ldw	r2,-8(fp)
 2015de0:	e0ffff17 	ldw	r3,-4(fp)
 2015de4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 2015de8:	e0bffe17 	ldw	r2,-8(fp)
 2015dec:	00c00fc4 	movi	r3,63
 2015df0:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 2015df4:	e0bffe17 	ldw	r2,-8(fp)
 2015df8:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 2015dfc:	e0bffe17 	ldw	r2,-8(fp)
 2015e00:	10800c04 	addi	r2,r2,48
 2015e04:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 2015e08:	e0bfff17 	ldw	r2,-4(fp)
 2015e0c:	10800c04 	addi	r2,r2,48
 2015e10:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 2015e14:	e0bffd0b 	ldhu	r2,-12(fp)
 2015e18:	10800044 	addi	r2,r2,1
 2015e1c:	e0bffd0d 	sth	r2,-12(fp)
 2015e20:	e0bffd0b 	ldhu	r2,-12(fp)
 2015e24:	10800ef0 	cmpltui	r2,r2,59
 2015e28:	103fea1e 	bne	r2,zero,2015dd4 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 2015e2c:	e0bffe17 	ldw	r2,-8(fp)
 2015e30:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 2015e34:	e0bffe17 	ldw	r2,-8(fp)
 2015e38:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 2015e3c:	e0bffe17 	ldw	r2,-8(fp)
 2015e40:	00c00fc4 	movi	r3,63
 2015e44:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 2015e48:	e0bffe17 	ldw	r2,-8(fp)
 2015e4c:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 2015e50:	008080f4 	movhi	r2,515
 2015e54:	10b56904 	addi	r2,r2,-10844
 2015e58:	d0a75c15 	stw	r2,-25232(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 2015e5c:	0001883a 	nop
 2015e60:	e037883a 	mov	sp,fp
 2015e64:	dfc00117 	ldw	ra,4(sp)
 2015e68:	df000017 	ldw	fp,0(sp)
 2015e6c:	dec00204 	addi	sp,sp,8
 2015e70:	f800283a 	ret

02015e74 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 2015e74:	deffff04 	addi	sp,sp,-4
 2015e78:	df000015 	stw	fp,0(sp)
 2015e7c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 2015e80:	d0275f15 	stw	zero,-25220(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 2015e84:	d0275d05 	stb	zero,-25228(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 2015e88:	d0274f05 	stb	zero,-25284(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 2015e8c:	d0275745 	stb	zero,-25251(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 2015e90:	d0274f45 	stb	zero,-25283(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 2015e94:	d0275415 	stw	zero,-25264(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 2015e98:	d0275015 	stw	zero,-25280(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 2015e9c:	d0276215 	stw	zero,-25208(gp)
    OSIdleCtrMax  = 0L;
 2015ea0:	d0275515 	stw	zero,-25260(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 2015ea4:	d0276105 	stb	zero,-25212(gp)
#endif
}
 2015ea8:	0001883a 	nop
 2015eac:	e037883a 	mov	sp,fp
 2015eb0:	df000017 	ldw	fp,0(sp)
 2015eb4:	dec00104 	addi	sp,sp,4
 2015eb8:	f800283a 	ret

02015ebc <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 2015ebc:	defffd04 	addi	sp,sp,-12
 2015ec0:	df000215 	stw	fp,8(sp)
 2015ec4:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 2015ec8:	d0275b05 	stb	zero,-25236(gp)
    prdytbl       = &OSRdyTbl[0];
 2015ecc:	d0a75b44 	addi	r2,gp,-25235
 2015ed0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 2015ed4:	e03ffe05 	stb	zero,-8(fp)
 2015ed8:	00000706 	br	2015ef8 <OS_InitRdyList+0x3c>
        *prdytbl++ = 0;
 2015edc:	e0bfff17 	ldw	r2,-4(fp)
 2015ee0:	10c00044 	addi	r3,r2,1
 2015ee4:	e0ffff15 	stw	r3,-4(fp)
 2015ee8:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 2015eec:	e0bffe03 	ldbu	r2,-8(fp)
 2015ef0:	10800044 	addi	r2,r2,1
 2015ef4:	e0bffe05 	stb	r2,-8(fp)
 2015ef8:	e0bffe03 	ldbu	r2,-8(fp)
 2015efc:	108000f0 	cmpltui	r2,r2,3
 2015f00:	103ff61e 	bne	r2,zero,2015edc <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 2015f04:	d0275145 	stb	zero,-25275(gp)
    OSPrioHighRdy = 0;
 2015f08:	d0275105 	stb	zero,-25276(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 2015f0c:	d0275915 	stw	zero,-25244(gp)
    OSTCBCur      = (OS_TCB *)0;
 2015f10:	d0275e15 	stw	zero,-25224(gp)
}
 2015f14:	0001883a 	nop
 2015f18:	e037883a 	mov	sp,fp
 2015f1c:	df000017 	ldw	fp,0(sp)
 2015f20:	dec00104 	addi	sp,sp,4
 2015f24:	f800283a 	ret

02015f28 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 2015f28:	defff804 	addi	sp,sp,-32
 2015f2c:	dfc00715 	stw	ra,28(sp)
 2015f30:	df000615 	stw	fp,24(sp)
 2015f34:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 2015f38:	008000c4 	movi	r2,3
 2015f3c:	d8800415 	stw	r2,16(sp)
 2015f40:	d8000315 	stw	zero,12(sp)
 2015f44:	00808004 	movi	r2,512
 2015f48:	d8800215 	stw	r2,8(sp)
 2015f4c:	008080f4 	movhi	r2,515
 2015f50:	10b36904 	addi	r2,r2,-12892
 2015f54:	d8800115 	stw	r2,4(sp)
 2015f58:	00bfffd4 	movui	r2,65535
 2015f5c:	d8800015 	stw	r2,0(sp)
 2015f60:	01c00504 	movi	r7,20
 2015f64:	018080f4 	movhi	r6,515
 2015f68:	31b56804 	addi	r6,r6,-10848
 2015f6c:	000b883a 	mov	r5,zero
 2015f70:	01008074 	movhi	r4,513
 2015f74:	2118f504 	addi	r4,r4,25556
 2015f78:	201b55c0 	call	201b55c <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 2015f7c:	e1bfff04 	addi	r6,fp,-4
 2015f80:	014080b4 	movhi	r5,514
 2015f84:	297ebe04 	addi	r5,r5,-1288
 2015f88:	01000504 	movi	r4,20
 2015f8c:	201bd6c0 	call	201bd6c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 2015f90:	0001883a 	nop
 2015f94:	e037883a 	mov	sp,fp
 2015f98:	dfc00117 	ldw	ra,4(sp)
 2015f9c:	df000017 	ldw	fp,0(sp)
 2015fa0:	dec00204 	addi	sp,sp,8
 2015fa4:	f800283a 	ret

02015fa8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 2015fa8:	defff804 	addi	sp,sp,-32
 2015fac:	dfc00715 	stw	ra,28(sp)
 2015fb0:	df000615 	stw	fp,24(sp)
 2015fb4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 2015fb8:	008000c4 	movi	r2,3
 2015fbc:	d8800415 	stw	r2,16(sp)
 2015fc0:	d8000315 	stw	zero,12(sp)
 2015fc4:	00808004 	movi	r2,512
 2015fc8:	d8800215 	stw	r2,8(sp)
 2015fcc:	008080f4 	movhi	r2,515
 2015fd0:	10b0f104 	addi	r2,r2,-15420
 2015fd4:	d8800115 	stw	r2,4(sp)
 2015fd8:	00bfff94 	movui	r2,65534
 2015fdc:	d8800015 	stw	r2,0(sp)
 2015fe0:	01c004c4 	movi	r7,19
 2015fe4:	018080f4 	movhi	r6,515
 2015fe8:	31b2f004 	addi	r6,r6,-13376
 2015fec:	000b883a 	mov	r5,zero
 2015ff0:	01008074 	movhi	r4,513
 2015ff4:	21190c04 	addi	r4,r4,25648
 2015ff8:	201b55c0 	call	201b55c <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 2015ffc:	e1bfff04 	addi	r6,fp,-4
 2016000:	014080b4 	movhi	r5,514
 2016004:	297ec204 	addi	r5,r5,-1272
 2016008:	010004c4 	movi	r4,19
 201600c:	201bd6c0 	call	201bd6c <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 2016010:	0001883a 	nop
 2016014:	e037883a 	mov	sp,fp
 2016018:	dfc00117 	ldw	ra,4(sp)
 201601c:	df000017 	ldw	fp,0(sp)
 2016020:	dec00204 	addi	sp,sp,8
 2016024:	f800283a 	ret

02016028 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 2016028:	defffb04 	addi	sp,sp,-20
 201602c:	dfc00415 	stw	ra,16(sp)
 2016030:	df000315 	stw	fp,12(sp)
 2016034:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 2016038:	01414404 	movi	r5,1296
 201603c:	010080f4 	movhi	r4,515
 2016040:	21383904 	addi	r4,r4,-7964
 2016044:	201610c0 	call	201610c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 2016048:	01401504 	movi	r5,84
 201604c:	010080f4 	movhi	r4,515
 2016050:	21397d04 	addi	r4,r4,-6668
 2016054:	201610c0 	call	201610c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 2016058:	008080f4 	movhi	r2,515
 201605c:	10b83904 	addi	r2,r2,-7964
 2016060:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 2016064:	008080f4 	movhi	r2,515
 2016068:	10b85404 	addi	r2,r2,-7856
 201606c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 2016070:	e03ffd05 	stb	zero,-12(fp)
 2016074:	00001106 	br	20160bc <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 2016078:	e0bffe17 	ldw	r2,-8(fp)
 201607c:	e0ffff17 	ldw	r3,-4(fp)
 2016080:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 2016084:	e0bffe17 	ldw	r2,-8(fp)
 2016088:	00c00fc4 	movi	r3,63
 201608c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 2016090:	e0bffe17 	ldw	r2,-8(fp)
 2016094:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 2016098:	e0bffe17 	ldw	r2,-8(fp)
 201609c:	10801b04 	addi	r2,r2,108
 20160a0:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 20160a4:	e0bfff17 	ldw	r2,-4(fp)
 20160a8:	10801b04 	addi	r2,r2,108
 20160ac:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 20160b0:	e0bffd03 	ldbu	r2,-12(fp)
 20160b4:	10800044 	addi	r2,r2,1
 20160b8:	e0bffd05 	stb	r2,-12(fp)
 20160bc:	e0bffd03 	ldbu	r2,-12(fp)
 20160c0:	108002f0 	cmpltui	r2,r2,11
 20160c4:	103fec1e 	bne	r2,zero,2016078 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 20160c8:	e0bffe17 	ldw	r2,-8(fp)
 20160cc:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 20160d0:	e0bffe17 	ldw	r2,-8(fp)
 20160d4:	00c00fc4 	movi	r3,63
 20160d8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 20160dc:	e0bffe17 	ldw	r2,-8(fp)
 20160e0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 20160e4:	d0275215 	stw	zero,-25272(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 20160e8:	008080f4 	movhi	r2,515
 20160ec:	10b83904 	addi	r2,r2,-7964
 20160f0:	d0a75615 	stw	r2,-25256(gp)
}
 20160f4:	0001883a 	nop
 20160f8:	e037883a 	mov	sp,fp
 20160fc:	dfc00117 	ldw	ra,4(sp)
 2016100:	df000017 	ldw	fp,0(sp)
 2016104:	dec00204 	addi	sp,sp,8
 2016108:	f800283a 	ret

0201610c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 201610c:	defffd04 	addi	sp,sp,-12
 2016110:	df000215 	stw	fp,8(sp)
 2016114:	df000204 	addi	fp,sp,8
 2016118:	e13ffe15 	stw	r4,-8(fp)
 201611c:	2805883a 	mov	r2,r5
 2016120:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 2016124:	00000706 	br	2016144 <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 2016128:	e0bffe17 	ldw	r2,-8(fp)
 201612c:	10c00044 	addi	r3,r2,1
 2016130:	e0fffe15 	stw	r3,-8(fp)
 2016134:	10000005 	stb	zero,0(r2)
        size--;
 2016138:	e0bfff0b 	ldhu	r2,-4(fp)
 201613c:	10bfffc4 	addi	r2,r2,-1
 2016140:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 2016144:	e0bfff0b 	ldhu	r2,-4(fp)
 2016148:	103ff71e 	bne	r2,zero,2016128 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 201614c:	0001883a 	nop
 2016150:	e037883a 	mov	sp,fp
 2016154:	df000017 	ldw	fp,0(sp)
 2016158:	dec00104 	addi	sp,sp,4
 201615c:	f800283a 	ret

02016160 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 2016160:	defffc04 	addi	sp,sp,-16
 2016164:	df000315 	stw	fp,12(sp)
 2016168:	df000304 	addi	fp,sp,12
 201616c:	e13ffd15 	stw	r4,-12(fp)
 2016170:	e17ffe15 	stw	r5,-8(fp)
 2016174:	3005883a 	mov	r2,r6
 2016178:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 201617c:	00000b06 	br	20161ac <OS_MemCopy+0x4c>
        *pdest++ = *psrc++;
 2016180:	e0bffd17 	ldw	r2,-12(fp)
 2016184:	10c00044 	addi	r3,r2,1
 2016188:	e0fffd15 	stw	r3,-12(fp)
 201618c:	e0fffe17 	ldw	r3,-8(fp)
 2016190:	19000044 	addi	r4,r3,1
 2016194:	e13ffe15 	stw	r4,-8(fp)
 2016198:	18c00003 	ldbu	r3,0(r3)
 201619c:	10c00005 	stb	r3,0(r2)
        size--;
 20161a0:	e0bfff0b 	ldhu	r2,-4(fp)
 20161a4:	10bfffc4 	addi	r2,r2,-1
 20161a8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 20161ac:	e0bfff0b 	ldhu	r2,-4(fp)
 20161b0:	103ff31e 	bne	r2,zero,2016180 <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 20161b4:	0001883a 	nop
 20161b8:	e037883a 	mov	sp,fp
 20161bc:	df000017 	ldw	fp,0(sp)
 20161c0:	dec00104 	addi	sp,sp,4
 20161c4:	f800283a 	ret

020161c8 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 20161c8:	defffb04 	addi	sp,sp,-20
 20161cc:	dfc00415 	stw	ra,16(sp)
 20161d0:	df000315 	stw	fp,12(sp)
 20161d4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 20161d8:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20161dc:	0005303a 	rdctl	r2,status
 20161e0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20161e4:	e0ffff17 	ldw	r3,-4(fp)
 20161e8:	00bfff84 	movi	r2,-2
 20161ec:	1884703a 	and	r2,r3,r2
 20161f0:	1001703a 	wrctl	status,r2
  
  return context;
 20161f4:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
 20161f8:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 20161fc:	d0a75d03 	ldbu	r2,-25228(gp)
 2016200:	10803fcc 	andi	r2,r2,255
 2016204:	10001a1e 	bne	r2,zero,2016270 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 2016208:	d0a74f03 	ldbu	r2,-25284(gp)
 201620c:	10803fcc 	andi	r2,r2,255
 2016210:	1000171e 	bne	r2,zero,2016270 <OS_Sched+0xa8>
            OS_SchedNew();
 2016214:	20162980 	call	2016298 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 2016218:	d0e75103 	ldbu	r3,-25276(gp)
 201621c:	d0a75143 	ldbu	r2,-25275(gp)
 2016220:	18c03fcc 	andi	r3,r3,255
 2016224:	10803fcc 	andi	r2,r2,255
 2016228:	18801126 	beq	r3,r2,2016270 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 201622c:	d0a75103 	ldbu	r2,-25276(gp)
 2016230:	10c03fcc 	andi	r3,r2,255
 2016234:	008080f4 	movhi	r2,515
 2016238:	10b97d04 	addi	r2,r2,-6668
 201623c:	18c7883a 	add	r3,r3,r3
 2016240:	18c7883a 	add	r3,r3,r3
 2016244:	10c5883a 	add	r2,r2,r3
 2016248:	10800017 	ldw	r2,0(r2)
 201624c:	d0a75915 	stw	r2,-25244(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 2016250:	d0a75917 	ldw	r2,-25244(gp)
 2016254:	10c00e17 	ldw	r3,56(r2)
 2016258:	18c00044 	addi	r3,r3,1
 201625c:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 2016260:	d0a75417 	ldw	r2,-25264(gp)
 2016264:	10800044 	addi	r2,r2,1
 2016268:	d0a75415 	stw	r2,-25264(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 201626c:	201e8640 	call	201e864 <OSCtxSw>
 2016270:	e0bffd17 	ldw	r2,-12(fp)
 2016274:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016278:	e0bffe17 	ldw	r2,-8(fp)
 201627c:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 2016280:	0001883a 	nop
 2016284:	e037883a 	mov	sp,fp
 2016288:	dfc00117 	ldw	ra,4(sp)
 201628c:	df000017 	ldw	fp,0(sp)
 2016290:	dec00204 	addi	sp,sp,8
 2016294:	f800283a 	ret

02016298 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 2016298:	defffe04 	addi	sp,sp,-8
 201629c:	df000115 	stw	fp,4(sp)
 20162a0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 20162a4:	d0a75b03 	ldbu	r2,-25236(gp)
 20162a8:	10c03fcc 	andi	r3,r2,255
 20162ac:	008080b4 	movhi	r2,514
 20162b0:	10be7e04 	addi	r2,r2,-1544
 20162b4:	10c5883a 	add	r2,r2,r3
 20162b8:	10800003 	ldbu	r2,0(r2)
 20162bc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 20162c0:	e0bfff03 	ldbu	r2,-4(fp)
 20162c4:	100490fa 	slli	r2,r2,3
 20162c8:	1009883a 	mov	r4,r2
 20162cc:	e0ffff03 	ldbu	r3,-4(fp)
 20162d0:	d0a75b44 	addi	r2,gp,-25235
 20162d4:	1885883a 	add	r2,r3,r2
 20162d8:	10800003 	ldbu	r2,0(r2)
 20162dc:	10c03fcc 	andi	r3,r2,255
 20162e0:	008080b4 	movhi	r2,514
 20162e4:	10be7e04 	addi	r2,r2,-1544
 20162e8:	10c5883a 	add	r2,r2,r3
 20162ec:	10800003 	ldbu	r2,0(r2)
 20162f0:	2085883a 	add	r2,r4,r2
 20162f4:	d0a75105 	stb	r2,-25276(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 20162f8:	0001883a 	nop
 20162fc:	e037883a 	mov	sp,fp
 2016300:	df000017 	ldw	fp,0(sp)
 2016304:	dec00104 	addi	sp,sp,4
 2016308:	f800283a 	ret

0201630c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 201630c:	defffc04 	addi	sp,sp,-16
 2016310:	df000315 	stw	fp,12(sp)
 2016314:	df000304 	addi	fp,sp,12
 2016318:	e13ffe15 	stw	r4,-8(fp)
 201631c:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 2016320:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 2016324:	00000b06 	br	2016354 <OS_StrCopy+0x48>
        *pdest++ = *psrc++;
 2016328:	e0bffe17 	ldw	r2,-8(fp)
 201632c:	10c00044 	addi	r3,r2,1
 2016330:	e0fffe15 	stw	r3,-8(fp)
 2016334:	e0ffff17 	ldw	r3,-4(fp)
 2016338:	19000044 	addi	r4,r3,1
 201633c:	e13fff15 	stw	r4,-4(fp)
 2016340:	18c00003 	ldbu	r3,0(r3)
 2016344:	10c00005 	stb	r3,0(r2)
        len++;
 2016348:	e0bffd03 	ldbu	r2,-12(fp)
 201634c:	10800044 	addi	r2,r2,1
 2016350:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 2016354:	e0bfff17 	ldw	r2,-4(fp)
 2016358:	10800003 	ldbu	r2,0(r2)
 201635c:	10803fcc 	andi	r2,r2,255
 2016360:	103ff11e 	bne	r2,zero,2016328 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 2016364:	e0bffe17 	ldw	r2,-8(fp)
 2016368:	10000005 	stb	zero,0(r2)
    return (len);
 201636c:	e0bffd03 	ldbu	r2,-12(fp)
}
 2016370:	e037883a 	mov	sp,fp
 2016374:	df000017 	ldw	fp,0(sp)
 2016378:	dec00104 	addi	sp,sp,4
 201637c:	f800283a 	ret

02016380 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 2016380:	defffd04 	addi	sp,sp,-12
 2016384:	df000215 	stw	fp,8(sp)
 2016388:	df000204 	addi	fp,sp,8
 201638c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 2016390:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 2016394:	00000606 	br	20163b0 <OS_StrLen+0x30>
        psrc++;
 2016398:	e0bfff17 	ldw	r2,-4(fp)
 201639c:	10800044 	addi	r2,r2,1
 20163a0:	e0bfff15 	stw	r2,-4(fp)
        len++;
 20163a4:	e0bffe03 	ldbu	r2,-8(fp)
 20163a8:	10800044 	addi	r2,r2,1
 20163ac:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 20163b0:	e0bfff17 	ldw	r2,-4(fp)
 20163b4:	10800003 	ldbu	r2,0(r2)
 20163b8:	10803fcc 	andi	r2,r2,255
 20163bc:	103ff61e 	bne	r2,zero,2016398 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 20163c0:	e0bffe03 	ldbu	r2,-8(fp)
}
 20163c4:	e037883a 	mov	sp,fp
 20163c8:	df000017 	ldw	fp,0(sp)
 20163cc:	dec00104 	addi	sp,sp,4
 20163d0:	f800283a 	ret

020163d4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 20163d4:	defffa04 	addi	sp,sp,-24
 20163d8:	dfc00515 	stw	ra,20(sp)
 20163dc:	df000415 	stw	fp,16(sp)
 20163e0:	df000404 	addi	fp,sp,16
 20163e4:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20163e8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20163ec:	0005303a 	rdctl	r2,status
 20163f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20163f4:	e0fffd17 	ldw	r3,-12(fp)
 20163f8:	00bfff84 	movi	r2,-2
 20163fc:	1884703a 	and	r2,r3,r2
 2016400:	1001703a 	wrctl	status,r2
  
  return context;
 2016404:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 2016408:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 201640c:	d0a75017 	ldw	r2,-25280(gp)
 2016410:	10800044 	addi	r2,r2,1
 2016414:	d0a75015 	stw	r2,-25280(gp)
 2016418:	e0bffc17 	ldw	r2,-16(fp)
 201641c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016420:	e0bffe17 	ldw	r2,-8(fp)
 2016424:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 2016428:	201eb780 	call	201eb78 <OSTaskIdleHook>
    }
 201642c:	003fef06 	br	20163ec <OS_TaskIdle+0x18>

02016430 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 2016430:	defffa04 	addi	sp,sp,-24
 2016434:	dfc00515 	stw	ra,20(sp)
 2016438:	df000415 	stw	fp,16(sp)
 201643c:	df000404 	addi	fp,sp,16
 2016440:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2016444:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 2016448:	00000206 	br	2016454 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 201644c:	01003204 	movi	r4,200
 2016450:	201c62c0 	call	201c62c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 2016454:	d0a76103 	ldbu	r2,-25212(gp)
 2016458:	10803fcc 	andi	r2,r2,255
 201645c:	103ffb26 	beq	r2,zero,201644c <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 2016460:	d0a75517 	ldw	r2,-25260(gp)
 2016464:	01401904 	movi	r5,100
 2016468:	1009883a 	mov	r4,r2
 201646c:	2003fd80 	call	2003fd8 <__udivsi3>
 2016470:	d0a75515 	stw	r2,-25260(gp)
    if (OSIdleCtrMax == 0L) {
 2016474:	d0a75517 	ldw	r2,-25260(gp)
 2016478:	1000031e 	bne	r2,zero,2016488 <OS_TaskStat+0x58>
        OSCPUUsage = 0;
 201647c:	d0275705 	stb	zero,-25252(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 2016480:	01003fc4 	movi	r4,255
 2016484:	201c2b40 	call	201c2b4 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016488:	0005303a 	rdctl	r2,status
 201648c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016490:	e0fffd17 	ldw	r3,-12(fp)
 2016494:	00bfff84 	movi	r2,-2
 2016498:	1884703a 	and	r2,r3,r2
 201649c:	1001703a 	wrctl	status,r2
  
  return context;
 20164a0:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 20164a4:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 20164a8:	d0a75017 	ldw	r2,-25280(gp)
 20164ac:	d0a76215 	stw	r2,-25208(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 20164b0:	d0275015 	stw	zero,-25280(gp)
 20164b4:	e0bffc17 	ldw	r2,-16(fp)
 20164b8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20164bc:	e0bffe17 	ldw	r2,-8(fp)
 20164c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 20164c4:	d0a76217 	ldw	r2,-25208(gp)
 20164c8:	d0e75517 	ldw	r3,-25260(gp)
 20164cc:	180b883a 	mov	r5,r3
 20164d0:	1009883a 	mov	r4,r2
 20164d4:	2003fd80 	call	2003fd8 <__udivsi3>
 20164d8:	1007883a 	mov	r3,r2
 20164dc:	00801904 	movi	r2,100
 20164e0:	10c5c83a 	sub	r2,r2,r3
 20164e4:	d0a75705 	stb	r2,-25252(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 20164e8:	201eaf80 	call	201eaf8 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 20164ec:	20164fc0 	call	20164fc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 20164f0:	01001904 	movi	r4,100
 20164f4:	201c62c0 	call	201c62c <OSTimeDly>
    }
 20164f8:	003fe306 	br	2016488 <OS_TaskStat+0x58>

020164fc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 20164fc:	defffa04 	addi	sp,sp,-24
 2016500:	dfc00515 	stw	ra,20(sp)
 2016504:	df000415 	stw	fp,16(sp)
 2016508:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 201650c:	e03ffc05 	stb	zero,-16(fp)
 2016510:	00002406 	br	20165a4 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 2016514:	e0bffc03 	ldbu	r2,-16(fp)
 2016518:	e0fffe04 	addi	r3,fp,-8
 201651c:	180b883a 	mov	r5,r3
 2016520:	1009883a 	mov	r4,r2
 2016524:	201c0f40 	call	201c0f4 <OSTaskStkChk>
 2016528:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 201652c:	e0bffc43 	ldbu	r2,-15(fp)
 2016530:	1000191e 	bne	r2,zero,2016598 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 2016534:	e0fffc03 	ldbu	r3,-16(fp)
 2016538:	008080f4 	movhi	r2,515
 201653c:	10b97d04 	addi	r2,r2,-6668
 2016540:	18c7883a 	add	r3,r3,r3
 2016544:	18c7883a 	add	r3,r3,r3
 2016548:	10c5883a 	add	r2,r2,r3
 201654c:	10800017 	ldw	r2,0(r2)
 2016550:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 2016554:	e0bffd17 	ldw	r2,-12(fp)
 2016558:	10000f26 	beq	r2,zero,2016598 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 201655c:	e0bffd17 	ldw	r2,-12(fp)
 2016560:	10800060 	cmpeqi	r2,r2,1
 2016564:	10000c1e 	bne	r2,zero,2016598 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 2016568:	e0bffd17 	ldw	r2,-12(fp)
 201656c:	10c00217 	ldw	r3,8(r2)
 2016570:	e0bffd17 	ldw	r2,-12(fp)
 2016574:	10800317 	ldw	r2,12(r2)
 2016578:	1085883a 	add	r2,r2,r2
 201657c:	1085883a 	add	r2,r2,r2
 2016580:	1887883a 	add	r3,r3,r2
 2016584:	e0bffd17 	ldw	r2,-12(fp)
 2016588:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 201658c:	e0ffff17 	ldw	r3,-4(fp)
 2016590:	e0bffd17 	ldw	r2,-12(fp)
 2016594:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 2016598:	e0bffc03 	ldbu	r2,-16(fp)
 201659c:	10800044 	addi	r2,r2,1
 20165a0:	e0bffc05 	stb	r2,-16(fp)
 20165a4:	e0bffc03 	ldbu	r2,-16(fp)
 20165a8:	10800570 	cmpltui	r2,r2,21
 20165ac:	103fd91e 	bne	r2,zero,2016514 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 20165b0:	0001883a 	nop
 20165b4:	e037883a 	mov	sp,fp
 20165b8:	dfc00117 	ldw	ra,4(sp)
 20165bc:	df000017 	ldw	fp,0(sp)
 20165c0:	dec00204 	addi	sp,sp,8
 20165c4:	f800283a 	ret

020165c8 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 20165c8:	defff204 	addi	sp,sp,-56
 20165cc:	dfc00d15 	stw	ra,52(sp)
 20165d0:	df000c15 	stw	fp,48(sp)
 20165d4:	df000c04 	addi	fp,sp,48
 20165d8:	e17ffc15 	stw	r5,-16(fp)
 20165dc:	e1bffd15 	stw	r6,-12(fp)
 20165e0:	3807883a 	mov	r3,r7
 20165e4:	e0800417 	ldw	r2,16(fp)
 20165e8:	e13ffb05 	stb	r4,-20(fp)
 20165ec:	e0fffe0d 	sth	r3,-8(fp)
 20165f0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 20165f4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20165f8:	0005303a 	rdctl	r2,status
 20165fc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016600:	e0fffa17 	ldw	r3,-24(fp)
 2016604:	00bfff84 	movi	r2,-2
 2016608:	1884703a 	and	r2,r3,r2
 201660c:	1001703a 	wrctl	status,r2
  
  return context;
 2016610:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
 2016614:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 2016618:	d0a75617 	ldw	r2,-25256(gp)
 201661c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
 2016620:	e0bff617 	ldw	r2,-40(fp)
 2016624:	10009326 	beq	r2,zero,2016874 <OS_TCBInit+0x2ac>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 2016628:	e0bff617 	ldw	r2,-40(fp)
 201662c:	10800517 	ldw	r2,20(r2)
 2016630:	d0a75615 	stw	r2,-25256(gp)
 2016634:	e0bff417 	ldw	r2,-48(fp)
 2016638:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201663c:	e0bff817 	ldw	r2,-32(fp)
 2016640:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 2016644:	e0bff617 	ldw	r2,-40(fp)
 2016648:	e0fffc17 	ldw	r3,-16(fp)
 201664c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 2016650:	e0bff617 	ldw	r2,-40(fp)
 2016654:	e0fffb03 	ldbu	r3,-20(fp)
 2016658:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 201665c:	e0bff617 	ldw	r2,-40(fp)
 2016660:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 2016664:	e0bff617 	ldw	r2,-40(fp)
 2016668:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 201666c:	e0bff617 	ldw	r2,-40(fp)
 2016670:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 2016674:	e0bff617 	ldw	r2,-40(fp)
 2016678:	e0c00317 	ldw	r3,12(fp)
 201667c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 2016680:	e0bff617 	ldw	r2,-40(fp)
 2016684:	e0c00217 	ldw	r3,8(fp)
 2016688:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 201668c:	e0bff617 	ldw	r2,-40(fp)
 2016690:	e0fffd17 	ldw	r3,-12(fp)
 2016694:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 2016698:	e0bff617 	ldw	r2,-40(fp)
 201669c:	e0ffff0b 	ldhu	r3,-4(fp)
 20166a0:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 20166a4:	e0bff617 	ldw	r2,-40(fp)
 20166a8:	e0fffe0b 	ldhu	r3,-8(fp)
 20166ac:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 20166b0:	e0bff617 	ldw	r2,-40(fp)
 20166b4:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 20166b8:	e0bffb03 	ldbu	r2,-20(fp)
 20166bc:	1004d0fa 	srli	r2,r2,3
 20166c0:	1007883a 	mov	r3,r2
 20166c4:	e0bff617 	ldw	r2,-40(fp)
 20166c8:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 20166cc:	e0bffb03 	ldbu	r2,-20(fp)
 20166d0:	108001cc 	andi	r2,r2,7
 20166d4:	1007883a 	mov	r3,r2
 20166d8:	e0bff617 	ldw	r2,-40(fp)
 20166dc:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 20166e0:	e0bff617 	ldw	r2,-40(fp)
 20166e4:	10800d03 	ldbu	r2,52(r2)
 20166e8:	10803fcc 	andi	r2,r2,255
 20166ec:	00c00044 	movi	r3,1
 20166f0:	1884983a 	sll	r2,r3,r2
 20166f4:	1007883a 	mov	r3,r2
 20166f8:	e0bff617 	ldw	r2,-40(fp)
 20166fc:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 2016700:	e0bff617 	ldw	r2,-40(fp)
 2016704:	10800cc3 	ldbu	r2,51(r2)
 2016708:	10803fcc 	andi	r2,r2,255
 201670c:	00c00044 	movi	r3,1
 2016710:	1884983a 	sll	r2,r3,r2
 2016714:	1007883a 	mov	r3,r2
 2016718:	e0bff617 	ldw	r2,-40(fp)
 201671c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 2016720:	e0bff617 	ldw	r2,-40(fp)
 2016724:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 2016728:	e0bff617 	ldw	r2,-40(fp)
 201672c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 2016730:	e0bff617 	ldw	r2,-40(fp)
 2016734:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 2016738:	e0bff617 	ldw	r2,-40(fp)
 201673c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 2016740:	e0bff617 	ldw	r2,-40(fp)
 2016744:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 2016748:	e0bff617 	ldw	r2,-40(fp)
 201674c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 2016750:	e0bff617 	ldw	r2,-40(fp)
 2016754:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 2016758:	e0bff617 	ldw	r2,-40(fp)
 201675c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 2016760:	e0bff617 	ldw	r2,-40(fp)
 2016764:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 2016768:	e0bff617 	ldw	r2,-40(fp)
 201676c:	00c00fc4 	movi	r3,63
 2016770:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 2016774:	e0bff617 	ldw	r2,-40(fp)
 2016778:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 201677c:	e13ff617 	ldw	r4,-40(fp)
 2016780:	201eb980 	call	201eb98 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 2016784:	e13ff617 	ldw	r4,-40(fp)
 2016788:	201ea900 	call	201ea90 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201678c:	0005303a 	rdctl	r2,status
 2016790:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016794:	e0fff517 	ldw	r3,-44(fp)
 2016798:	00bfff84 	movi	r2,-2
 201679c:	1884703a 	and	r2,r3,r2
 20167a0:	1001703a 	wrctl	status,r2
  
  return context;
 20167a4:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 20167a8:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 20167ac:	e0fffb03 	ldbu	r3,-20(fp)
 20167b0:	008080f4 	movhi	r2,515
 20167b4:	10b97d04 	addi	r2,r2,-6668
 20167b8:	18c7883a 	add	r3,r3,r3
 20167bc:	18c7883a 	add	r3,r3,r3
 20167c0:	10c5883a 	add	r2,r2,r3
 20167c4:	e0fff617 	ldw	r3,-40(fp)
 20167c8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 20167cc:	d0e75217 	ldw	r3,-25272(gp)
 20167d0:	e0bff617 	ldw	r2,-40(fp)
 20167d4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 20167d8:	e0bff617 	ldw	r2,-40(fp)
 20167dc:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 20167e0:	d0a75217 	ldw	r2,-25272(gp)
 20167e4:	10000326 	beq	r2,zero,20167f4 <OS_TCBInit+0x22c>
            OSTCBList->OSTCBPrev = ptcb;
 20167e8:	d0a75217 	ldw	r2,-25272(gp)
 20167ec:	e0fff617 	ldw	r3,-40(fp)
 20167f0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 20167f4:	e0bff617 	ldw	r2,-40(fp)
 20167f8:	d0a75215 	stw	r2,-25272(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 20167fc:	e0bff617 	ldw	r2,-40(fp)
 2016800:	10c00d83 	ldbu	r3,54(r2)
 2016804:	d0a75b03 	ldbu	r2,-25236(gp)
 2016808:	1884b03a 	or	r2,r3,r2
 201680c:	d0a75b05 	stb	r2,-25236(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 2016810:	e0bff617 	ldw	r2,-40(fp)
 2016814:	10800d03 	ldbu	r2,52(r2)
 2016818:	10c03fcc 	andi	r3,r2,255
 201681c:	e0bff617 	ldw	r2,-40(fp)
 2016820:	10800d03 	ldbu	r2,52(r2)
 2016824:	11003fcc 	andi	r4,r2,255
 2016828:	d0a75b44 	addi	r2,gp,-25235
 201682c:	2085883a 	add	r2,r4,r2
 2016830:	11000003 	ldbu	r4,0(r2)
 2016834:	e0bff617 	ldw	r2,-40(fp)
 2016838:	10800d43 	ldbu	r2,53(r2)
 201683c:	2084b03a 	or	r2,r4,r2
 2016840:	1009883a 	mov	r4,r2
 2016844:	d0a75b44 	addi	r2,gp,-25235
 2016848:	1885883a 	add	r2,r3,r2
 201684c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 2016850:	d0a75743 	ldbu	r2,-25251(gp)
 2016854:	10800044 	addi	r2,r2,1
 2016858:	d0a75745 	stb	r2,-25251(gp)
 201685c:	e0bff417 	ldw	r2,-48(fp)
 2016860:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016864:	e0bff717 	ldw	r2,-36(fp)
 2016868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 201686c:	0005883a 	mov	r2,zero
 2016870:	00000506 	br	2016888 <OS_TCBInit+0x2c0>
 2016874:	e0bff417 	ldw	r2,-48(fp)
 2016878:	e0bff915 	stw	r2,-28(fp)
 201687c:	e0bff917 	ldw	r2,-28(fp)
 2016880:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 2016884:	00801084 	movi	r2,66
}
 2016888:	e037883a 	mov	sp,fp
 201688c:	dfc00117 	ldw	ra,4(sp)
 2016890:	df000017 	ldw	fp,0(sp)
 2016894:	dec00204 	addi	sp,sp,8
 2016898:	f800283a 	ret

0201689c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 201689c:	defffe04 	addi	sp,sp,-8
 20168a0:	df000115 	stw	fp,4(sp)
 20168a4:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 20168a8:	d0a01504 	addi	r2,gp,-32684
 20168ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 20168b0:	d0a01604 	addi	r2,gp,-32680
 20168b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 20168b8:	d0a01784 	addi	r2,gp,-32674
 20168bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 20168c0:	d0a01804 	addi	r2,gp,-32672
 20168c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 20168c8:	d0a01704 	addi	r2,gp,-32676
 20168cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 20168d0:	d0a01884 	addi	r2,gp,-32670
 20168d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 20168d8:	d0a01904 	addi	r2,gp,-32668
 20168dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 20168e0:	d0a01984 	addi	r2,gp,-32666
 20168e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 20168e8:	d0a01a04 	addi	r2,gp,-32664
 20168ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 20168f0:	d0a01a84 	addi	r2,gp,-32662
 20168f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 20168f8:	d0a01b04 	addi	r2,gp,-32660
 20168fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 2016900:	d0a01b84 	addi	r2,gp,-32658
 2016904:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 2016908:	d0a01c04 	addi	r2,gp,-32656
 201690c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 2016910:	d0a01c84 	addi	r2,gp,-32654
 2016914:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 2016918:	d0a01d04 	addi	r2,gp,-32652
 201691c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 2016920:	d0a01d84 	addi	r2,gp,-32650
 2016924:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 2016928:	d0a01e04 	addi	r2,gp,-32648
 201692c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 2016930:	d0a01e84 	addi	r2,gp,-32646
 2016934:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 2016938:	d0a01f04 	addi	r2,gp,-32644
 201693c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 2016940:	d0a01f84 	addi	r2,gp,-32642
 2016944:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 2016948:	d0a02004 	addi	r2,gp,-32640
 201694c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 2016950:	d0a02084 	addi	r2,gp,-32638
 2016954:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 2016958:	d0a02104 	addi	r2,gp,-32636
 201695c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 2016960:	d0a02184 	addi	r2,gp,-32634
 2016964:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 2016968:	d0a02204 	addi	r2,gp,-32632
 201696c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 2016970:	d0a02284 	addi	r2,gp,-32630
 2016974:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 2016978:	d0a02304 	addi	r2,gp,-32628
 201697c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 2016980:	d0a02384 	addi	r2,gp,-32626
 2016984:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 2016988:	d0a02404 	addi	r2,gp,-32624
 201698c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 2016990:	d0a02484 	addi	r2,gp,-32622
 2016994:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 2016998:	d0a02504 	addi	r2,gp,-32620
 201699c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 20169a0:	d0a02584 	addi	r2,gp,-32618
 20169a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 20169a8:	d0a02604 	addi	r2,gp,-32616
 20169ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 20169b0:	d0a02684 	addi	r2,gp,-32614
 20169b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 20169b8:	d0a02704 	addi	r2,gp,-32612
 20169bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 20169c0:	d0a02784 	addi	r2,gp,-32610
 20169c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 20169c8:	d0a02804 	addi	r2,gp,-32608
 20169cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 20169d0:	d0a02884 	addi	r2,gp,-32606
 20169d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 20169d8:	d0a02904 	addi	r2,gp,-32604
 20169dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 20169e0:	d0a02984 	addi	r2,gp,-32602
 20169e4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 20169e8:	d0a02a04 	addi	r2,gp,-32600
 20169ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 20169f0:	d0a02a84 	addi	r2,gp,-32598
 20169f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 20169f8:	d0a02b04 	addi	r2,gp,-32596
 20169fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 2016a00:	d0a02b84 	addi	r2,gp,-32594
 2016a04:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 2016a08:	d0a02c04 	addi	r2,gp,-32592
 2016a0c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 2016a10:	d0a03104 	addi	r2,gp,-32572
 2016a14:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 2016a18:	0001883a 	nop
 2016a1c:	e037883a 	mov	sp,fp
 2016a20:	df000017 	ldw	fp,0(sp)
 2016a24:	dec00104 	addi	sp,sp,4
 2016a28:	f800283a 	ret

02016a2c <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 2016a2c:	defff204 	addi	sp,sp,-56
 2016a30:	df000d15 	stw	fp,52(sp)
 2016a34:	df000d04 	addi	fp,sp,52
 2016a38:	e13ffc15 	stw	r4,-16(fp)
 2016a3c:	2807883a 	mov	r3,r5
 2016a40:	3005883a 	mov	r2,r6
 2016a44:	e1ffff15 	stw	r7,-4(fp)
 2016a48:	e0fffd0d 	sth	r3,-12(fp)
 2016a4c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 2016a50:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2016a54:	e0bfff17 	ldw	r2,-4(fp)
 2016a58:	1000021e 	bne	r2,zero,2016a64 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 2016a5c:	0005883a 	mov	r2,zero
 2016a60:	0000b006 	br	2016d24 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 2016a64:	e0bffc17 	ldw	r2,-16(fp)
 2016a68:	1000051e 	bne	r2,zero,2016a80 <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2016a6c:	e0bfff17 	ldw	r2,-4(fp)
 2016a70:	00c01b84 	movi	r3,110
 2016a74:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2016a78:	0005883a 	mov	r2,zero
 2016a7c:	0000a906 	br	2016d24 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 2016a80:	e0bffc17 	ldw	r2,-16(fp)
 2016a84:	10800003 	ldbu	r2,0(r2)
 2016a88:	10803fcc 	andi	r2,r2,255
 2016a8c:	10800160 	cmpeqi	r2,r2,5
 2016a90:	1000051e 	bne	r2,zero,2016aa8 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 2016a94:	e0bfff17 	ldw	r2,-4(fp)
 2016a98:	00c00044 	movi	r3,1
 2016a9c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2016aa0:	0005883a 	mov	r2,zero
 2016aa4:	00009f06 	br	2016d24 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 2016aa8:	e0fffe03 	ldbu	r3,-8(fp)
 2016aac:	00bfe004 	movi	r2,-128
 2016ab0:	1884703a 	and	r2,r3,r2
 2016ab4:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 2016ab8:	e0bff503 	ldbu	r2,-44(fp)
 2016abc:	10000626 	beq	r2,zero,2016ad8 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 2016ac0:	e0bffe03 	ldbu	r2,-8(fp)
 2016ac4:	10801fcc 	andi	r2,r2,127
 2016ac8:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 2016acc:	00800044 	movi	r2,1
 2016ad0:	e0bff385 	stb	r2,-50(fp)
 2016ad4:	00000106 	br	2016adc <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 2016ad8:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 2016adc:	e0bfff17 	ldw	r2,-4(fp)
 2016ae0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016ae4:	0005303a 	rdctl	r2,status
 2016ae8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016aec:	e0fffb17 	ldw	r3,-20(fp)
 2016af0:	00bfff84 	movi	r2,-2
 2016af4:	1884703a 	and	r2,r3,r2
 2016af8:	1001703a 	wrctl	status,r2
  
  return context;
 2016afc:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 2016b00:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 2016b04:	e0bffe03 	ldbu	r2,-8(fp)
 2016b08:	10c00060 	cmpeqi	r3,r2,1
 2016b0c:	18005f1e 	bne	r3,zero,2016c8c <OSFlagAccept+0x260>
 2016b10:	10c00088 	cmpgei	r3,r2,2
 2016b14:	1800021e 	bne	r3,zero,2016b20 <OSFlagAccept+0xf4>
 2016b18:	10003f26 	beq	r2,zero,2016c18 <OSFlagAccept+0x1ec>
 2016b1c:	00007706 	br	2016cfc <OSFlagAccept+0x2d0>
 2016b20:	10c000a0 	cmpeqi	r3,r2,2
 2016b24:	1800031e 	bne	r3,zero,2016b34 <OSFlagAccept+0x108>
 2016b28:	108000e0 	cmpeqi	r2,r2,3
 2016b2c:	10001e1e 	bne	r2,zero,2016ba8 <OSFlagAccept+0x17c>
 2016b30:	00007206 	br	2016cfc <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 2016b34:	e0bffc17 	ldw	r2,-16(fp)
 2016b38:	10c0020b 	ldhu	r3,8(r2)
 2016b3c:	e0bffd0b 	ldhu	r2,-12(fp)
 2016b40:	1884703a 	and	r2,r3,r2
 2016b44:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2016b48:	e0fff30b 	ldhu	r3,-52(fp)
 2016b4c:	e0bffd0b 	ldhu	r2,-12(fp)
 2016b50:	18800d1e 	bne	r3,r2,2016b88 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2016b54:	e0bff383 	ldbu	r2,-50(fp)
 2016b58:	10800058 	cmpnei	r2,r2,1
 2016b5c:	10000d1e 	bne	r2,zero,2016b94 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 2016b60:	e0bffc17 	ldw	r2,-16(fp)
 2016b64:	1080020b 	ldhu	r2,8(r2)
 2016b68:	1007883a 	mov	r3,r2
 2016b6c:	e0bff30b 	ldhu	r2,-52(fp)
 2016b70:	0084303a 	nor	r2,zero,r2
 2016b74:	1884703a 	and	r2,r3,r2
 2016b78:	1007883a 	mov	r3,r2
 2016b7c:	e0bffc17 	ldw	r2,-16(fp)
 2016b80:	10c0020d 	sth	r3,8(r2)
 2016b84:	00000306 	br	2016b94 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2016b88:	e0bfff17 	ldw	r2,-4(fp)
 2016b8c:	00c01c04 	movi	r3,112
 2016b90:	10c00005 	stb	r3,0(r2)
 2016b94:	e0bff417 	ldw	r2,-48(fp)
 2016b98:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016b9c:	e0bff617 	ldw	r2,-40(fp)
 2016ba0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2016ba4:	00005e06 	br	2016d20 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 2016ba8:	e0bffc17 	ldw	r2,-16(fp)
 2016bac:	10c0020b 	ldhu	r3,8(r2)
 2016bb0:	e0bffd0b 	ldhu	r2,-12(fp)
 2016bb4:	1884703a 	and	r2,r3,r2
 2016bb8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 2016bbc:	e0bff30b 	ldhu	r2,-52(fp)
 2016bc0:	10000d26 	beq	r2,zero,2016bf8 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2016bc4:	e0bff383 	ldbu	r2,-50(fp)
 2016bc8:	10800058 	cmpnei	r2,r2,1
 2016bcc:	10000d1e 	bne	r2,zero,2016c04 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 2016bd0:	e0bffc17 	ldw	r2,-16(fp)
 2016bd4:	1080020b 	ldhu	r2,8(r2)
 2016bd8:	1007883a 	mov	r3,r2
 2016bdc:	e0bff30b 	ldhu	r2,-52(fp)
 2016be0:	0084303a 	nor	r2,zero,r2
 2016be4:	1884703a 	and	r2,r3,r2
 2016be8:	1007883a 	mov	r3,r2
 2016bec:	e0bffc17 	ldw	r2,-16(fp)
 2016bf0:	10c0020d 	sth	r3,8(r2)
 2016bf4:	00000306 	br	2016c04 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2016bf8:	e0bfff17 	ldw	r2,-4(fp)
 2016bfc:	00c01c04 	movi	r3,112
 2016c00:	10c00005 	stb	r3,0(r2)
 2016c04:	e0bff417 	ldw	r2,-48(fp)
 2016c08:	e0bff715 	stw	r2,-36(fp)
 2016c0c:	e0bff717 	ldw	r2,-36(fp)
 2016c10:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2016c14:	00004206 	br	2016d20 <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 2016c18:	e0bffc17 	ldw	r2,-16(fp)
 2016c1c:	1080020b 	ldhu	r2,8(r2)
 2016c20:	0084303a 	nor	r2,zero,r2
 2016c24:	1007883a 	mov	r3,r2
 2016c28:	e0bffd0b 	ldhu	r2,-12(fp)
 2016c2c:	1884703a 	and	r2,r3,r2
 2016c30:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2016c34:	e0fff30b 	ldhu	r3,-52(fp)
 2016c38:	e0bffd0b 	ldhu	r2,-12(fp)
 2016c3c:	18800b1e 	bne	r3,r2,2016c6c <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2016c40:	e0bff383 	ldbu	r2,-50(fp)
 2016c44:	10800058 	cmpnei	r2,r2,1
 2016c48:	10000b1e 	bne	r2,zero,2016c78 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 2016c4c:	e0bffc17 	ldw	r2,-16(fp)
 2016c50:	10c0020b 	ldhu	r3,8(r2)
 2016c54:	e0bff30b 	ldhu	r2,-52(fp)
 2016c58:	1884b03a 	or	r2,r3,r2
 2016c5c:	1007883a 	mov	r3,r2
 2016c60:	e0bffc17 	ldw	r2,-16(fp)
 2016c64:	10c0020d 	sth	r3,8(r2)
 2016c68:	00000306 	br	2016c78 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2016c6c:	e0bfff17 	ldw	r2,-4(fp)
 2016c70:	00c01c04 	movi	r3,112
 2016c74:	10c00005 	stb	r3,0(r2)
 2016c78:	e0bff417 	ldw	r2,-48(fp)
 2016c7c:	e0bff815 	stw	r2,-32(fp)
 2016c80:	e0bff817 	ldw	r2,-32(fp)
 2016c84:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2016c88:	00002506 	br	2016d20 <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 2016c8c:	e0bffc17 	ldw	r2,-16(fp)
 2016c90:	1080020b 	ldhu	r2,8(r2)
 2016c94:	0084303a 	nor	r2,zero,r2
 2016c98:	1007883a 	mov	r3,r2
 2016c9c:	e0bffd0b 	ldhu	r2,-12(fp)
 2016ca0:	1884703a 	and	r2,r3,r2
 2016ca4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 2016ca8:	e0bff30b 	ldhu	r2,-52(fp)
 2016cac:	10000b26 	beq	r2,zero,2016cdc <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2016cb0:	e0bff383 	ldbu	r2,-50(fp)
 2016cb4:	10800058 	cmpnei	r2,r2,1
 2016cb8:	10000b1e 	bne	r2,zero,2016ce8 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 2016cbc:	e0bffc17 	ldw	r2,-16(fp)
 2016cc0:	10c0020b 	ldhu	r3,8(r2)
 2016cc4:	e0bff30b 	ldhu	r2,-52(fp)
 2016cc8:	1884b03a 	or	r2,r3,r2
 2016ccc:	1007883a 	mov	r3,r2
 2016cd0:	e0bffc17 	ldw	r2,-16(fp)
 2016cd4:	10c0020d 	sth	r3,8(r2)
 2016cd8:	00000306 	br	2016ce8 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2016cdc:	e0bfff17 	ldw	r2,-4(fp)
 2016ce0:	00c01c04 	movi	r3,112
 2016ce4:	10c00005 	stb	r3,0(r2)
 2016ce8:	e0bff417 	ldw	r2,-48(fp)
 2016cec:	e0bff915 	stw	r2,-28(fp)
 2016cf0:	e0bff917 	ldw	r2,-28(fp)
 2016cf4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2016cf8:	00000906 	br	2016d20 <OSFlagAccept+0x2f4>
 2016cfc:	e0bff417 	ldw	r2,-48(fp)
 2016d00:	e0bffa15 	stw	r2,-24(fp)
 2016d04:	e0bffa17 	ldw	r2,-24(fp)
 2016d08:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 2016d0c:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 2016d10:	e0bfff17 	ldw	r2,-4(fp)
 2016d14:	00c01bc4 	movi	r3,111
 2016d18:	10c00005 	stb	r3,0(r2)
             break;
 2016d1c:	0001883a 	nop
    }
    return (flags_rdy);
 2016d20:	e0bff30b 	ldhu	r2,-52(fp)
}
 2016d24:	e037883a 	mov	sp,fp
 2016d28:	df000017 	ldw	fp,0(sp)
 2016d2c:	dec00104 	addi	sp,sp,4
 2016d30:	f800283a 	ret

02016d34 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 2016d34:	defff804 	addi	sp,sp,-32
 2016d38:	df000715 	stw	fp,28(sp)
 2016d3c:	df000704 	addi	fp,sp,28
 2016d40:	2005883a 	mov	r2,r4
 2016d44:	e17fff15 	stw	r5,-4(fp)
 2016d48:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 2016d4c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 2016d50:	e0bfff17 	ldw	r2,-4(fp)
 2016d54:	1000021e 	bne	r2,zero,2016d60 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 2016d58:	0005883a 	mov	r2,zero
 2016d5c:	00003306 	br	2016e2c <OSFlagCreate+0xf8>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 2016d60:	d0a75d03 	ldbu	r2,-25228(gp)
 2016d64:	10803fcc 	andi	r2,r2,255
 2016d68:	10000526 	beq	r2,zero,2016d80 <OSFlagCreate+0x4c>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 2016d6c:	e0bfff17 	ldw	r2,-4(fp)
 2016d70:	00c00404 	movi	r3,16
 2016d74:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 2016d78:	0005883a 	mov	r2,zero
 2016d7c:	00002b06 	br	2016e2c <OSFlagCreate+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016d80:	0005303a 	rdctl	r2,status
 2016d84:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016d88:	e0fffd17 	ldw	r3,-12(fp)
 2016d8c:	00bfff84 	movi	r2,-2
 2016d90:	1884703a 	and	r2,r3,r2
 2016d94:	1001703a 	wrctl	status,r2
  
  return context;
 2016d98:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2016d9c:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 2016da0:	d0a76017 	ldw	r2,-25216(gp)
 2016da4:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 2016da8:	e0bffb17 	ldw	r2,-20(fp)
 2016dac:	10001726 	beq	r2,zero,2016e0c <OSFlagCreate+0xd8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 2016db0:	d0a76017 	ldw	r2,-25216(gp)
 2016db4:	10800117 	ldw	r2,4(r2)
 2016db8:	d0a76015 	stw	r2,-25216(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 2016dbc:	e0bffb17 	ldw	r2,-20(fp)
 2016dc0:	00c00144 	movi	r3,5
 2016dc4:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 2016dc8:	e0bffb17 	ldw	r2,-20(fp)
 2016dcc:	e0fffe0b 	ldhu	r3,-8(fp)
 2016dd0:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 2016dd4:	e0bffb17 	ldw	r2,-20(fp)
 2016dd8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 2016ddc:	e0bffb17 	ldw	r2,-20(fp)
 2016de0:	00c00fc4 	movi	r3,63
 2016de4:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2016de8:	e0bffb17 	ldw	r2,-20(fp)
 2016dec:	100002c5 	stb	zero,11(r2)
 2016df0:	e0bff917 	ldw	r2,-28(fp)
 2016df4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016df8:	e0bffa17 	ldw	r2,-24(fp)
 2016dfc:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 2016e00:	e0bfff17 	ldw	r2,-4(fp)
 2016e04:	10000005 	stb	zero,0(r2)
 2016e08:	00000706 	br	2016e28 <OSFlagCreate+0xf4>
 2016e0c:	e0bff917 	ldw	r2,-28(fp)
 2016e10:	e0bffc15 	stw	r2,-16(fp)
 2016e14:	e0bffc17 	ldw	r2,-16(fp)
 2016e18:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 2016e1c:	e0bfff17 	ldw	r2,-4(fp)
 2016e20:	00c01c84 	movi	r3,114
 2016e24:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 2016e28:	e0bffb17 	ldw	r2,-20(fp)
}
 2016e2c:	e037883a 	mov	sp,fp
 2016e30:	df000017 	ldw	fp,0(sp)
 2016e34:	dec00104 	addi	sp,sp,4
 2016e38:	f800283a 	ret

02016e3c <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 2016e3c:	defff204 	addi	sp,sp,-56
 2016e40:	dfc00d15 	stw	ra,52(sp)
 2016e44:	df000c15 	stw	fp,48(sp)
 2016e48:	df000c04 	addi	fp,sp,48
 2016e4c:	e13ffd15 	stw	r4,-12(fp)
 2016e50:	2805883a 	mov	r2,r5
 2016e54:	e1bfff15 	stw	r6,-4(fp)
 2016e58:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 2016e5c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2016e60:	e0bfff17 	ldw	r2,-4(fp)
 2016e64:	1000021e 	bne	r2,zero,2016e70 <OSFlagDel+0x34>
        return (pgrp);
 2016e68:	e0bffd17 	ldw	r2,-12(fp)
 2016e6c:	00008006 	br	2017070 <OSFlagDel+0x234>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 2016e70:	e0bffd17 	ldw	r2,-12(fp)
 2016e74:	1000051e 	bne	r2,zero,2016e8c <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2016e78:	e0bfff17 	ldw	r2,-4(fp)
 2016e7c:	00c01b84 	movi	r3,110
 2016e80:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 2016e84:	e0bffd17 	ldw	r2,-12(fp)
 2016e88:	00007906 	br	2017070 <OSFlagDel+0x234>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 2016e8c:	d0a75d03 	ldbu	r2,-25228(gp)
 2016e90:	10803fcc 	andi	r2,r2,255
 2016e94:	10000526 	beq	r2,zero,2016eac <OSFlagDel+0x70>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 2016e98:	e0bfff17 	ldw	r2,-4(fp)
 2016e9c:	00c003c4 	movi	r3,15
 2016ea0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 2016ea4:	e0bffd17 	ldw	r2,-12(fp)
 2016ea8:	00007106 	br	2017070 <OSFlagDel+0x234>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 2016eac:	e0bffd17 	ldw	r2,-12(fp)
 2016eb0:	10800003 	ldbu	r2,0(r2)
 2016eb4:	10803fcc 	andi	r2,r2,255
 2016eb8:	10800160 	cmpeqi	r2,r2,5
 2016ebc:	1000051e 	bne	r2,zero,2016ed4 <OSFlagDel+0x98>
        *perr = OS_ERR_EVENT_TYPE;
 2016ec0:	e0bfff17 	ldw	r2,-4(fp)
 2016ec4:	00c00044 	movi	r3,1
 2016ec8:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 2016ecc:	e0bffd17 	ldw	r2,-12(fp)
 2016ed0:	00006706 	br	2017070 <OSFlagDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016ed4:	0005303a 	rdctl	r2,status
 2016ed8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016edc:	e0fffc17 	ldw	r3,-16(fp)
 2016ee0:	00bfff84 	movi	r2,-2
 2016ee4:	1884703a 	and	r2,r3,r2
 2016ee8:	1001703a 	wrctl	status,r2
  
  return context;
 2016eec:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2016ef0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 2016ef4:	e0bffd17 	ldw	r2,-12(fp)
 2016ef8:	10800117 	ldw	r2,4(r2)
 2016efc:	10000326 	beq	r2,zero,2016f0c <OSFlagDel+0xd0>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 2016f00:	00800044 	movi	r2,1
 2016f04:	e0bff405 	stb	r2,-48(fp)
 2016f08:	00000106 	br	2016f10 <OSFlagDel+0xd4>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 2016f0c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 2016f10:	e0bffe03 	ldbu	r2,-8(fp)
 2016f14:	10000326 	beq	r2,zero,2016f24 <OSFlagDel+0xe8>
 2016f18:	10800060 	cmpeqi	r2,r2,1
 2016f1c:	1000231e 	bne	r2,zero,2016fac <OSFlagDel+0x170>
 2016f20:	00004806 	br	2017044 <OSFlagDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 2016f24:	e0bff403 	ldbu	r2,-48(fp)
 2016f28:	1000161e 	bne	r2,zero,2016f84 <OSFlagDel+0x148>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 2016f2c:	e0bffd17 	ldw	r2,-12(fp)
 2016f30:	00c00fc4 	movi	r3,63
 2016f34:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2016f38:	e0bffd17 	ldw	r2,-12(fp)
 2016f3c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2016f40:	e0bffd17 	ldw	r2,-12(fp)
 2016f44:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 2016f48:	d0e76017 	ldw	r3,-25216(gp)
 2016f4c:	e0bffd17 	ldw	r2,-12(fp)
 2016f50:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 2016f54:	e0bffd17 	ldw	r2,-12(fp)
 2016f58:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 2016f5c:	e0bffd17 	ldw	r2,-12(fp)
 2016f60:	d0a76015 	stw	r2,-25216(gp)
 2016f64:	e0bff717 	ldw	r2,-36(fp)
 2016f68:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016f6c:	e0bff817 	ldw	r2,-32(fp)
 2016f70:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 2016f74:	e0bfff17 	ldw	r2,-4(fp)
 2016f78:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 2016f7c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 2016f80:	00003a06 	br	201706c <OSFlagDel+0x230>
 2016f84:	e0bff717 	ldw	r2,-36(fp)
 2016f88:	e0bff915 	stw	r2,-28(fp)
 2016f8c:	e0bff917 	ldw	r2,-28(fp)
 2016f90:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 2016f94:	e0bfff17 	ldw	r2,-4(fp)
 2016f98:	00c01244 	movi	r3,73
 2016f9c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 2016fa0:	e0bffd17 	ldw	r2,-12(fp)
 2016fa4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 2016fa8:	00003006 	br	201706c <OSFlagDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2016fac:	e0bffd17 	ldw	r2,-12(fp)
 2016fb0:	10800117 	ldw	r2,4(r2)
 2016fb4:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 2016fb8:	00000606 	br	2016fd4 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 2016fbc:	000b883a 	mov	r5,zero
 2016fc0:	e13ff517 	ldw	r4,-44(fp)
 2016fc4:	2017fa80 	call	2017fa8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 2016fc8:	e0bff517 	ldw	r2,-44(fp)
 2016fcc:	10800017 	ldw	r2,0(r2)
 2016fd0:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 2016fd4:	e0bff517 	ldw	r2,-44(fp)
 2016fd8:	103ff81e 	bne	r2,zero,2016fbc <OSFlagDel+0x180>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 2016fdc:	e0bffd17 	ldw	r2,-12(fp)
 2016fe0:	00c00fc4 	movi	r3,63
 2016fe4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2016fe8:	e0bffd17 	ldw	r2,-12(fp)
 2016fec:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2016ff0:	e0bffd17 	ldw	r2,-12(fp)
 2016ff4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 2016ff8:	d0e76017 	ldw	r3,-25216(gp)
 2016ffc:	e0bffd17 	ldw	r2,-12(fp)
 2017000:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 2017004:	e0bffd17 	ldw	r2,-12(fp)
 2017008:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 201700c:	e0bffd17 	ldw	r2,-12(fp)
 2017010:	d0a76015 	stw	r2,-25216(gp)
 2017014:	e0bff717 	ldw	r2,-36(fp)
 2017018:	e0bffa15 	stw	r2,-24(fp)
 201701c:	e0bffa17 	ldw	r2,-24(fp)
 2017020:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 2017024:	e0bff403 	ldbu	r2,-48(fp)
 2017028:	10800058 	cmpnei	r2,r2,1
 201702c:	1000011e 	bne	r2,zero,2017034 <OSFlagDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 2017030:	20161c80 	call	20161c8 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 2017034:	e0bfff17 	ldw	r2,-4(fp)
 2017038:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 201703c:	e03ff615 	stw	zero,-40(fp)
             break;
 2017040:	00000a06 	br	201706c <OSFlagDel+0x230>
 2017044:	e0bff717 	ldw	r2,-36(fp)
 2017048:	e0bffb15 	stw	r2,-20(fp)
 201704c:	e0bffb17 	ldw	r2,-20(fp)
 2017050:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 2017054:	e0bfff17 	ldw	r2,-4(fp)
 2017058:	00c001c4 	movi	r3,7
 201705c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 2017060:	e0bffd17 	ldw	r2,-12(fp)
 2017064:	e0bff615 	stw	r2,-40(fp)
             break;
 2017068:	0001883a 	nop
    }
    return (pgrp_return);
 201706c:	e0bff617 	ldw	r2,-40(fp)
}
 2017070:	e037883a 	mov	sp,fp
 2017074:	dfc00117 	ldw	ra,4(sp)
 2017078:	df000017 	ldw	fp,0(sp)
 201707c:	dec00204 	addi	sp,sp,8
 2017080:	f800283a 	ret

02017084 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 2017084:	defff604 	addi	sp,sp,-40
 2017088:	dfc00915 	stw	ra,36(sp)
 201708c:	df000815 	stw	fp,32(sp)
 2017090:	df000804 	addi	fp,sp,32
 2017094:	e13ffd15 	stw	r4,-12(fp)
 2017098:	e17ffe15 	stw	r5,-8(fp)
 201709c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20170a0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 20170a4:	e0bfff17 	ldw	r2,-4(fp)
 20170a8:	1000021e 	bne	r2,zero,20170b4 <OSFlagNameGet+0x30>
        return (0);
 20170ac:	0005883a 	mov	r2,zero
 20170b0:	00003906 	br	2017198 <OSFlagNameGet+0x114>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 20170b4:	e0bffd17 	ldw	r2,-12(fp)
 20170b8:	1000051e 	bne	r2,zero,20170d0 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 20170bc:	e0bfff17 	ldw	r2,-4(fp)
 20170c0:	00c01b84 	movi	r3,110
 20170c4:	10c00005 	stb	r3,0(r2)
        return (0);
 20170c8:	0005883a 	mov	r2,zero
 20170cc:	00003206 	br	2017198 <OSFlagNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 20170d0:	e0bffe17 	ldw	r2,-8(fp)
 20170d4:	1000051e 	bne	r2,zero,20170ec <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 20170d8:	e0bfff17 	ldw	r2,-4(fp)
 20170dc:	00c00304 	movi	r3,12
 20170e0:	10c00005 	stb	r3,0(r2)
        return (0);
 20170e4:	0005883a 	mov	r2,zero
 20170e8:	00002b06 	br	2017198 <OSFlagNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 20170ec:	d0a75d03 	ldbu	r2,-25228(gp)
 20170f0:	10803fcc 	andi	r2,r2,255
 20170f4:	10000526 	beq	r2,zero,201710c <OSFlagNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 20170f8:	e0bfff17 	ldw	r2,-4(fp)
 20170fc:	00c00444 	movi	r3,17
 2017100:	10c00005 	stb	r3,0(r2)
        return (0);
 2017104:	0005883a 	mov	r2,zero
 2017108:	00002306 	br	2017198 <OSFlagNameGet+0x114>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201710c:	0005303a 	rdctl	r2,status
 2017110:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017114:	e0fffc17 	ldw	r3,-16(fp)
 2017118:	00bfff84 	movi	r2,-2
 201711c:	1884703a 	and	r2,r3,r2
 2017120:	1001703a 	wrctl	status,r2
  
  return context;
 2017124:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2017128:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 201712c:	e0bffd17 	ldw	r2,-12(fp)
 2017130:	10800003 	ldbu	r2,0(r2)
 2017134:	10803fcc 	andi	r2,r2,255
 2017138:	10800160 	cmpeqi	r2,r2,5
 201713c:	1000091e 	bne	r2,zero,2017164 <OSFlagNameGet+0xe0>
 2017140:	e0bff817 	ldw	r2,-32(fp)
 2017144:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017148:	e0bff917 	ldw	r2,-28(fp)
 201714c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 2017150:	e0bfff17 	ldw	r2,-4(fp)
 2017154:	00c00044 	movi	r3,1
 2017158:	10c00005 	stb	r3,0(r2)
        return (0);
 201715c:	0005883a 	mov	r2,zero
 2017160:	00000d06 	br	2017198 <OSFlagNameGet+0x114>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 2017164:	e0bffd17 	ldw	r2,-12(fp)
 2017168:	10800284 	addi	r2,r2,10
 201716c:	100b883a 	mov	r5,r2
 2017170:	e13ffe17 	ldw	r4,-8(fp)
 2017174:	201630c0 	call	201630c <OS_StrCopy>
 2017178:	e0bffb05 	stb	r2,-20(fp)
 201717c:	e0bff817 	ldw	r2,-32(fp)
 2017180:	e0bffa15 	stw	r2,-24(fp)
 2017184:	e0bffa17 	ldw	r2,-24(fp)
 2017188:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201718c:	e0bfff17 	ldw	r2,-4(fp)
 2017190:	10000005 	stb	zero,0(r2)
    return (len);
 2017194:	e0bffb03 	ldbu	r2,-20(fp)
}
 2017198:	e037883a 	mov	sp,fp
 201719c:	dfc00117 	ldw	ra,4(sp)
 20171a0:	df000017 	ldw	fp,0(sp)
 20171a4:	dec00204 	addi	sp,sp,8
 20171a8:	f800283a 	ret

020171ac <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 20171ac:	defff504 	addi	sp,sp,-44
 20171b0:	dfc00a15 	stw	ra,40(sp)
 20171b4:	df000915 	stw	fp,36(sp)
 20171b8:	df000904 	addi	fp,sp,36
 20171bc:	e13ffd15 	stw	r4,-12(fp)
 20171c0:	e17ffe15 	stw	r5,-8(fp)
 20171c4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20171c8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 20171cc:	e0bfff17 	ldw	r2,-4(fp)
 20171d0:	10004326 	beq	r2,zero,20172e0 <OSFlagNameSet+0x134>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 20171d4:	e0bffd17 	ldw	r2,-12(fp)
 20171d8:	1000041e 	bne	r2,zero,20171ec <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 20171dc:	e0bfff17 	ldw	r2,-4(fp)
 20171e0:	00c01b84 	movi	r3,110
 20171e4:	10c00005 	stb	r3,0(r2)
        return;
 20171e8:	00003e06 	br	20172e4 <OSFlagNameSet+0x138>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 20171ec:	e0bffe17 	ldw	r2,-8(fp)
 20171f0:	1000041e 	bne	r2,zero,2017204 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 20171f4:	e0bfff17 	ldw	r2,-4(fp)
 20171f8:	00c00304 	movi	r3,12
 20171fc:	10c00005 	stb	r3,0(r2)
        return;
 2017200:	00003806 	br	20172e4 <OSFlagNameSet+0x138>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2017204:	d0a75d03 	ldbu	r2,-25228(gp)
 2017208:	10803fcc 	andi	r2,r2,255
 201720c:	10000426 	beq	r2,zero,2017220 <OSFlagNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 2017210:	e0bfff17 	ldw	r2,-4(fp)
 2017214:	00c00484 	movi	r3,18
 2017218:	10c00005 	stb	r3,0(r2)
        return;
 201721c:	00003106 	br	20172e4 <OSFlagNameSet+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017220:	0005303a 	rdctl	r2,status
 2017224:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017228:	e0fffc17 	ldw	r3,-16(fp)
 201722c:	00bfff84 	movi	r2,-2
 2017230:	1884703a 	and	r2,r3,r2
 2017234:	1001703a 	wrctl	status,r2
  
  return context;
 2017238:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201723c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 2017240:	e0bffd17 	ldw	r2,-12(fp)
 2017244:	10800003 	ldbu	r2,0(r2)
 2017248:	10803fcc 	andi	r2,r2,255
 201724c:	10800160 	cmpeqi	r2,r2,5
 2017250:	1000081e 	bne	r2,zero,2017274 <OSFlagNameSet+0xc8>
 2017254:	e0bff717 	ldw	r2,-36(fp)
 2017258:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201725c:	e0bff817 	ldw	r2,-32(fp)
 2017260:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 2017264:	e0bfff17 	ldw	r2,-4(fp)
 2017268:	00c00044 	movi	r3,1
 201726c:	10c00005 	stb	r3,0(r2)
        return;
 2017270:	00001c06 	br	20172e4 <OSFlagNameSet+0x138>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 2017274:	e13ffe17 	ldw	r4,-8(fp)
 2017278:	20163800 	call	2016380 <OS_StrLen>
 201727c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 2017280:	e0bffa03 	ldbu	r2,-24(fp)
 2017284:	10800830 	cmpltui	r2,r2,32
 2017288:	1000081e 	bne	r2,zero,20172ac <OSFlagNameSet+0x100>
 201728c:	e0bff717 	ldw	r2,-36(fp)
 2017290:	e0bff915 	stw	r2,-28(fp)
 2017294:	e0bff917 	ldw	r2,-28(fp)
 2017298:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 201729c:	e0bfff17 	ldw	r2,-4(fp)
 20172a0:	00c01cc4 	movi	r3,115
 20172a4:	10c00005 	stb	r3,0(r2)
        return;
 20172a8:	00000e06 	br	20172e4 <OSFlagNameSet+0x138>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 20172ac:	e0bffd17 	ldw	r2,-12(fp)
 20172b0:	10800284 	addi	r2,r2,10
 20172b4:	e17ffe17 	ldw	r5,-8(fp)
 20172b8:	1009883a 	mov	r4,r2
 20172bc:	201630c0 	call	201630c <OS_StrCopy>
 20172c0:	e0bff717 	ldw	r2,-36(fp)
 20172c4:	e0bffb15 	stw	r2,-20(fp)
 20172c8:	e0bffb17 	ldw	r2,-20(fp)
 20172cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 20172d0:	e0bfff17 	ldw	r2,-4(fp)
 20172d4:	10000005 	stb	zero,0(r2)
    return;
 20172d8:	0001883a 	nop
 20172dc:	00000106 	br	20172e4 <OSFlagNameSet+0x138>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 20172e0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 20172e4:	e037883a 	mov	sp,fp
 20172e8:	dfc00117 	ldw	ra,4(sp)
 20172ec:	df000017 	ldw	fp,0(sp)
 20172f0:	dec00204 	addi	sp,sp,8
 20172f4:	f800283a 	ret

020172f8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 20172f8:	deffe104 	addi	sp,sp,-124
 20172fc:	dfc01e15 	stw	ra,120(sp)
 2017300:	df001d15 	stw	fp,116(sp)
 2017304:	df001d04 	addi	fp,sp,116
 2017308:	e13ffc15 	stw	r4,-16(fp)
 201730c:	2809883a 	mov	r4,r5
 2017310:	3007883a 	mov	r3,r6
 2017314:	3805883a 	mov	r2,r7
 2017318:	e13ffd0d 	sth	r4,-12(fp)
 201731c:	e0fffe05 	stb	r3,-8(fp)
 2017320:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 2017324:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2017328:	e0800217 	ldw	r2,8(fp)
 201732c:	1000021e 	bne	r2,zero,2017338 <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 2017330:	0005883a 	mov	r2,zero
 2017334:	00015906 	br	201789c <OSFlagPend+0x5a4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 2017338:	e0bffc17 	ldw	r2,-16(fp)
 201733c:	1000051e 	bne	r2,zero,2017354 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2017340:	e0800217 	ldw	r2,8(fp)
 2017344:	00c01b84 	movi	r3,110
 2017348:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 201734c:	0005883a 	mov	r2,zero
 2017350:	00015206 	br	201789c <OSFlagPend+0x5a4>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 2017354:	d0a75d03 	ldbu	r2,-25228(gp)
 2017358:	10803fcc 	andi	r2,r2,255
 201735c:	10000526 	beq	r2,zero,2017374 <OSFlagPend+0x7c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 2017360:	e0800217 	ldw	r2,8(fp)
 2017364:	00c00084 	movi	r3,2
 2017368:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 201736c:	0005883a 	mov	r2,zero
 2017370:	00014a06 	br	201789c <OSFlagPend+0x5a4>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 2017374:	d0a74f03 	ldbu	r2,-25284(gp)
 2017378:	10803fcc 	andi	r2,r2,255
 201737c:	10000526 	beq	r2,zero,2017394 <OSFlagPend+0x9c>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 2017380:	e0800217 	ldw	r2,8(fp)
 2017384:	00c00344 	movi	r3,13
 2017388:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 201738c:	0005883a 	mov	r2,zero
 2017390:	00014206 	br	201789c <OSFlagPend+0x5a4>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 2017394:	e0bffc17 	ldw	r2,-16(fp)
 2017398:	10800003 	ldbu	r2,0(r2)
 201739c:	10803fcc 	andi	r2,r2,255
 20173a0:	10800160 	cmpeqi	r2,r2,5
 20173a4:	1000051e 	bne	r2,zero,20173bc <OSFlagPend+0xc4>
        *perr = OS_ERR_EVENT_TYPE;
 20173a8:	e0800217 	ldw	r2,8(fp)
 20173ac:	00c00044 	movi	r3,1
 20173b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 20173b4:	0005883a 	mov	r2,zero
 20173b8:	00013806 	br	201789c <OSFlagPend+0x5a4>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 20173bc:	e0fffe03 	ldbu	r3,-8(fp)
 20173c0:	00bfe004 	movi	r2,-128
 20173c4:	1884703a 	and	r2,r3,r2
 20173c8:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 20173cc:	e0bfe603 	ldbu	r2,-104(fp)
 20173d0:	10000626 	beq	r2,zero,20173ec <OSFlagPend+0xf4>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 20173d4:	e0bffe03 	ldbu	r2,-8(fp)
 20173d8:	10801fcc 	andi	r2,r2,127
 20173dc:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 20173e0:	00800044 	movi	r2,1
 20173e4:	e0bfe405 	stb	r2,-112(fp)
 20173e8:	00000106 	br	20173f0 <OSFlagPend+0xf8>
    } else {
        consume    = OS_FALSE;
 20173ec:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20173f0:	0005303a 	rdctl	r2,status
 20173f4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20173f8:	e0fff617 	ldw	r3,-40(fp)
 20173fc:	00bfff84 	movi	r2,-2
 2017400:	1884703a 	and	r2,r3,r2
 2017404:	1001703a 	wrctl	status,r2
  
  return context;
 2017408:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 201740c:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
 2017410:	e0bffe03 	ldbu	r2,-8(fp)
 2017414:	10c00060 	cmpeqi	r3,r2,1
 2017418:	1800921e 	bne	r3,zero,2017664 <OSFlagPend+0x36c>
 201741c:	10c00088 	cmpgei	r3,r2,2
 2017420:	1800021e 	bne	r3,zero,201742c <OSFlagPend+0x134>
 2017424:	10006126 	beq	r2,zero,20175ac <OSFlagPend+0x2b4>
 2017428:	0000bb06 	br	2017718 <OSFlagPend+0x420>
 201742c:	10c000a0 	cmpeqi	r3,r2,2
 2017430:	1800031e 	bne	r3,zero,2017440 <OSFlagPend+0x148>
 2017434:	108000e0 	cmpeqi	r2,r2,3
 2017438:	10002f1e 	bne	r2,zero,20174f8 <OSFlagPend+0x200>
 201743c:	0000b606 	br	2017718 <OSFlagPend+0x420>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 2017440:	e0bffc17 	ldw	r2,-16(fp)
 2017444:	10c0020b 	ldhu	r3,8(r2)
 2017448:	e0bffd0b 	ldhu	r2,-12(fp)
 201744c:	1884703a 	and	r2,r3,r2
 2017450:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2017454:	e0ffe80b 	ldhu	r3,-96(fp)
 2017458:	e0bffd0b 	ldhu	r2,-12(fp)
 201745c:	1880171e 	bne	r3,r2,20174bc <OSFlagPend+0x1c4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2017460:	e0bfe403 	ldbu	r2,-112(fp)
 2017464:	10800058 	cmpnei	r2,r2,1
 2017468:	1000091e 	bne	r2,zero,2017490 <OSFlagPend+0x198>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 201746c:	e0bffc17 	ldw	r2,-16(fp)
 2017470:	1080020b 	ldhu	r2,8(r2)
 2017474:	1007883a 	mov	r3,r2
 2017478:	e0bfe80b 	ldhu	r2,-96(fp)
 201747c:	0084303a 	nor	r2,zero,r2
 2017480:	1884703a 	and	r2,r3,r2
 2017484:	1007883a 	mov	r3,r2
 2017488:	e0bffc17 	ldw	r2,-16(fp)
 201748c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 2017490:	d0a75e17 	ldw	r2,-25224(gp)
 2017494:	e0ffe80b 	ldhu	r3,-96(fp)
 2017498:	10c00b0d 	sth	r3,44(r2)
 201749c:	e0bfe517 	ldw	r2,-108(fp)
 20174a0:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20174a4:	e0bfe717 	ldw	r2,-100(fp)
 20174a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 20174ac:	e0800217 	ldw	r2,8(fp)
 20174b0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 20174b4:	e0bfe80b 	ldhu	r2,-96(fp)
 20174b8:	0000f806 	br	201789c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 20174bc:	e13ffd0b 	ldhu	r4,-12(fp)
 20174c0:	e17ffe03 	ldbu	r5,-8(fp)
 20174c4:	e0bfff0b 	ldhu	r2,-4(fp)
 20174c8:	e0fff704 	addi	r3,fp,-36
 20174cc:	d8800015 	stw	r2,0(sp)
 20174d0:	280f883a 	mov	r7,r5
 20174d4:	200d883a 	mov	r6,r4
 20174d8:	180b883a 	mov	r5,r3
 20174dc:	e13ffc17 	ldw	r4,-16(fp)
 20174e0:	2017d680 	call	2017d68 <OS_FlagBlock>
 20174e4:	e0bfe517 	ldw	r2,-108(fp)
 20174e8:	e0bfe915 	stw	r2,-92(fp)
 20174ec:	e0bfe917 	ldw	r2,-92(fp)
 20174f0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 20174f4:	00009206 	br	2017740 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 20174f8:	e0bffc17 	ldw	r2,-16(fp)
 20174fc:	10c0020b 	ldhu	r3,8(r2)
 2017500:	e0bffd0b 	ldhu	r2,-12(fp)
 2017504:	1884703a 	and	r2,r3,r2
 2017508:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 201750c:	e0bfe80b 	ldhu	r2,-96(fp)
 2017510:	10001726 	beq	r2,zero,2017570 <OSFlagPend+0x278>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2017514:	e0bfe403 	ldbu	r2,-112(fp)
 2017518:	10800058 	cmpnei	r2,r2,1
 201751c:	1000091e 	bne	r2,zero,2017544 <OSFlagPend+0x24c>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 2017520:	e0bffc17 	ldw	r2,-16(fp)
 2017524:	1080020b 	ldhu	r2,8(r2)
 2017528:	1007883a 	mov	r3,r2
 201752c:	e0bfe80b 	ldhu	r2,-96(fp)
 2017530:	0084303a 	nor	r2,zero,r2
 2017534:	1884703a 	and	r2,r3,r2
 2017538:	1007883a 	mov	r3,r2
 201753c:	e0bffc17 	ldw	r2,-16(fp)
 2017540:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 2017544:	d0a75e17 	ldw	r2,-25224(gp)
 2017548:	e0ffe80b 	ldhu	r3,-96(fp)
 201754c:	10c00b0d 	sth	r3,44(r2)
 2017550:	e0bfe517 	ldw	r2,-108(fp)
 2017554:	e0bfea15 	stw	r2,-88(fp)
 2017558:	e0bfea17 	ldw	r2,-88(fp)
 201755c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2017560:	e0800217 	ldw	r2,8(fp)
 2017564:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2017568:	e0bfe80b 	ldhu	r2,-96(fp)
 201756c:	0000cb06 	br	201789c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2017570:	e13ffd0b 	ldhu	r4,-12(fp)
 2017574:	e17ffe03 	ldbu	r5,-8(fp)
 2017578:	e0bfff0b 	ldhu	r2,-4(fp)
 201757c:	e0fff704 	addi	r3,fp,-36
 2017580:	d8800015 	stw	r2,0(sp)
 2017584:	280f883a 	mov	r7,r5
 2017588:	200d883a 	mov	r6,r4
 201758c:	180b883a 	mov	r5,r3
 2017590:	e13ffc17 	ldw	r4,-16(fp)
 2017594:	2017d680 	call	2017d68 <OS_FlagBlock>
 2017598:	e0bfe517 	ldw	r2,-108(fp)
 201759c:	e0bfeb15 	stw	r2,-84(fp)
 20175a0:	e0bfeb17 	ldw	r2,-84(fp)
 20175a4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 20175a8:	00006506 	br	2017740 <OSFlagPend+0x448>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 20175ac:	e0bffc17 	ldw	r2,-16(fp)
 20175b0:	1080020b 	ldhu	r2,8(r2)
 20175b4:	0084303a 	nor	r2,zero,r2
 20175b8:	1007883a 	mov	r3,r2
 20175bc:	e0bffd0b 	ldhu	r2,-12(fp)
 20175c0:	1884703a 	and	r2,r3,r2
 20175c4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 20175c8:	e0ffe80b 	ldhu	r3,-96(fp)
 20175cc:	e0bffd0b 	ldhu	r2,-12(fp)
 20175d0:	1880151e 	bne	r3,r2,2017628 <OSFlagPend+0x330>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 20175d4:	e0bfe403 	ldbu	r2,-112(fp)
 20175d8:	10800058 	cmpnei	r2,r2,1
 20175dc:	1000071e 	bne	r2,zero,20175fc <OSFlagPend+0x304>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 20175e0:	e0bffc17 	ldw	r2,-16(fp)
 20175e4:	10c0020b 	ldhu	r3,8(r2)
 20175e8:	e0bfe80b 	ldhu	r2,-96(fp)
 20175ec:	1884b03a 	or	r2,r3,r2
 20175f0:	1007883a 	mov	r3,r2
 20175f4:	e0bffc17 	ldw	r2,-16(fp)
 20175f8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 20175fc:	d0a75e17 	ldw	r2,-25224(gp)
 2017600:	e0ffe80b 	ldhu	r3,-96(fp)
 2017604:	10c00b0d 	sth	r3,44(r2)
 2017608:	e0bfe517 	ldw	r2,-108(fp)
 201760c:	e0bfec15 	stw	r2,-80(fp)
 2017610:	e0bfec17 	ldw	r2,-80(fp)
 2017614:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2017618:	e0800217 	ldw	r2,8(fp)
 201761c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2017620:	e0bfe80b 	ldhu	r2,-96(fp)
 2017624:	00009d06 	br	201789c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2017628:	e13ffd0b 	ldhu	r4,-12(fp)
 201762c:	e17ffe03 	ldbu	r5,-8(fp)
 2017630:	e0bfff0b 	ldhu	r2,-4(fp)
 2017634:	e0fff704 	addi	r3,fp,-36
 2017638:	d8800015 	stw	r2,0(sp)
 201763c:	280f883a 	mov	r7,r5
 2017640:	200d883a 	mov	r6,r4
 2017644:	180b883a 	mov	r5,r3
 2017648:	e13ffc17 	ldw	r4,-16(fp)
 201764c:	2017d680 	call	2017d68 <OS_FlagBlock>
 2017650:	e0bfe517 	ldw	r2,-108(fp)
 2017654:	e0bfed15 	stw	r2,-76(fp)
 2017658:	e0bfed17 	ldw	r2,-76(fp)
 201765c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 2017660:	00003706 	br	2017740 <OSFlagPend+0x448>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 2017664:	e0bffc17 	ldw	r2,-16(fp)
 2017668:	1080020b 	ldhu	r2,8(r2)
 201766c:	0084303a 	nor	r2,zero,r2
 2017670:	1007883a 	mov	r3,r2
 2017674:	e0bffd0b 	ldhu	r2,-12(fp)
 2017678:	1884703a 	and	r2,r3,r2
 201767c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 2017680:	e0bfe80b 	ldhu	r2,-96(fp)
 2017684:	10001526 	beq	r2,zero,20176dc <OSFlagPend+0x3e4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2017688:	e0bfe403 	ldbu	r2,-112(fp)
 201768c:	10800058 	cmpnei	r2,r2,1
 2017690:	1000071e 	bne	r2,zero,20176b0 <OSFlagPend+0x3b8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 2017694:	e0bffc17 	ldw	r2,-16(fp)
 2017698:	10c0020b 	ldhu	r3,8(r2)
 201769c:	e0bfe80b 	ldhu	r2,-96(fp)
 20176a0:	1884b03a 	or	r2,r3,r2
 20176a4:	1007883a 	mov	r3,r2
 20176a8:	e0bffc17 	ldw	r2,-16(fp)
 20176ac:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 20176b0:	d0a75e17 	ldw	r2,-25224(gp)
 20176b4:	e0ffe80b 	ldhu	r3,-96(fp)
 20176b8:	10c00b0d 	sth	r3,44(r2)
 20176bc:	e0bfe517 	ldw	r2,-108(fp)
 20176c0:	e0bfee15 	stw	r2,-72(fp)
 20176c4:	e0bfee17 	ldw	r2,-72(fp)
 20176c8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 20176cc:	e0800217 	ldw	r2,8(fp)
 20176d0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 20176d4:	e0bfe80b 	ldhu	r2,-96(fp)
 20176d8:	00007006 	br	201789c <OSFlagPend+0x5a4>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 20176dc:	e13ffd0b 	ldhu	r4,-12(fp)
 20176e0:	e17ffe03 	ldbu	r5,-8(fp)
 20176e4:	e0bfff0b 	ldhu	r2,-4(fp)
 20176e8:	e0fff704 	addi	r3,fp,-36
 20176ec:	d8800015 	stw	r2,0(sp)
 20176f0:	280f883a 	mov	r7,r5
 20176f4:	200d883a 	mov	r6,r4
 20176f8:	180b883a 	mov	r5,r3
 20176fc:	e13ffc17 	ldw	r4,-16(fp)
 2017700:	2017d680 	call	2017d68 <OS_FlagBlock>
 2017704:	e0bfe517 	ldw	r2,-108(fp)
 2017708:	e0bfef15 	stw	r2,-68(fp)
 201770c:	e0bfef17 	ldw	r2,-68(fp)
 2017710:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 2017714:	00000a06 	br	2017740 <OSFlagPend+0x448>
 2017718:	e0bfe517 	ldw	r2,-108(fp)
 201771c:	e0bff015 	stw	r2,-64(fp)
 2017720:	e0bff017 	ldw	r2,-64(fp)
 2017724:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 2017728:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 201772c:	e0800217 	ldw	r2,8(fp)
 2017730:	00c01bc4 	movi	r3,111
 2017734:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 2017738:	e0bfe80b 	ldhu	r2,-96(fp)
 201773c:	00005706 	br	201789c <OSFlagPend+0x5a4>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 2017740:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017744:	0005303a 	rdctl	r2,status
 2017748:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201774c:	e0fff117 	ldw	r3,-60(fp)
 2017750:	00bfff84 	movi	r2,-2
 2017754:	1884703a 	and	r2,r3,r2
 2017758:	1001703a 	wrctl	status,r2
  
  return context;
 201775c:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
 2017760:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 2017764:	d0a75e17 	ldw	r2,-25224(gp)
 2017768:	10800c43 	ldbu	r2,49(r2)
 201776c:	10803fcc 	andi	r2,r2,255
 2017770:	10001c26 	beq	r2,zero,20177e4 <OSFlagPend+0x4ec>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 2017774:	d0a75e17 	ldw	r2,-25224(gp)
 2017778:	10800c43 	ldbu	r2,49(r2)
 201777c:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2017780:	d0a75e17 	ldw	r2,-25224(gp)
 2017784:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 2017788:	e0bff704 	addi	r2,fp,-36
 201778c:	1009883a 	mov	r4,r2
 2017790:	201809c0 	call	201809c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 2017794:	d0a75e17 	ldw	r2,-25224(gp)
 2017798:	10000c05 	stb	zero,48(r2)
 201779c:	e0bfe517 	ldw	r2,-108(fp)
 20177a0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20177a4:	e0bff217 	ldw	r2,-56(fp)
 20177a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 20177ac:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
 20177b0:	e0bff303 	ldbu	r2,-52(fp)
 20177b4:	108000a0 	cmpeqi	r2,r2,2
 20177b8:	10000426 	beq	r2,zero,20177cc <OSFlagPend+0x4d4>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 20177bc:	e0800217 	ldw	r2,8(fp)
 20177c0:	00c00384 	movi	r3,14
 20177c4:	10c00005 	stb	r3,0(r2)
                 break;
 20177c8:	00000406 	br	20177dc <OSFlagPend+0x4e4>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 20177cc:	e0800217 	ldw	r2,8(fp)
 20177d0:	00c00284 	movi	r3,10
 20177d4:	10c00005 	stb	r3,0(r2)
                 break;
 20177d8:	0001883a 	nop
        }
        return (flags_rdy);
 20177dc:	e0bfe80b 	ldhu	r2,-96(fp)
 20177e0:	00002e06 	br	201789c <OSFlagPend+0x5a4>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 20177e4:	d0a75e17 	ldw	r2,-25224(gp)
 20177e8:	10800b0b 	ldhu	r2,44(r2)
 20177ec:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 20177f0:	e0bfe403 	ldbu	r2,-112(fp)
 20177f4:	10800058 	cmpnei	r2,r2,1
 20177f8:	1000211e 	bne	r2,zero,2017880 <OSFlagPend+0x588>
        switch (wait_type) {
 20177fc:	e0bffe03 	ldbu	r2,-8(fp)
 2017800:	10001616 	blt	r2,zero,201785c <OSFlagPend+0x564>
 2017804:	10c00090 	cmplti	r3,r2,2
 2017808:	18000c1e 	bne	r3,zero,201783c <OSFlagPend+0x544>
 201780c:	10800108 	cmpgei	r2,r2,4
 2017810:	1000121e 	bne	r2,zero,201785c <OSFlagPend+0x564>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 2017814:	e0bffc17 	ldw	r2,-16(fp)
 2017818:	1080020b 	ldhu	r2,8(r2)
 201781c:	1007883a 	mov	r3,r2
 2017820:	e0bfe80b 	ldhu	r2,-96(fp)
 2017824:	0084303a 	nor	r2,zero,r2
 2017828:	1884703a 	and	r2,r3,r2
 201782c:	1007883a 	mov	r3,r2
 2017830:	e0bffc17 	ldw	r2,-16(fp)
 2017834:	10c0020d 	sth	r3,8(r2)
                 break;
 2017838:	00001106 	br	2017880 <OSFlagPend+0x588>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 201783c:	e0bffc17 	ldw	r2,-16(fp)
 2017840:	10c0020b 	ldhu	r3,8(r2)
 2017844:	e0bfe80b 	ldhu	r2,-96(fp)
 2017848:	1884b03a 	or	r2,r3,r2
 201784c:	1007883a 	mov	r3,r2
 2017850:	e0bffc17 	ldw	r2,-16(fp)
 2017854:	10c0020d 	sth	r3,8(r2)
                 break;
 2017858:	00000906 	br	2017880 <OSFlagPend+0x588>
 201785c:	e0bfe517 	ldw	r2,-108(fp)
 2017860:	e0bff415 	stw	r2,-48(fp)
 2017864:	e0bff417 	ldw	r2,-48(fp)
 2017868:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 201786c:	e0800217 	ldw	r2,8(fp)
 2017870:	00c01bc4 	movi	r3,111
 2017874:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 2017878:	0005883a 	mov	r2,zero
 201787c:	00000706 	br	201789c <OSFlagPend+0x5a4>
 2017880:	e0bfe517 	ldw	r2,-108(fp)
 2017884:	e0bff515 	stw	r2,-44(fp)
 2017888:	e0bff517 	ldw	r2,-44(fp)
 201788c:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 2017890:	e0800217 	ldw	r2,8(fp)
 2017894:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 2017898:	e0bfe80b 	ldhu	r2,-96(fp)
}
 201789c:	e037883a 	mov	sp,fp
 20178a0:	dfc00117 	ldw	ra,4(sp)
 20178a4:	df000017 	ldw	fp,0(sp)
 20178a8:	dec00204 	addi	sp,sp,8
 20178ac:	f800283a 	ret

020178b0 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 20178b0:	defffb04 	addi	sp,sp,-20
 20178b4:	df000415 	stw	fp,16(sp)
 20178b8:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 20178bc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20178c0:	0005303a 	rdctl	r2,status
 20178c4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20178c8:	e0fffe17 	ldw	r3,-8(fp)
 20178cc:	00bfff84 	movi	r2,-2
 20178d0:	1884703a 	and	r2,r3,r2
 20178d4:	1001703a 	wrctl	status,r2
  
  return context;
 20178d8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 20178dc:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 20178e0:	d0a75e17 	ldw	r2,-25224(gp)
 20178e4:	10800b0b 	ldhu	r2,44(r2)
 20178e8:	e0bffd0d 	sth	r2,-12(fp)
 20178ec:	e0bffc17 	ldw	r2,-16(fp)
 20178f0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20178f4:	e0bfff17 	ldw	r2,-4(fp)
 20178f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 20178fc:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2017900:	e037883a 	mov	sp,fp
 2017904:	df000017 	ldw	fp,0(sp)
 2017908:	dec00104 	addi	sp,sp,4
 201790c:	f800283a 	ret

02017910 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 2017910:	deffef04 	addi	sp,sp,-68
 2017914:	dfc01015 	stw	ra,64(sp)
 2017918:	df000f15 	stw	fp,60(sp)
 201791c:	df000f04 	addi	fp,sp,60
 2017920:	e13ffc15 	stw	r4,-16(fp)
 2017924:	2807883a 	mov	r3,r5
 2017928:	3005883a 	mov	r2,r6
 201792c:	e1ffff15 	stw	r7,-4(fp)
 2017930:	e0fffd0d 	sth	r3,-12(fp)
 2017934:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 2017938:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 201793c:	e0bfff17 	ldw	r2,-4(fp)
 2017940:	1000021e 	bne	r2,zero,201794c <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 2017944:	0005883a 	mov	r2,zero
 2017948:	0000d106 	br	2017c90 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 201794c:	e0bffc17 	ldw	r2,-16(fp)
 2017950:	1000051e 	bne	r2,zero,2017968 <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2017954:	e0bfff17 	ldw	r2,-4(fp)
 2017958:	00c01b84 	movi	r3,110
 201795c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017960:	0005883a 	mov	r2,zero
 2017964:	0000ca06 	br	2017c90 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 2017968:	e0bffc17 	ldw	r2,-16(fp)
 201796c:	10800003 	ldbu	r2,0(r2)
 2017970:	10803fcc 	andi	r2,r2,255
 2017974:	10800160 	cmpeqi	r2,r2,5
 2017978:	1000051e 	bne	r2,zero,2017990 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 201797c:	e0bfff17 	ldw	r2,-4(fp)
 2017980:	00c00044 	movi	r3,1
 2017984:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017988:	0005883a 	mov	r2,zero
 201798c:	0000c006 	br	2017c90 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017990:	0005303a 	rdctl	r2,status
 2017994:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017998:	e0fffb17 	ldw	r3,-20(fp)
 201799c:	00bfff84 	movi	r2,-2
 20179a0:	1884703a 	and	r2,r3,r2
 20179a4:	1001703a 	wrctl	status,r2
  
  return context;
 20179a8:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 20179ac:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 20179b0:	e0bffe03 	ldbu	r2,-8(fp)
 20179b4:	10000326 	beq	r2,zero,20179c4 <OSFlagPost+0xb4>
 20179b8:	10800060 	cmpeqi	r2,r2,1
 20179bc:	10000b1e 	bne	r2,zero,20179ec <OSFlagPost+0xdc>
 20179c0:	00001206 	br	2017a0c <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 20179c4:	e0bffc17 	ldw	r2,-16(fp)
 20179c8:	1080020b 	ldhu	r2,8(r2)
 20179cc:	1007883a 	mov	r3,r2
 20179d0:	e0bffd0b 	ldhu	r2,-12(fp)
 20179d4:	0084303a 	nor	r2,zero,r2
 20179d8:	1884703a 	and	r2,r3,r2
 20179dc:	1007883a 	mov	r3,r2
 20179e0:	e0bffc17 	ldw	r2,-16(fp)
 20179e4:	10c0020d 	sth	r3,8(r2)
             break;
 20179e8:	00001106 	br	2017a30 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 20179ec:	e0bffc17 	ldw	r2,-16(fp)
 20179f0:	10c0020b 	ldhu	r3,8(r2)
 20179f4:	e0bffd0b 	ldhu	r2,-12(fp)
 20179f8:	1884b03a 	or	r2,r3,r2
 20179fc:	1007883a 	mov	r3,r2
 2017a00:	e0bffc17 	ldw	r2,-16(fp)
 2017a04:	10c0020d 	sth	r3,8(r2)
             break;
 2017a08:	00000906 	br	2017a30 <OSFlagPost+0x120>
 2017a0c:	e0bff317 	ldw	r2,-52(fp)
 2017a10:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017a14:	e0bff417 	ldw	r2,-48(fp)
 2017a18:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 2017a1c:	e0bfff17 	ldw	r2,-4(fp)
 2017a20:	00c01c44 	movi	r3,113
 2017a24:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 2017a28:	0005883a 	mov	r2,zero
 2017a2c:	00009806 	br	2017c90 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 2017a30:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2017a34:	e0bffc17 	ldw	r2,-16(fp)
 2017a38:	10800117 	ldw	r2,4(r2)
 2017a3c:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 2017a40:	00007706 	br	2017c20 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 2017a44:	e0bff117 	ldw	r2,-60(fp)
 2017a48:	10800483 	ldbu	r2,18(r2)
 2017a4c:	10803fcc 	andi	r2,r2,255
 2017a50:	10c00060 	cmpeqi	r3,r2,1
 2017a54:	18004a1e 	bne	r3,zero,2017b80 <OSFlagPost+0x270>
 2017a58:	10c00088 	cmpgei	r3,r2,2
 2017a5c:	1800021e 	bne	r3,zero,2017a68 <OSFlagPost+0x158>
 2017a60:	10002f26 	beq	r2,zero,2017b20 <OSFlagPost+0x210>
 2017a64:	00005b06 	br	2017bd4 <OSFlagPost+0x2c4>
 2017a68:	10c000a0 	cmpeqi	r3,r2,2
 2017a6c:	1800031e 	bne	r3,zero,2017a7c <OSFlagPost+0x16c>
 2017a70:	108000e0 	cmpeqi	r2,r2,3
 2017a74:	1000171e 	bne	r2,zero,2017ad4 <OSFlagPost+0x1c4>
 2017a78:	00005606 	br	2017bd4 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2017a7c:	e0bffc17 	ldw	r2,-16(fp)
 2017a80:	10c0020b 	ldhu	r3,8(r2)
 2017a84:	e0bff117 	ldw	r2,-60(fp)
 2017a88:	1080040b 	ldhu	r2,16(r2)
 2017a8c:	1884703a 	and	r2,r3,r2
 2017a90:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 2017a94:	e0bff117 	ldw	r2,-60(fp)
 2017a98:	1080040b 	ldhu	r2,16(r2)
 2017a9c:	10ffffcc 	andi	r3,r2,65535
 2017aa0:	e0bff60b 	ldhu	r2,-40(fp)
 2017aa4:	1880541e 	bne	r3,r2,2017bf8 <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2017aa8:	e0bff60b 	ldhu	r2,-40(fp)
 2017aac:	100b883a 	mov	r5,r2
 2017ab0:	e13ff117 	ldw	r4,-60(fp)
 2017ab4:	2017fa80 	call	2017fa8 <OS_FlagTaskRdy>
 2017ab8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 2017abc:	e0bff683 	ldbu	r2,-38(fp)
 2017ac0:	10800058 	cmpnei	r2,r2,1
 2017ac4:	10004c1e 	bne	r2,zero,2017bf8 <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2017ac8:	00800044 	movi	r2,1
 2017acc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2017ad0:	00004906 	br	2017bf8 <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2017ad4:	e0bffc17 	ldw	r2,-16(fp)
 2017ad8:	10c0020b 	ldhu	r3,8(r2)
 2017adc:	e0bff117 	ldw	r2,-60(fp)
 2017ae0:	1080040b 	ldhu	r2,16(r2)
 2017ae4:	1884703a 	and	r2,r3,r2
 2017ae8:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 2017aec:	e0bff60b 	ldhu	r2,-40(fp)
 2017af0:	10004326 	beq	r2,zero,2017c00 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2017af4:	e0bff60b 	ldhu	r2,-40(fp)
 2017af8:	100b883a 	mov	r5,r2
 2017afc:	e13ff117 	ldw	r4,-60(fp)
 2017b00:	2017fa80 	call	2017fa8 <OS_FlagTaskRdy>
 2017b04:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 2017b08:	e0bff683 	ldbu	r2,-38(fp)
 2017b0c:	10800058 	cmpnei	r2,r2,1
 2017b10:	10003b1e 	bne	r2,zero,2017c00 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2017b14:	00800044 	movi	r2,1
 2017b18:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2017b1c:	00003806 	br	2017c00 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2017b20:	e0bffc17 	ldw	r2,-16(fp)
 2017b24:	1080020b 	ldhu	r2,8(r2)
 2017b28:	0084303a 	nor	r2,zero,r2
 2017b2c:	1007883a 	mov	r3,r2
 2017b30:	e0bff117 	ldw	r2,-60(fp)
 2017b34:	1080040b 	ldhu	r2,16(r2)
 2017b38:	1884703a 	and	r2,r3,r2
 2017b3c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 2017b40:	e0bff117 	ldw	r2,-60(fp)
 2017b44:	1080040b 	ldhu	r2,16(r2)
 2017b48:	10ffffcc 	andi	r3,r2,65535
 2017b4c:	e0bff60b 	ldhu	r2,-40(fp)
 2017b50:	18802d1e 	bne	r3,r2,2017c08 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2017b54:	e0bff60b 	ldhu	r2,-40(fp)
 2017b58:	100b883a 	mov	r5,r2
 2017b5c:	e13ff117 	ldw	r4,-60(fp)
 2017b60:	2017fa80 	call	2017fa8 <OS_FlagTaskRdy>
 2017b64:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 2017b68:	e0bff683 	ldbu	r2,-38(fp)
 2017b6c:	10800058 	cmpnei	r2,r2,1
 2017b70:	1000251e 	bne	r2,zero,2017c08 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2017b74:	00800044 	movi	r2,1
 2017b78:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2017b7c:	00002206 	br	2017c08 <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2017b80:	e0bffc17 	ldw	r2,-16(fp)
 2017b84:	1080020b 	ldhu	r2,8(r2)
 2017b88:	0084303a 	nor	r2,zero,r2
 2017b8c:	1007883a 	mov	r3,r2
 2017b90:	e0bff117 	ldw	r2,-60(fp)
 2017b94:	1080040b 	ldhu	r2,16(r2)
 2017b98:	1884703a 	and	r2,r3,r2
 2017b9c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 2017ba0:	e0bff60b 	ldhu	r2,-40(fp)
 2017ba4:	10001a26 	beq	r2,zero,2017c10 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2017ba8:	e0bff60b 	ldhu	r2,-40(fp)
 2017bac:	100b883a 	mov	r5,r2
 2017bb0:	e13ff117 	ldw	r4,-60(fp)
 2017bb4:	2017fa80 	call	2017fa8 <OS_FlagTaskRdy>
 2017bb8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
 2017bbc:	e0bff683 	ldbu	r2,-38(fp)
 2017bc0:	10800058 	cmpnei	r2,r2,1
 2017bc4:	1000121e 	bne	r2,zero,2017c10 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2017bc8:	00800044 	movi	r2,1
 2017bcc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2017bd0:	00000f06 	br	2017c10 <OSFlagPost+0x300>
 2017bd4:	e0bff317 	ldw	r2,-52(fp)
 2017bd8:	e0bff515 	stw	r2,-44(fp)
 2017bdc:	e0bff517 	ldw	r2,-44(fp)
 2017be0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 2017be4:	e0bfff17 	ldw	r2,-4(fp)
 2017be8:	00c01bc4 	movi	r3,111
 2017bec:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 2017bf0:	0005883a 	mov	r2,zero
 2017bf4:	00002606 	br	2017c90 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 2017bf8:	0001883a 	nop
 2017bfc:	00000506 	br	2017c14 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 2017c00:	0001883a 	nop
 2017c04:	00000306 	br	2017c14 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 2017c08:	0001883a 	nop
 2017c0c:	00000106 	br	2017c14 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 2017c10:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 2017c14:	e0bff117 	ldw	r2,-60(fp)
 2017c18:	10800017 	ldw	r2,0(r2)
 2017c1c:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 2017c20:	e0bff117 	ldw	r2,-60(fp)
 2017c24:	103f871e 	bne	r2,zero,2017a44 <OSFlagPost+0x134>
 2017c28:	e0bff317 	ldw	r2,-52(fp)
 2017c2c:	e0bff715 	stw	r2,-36(fp)
 2017c30:	e0bff717 	ldw	r2,-36(fp)
 2017c34:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 2017c38:	e0bff203 	ldbu	r2,-56(fp)
 2017c3c:	10800058 	cmpnei	r2,r2,1
 2017c40:	1000011e 	bne	r2,zero,2017c48 <OSFlagPost+0x338>
        OS_Sched();
 2017c44:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017c48:	0005303a 	rdctl	r2,status
 2017c4c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017c50:	e0fffa17 	ldw	r3,-24(fp)
 2017c54:	00bfff84 	movi	r2,-2
 2017c58:	1884703a 	and	r2,r3,r2
 2017c5c:	1001703a 	wrctl	status,r2
  
  return context;
 2017c60:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 2017c64:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 2017c68:	e0bffc17 	ldw	r2,-16(fp)
 2017c6c:	1080020b 	ldhu	r2,8(r2)
 2017c70:	e0bff90d 	sth	r2,-28(fp)
 2017c74:	e0bff317 	ldw	r2,-52(fp)
 2017c78:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017c7c:	e0bff817 	ldw	r2,-32(fp)
 2017c80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 2017c84:	e0bfff17 	ldw	r2,-4(fp)
 2017c88:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 2017c8c:	e0bff90b 	ldhu	r2,-28(fp)
}
 2017c90:	e037883a 	mov	sp,fp
 2017c94:	dfc00117 	ldw	ra,4(sp)
 2017c98:	df000017 	ldw	fp,0(sp)
 2017c9c:	dec00204 	addi	sp,sp,8
 2017ca0:	f800283a 	ret

02017ca4 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 2017ca4:	defff904 	addi	sp,sp,-28
 2017ca8:	df000615 	stw	fp,24(sp)
 2017cac:	df000604 	addi	fp,sp,24
 2017cb0:	e13ffe15 	stw	r4,-8(fp)
 2017cb4:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 2017cb8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 2017cbc:	e0bfff17 	ldw	r2,-4(fp)
 2017cc0:	1000021e 	bne	r2,zero,2017ccc <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 2017cc4:	0005883a 	mov	r2,zero
 2017cc8:	00002306 	br	2017d58 <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 2017ccc:	e0bffe17 	ldw	r2,-8(fp)
 2017cd0:	1000051e 	bne	r2,zero,2017ce8 <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2017cd4:	e0bfff17 	ldw	r2,-4(fp)
 2017cd8:	00c01b84 	movi	r3,110
 2017cdc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017ce0:	0005883a 	mov	r2,zero
 2017ce4:	00001c06 	br	2017d58 <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 2017ce8:	e0bffe17 	ldw	r2,-8(fp)
 2017cec:	10800003 	ldbu	r2,0(r2)
 2017cf0:	10803fcc 	andi	r2,r2,255
 2017cf4:	10800160 	cmpeqi	r2,r2,5
 2017cf8:	1000051e 	bne	r2,zero,2017d10 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 2017cfc:	e0bfff17 	ldw	r2,-4(fp)
 2017d00:	00c00044 	movi	r3,1
 2017d04:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017d08:	0005883a 	mov	r2,zero
 2017d0c:	00001206 	br	2017d58 <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017d10:	0005303a 	rdctl	r2,status
 2017d14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017d18:	e0fffc17 	ldw	r3,-16(fp)
 2017d1c:	00bfff84 	movi	r2,-2
 2017d20:	1884703a 	and	r2,r3,r2
 2017d24:	1001703a 	wrctl	status,r2
  
  return context;
 2017d28:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2017d2c:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 2017d30:	e0bffe17 	ldw	r2,-8(fp)
 2017d34:	1080020b 	ldhu	r2,8(r2)
 2017d38:	e0bffb0d 	sth	r2,-20(fp)
 2017d3c:	e0bffa17 	ldw	r2,-24(fp)
 2017d40:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017d44:	e0bffd17 	ldw	r2,-12(fp)
 2017d48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2017d4c:	e0bfff17 	ldw	r2,-4(fp)
 2017d50:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 2017d54:	e0bffb0b 	ldhu	r2,-20(fp)
}
 2017d58:	e037883a 	mov	sp,fp
 2017d5c:	df000017 	ldw	fp,0(sp)
 2017d60:	dec00104 	addi	sp,sp,4
 2017d64:	f800283a 	ret

02017d68 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 2017d68:	defff804 	addi	sp,sp,-32
 2017d6c:	df000715 	stw	fp,28(sp)
 2017d70:	df000704 	addi	fp,sp,28
 2017d74:	e13ffb15 	stw	r4,-20(fp)
 2017d78:	e17ffc15 	stw	r5,-16(fp)
 2017d7c:	3009883a 	mov	r4,r6
 2017d80:	3807883a 	mov	r3,r7
 2017d84:	e0800117 	ldw	r2,4(fp)
 2017d88:	e13ffd0d 	sth	r4,-12(fp)
 2017d8c:	e0fffe05 	stb	r3,-8(fp)
 2017d90:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 2017d94:	d0a75e17 	ldw	r2,-25224(gp)
 2017d98:	d0e75e17 	ldw	r3,-25224(gp)
 2017d9c:	18c00c03 	ldbu	r3,48(r3)
 2017da0:	18c00814 	ori	r3,r3,32
 2017da4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 2017da8:	d0a75e17 	ldw	r2,-25224(gp)
 2017dac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 2017db0:	d0a75e17 	ldw	r2,-25224(gp)
 2017db4:	e0ffff0b 	ldhu	r3,-4(fp)
 2017db8:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 2017dbc:	d0a75e17 	ldw	r2,-25224(gp)
 2017dc0:	e0fffc17 	ldw	r3,-16(fp)
 2017dc4:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 2017dc8:	e0bffc17 	ldw	r2,-16(fp)
 2017dcc:	e0fffd0b 	ldhu	r3,-12(fp)
 2017dd0:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 2017dd4:	e0bffc17 	ldw	r2,-16(fp)
 2017dd8:	e0fffe03 	ldbu	r3,-8(fp)
 2017ddc:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 2017de0:	d0e75e17 	ldw	r3,-25224(gp)
 2017de4:	e0bffc17 	ldw	r2,-16(fp)
 2017de8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 2017dec:	e0bffb17 	ldw	r2,-20(fp)
 2017df0:	10c00117 	ldw	r3,4(r2)
 2017df4:	e0bffc17 	ldw	r2,-16(fp)
 2017df8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 2017dfc:	e0bffc17 	ldw	r2,-16(fp)
 2017e00:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 2017e04:	e0bffc17 	ldw	r2,-16(fp)
 2017e08:	e0fffb17 	ldw	r3,-20(fp)
 2017e0c:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2017e10:	e0bffb17 	ldw	r2,-20(fp)
 2017e14:	10800117 	ldw	r2,4(r2)
 2017e18:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 2017e1c:	e0bff917 	ldw	r2,-28(fp)
 2017e20:	10000326 	beq	r2,zero,2017e30 <OS_FlagBlock+0xc8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 2017e24:	e0bff917 	ldw	r2,-28(fp)
 2017e28:	e0fffc17 	ldw	r3,-16(fp)
 2017e2c:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 2017e30:	e0bffb17 	ldw	r2,-20(fp)
 2017e34:	e0fffc17 	ldw	r3,-16(fp)
 2017e38:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 2017e3c:	d0a75e17 	ldw	r2,-25224(gp)
 2017e40:	10800d03 	ldbu	r2,52(r2)
 2017e44:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 2017e48:	e0fffa03 	ldbu	r3,-24(fp)
 2017e4c:	e13ffa03 	ldbu	r4,-24(fp)
 2017e50:	d0a75b44 	addi	r2,gp,-25235
 2017e54:	2085883a 	add	r2,r4,r2
 2017e58:	10800003 	ldbu	r2,0(r2)
 2017e5c:	1009883a 	mov	r4,r2
 2017e60:	d0a75e17 	ldw	r2,-25224(gp)
 2017e64:	10800d43 	ldbu	r2,53(r2)
 2017e68:	0084303a 	nor	r2,zero,r2
 2017e6c:	2084703a 	and	r2,r4,r2
 2017e70:	1009883a 	mov	r4,r2
 2017e74:	d0a75b44 	addi	r2,gp,-25235
 2017e78:	1885883a 	add	r2,r3,r2
 2017e7c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 2017e80:	e0fffa03 	ldbu	r3,-24(fp)
 2017e84:	d0a75b44 	addi	r2,gp,-25235
 2017e88:	1885883a 	add	r2,r3,r2
 2017e8c:	10800003 	ldbu	r2,0(r2)
 2017e90:	10803fcc 	andi	r2,r2,255
 2017e94:	1000071e 	bne	r2,zero,2017eb4 <OS_FlagBlock+0x14c>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 2017e98:	d0a75e17 	ldw	r2,-25224(gp)
 2017e9c:	10800d83 	ldbu	r2,54(r2)
 2017ea0:	0084303a 	nor	r2,zero,r2
 2017ea4:	1007883a 	mov	r3,r2
 2017ea8:	d0a75b03 	ldbu	r2,-25236(gp)
 2017eac:	1884703a 	and	r2,r3,r2
 2017eb0:	d0a75b05 	stb	r2,-25236(gp)
    }
}
 2017eb4:	0001883a 	nop
 2017eb8:	e037883a 	mov	sp,fp
 2017ebc:	df000017 	ldw	fp,0(sp)
 2017ec0:	dec00104 	addi	sp,sp,4
 2017ec4:	f800283a 	ret

02017ec8 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 2017ec8:	defffb04 	addi	sp,sp,-20
 2017ecc:	dfc00415 	stw	ra,16(sp)
 2017ed0:	df000315 	stw	fp,12(sp)
 2017ed4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 2017ed8:	0140dc04 	movi	r5,880
 2017edc:	010080f4 	movhi	r4,515
 2017ee0:	212d0904 	addi	r4,r4,-19420
 2017ee4:	201610c0 	call	201610c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 2017ee8:	008080f4 	movhi	r2,515
 2017eec:	10ad0904 	addi	r2,r2,-19420
 2017ef0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 2017ef4:	008080f4 	movhi	r2,515
 2017ef8:	10ad1404 	addi	r2,r2,-19376
 2017efc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 2017f00:	e03ffd0d 	sth	zero,-12(fp)
 2017f04:	00001306 	br	2017f54 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2017f08:	e0bffe17 	ldw	r2,-8(fp)
 2017f0c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 2017f10:	e0bffe17 	ldw	r2,-8(fp)
 2017f14:	e0ffff17 	ldw	r3,-4(fp)
 2017f18:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 2017f1c:	e0bffe17 	ldw	r2,-8(fp)
 2017f20:	00c00fc4 	movi	r3,63
 2017f24:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 2017f28:	e0bffe17 	ldw	r2,-8(fp)
 2017f2c:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 2017f30:	e0bffe17 	ldw	r2,-8(fp)
 2017f34:	10800b04 	addi	r2,r2,44
 2017f38:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 2017f3c:	e0bfff17 	ldw	r2,-4(fp)
 2017f40:	10800b04 	addi	r2,r2,44
 2017f44:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 2017f48:	e0bffd0b 	ldhu	r2,-12(fp)
 2017f4c:	10800044 	addi	r2,r2,1
 2017f50:	e0bffd0d 	sth	r2,-12(fp)
 2017f54:	e0bffd0b 	ldhu	r2,-12(fp)
 2017f58:	108004f0 	cmpltui	r2,r2,19
 2017f5c:	103fea1e 	bne	r2,zero,2017f08 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2017f60:	e0bffe17 	ldw	r2,-8(fp)
 2017f64:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 2017f68:	e0bffe17 	ldw	r2,-8(fp)
 2017f6c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 2017f70:	e0bffe17 	ldw	r2,-8(fp)
 2017f74:	00c00fc4 	movi	r3,63
 2017f78:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 2017f7c:	e0bffe17 	ldw	r2,-8(fp)
 2017f80:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 2017f84:	008080f4 	movhi	r2,515
 2017f88:	10ad0904 	addi	r2,r2,-19420
 2017f8c:	d0a76015 	stw	r2,-25216(gp)
#endif
}
 2017f90:	0001883a 	nop
 2017f94:	e037883a 	mov	sp,fp
 2017f98:	dfc00117 	ldw	ra,4(sp)
 2017f9c:	df000017 	ldw	fp,0(sp)
 2017fa0:	dec00204 	addi	sp,sp,8
 2017fa4:	f800283a 	ret

02017fa8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 2017fa8:	defffa04 	addi	sp,sp,-24
 2017fac:	dfc00515 	stw	ra,20(sp)
 2017fb0:	df000415 	stw	fp,16(sp)
 2017fb4:	df000404 	addi	fp,sp,16
 2017fb8:	e13ffe15 	stw	r4,-8(fp)
 2017fbc:	2805883a 	mov	r2,r5
 2017fc0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 2017fc4:	e0bffe17 	ldw	r2,-8(fp)
 2017fc8:	10800217 	ldw	r2,8(r2)
 2017fcc:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 2017fd0:	e0bffd17 	ldw	r2,-12(fp)
 2017fd4:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 2017fd8:	e0bffd17 	ldw	r2,-12(fp)
 2017fdc:	e0ffff0b 	ldhu	r3,-4(fp)
 2017fe0:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 2017fe4:	e0bffd17 	ldw	r2,-12(fp)
 2017fe8:	10c00c03 	ldbu	r3,48(r2)
 2017fec:	00bff7c4 	movi	r2,-33
 2017ff0:	1884703a 	and	r2,r3,r2
 2017ff4:	1007883a 	mov	r3,r2
 2017ff8:	e0bffd17 	ldw	r2,-12(fp)
 2017ffc:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 2018000:	e0bffd17 	ldw	r2,-12(fp)
 2018004:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 2018008:	e0bffd17 	ldw	r2,-12(fp)
 201800c:	10800c03 	ldbu	r2,48(r2)
 2018010:	10803fcc 	andi	r2,r2,255
 2018014:	1000181e 	bne	r2,zero,2018078 <OS_FlagTaskRdy+0xd0>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 2018018:	e0bffd17 	ldw	r2,-12(fp)
 201801c:	10c00d83 	ldbu	r3,54(r2)
 2018020:	d0a75b03 	ldbu	r2,-25236(gp)
 2018024:	1884b03a 	or	r2,r3,r2
 2018028:	d0a75b05 	stb	r2,-25236(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 201802c:	e0bffd17 	ldw	r2,-12(fp)
 2018030:	10800d03 	ldbu	r2,52(r2)
 2018034:	10c03fcc 	andi	r3,r2,255
 2018038:	e0bffd17 	ldw	r2,-12(fp)
 201803c:	10800d03 	ldbu	r2,52(r2)
 2018040:	11003fcc 	andi	r4,r2,255
 2018044:	d0a75b44 	addi	r2,gp,-25235
 2018048:	2085883a 	add	r2,r4,r2
 201804c:	11000003 	ldbu	r4,0(r2)
 2018050:	e0bffd17 	ldw	r2,-12(fp)
 2018054:	10800d43 	ldbu	r2,53(r2)
 2018058:	2084b03a 	or	r2,r4,r2
 201805c:	1009883a 	mov	r4,r2
 2018060:	d0a75b44 	addi	r2,gp,-25235
 2018064:	1885883a 	add	r2,r3,r2
 2018068:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
 201806c:	00800044 	movi	r2,1
 2018070:	e0bffc05 	stb	r2,-16(fp)
 2018074:	00000106 	br	201807c <OS_FlagTaskRdy+0xd4>
    } else {
        sched                   = OS_FALSE;
 2018078:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 201807c:	e13ffe17 	ldw	r4,-8(fp)
 2018080:	201809c0 	call	201809c <OS_FlagUnlink>
    return (sched);
 2018084:	e0bffc03 	ldbu	r2,-16(fp)
}
 2018088:	e037883a 	mov	sp,fp
 201808c:	dfc00117 	ldw	ra,4(sp)
 2018090:	df000017 	ldw	fp,0(sp)
 2018094:	dec00204 	addi	sp,sp,8
 2018098:	f800283a 	ret

0201809c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 201809c:	defffa04 	addi	sp,sp,-24
 20180a0:	df000515 	stw	fp,20(sp)
 20180a4:	df000504 	addi	fp,sp,20
 20180a8:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 20180ac:	e0bfff17 	ldw	r2,-4(fp)
 20180b0:	10800117 	ldw	r2,4(r2)
 20180b4:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 20180b8:	e0bfff17 	ldw	r2,-4(fp)
 20180bc:	10800017 	ldw	r2,0(r2)
 20180c0:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 20180c4:	e0bffb17 	ldw	r2,-20(fp)
 20180c8:	10000b1e 	bne	r2,zero,20180f8 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 20180cc:	e0bfff17 	ldw	r2,-4(fp)
 20180d0:	10800317 	ldw	r2,12(r2)
 20180d4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 20180d8:	e0bffd17 	ldw	r2,-12(fp)
 20180dc:	e0fffc17 	ldw	r3,-16(fp)
 20180e0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 20180e4:	e0bffc17 	ldw	r2,-16(fp)
 20180e8:	10000b26 	beq	r2,zero,2018118 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 20180ec:	e0bffc17 	ldw	r2,-16(fp)
 20180f0:	10000115 	stw	zero,4(r2)
 20180f4:	00000806 	br	2018118 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 20180f8:	e0bffb17 	ldw	r2,-20(fp)
 20180fc:	e0fffc17 	ldw	r3,-16(fp)
 2018100:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 2018104:	e0bffc17 	ldw	r2,-16(fp)
 2018108:	10000326 	beq	r2,zero,2018118 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 201810c:	e0bffc17 	ldw	r2,-16(fp)
 2018110:	e0fffb17 	ldw	r3,-20(fp)
 2018114:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 2018118:	e0bfff17 	ldw	r2,-4(fp)
 201811c:	10800217 	ldw	r2,8(r2)
 2018120:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 2018124:	e0bffe17 	ldw	r2,-8(fp)
 2018128:	10000a15 	stw	zero,40(r2)
#endif
}
 201812c:	0001883a 	nop
 2018130:	e037883a 	mov	sp,fp
 2018134:	df000017 	ldw	fp,0(sp)
 2018138:	dec00104 	addi	sp,sp,4
 201813c:	f800283a 	ret

02018140 <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
 2018140:	defffa04 	addi	sp,sp,-24
 2018144:	df000515 	stw	fp,20(sp)
 2018148:	df000504 	addi	fp,sp,20
 201814c:	e13fff15 	stw	r4,-4(fp)
    void      *pmsg;
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr = 0;
 2018150:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
 2018154:	e0bfff17 	ldw	r2,-4(fp)
 2018158:	1000021e 	bne	r2,zero,2018164 <OSMboxAccept+0x24>
        return ((void *)0);
 201815c:	0005883a 	mov	r2,zero
 2018160:	00001906 	br	20181c8 <OSMboxAccept+0x88>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
 2018164:	e0bfff17 	ldw	r2,-4(fp)
 2018168:	10800003 	ldbu	r2,0(r2)
 201816c:	10803fcc 	andi	r2,r2,255
 2018170:	10800060 	cmpeqi	r2,r2,1
 2018174:	1000021e 	bne	r2,zero,2018180 <OSMboxAccept+0x40>
        return ((void *)0);
 2018178:	0005883a 	mov	r2,zero
 201817c:	00001206 	br	20181c8 <OSMboxAccept+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018180:	0005303a 	rdctl	r2,status
 2018184:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018188:	e0fffd17 	ldw	r3,-12(fp)
 201818c:	00bfff84 	movi	r2,-2
 2018190:	1884703a 	and	r2,r3,r2
 2018194:	1001703a 	wrctl	status,r2
  
  return context;
 2018198:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 201819c:	e0bffb15 	stw	r2,-20(fp)
    pmsg               = pevent->OSEventPtr;
 20181a0:	e0bfff17 	ldw	r2,-4(fp)
 20181a4:	10800117 	ldw	r2,4(r2)
 20181a8:	e0bffc15 	stw	r2,-16(fp)
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
 20181ac:	e0bfff17 	ldw	r2,-4(fp)
 20181b0:	10000115 	stw	zero,4(r2)
 20181b4:	e0bffb17 	ldw	r2,-20(fp)
 20181b8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20181bc:	e0bffe17 	ldw	r2,-8(fp)
 20181c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                        /* Return the message received (or NULL)     */
 20181c4:	e0bffc17 	ldw	r2,-16(fp)
}
 20181c8:	e037883a 	mov	sp,fp
 20181cc:	df000017 	ldw	fp,0(sp)
 20181d0:	dec00104 	addi	sp,sp,4
 20181d4:	f800283a 	ret

020181d8 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *pmsg)
{
 20181d8:	defff904 	addi	sp,sp,-28
 20181dc:	dfc00615 	stw	ra,24(sp)
 20181e0:	df000515 	stw	fp,20(sp)
 20181e4:	df000504 	addi	fp,sp,20
 20181e8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20181ec:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 20181f0:	d0a75d03 	ldbu	r2,-25228(gp)
 20181f4:	10803fcc 	andi	r2,r2,255
 20181f8:	10000226 	beq	r2,zero,2018204 <OSMboxCreate+0x2c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 20181fc:	0005883a 	mov	r2,zero
 2018200:	00002506 	br	2018298 <OSMboxCreate+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018204:	0005303a 	rdctl	r2,status
 2018208:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201820c:	e0fffe17 	ldw	r3,-8(fp)
 2018210:	00bfff84 	movi	r2,-2
 2018214:	1884703a 	and	r2,r3,r2
 2018218:	1001703a 	wrctl	status,r2
  
  return context;
 201821c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 2018220:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 2018224:	d0a75c17 	ldw	r2,-25232(gp)
 2018228:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 201822c:	d0a75c17 	ldw	r2,-25232(gp)
 2018230:	10000326 	beq	r2,zero,2018240 <OSMboxCreate+0x68>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 2018234:	d0a75c17 	ldw	r2,-25232(gp)
 2018238:	10800117 	ldw	r2,4(r2)
 201823c:	d0a75c15 	stw	r2,-25232(gp)
 2018240:	e0bffb17 	ldw	r2,-20(fp)
 2018244:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018248:	e0bffc17 	ldw	r2,-16(fp)
 201824c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {
 2018250:	e0bffd17 	ldw	r2,-12(fp)
 2018254:	10000f26 	beq	r2,zero,2018294 <OSMboxCreate+0xbc>
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
 2018258:	e0bffd17 	ldw	r2,-12(fp)
 201825c:	00c00044 	movi	r3,1
 2018260:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = 0;
 2018264:	e0bffd17 	ldw	r2,-12(fp)
 2018268:	1000020d 	sth	zero,8(r2)
        pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
 201826c:	e0bffd17 	ldw	r2,-12(fp)
 2018270:	e0ffff17 	ldw	r3,-4(fp)
 2018274:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
 2018278:	e0bffd17 	ldw	r2,-12(fp)
 201827c:	00c00fc4 	movi	r3,63
 2018280:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 2018284:	e0bffd17 	ldw	r2,-12(fp)
 2018288:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);
 201828c:	e13ffd17 	ldw	r4,-12(fp)
 2018290:	2015d2c0 	call	2015d2c <OS_EventWaitListInit>
    }
    return (pevent);                             /* Return pointer to event control block              */
 2018294:	e0bffd17 	ldw	r2,-12(fp)
}
 2018298:	e037883a 	mov	sp,fp
 201829c:	dfc00117 	ldw	ra,4(sp)
 20182a0:	df000017 	ldw	fp,0(sp)
 20182a4:	dec00204 	addi	sp,sp,8
 20182a8:	f800283a 	ret

020182ac <OSMboxDel>:
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 20182ac:	defff304 	addi	sp,sp,-52
 20182b0:	dfc00c15 	stw	ra,48(sp)
 20182b4:	df000b15 	stw	fp,44(sp)
 20182b8:	df000b04 	addi	fp,sp,44
 20182bc:	e13ffd15 	stw	r4,-12(fp)
 20182c0:	2805883a 	mov	r2,r5
 20182c4:	e1bfff15 	stw	r6,-4(fp)
 20182c8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 20182cc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 20182d0:	e0bfff17 	ldw	r2,-4(fp)
 20182d4:	1000021e 	bne	r2,zero,20182e0 <OSMboxDel+0x34>
        return (pevent);
 20182d8:	e0bffd17 	ldw	r2,-12(fp)
 20182dc:	00007e06 	br	20184d8 <OSMboxDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 20182e0:	e0bffd17 	ldw	r2,-12(fp)
 20182e4:	1000051e 	bne	r2,zero,20182fc <OSMboxDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 20182e8:	e0bfff17 	ldw	r2,-4(fp)
 20182ec:	00c00104 	movi	r3,4
 20182f0:	10c00005 	stb	r3,0(r2)
        return (pevent);
 20182f4:	e0bffd17 	ldw	r2,-12(fp)
 20182f8:	00007706 	br	20184d8 <OSMboxDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 20182fc:	e0bffd17 	ldw	r2,-12(fp)
 2018300:	10800003 	ldbu	r2,0(r2)
 2018304:	10803fcc 	andi	r2,r2,255
 2018308:	10800060 	cmpeqi	r2,r2,1
 201830c:	1000051e 	bne	r2,zero,2018324 <OSMboxDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2018310:	e0bfff17 	ldw	r2,-4(fp)
 2018314:	00c00044 	movi	r3,1
 2018318:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201831c:	e0bffd17 	ldw	r2,-12(fp)
 2018320:	00006d06 	br	20184d8 <OSMboxDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 2018324:	d0a75d03 	ldbu	r2,-25228(gp)
 2018328:	10803fcc 	andi	r2,r2,255
 201832c:	10000526 	beq	r2,zero,2018344 <OSMboxDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 2018330:	e0bfff17 	ldw	r2,-4(fp)
 2018334:	00c003c4 	movi	r3,15
 2018338:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201833c:	e0bffd17 	ldw	r2,-12(fp)
 2018340:	00006506 	br	20184d8 <OSMboxDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018344:	0005303a 	rdctl	r2,status
 2018348:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201834c:	e0fffc17 	ldw	r3,-16(fp)
 2018350:	00bfff84 	movi	r2,-2
 2018354:	1884703a 	and	r2,r3,r2
 2018358:	1001703a 	wrctl	status,r2
  
  return context;
 201835c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2018360:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
 2018364:	e0bffd17 	ldw	r2,-12(fp)
 2018368:	10800283 	ldbu	r2,10(r2)
 201836c:	10803fcc 	andi	r2,r2,255
 2018370:	10000326 	beq	r2,zero,2018380 <OSMboxDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 2018374:	00800044 	movi	r2,1
 2018378:	e0bff505 	stb	r2,-44(fp)
 201837c:	00000106 	br	2018384 <OSMboxDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 2018380:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 2018384:	e0bffe03 	ldbu	r2,-8(fp)
 2018388:	10000326 	beq	r2,zero,2018398 <OSMboxDel+0xec>
 201838c:	10800060 	cmpeqi	r2,r2,1
 2018390:	1000281e 	bne	r2,zero,2018434 <OSMboxDel+0x188>
 2018394:	00004506 	br	20184ac <OSMboxDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
 2018398:	e0bff503 	ldbu	r2,-44(fp)
 201839c:	1000161e 	bne	r2,zero,20183f8 <OSMboxDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 20183a0:	e0bffd17 	ldw	r2,-12(fp)
 20183a4:	00c00fc4 	movi	r3,63
 20183a8:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 20183ac:	e0bffd17 	ldw	r2,-12(fp)
 20183b0:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 20183b4:	e0bffd17 	ldw	r2,-12(fp)
 20183b8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 20183bc:	d0e75c17 	ldw	r3,-25232(gp)
 20183c0:	e0bffd17 	ldw	r2,-12(fp)
 20183c4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
 20183c8:	e0bffd17 	ldw	r2,-12(fp)
 20183cc:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
 20183d0:	e0bffd17 	ldw	r2,-12(fp)
 20183d4:	d0a75c15 	stw	r2,-25232(gp)
 20183d8:	e0bff717 	ldw	r2,-36(fp)
 20183dc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20183e0:	e0bff817 	ldw	r2,-32(fp)
 20183e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
 20183e8:	e0bfff17 	ldw	r2,-4(fp)
 20183ec:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
 20183f0:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
 20183f4:	00003706 	br	20184d4 <OSMboxDel+0x228>
 20183f8:	e0bff717 	ldw	r2,-36(fp)
 20183fc:	e0bff915 	stw	r2,-28(fp)
 2018400:	e0bff917 	ldw	r2,-28(fp)
 2018404:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
 2018408:	e0bfff17 	ldw	r2,-4(fp)
 201840c:	00c01244 	movi	r3,73
 2018410:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
 2018414:	e0bffd17 	ldw	r2,-12(fp)
 2018418:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 201841c:	00002d06 	br	20184d4 <OSMboxDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
 2018420:	000f883a 	mov	r7,zero
 2018424:	01800084 	movi	r6,2
 2018428:	000b883a 	mov	r5,zero
 201842c:	e13ffd17 	ldw	r4,-12(fp)
 2018430:	201577c0 	call	201577c <OS_EventTaskRdy>
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
 2018434:	e0bffd17 	ldw	r2,-12(fp)
 2018438:	10800283 	ldbu	r2,10(r2)
 201843c:	10803fcc 	andi	r2,r2,255
 2018440:	103ff71e 	bne	r2,zero,2018420 <OSMboxDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 2018444:	e0bffd17 	ldw	r2,-12(fp)
 2018448:	00c00fc4 	movi	r3,63
 201844c:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 2018450:	e0bffd17 	ldw	r2,-12(fp)
 2018454:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2018458:	e0bffd17 	ldw	r2,-12(fp)
 201845c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 2018460:	d0e75c17 	ldw	r3,-25232(gp)
 2018464:	e0bffd17 	ldw	r2,-12(fp)
 2018468:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 201846c:	e0bffd17 	ldw	r2,-12(fp)
 2018470:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 2018474:	e0bffd17 	ldw	r2,-12(fp)
 2018478:	d0a75c15 	stw	r2,-25232(gp)
 201847c:	e0bff717 	ldw	r2,-36(fp)
 2018480:	e0bffa15 	stw	r2,-24(fp)
 2018484:	e0bffa17 	ldw	r2,-24(fp)
 2018488:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 201848c:	e0bff503 	ldbu	r2,-44(fp)
 2018490:	10800058 	cmpnei	r2,r2,1
 2018494:	1000011e 	bne	r2,zero,201849c <OSMboxDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 2018498:	20161c80 	call	20161c8 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
 201849c:	e0bfff17 	ldw	r2,-4(fp)
 20184a0:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
 20184a4:	e03ff615 	stw	zero,-40(fp)
             break;
 20184a8:	00000a06 	br	20184d4 <OSMboxDel+0x228>
 20184ac:	e0bff717 	ldw	r2,-36(fp)
 20184b0:	e0bffb15 	stw	r2,-20(fp)
 20184b4:	e0bffb17 	ldw	r2,-20(fp)
 20184b8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
 20184bc:	e0bfff17 	ldw	r2,-4(fp)
 20184c0:	00c001c4 	movi	r3,7
 20184c4:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
 20184c8:	e0bffd17 	ldw	r2,-12(fp)
 20184cc:	e0bff615 	stw	r2,-40(fp)
             break;
 20184d0:	0001883a 	nop
    }
    return (pevent_return);
 20184d4:	e0bff617 	ldw	r2,-40(fp)
}
 20184d8:	e037883a 	mov	sp,fp
 20184dc:	dfc00117 	ldw	ra,4(sp)
 20184e0:	df000017 	ldw	fp,0(sp)
 20184e4:	dec00204 	addi	sp,sp,8
 20184e8:	f800283a 	ret

020184ec <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/
/*$PAGE*/
void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 20184ec:	defff404 	addi	sp,sp,-48
 20184f0:	dfc00b15 	stw	ra,44(sp)
 20184f4:	df000a15 	stw	fp,40(sp)
 20184f8:	df000a04 	addi	fp,sp,40
 20184fc:	e13ffd15 	stw	r4,-12(fp)
 2018500:	2805883a 	mov	r2,r5
 2018504:	e1bfff15 	stw	r6,-4(fp)
 2018508:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201850c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 2018510:	e0bfff17 	ldw	r2,-4(fp)
 2018514:	1000021e 	bne	r2,zero,2018520 <OSMboxPend+0x34>
        return ((void *)0);
 2018518:	0005883a 	mov	r2,zero
 201851c:	00007b06 	br	201870c <OSMboxPend+0x220>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 2018520:	e0bffd17 	ldw	r2,-12(fp)
 2018524:	1000051e 	bne	r2,zero,201853c <OSMboxPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 2018528:	e0bfff17 	ldw	r2,-4(fp)
 201852c:	00c00104 	movi	r3,4
 2018530:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2018534:	0005883a 	mov	r2,zero
 2018538:	00007406 	br	201870c <OSMboxPend+0x220>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 201853c:	e0bffd17 	ldw	r2,-12(fp)
 2018540:	10800003 	ldbu	r2,0(r2)
 2018544:	10803fcc 	andi	r2,r2,255
 2018548:	10800060 	cmpeqi	r2,r2,1
 201854c:	1000051e 	bne	r2,zero,2018564 <OSMboxPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2018550:	e0bfff17 	ldw	r2,-4(fp)
 2018554:	00c00044 	movi	r3,1
 2018558:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201855c:	0005883a 	mov	r2,zero
 2018560:	00006a06 	br	201870c <OSMboxPend+0x220>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 2018564:	d0a75d03 	ldbu	r2,-25228(gp)
 2018568:	10803fcc 	andi	r2,r2,255
 201856c:	10000526 	beq	r2,zero,2018584 <OSMboxPend+0x98>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 2018570:	e0bfff17 	ldw	r2,-4(fp)
 2018574:	00c00084 	movi	r3,2
 2018578:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201857c:	0005883a 	mov	r2,zero
 2018580:	00006206 	br	201870c <OSMboxPend+0x220>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 2018584:	d0a74f03 	ldbu	r2,-25284(gp)
 2018588:	10803fcc 	andi	r2,r2,255
 201858c:	10000526 	beq	r2,zero,20185a4 <OSMboxPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 2018590:	e0bfff17 	ldw	r2,-4(fp)
 2018594:	00c00344 	movi	r3,13
 2018598:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201859c:	0005883a 	mov	r2,zero
 20185a0:	00005a06 	br	201870c <OSMboxPend+0x220>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20185a4:	0005303a 	rdctl	r2,status
 20185a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20185ac:	e0fffc17 	ldw	r3,-16(fp)
 20185b0:	00bfff84 	movi	r2,-2
 20185b4:	1884703a 	and	r2,r3,r2
 20185b8:	1001703a 	wrctl	status,r2
  
  return context;
 20185bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 20185c0:	e0bff715 	stw	r2,-36(fp)
    pmsg = pevent->OSEventPtr;
 20185c4:	e0bffd17 	ldw	r2,-12(fp)
 20185c8:	10800117 	ldw	r2,4(r2)
 20185cc:	e0bff615 	stw	r2,-40(fp)
    if (pmsg != (void *)0) {                          /* See if there is already a message             */
 20185d0:	e0bff617 	ldw	r2,-40(fp)
 20185d4:	10000a26 	beq	r2,zero,2018600 <OSMboxPend+0x114>
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
 20185d8:	e0bffd17 	ldw	r2,-12(fp)
 20185dc:	10000115 	stw	zero,4(r2)
 20185e0:	e0bff717 	ldw	r2,-36(fp)
 20185e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20185e8:	e0bff817 	ldw	r2,-32(fp)
 20185ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 20185f0:	e0bfff17 	ldw	r2,-4(fp)
 20185f4:	10000005 	stb	zero,0(r2)
        return (pmsg);                                /* Return the message received (or NULL)         */
 20185f8:	e0bff617 	ldw	r2,-40(fp)
 20185fc:	00004306 	br	201870c <OSMboxPend+0x220>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
 2018600:	d0a75e17 	ldw	r2,-25224(gp)
 2018604:	d0e75e17 	ldw	r3,-25224(gp)
 2018608:	18c00c03 	ldbu	r3,48(r3)
 201860c:	18c00094 	ori	r3,r3,2
 2018610:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2018614:	d0a75e17 	ldw	r2,-25224(gp)
 2018618:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
 201861c:	d0a75e17 	ldw	r2,-25224(gp)
 2018620:	e0fffe0b 	ldhu	r3,-8(fp)
 2018624:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 2018628:	e13ffd17 	ldw	r4,-12(fp)
 201862c:	20159140 	call	2015914 <OS_EventTaskWait>
 2018630:	e0bff717 	ldw	r2,-36(fp)
 2018634:	e0bffb15 	stw	r2,-20(fp)
 2018638:	e0bffb17 	ldw	r2,-20(fp)
 201863c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready to run  */
 2018640:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018644:	0005303a 	rdctl	r2,status
 2018648:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201864c:	e0fff917 	ldw	r3,-28(fp)
 2018650:	00bfff84 	movi	r2,-2
 2018654:	1884703a 	and	r2,r3,r2
 2018658:	1001703a 	wrctl	status,r2
  
  return context;
 201865c:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 2018660:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 2018664:	d0a75e17 	ldw	r2,-25224(gp)
 2018668:	10800c43 	ldbu	r2,49(r2)
 201866c:	10803fcc 	andi	r2,r2,255
 2018670:	10000326 	beq	r2,zero,2018680 <OSMboxPend+0x194>
 2018674:	108000a0 	cmpeqi	r2,r2,2
 2018678:	1000071e 	bne	r2,zero,2018698 <OSMboxPend+0x1ac>
 201867c:	00000b06 	br	20186ac <OSMboxPend+0x1c0>
        case OS_STAT_PEND_OK:
             pmsg =  OSTCBCur->OSTCBMsg;
 2018680:	d0a75e17 	ldw	r2,-25224(gp)
 2018684:	10800917 	ldw	r2,36(r2)
 2018688:	e0bff615 	stw	r2,-40(fp)
            *perr =  OS_ERR_NONE;
 201868c:	e0bfff17 	ldw	r2,-4(fp)
 2018690:	10000005 	stb	zero,0(r2)
             break;
 2018694:	00000e06 	br	20186d0 <OSMboxPend+0x1e4>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 2018698:	e03ff615 	stw	zero,-40(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 201869c:	e0bfff17 	ldw	r2,-4(fp)
 20186a0:	00c00384 	movi	r3,14
 20186a4:	10c00005 	stb	r3,0(r2)
             break;
 20186a8:	00000906 	br	20186d0 <OSMboxPend+0x1e4>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 20186ac:	d0a75e17 	ldw	r2,-25224(gp)
 20186b0:	e17ffd17 	ldw	r5,-12(fp)
 20186b4:	1009883a 	mov	r4,r2
 20186b8:	2015b740 	call	2015b74 <OS_EventTaskRemove>
             pmsg = (void *)0;
 20186bc:	e03ff615 	stw	zero,-40(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 20186c0:	e0bfff17 	ldw	r2,-4(fp)
 20186c4:	00c00284 	movi	r3,10
 20186c8:	10c00005 	stb	r3,0(r2)
             break;
 20186cc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 20186d0:	d0a75e17 	ldw	r2,-25224(gp)
 20186d4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 20186d8:	d0a75e17 	ldw	r2,-25224(gp)
 20186dc:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 20186e0:	d0a75e17 	ldw	r2,-25224(gp)
 20186e4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 20186e8:	d0a75e17 	ldw	r2,-25224(gp)
 20186ec:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 20186f0:	d0a75e17 	ldw	r2,-25224(gp)
 20186f4:	10000915 	stw	zero,36(r2)
 20186f8:	e0bff717 	ldw	r2,-36(fp)
 20186fc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018700:	e0bffa17 	ldw	r2,-24(fp)
 2018704:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 2018708:	e0bff617 	ldw	r2,-40(fp)
}
 201870c:	e037883a 	mov	sp,fp
 2018710:	dfc00117 	ldw	ra,4(sp)
 2018714:	df000017 	ldw	fp,0(sp)
 2018718:	dec00204 	addi	sp,sp,8
 201871c:	f800283a 	ret

02018720 <OSMboxPendAbort>:
*********************************************************************************************************
*/

#if OS_MBOX_PEND_ABORT_EN > 0
INT8U  OSMboxPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 2018720:	defff604 	addi	sp,sp,-40
 2018724:	dfc00915 	stw	ra,36(sp)
 2018728:	df000815 	stw	fp,32(sp)
 201872c:	df000804 	addi	fp,sp,32
 2018730:	e13ffd15 	stw	r4,-12(fp)
 2018734:	2805883a 	mov	r2,r5
 2018738:	e1bfff15 	stw	r6,-4(fp)
 201873c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2018740:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2018744:	e0bfff17 	ldw	r2,-4(fp)
 2018748:	1000021e 	bne	r2,zero,2018754 <OSMboxPendAbort+0x34>
        return (0);
 201874c:	0005883a 	mov	r2,zero
 2018750:	00004906 	br	2018878 <OSMboxPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 2018754:	e0bffd17 	ldw	r2,-12(fp)
 2018758:	1000051e 	bne	r2,zero,2018770 <OSMboxPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201875c:	e0bfff17 	ldw	r2,-4(fp)
 2018760:	00c00104 	movi	r3,4
 2018764:	10c00005 	stb	r3,0(r2)
        return (0);
 2018768:	0005883a 	mov	r2,zero
 201876c:	00004206 	br	2018878 <OSMboxPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 2018770:	e0bffd17 	ldw	r2,-12(fp)
 2018774:	10800003 	ldbu	r2,0(r2)
 2018778:	10803fcc 	andi	r2,r2,255
 201877c:	10800060 	cmpeqi	r2,r2,1
 2018780:	1000051e 	bne	r2,zero,2018798 <OSMboxPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2018784:	e0bfff17 	ldw	r2,-4(fp)
 2018788:	00c00044 	movi	r3,1
 201878c:	10c00005 	stb	r3,0(r2)
        return (0);
 2018790:	0005883a 	mov	r2,zero
 2018794:	00003806 	br	2018878 <OSMboxPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018798:	0005303a 	rdctl	r2,status
 201879c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20187a0:	e0fffc17 	ldw	r3,-16(fp)
 20187a4:	00bfff84 	movi	r2,-2
 20187a8:	1884703a 	and	r2,r3,r2
 20187ac:	1001703a 	wrctl	status,r2
  
  return context;
 20187b0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 20187b4:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
 20187b8:	e0bffd17 	ldw	r2,-12(fp)
 20187bc:	10800283 	ldbu	r2,10(r2)
 20187c0:	10803fcc 	andi	r2,r2,255
 20187c4:	10002526 	beq	r2,zero,201885c <OSMboxPendAbort+0x13c>
        nbr_tasks = 0;
 20187c8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 20187cc:	e0bffe03 	ldbu	r2,-8(fp)
 20187d0:	10800060 	cmpeqi	r2,r2,1
 20187d4:	10000e26 	beq	r2,zero,2018810 <OSMboxPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
 20187d8:	00000806 	br	20187fc <OSMboxPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
 20187dc:	01c00084 	movi	r7,2
 20187e0:	01800084 	movi	r6,2
 20187e4:	000b883a 	mov	r5,zero
 20187e8:	e13ffd17 	ldw	r4,-12(fp)
 20187ec:	201577c0 	call	201577c <OS_EventTaskRdy>
                     nbr_tasks++;
 20187f0:	e0bff803 	ldbu	r2,-32(fp)
 20187f4:	10800044 	addi	r2,r2,1
 20187f8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
 20187fc:	e0bffd17 	ldw	r2,-12(fp)
 2018800:	10800283 	ldbu	r2,10(r2)
 2018804:	10803fcc 	andi	r2,r2,255
 2018808:	103ff41e 	bne	r2,zero,20187dc <OSMboxPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 201880c:	00000906 	br	2018834 <OSMboxPendAbort+0x114>
             
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on mailbox  */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
 2018810:	01c00084 	movi	r7,2
 2018814:	01800084 	movi	r6,2
 2018818:	000b883a 	mov	r5,zero
 201881c:	e13ffd17 	ldw	r4,-12(fp)
 2018820:	201577c0 	call	201577c <OS_EventTaskRdy>
                 nbr_tasks++;
 2018824:	e0bff803 	ldbu	r2,-32(fp)
 2018828:	10800044 	addi	r2,r2,1
 201882c:	e0bff805 	stb	r2,-32(fp)
                 break;
 2018830:	0001883a 	nop
 2018834:	e0bff917 	ldw	r2,-28(fp)
 2018838:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201883c:	e0bffa17 	ldw	r2,-24(fp)
 2018840:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 2018844:	20161c80 	call	20161c8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 2018848:	e0bfff17 	ldw	r2,-4(fp)
 201884c:	00c00384 	movi	r3,14
 2018850:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 2018854:	e0bff803 	ldbu	r2,-32(fp)
 2018858:	00000706 	br	2018878 <OSMboxPendAbort+0x158>
 201885c:	e0bff917 	ldw	r2,-28(fp)
 2018860:	e0bffb15 	stw	r2,-20(fp)
 2018864:	e0bffb17 	ldw	r2,-20(fp)
 2018868:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201886c:	e0bfff17 	ldw	r2,-4(fp)
 2018870:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on mailbox              */
 2018874:	0005883a 	mov	r2,zero
}
 2018878:	e037883a 	mov	sp,fp
 201887c:	dfc00117 	ldw	ra,4(sp)
 2018880:	df000017 	ldw	fp,0(sp)
 2018884:	dec00204 	addi	sp,sp,8
 2018888:	f800283a 	ret

0201888c <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *pmsg)
{
 201888c:	defff704 	addi	sp,sp,-36
 2018890:	dfc00815 	stw	ra,32(sp)
 2018894:	df000715 	stw	fp,28(sp)
 2018898:	df000704 	addi	fp,sp,28
 201889c:	e13ffe15 	stw	r4,-8(fp)
 20188a0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 20188a4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 20188a8:	e0bffe17 	ldw	r2,-8(fp)
 20188ac:	1000021e 	bne	r2,zero,20188b8 <OSMboxPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 20188b0:	00800104 	movi	r2,4
 20188b4:	00003406 	br	2018988 <OSMboxPost+0xfc>
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
 20188b8:	e0bfff17 	ldw	r2,-4(fp)
 20188bc:	1000021e 	bne	r2,zero,20188c8 <OSMboxPost+0x3c>
        return (OS_ERR_POST_NULL_PTR);
 20188c0:	008000c4 	movi	r2,3
 20188c4:	00003006 	br	2018988 <OSMboxPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 20188c8:	e0bffe17 	ldw	r2,-8(fp)
 20188cc:	10800003 	ldbu	r2,0(r2)
 20188d0:	10803fcc 	andi	r2,r2,255
 20188d4:	10800060 	cmpeqi	r2,r2,1
 20188d8:	1000021e 	bne	r2,zero,20188e4 <OSMboxPost+0x58>
        return (OS_ERR_EVENT_TYPE);
 20188dc:	00800044 	movi	r2,1
 20188e0:	00002906 	br	2018988 <OSMboxPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20188e4:	0005303a 	rdctl	r2,status
 20188e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20188ec:	e0fffd17 	ldw	r3,-12(fp)
 20188f0:	00bfff84 	movi	r2,-2
 20188f4:	1884703a 	and	r2,r3,r2
 20188f8:	1001703a 	wrctl	status,r2
  
  return context;
 20188fc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2018900:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
 2018904:	e0bffe17 	ldw	r2,-8(fp)
 2018908:	10800283 	ldbu	r2,10(r2)
 201890c:	10803fcc 	andi	r2,r2,255
 2018910:	10000c26 	beq	r2,zero,2018944 <OSMboxPost+0xb8>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 2018914:	000f883a 	mov	r7,zero
 2018918:	01800084 	movi	r6,2
 201891c:	e17fff17 	ldw	r5,-4(fp)
 2018920:	e13ffe17 	ldw	r4,-8(fp)
 2018924:	201577c0 	call	201577c <OS_EventTaskRdy>
 2018928:	e0bff917 	ldw	r2,-28(fp)
 201892c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018930:	e0bffa17 	ldw	r2,-24(fp)
 2018934:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 2018938:	20161c80 	call	20161c8 <OS_Sched>
        return (OS_ERR_NONE);
 201893c:	0005883a 	mov	r2,zero
 2018940:	00001106 	br	2018988 <OSMboxPost+0xfc>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 2018944:	e0bffe17 	ldw	r2,-8(fp)
 2018948:	10800117 	ldw	r2,4(r2)
 201894c:	10000626 	beq	r2,zero,2018968 <OSMboxPost+0xdc>
 2018950:	e0bff917 	ldw	r2,-28(fp)
 2018954:	e0bffb15 	stw	r2,-20(fp)
 2018958:	e0bffb17 	ldw	r2,-20(fp)
 201895c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MBOX_FULL);
 2018960:	00800504 	movi	r2,20
 2018964:	00000806 	br	2018988 <OSMboxPost+0xfc>
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
 2018968:	e0bffe17 	ldw	r2,-8(fp)
 201896c:	e0ffff17 	ldw	r3,-4(fp)
 2018970:	10c00115 	stw	r3,4(r2)
 2018974:	e0bff917 	ldw	r2,-28(fp)
 2018978:	e0bffc15 	stw	r2,-16(fp)
 201897c:	e0bffc17 	ldw	r2,-16(fp)
 2018980:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 2018984:	0005883a 	mov	r2,zero
}
 2018988:	e037883a 	mov	sp,fp
 201898c:	dfc00117 	ldw	ra,4(sp)
 2018990:	df000017 	ldw	fp,0(sp)
 2018994:	dec00204 	addi	sp,sp,8
 2018998:	f800283a 	ret

0201899c <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 201899c:	defff604 	addi	sp,sp,-40
 20189a0:	dfc00915 	stw	ra,36(sp)
 20189a4:	df000815 	stw	fp,32(sp)
 20189a8:	df000804 	addi	fp,sp,32
 20189ac:	e13ffd15 	stw	r4,-12(fp)
 20189b0:	e17ffe15 	stw	r5,-8(fp)
 20189b4:	3005883a 	mov	r2,r6
 20189b8:	e0bfff05 	stb	r2,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 20189bc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 20189c0:	e0bffd17 	ldw	r2,-12(fp)
 20189c4:	1000021e 	bne	r2,zero,20189d0 <OSMboxPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 20189c8:	00800104 	movi	r2,4
 20189cc:	00004506 	br	2018ae4 <OSMboxPostOpt+0x148>
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
 20189d0:	e0bffe17 	ldw	r2,-8(fp)
 20189d4:	1000021e 	bne	r2,zero,20189e0 <OSMboxPostOpt+0x44>
        return (OS_ERR_POST_NULL_PTR);
 20189d8:	008000c4 	movi	r2,3
 20189dc:	00004106 	br	2018ae4 <OSMboxPostOpt+0x148>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 20189e0:	e0bffd17 	ldw	r2,-12(fp)
 20189e4:	10800003 	ldbu	r2,0(r2)
 20189e8:	10803fcc 	andi	r2,r2,255
 20189ec:	10800060 	cmpeqi	r2,r2,1
 20189f0:	1000021e 	bne	r2,zero,20189fc <OSMboxPostOpt+0x60>
        return (OS_ERR_EVENT_TYPE);
 20189f4:	00800044 	movi	r2,1
 20189f8:	00003a06 	br	2018ae4 <OSMboxPostOpt+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20189fc:	0005303a 	rdctl	r2,status
 2018a00:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018a04:	e0fffc17 	ldw	r3,-16(fp)
 2018a08:	00bfff84 	movi	r2,-2
 2018a0c:	1884703a 	and	r2,r3,r2
 2018a10:	1001703a 	wrctl	status,r2
  
  return context;
 2018a14:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2018a18:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
 2018a1c:	e0bffd17 	ldw	r2,-12(fp)
 2018a20:	10800283 	ldbu	r2,10(r2)
 2018a24:	10803fcc 	andi	r2,r2,255
 2018a28:	10001d26 	beq	r2,zero,2018aa0 <OSMboxPostOpt+0x104>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 2018a2c:	e0bfff03 	ldbu	r2,-4(fp)
 2018a30:	1080004c 	andi	r2,r2,1
 2018a34:	10000b26 	beq	r2,zero,2018a64 <OSMboxPostOpt+0xc8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
 2018a38:	00000506 	br	2018a50 <OSMboxPostOpt+0xb4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 2018a3c:	000f883a 	mov	r7,zero
 2018a40:	01800084 	movi	r6,2
 2018a44:	e17ffe17 	ldw	r5,-8(fp)
 2018a48:	e13ffd17 	ldw	r4,-12(fp)
 2018a4c:	201577c0 	call	201577c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
 2018a50:	e0bffd17 	ldw	r2,-12(fp)
 2018a54:	10800283 	ldbu	r2,10(r2)
 2018a58:	10803fcc 	andi	r2,r2,255
 2018a5c:	103ff71e 	bne	r2,zero,2018a3c <OSMboxPostOpt+0xa0>
 2018a60:	00000506 	br	2018a78 <OSMboxPostOpt+0xdc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 2018a64:	000f883a 	mov	r7,zero
 2018a68:	01800084 	movi	r6,2
 2018a6c:	e17ffe17 	ldw	r5,-8(fp)
 2018a70:	e13ffd17 	ldw	r4,-12(fp)
 2018a74:	201577c0 	call	201577c <OS_EventTaskRdy>
 2018a78:	e0bff817 	ldw	r2,-32(fp)
 2018a7c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018a80:	e0bff917 	ldw	r2,-28(fp)
 2018a84:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 2018a88:	e0bfff03 	ldbu	r2,-4(fp)
 2018a8c:	1080010c 	andi	r2,r2,4
 2018a90:	1000011e 	bne	r2,zero,2018a98 <OSMboxPostOpt+0xfc>
            OS_Sched();                               /* Find HPT ready to run                         */
 2018a94:	20161c80 	call	20161c8 <OS_Sched>
        }
        return (OS_ERR_NONE);
 2018a98:	0005883a 	mov	r2,zero
 2018a9c:	00001106 	br	2018ae4 <OSMboxPostOpt+0x148>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 2018aa0:	e0bffd17 	ldw	r2,-12(fp)
 2018aa4:	10800117 	ldw	r2,4(r2)
 2018aa8:	10000626 	beq	r2,zero,2018ac4 <OSMboxPostOpt+0x128>
 2018aac:	e0bff817 	ldw	r2,-32(fp)
 2018ab0:	e0bffa15 	stw	r2,-24(fp)
 2018ab4:	e0bffa17 	ldw	r2,-24(fp)
 2018ab8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MBOX_FULL);
 2018abc:	00800504 	movi	r2,20
 2018ac0:	00000806 	br	2018ae4 <OSMboxPostOpt+0x148>
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
 2018ac4:	e0bffd17 	ldw	r2,-12(fp)
 2018ac8:	e0fffe17 	ldw	r3,-8(fp)
 2018acc:	10c00115 	stw	r3,4(r2)
 2018ad0:	e0bff817 	ldw	r2,-32(fp)
 2018ad4:	e0bffb15 	stw	r2,-20(fp)
 2018ad8:	e0bffb17 	ldw	r2,-20(fp)
 2018adc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 2018ae0:	0005883a 	mov	r2,zero
}
 2018ae4:	e037883a 	mov	sp,fp
 2018ae8:	dfc00117 	ldw	ra,4(sp)
 2018aec:	df000017 	ldw	fp,0(sp)
 2018af0:	dec00204 	addi	sp,sp,8
 2018af4:	f800283a 	ret

02018af8 <OSMboxQuery>:
*********************************************************************************************************
*/

#if OS_MBOX_QUERY_EN > 0
INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
{
 2018af8:	defff704 	addi	sp,sp,-36
 2018afc:	df000815 	stw	fp,32(sp)
 2018b00:	df000804 	addi	fp,sp,32
 2018b04:	e13ffe15 	stw	r4,-8(fp)
 2018b08:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2018b0c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 2018b10:	e0bffe17 	ldw	r2,-8(fp)
 2018b14:	1000021e 	bne	r2,zero,2018b20 <OSMboxQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 2018b18:	00800104 	movi	r2,4
 2018b1c:	00003606 	br	2018bf8 <OSMboxQuery+0x100>
    }
    if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
 2018b20:	e0bfff17 	ldw	r2,-4(fp)
 2018b24:	1000021e 	bne	r2,zero,2018b30 <OSMboxQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 2018b28:	00800244 	movi	r2,9
 2018b2c:	00003206 	br	2018bf8 <OSMboxQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 2018b30:	e0bffe17 	ldw	r2,-8(fp)
 2018b34:	10800003 	ldbu	r2,0(r2)
 2018b38:	10803fcc 	andi	r2,r2,255
 2018b3c:	10800060 	cmpeqi	r2,r2,1
 2018b40:	1000021e 	bne	r2,zero,2018b4c <OSMboxQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 2018b44:	00800044 	movi	r2,1
 2018b48:	00002b06 	br	2018bf8 <OSMboxQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018b4c:	0005303a 	rdctl	r2,status
 2018b50:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018b54:	e0fffd17 	ldw	r3,-12(fp)
 2018b58:	00bfff84 	movi	r2,-2
 2018b5c:	1884703a 	and	r2,r3,r2
 2018b60:	1001703a 	wrctl	status,r2
  
  return context;
 2018b64:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2018b68:	e0bffb15 	stw	r2,-20(fp)
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
 2018b6c:	e0bffe17 	ldw	r2,-8(fp)
 2018b70:	10c00283 	ldbu	r3,10(r2)
 2018b74:	e0bfff17 	ldw	r2,-4(fp)
 2018b78:	10c001c5 	stb	r3,7(r2)
    psrc                    = &pevent->OSEventTbl[0];
 2018b7c:	e0bffe17 	ldw	r2,-8(fp)
 2018b80:	108002c4 	addi	r2,r2,11
 2018b84:	e0bff915 	stw	r2,-28(fp)
    pdest                   = &p_mbox_data->OSEventTbl[0];
 2018b88:	e0bfff17 	ldw	r2,-4(fp)
 2018b8c:	10800104 	addi	r2,r2,4
 2018b90:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 2018b94:	e03ff805 	stb	zero,-32(fp)
 2018b98:	00000b06 	br	2018bc8 <OSMboxQuery+0xd0>
        *pdest++ = *psrc++;
 2018b9c:	e0bffa17 	ldw	r2,-24(fp)
 2018ba0:	10c00044 	addi	r3,r2,1
 2018ba4:	e0fffa15 	stw	r3,-24(fp)
 2018ba8:	e0fff917 	ldw	r3,-28(fp)
 2018bac:	19000044 	addi	r4,r3,1
 2018bb0:	e13ff915 	stw	r4,-28(fp)
 2018bb4:	18c00003 	ldbu	r3,0(r3)
 2018bb8:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 2018bbc:	e0bff803 	ldbu	r2,-32(fp)
 2018bc0:	10800044 	addi	r2,r2,1
 2018bc4:	e0bff805 	stb	r2,-32(fp)
 2018bc8:	e0bff803 	ldbu	r2,-32(fp)
 2018bcc:	108000f0 	cmpltui	r2,r2,3
 2018bd0:	103ff21e 	bne	r2,zero,2018b9c <OSMboxQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
 2018bd4:	e0bffe17 	ldw	r2,-8(fp)
 2018bd8:	10c00117 	ldw	r3,4(r2)
 2018bdc:	e0bfff17 	ldw	r2,-4(fp)
 2018be0:	10c00015 	stw	r3,0(r2)
 2018be4:	e0bffb17 	ldw	r2,-20(fp)
 2018be8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018bec:	e0bffc17 	ldw	r2,-16(fp)
 2018bf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 2018bf4:	0005883a 	mov	r2,zero
}
 2018bf8:	e037883a 	mov	sp,fp
 2018bfc:	df000017 	ldw	fp,0(sp)
 2018c00:	dec00104 	addi	sp,sp,4
 2018c04:	f800283a 	ret

02018c08 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 2018c08:	defff404 	addi	sp,sp,-48
 2018c0c:	df000b15 	stw	fp,44(sp)
 2018c10:	df000b04 	addi	fp,sp,44
 2018c14:	e13ffc15 	stw	r4,-16(fp)
 2018c18:	e17ffd15 	stw	r5,-12(fp)
 2018c1c:	e1bffe15 	stw	r6,-8(fp)
 2018c20:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2018c24:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 2018c28:	e0bfff17 	ldw	r2,-4(fp)
 2018c2c:	1000021e 	bne	r2,zero,2018c38 <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 2018c30:	0005883a 	mov	r2,zero
 2018c34:	00006506 	br	2018dcc <OSMemCreate+0x1c4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 2018c38:	e0bffc17 	ldw	r2,-16(fp)
 2018c3c:	1000051e 	bne	r2,zero,2018c54 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 2018c40:	e0bfff17 	ldw	r2,-4(fp)
 2018c44:	00c01884 	movi	r3,98
 2018c48:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 2018c4c:	0005883a 	mov	r2,zero
 2018c50:	00005e06 	br	2018dcc <OSMemCreate+0x1c4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 2018c54:	e0bffc17 	ldw	r2,-16(fp)
 2018c58:	108000cc 	andi	r2,r2,3
 2018c5c:	10000526 	beq	r2,zero,2018c74 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 2018c60:	e0bfff17 	ldw	r2,-4(fp)
 2018c64:	00c01884 	movi	r3,98
 2018c68:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 2018c6c:	0005883a 	mov	r2,zero
 2018c70:	00005606 	br	2018dcc <OSMemCreate+0x1c4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 2018c74:	e0bffd17 	ldw	r2,-12(fp)
 2018c78:	108000a8 	cmpgeui	r2,r2,2
 2018c7c:	1000051e 	bne	r2,zero,2018c94 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 2018c80:	e0bfff17 	ldw	r2,-4(fp)
 2018c84:	00c016c4 	movi	r3,91
 2018c88:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 2018c8c:	0005883a 	mov	r2,zero
 2018c90:	00004e06 	br	2018dcc <OSMemCreate+0x1c4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 2018c94:	e0bffe17 	ldw	r2,-8(fp)
 2018c98:	10800128 	cmpgeui	r2,r2,4
 2018c9c:	1000051e 	bne	r2,zero,2018cb4 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 2018ca0:	e0bfff17 	ldw	r2,-4(fp)
 2018ca4:	00c01704 	movi	r3,92
 2018ca8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 2018cac:	0005883a 	mov	r2,zero
 2018cb0:	00004606 	br	2018dcc <OSMemCreate+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018cb4:	0005303a 	rdctl	r2,status
 2018cb8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018cbc:	e0fffb17 	ldw	r3,-20(fp)
 2018cc0:	00bfff84 	movi	r2,-2
 2018cc4:	1884703a 	and	r2,r3,r2
 2018cc8:	1001703a 	wrctl	status,r2
  
  return context;
 2018ccc:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 2018cd0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 2018cd4:	d0a75817 	ldw	r2,-25248(gp)
 2018cd8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 2018cdc:	d0a75817 	ldw	r2,-25248(gp)
 2018ce0:	10000326 	beq	r2,zero,2018cf0 <OSMemCreate+0xe8>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 2018ce4:	d0a75817 	ldw	r2,-25248(gp)
 2018ce8:	10800117 	ldw	r2,4(r2)
 2018cec:	d0a75815 	stw	r2,-25248(gp)
 2018cf0:	e0bff817 	ldw	r2,-32(fp)
 2018cf4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018cf8:	e0bff917 	ldw	r2,-28(fp)
 2018cfc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 2018d00:	e0bffa17 	ldw	r2,-24(fp)
 2018d04:	1000051e 	bne	r2,zero,2018d1c <OSMemCreate+0x114>
        *perr = OS_ERR_MEM_INVALID_PART;
 2018d08:	e0bfff17 	ldw	r2,-4(fp)
 2018d0c:	00c01684 	movi	r3,90
 2018d10:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 2018d14:	0005883a 	mov	r2,zero
 2018d18:	00002c06 	br	2018dcc <OSMemCreate+0x1c4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 2018d1c:	e0bffc17 	ldw	r2,-16(fp)
 2018d20:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 2018d24:	e0fffc17 	ldw	r3,-16(fp)
 2018d28:	e0bffe17 	ldw	r2,-8(fp)
 2018d2c:	1885883a 	add	r2,r3,r2
 2018d30:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 2018d34:	e03ff715 	stw	zero,-36(fp)
 2018d38:	00000c06 	br	2018d6c <OSMemCreate+0x164>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 2018d3c:	e0bff617 	ldw	r2,-40(fp)
 2018d40:	e0fff517 	ldw	r3,-44(fp)
 2018d44:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 2018d48:	e0bff517 	ldw	r2,-44(fp)
 2018d4c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 2018d50:	e0fff517 	ldw	r3,-44(fp)
 2018d54:	e0bffe17 	ldw	r2,-8(fp)
 2018d58:	1885883a 	add	r2,r3,r2
 2018d5c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 2018d60:	e0bff717 	ldw	r2,-36(fp)
 2018d64:	10800044 	addi	r2,r2,1
 2018d68:	e0bff715 	stw	r2,-36(fp)
 2018d6c:	e0bffd17 	ldw	r2,-12(fp)
 2018d70:	10bfffc4 	addi	r2,r2,-1
 2018d74:	e0fff717 	ldw	r3,-36(fp)
 2018d78:	18bff036 	bltu	r3,r2,2018d3c <OSMemCreate+0x134>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 2018d7c:	e0bff617 	ldw	r2,-40(fp)
 2018d80:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 2018d84:	e0bffa17 	ldw	r2,-24(fp)
 2018d88:	e0fffc17 	ldw	r3,-16(fp)
 2018d8c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 2018d90:	e0bffa17 	ldw	r2,-24(fp)
 2018d94:	e0fffc17 	ldw	r3,-16(fp)
 2018d98:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 2018d9c:	e0bffa17 	ldw	r2,-24(fp)
 2018da0:	e0fffd17 	ldw	r3,-12(fp)
 2018da4:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 2018da8:	e0bffa17 	ldw	r2,-24(fp)
 2018dac:	e0fffd17 	ldw	r3,-12(fp)
 2018db0:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 2018db4:	e0bffa17 	ldw	r2,-24(fp)
 2018db8:	e0fffe17 	ldw	r3,-8(fp)
 2018dbc:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 2018dc0:	e0bfff17 	ldw	r2,-4(fp)
 2018dc4:	10000005 	stb	zero,0(r2)
    return (pmem);
 2018dc8:	e0bffa17 	ldw	r2,-24(fp)
}
 2018dcc:	e037883a 	mov	sp,fp
 2018dd0:	df000017 	ldw	fp,0(sp)
 2018dd4:	dec00104 	addi	sp,sp,4
 2018dd8:	f800283a 	ret

02018ddc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 2018ddc:	defff804 	addi	sp,sp,-32
 2018de0:	df000715 	stw	fp,28(sp)
 2018de4:	df000704 	addi	fp,sp,28
 2018de8:	e13ffe15 	stw	r4,-8(fp)
 2018dec:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2018df0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 2018df4:	e0bfff17 	ldw	r2,-4(fp)
 2018df8:	1000021e 	bne	r2,zero,2018e04 <OSMemGet+0x28>
        return ((void *)0);
 2018dfc:	0005883a 	mov	r2,zero
 2018e00:	00002e06 	br	2018ebc <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 2018e04:	e0bffe17 	ldw	r2,-8(fp)
 2018e08:	1000051e 	bne	r2,zero,2018e20 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 2018e0c:	e0bfff17 	ldw	r2,-4(fp)
 2018e10:	00c01804 	movi	r3,96
 2018e14:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2018e18:	0005883a 	mov	r2,zero
 2018e1c:	00002706 	br	2018ebc <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018e20:	0005303a 	rdctl	r2,status
 2018e24:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018e28:	e0fffd17 	ldw	r3,-12(fp)
 2018e2c:	00bfff84 	movi	r2,-2
 2018e30:	1884703a 	and	r2,r3,r2
 2018e34:	1001703a 	wrctl	status,r2
  
  return context;
 2018e38:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 2018e3c:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 2018e40:	e0bffe17 	ldw	r2,-8(fp)
 2018e44:	10800417 	ldw	r2,16(r2)
 2018e48:	10001426 	beq	r2,zero,2018e9c <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 2018e4c:	e0bffe17 	ldw	r2,-8(fp)
 2018e50:	10800117 	ldw	r2,4(r2)
 2018e54:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 2018e58:	e0bffb17 	ldw	r2,-20(fp)
 2018e5c:	10c00017 	ldw	r3,0(r2)
 2018e60:	e0bffe17 	ldw	r2,-8(fp)
 2018e64:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 2018e68:	e0bffe17 	ldw	r2,-8(fp)
 2018e6c:	10800417 	ldw	r2,16(r2)
 2018e70:	10ffffc4 	addi	r3,r2,-1
 2018e74:	e0bffe17 	ldw	r2,-8(fp)
 2018e78:	10c00415 	stw	r3,16(r2)
 2018e7c:	e0bff917 	ldw	r2,-28(fp)
 2018e80:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018e84:	e0bffa17 	ldw	r2,-24(fp)
 2018e88:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 2018e8c:	e0bfff17 	ldw	r2,-4(fp)
 2018e90:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 2018e94:	e0bffb17 	ldw	r2,-20(fp)
 2018e98:	00000806 	br	2018ebc <OSMemGet+0xe0>
 2018e9c:	e0bff917 	ldw	r2,-28(fp)
 2018ea0:	e0bffc15 	stw	r2,-16(fp)
 2018ea4:	e0bffc17 	ldw	r2,-16(fp)
 2018ea8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 2018eac:	e0bfff17 	ldw	r2,-4(fp)
 2018eb0:	00c01744 	movi	r3,93
 2018eb4:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 2018eb8:	0005883a 	mov	r2,zero
}
 2018ebc:	e037883a 	mov	sp,fp
 2018ec0:	df000017 	ldw	fp,0(sp)
 2018ec4:	dec00104 	addi	sp,sp,4
 2018ec8:	f800283a 	ret

02018ecc <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 2018ecc:	defff704 	addi	sp,sp,-36
 2018ed0:	dfc00815 	stw	ra,32(sp)
 2018ed4:	df000715 	stw	fp,28(sp)
 2018ed8:	df000704 	addi	fp,sp,28
 2018edc:	e13ffd15 	stw	r4,-12(fp)
 2018ee0:	e17ffe15 	stw	r5,-8(fp)
 2018ee4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2018ee8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2018eec:	e0bfff17 	ldw	r2,-4(fp)
 2018ef0:	1000021e 	bne	r2,zero,2018efc <OSMemNameGet+0x30>
        return (0);
 2018ef4:	0005883a 	mov	r2,zero
 2018ef8:	00002b06 	br	2018fa8 <OSMemNameGet+0xdc>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 2018efc:	e0bffd17 	ldw	r2,-12(fp)
 2018f00:	1000051e 	bne	r2,zero,2018f18 <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 2018f04:	e0bfff17 	ldw	r2,-4(fp)
 2018f08:	00c01804 	movi	r3,96
 2018f0c:	10c00005 	stb	r3,0(r2)
        return (0);
 2018f10:	0005883a 	mov	r2,zero
 2018f14:	00002406 	br	2018fa8 <OSMemNameGet+0xdc>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2018f18:	e0bffe17 	ldw	r2,-8(fp)
 2018f1c:	1000051e 	bne	r2,zero,2018f34 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 2018f20:	e0bfff17 	ldw	r2,-4(fp)
 2018f24:	00c00304 	movi	r3,12
 2018f28:	10c00005 	stb	r3,0(r2)
        return (0);
 2018f2c:	0005883a 	mov	r2,zero
 2018f30:	00001d06 	br	2018fa8 <OSMemNameGet+0xdc>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2018f34:	d0a75d03 	ldbu	r2,-25228(gp)
 2018f38:	10803fcc 	andi	r2,r2,255
 2018f3c:	10000526 	beq	r2,zero,2018f54 <OSMemNameGet+0x88>
        *perr = OS_ERR_NAME_GET_ISR;
 2018f40:	e0bfff17 	ldw	r2,-4(fp)
 2018f44:	00c00444 	movi	r3,17
 2018f48:	10c00005 	stb	r3,0(r2)
        return (0);
 2018f4c:	0005883a 	mov	r2,zero
 2018f50:	00001506 	br	2018fa8 <OSMemNameGet+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018f54:	0005303a 	rdctl	r2,status
 2018f58:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018f5c:	e0fffb17 	ldw	r3,-20(fp)
 2018f60:	00bfff84 	movi	r2,-2
 2018f64:	1884703a 	and	r2,r3,r2
 2018f68:	1001703a 	wrctl	status,r2
  
  return context;
 2018f6c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 2018f70:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 2018f74:	e0bffd17 	ldw	r2,-12(fp)
 2018f78:	10800504 	addi	r2,r2,20
 2018f7c:	100b883a 	mov	r5,r2
 2018f80:	e13ffe17 	ldw	r4,-8(fp)
 2018f84:	201630c0 	call	201630c <OS_StrCopy>
 2018f88:	e0bffa05 	stb	r2,-24(fp)
 2018f8c:	e0bff917 	ldw	r2,-28(fp)
 2018f90:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018f94:	e0bffc17 	ldw	r2,-16(fp)
 2018f98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2018f9c:	e0bfff17 	ldw	r2,-4(fp)
 2018fa0:	10000005 	stb	zero,0(r2)
    return (len);
 2018fa4:	e0bffa03 	ldbu	r2,-24(fp)
}
 2018fa8:	e037883a 	mov	sp,fp
 2018fac:	dfc00117 	ldw	ra,4(sp)
 2018fb0:	df000017 	ldw	fp,0(sp)
 2018fb4:	dec00204 	addi	sp,sp,8
 2018fb8:	f800283a 	ret

02018fbc <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 2018fbc:	defff604 	addi	sp,sp,-40
 2018fc0:	dfc00915 	stw	ra,36(sp)
 2018fc4:	df000815 	stw	fp,32(sp)
 2018fc8:	df000804 	addi	fp,sp,32
 2018fcc:	e13ffd15 	stw	r4,-12(fp)
 2018fd0:	e17ffe15 	stw	r5,-8(fp)
 2018fd4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2018fd8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2018fdc:	e0bfff17 	ldw	r2,-4(fp)
 2018fe0:	10003526 	beq	r2,zero,20190b8 <OSMemNameSet+0xfc>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 2018fe4:	e0bffd17 	ldw	r2,-12(fp)
 2018fe8:	1000041e 	bne	r2,zero,2018ffc <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 2018fec:	e0bfff17 	ldw	r2,-4(fp)
 2018ff0:	00c01804 	movi	r3,96
 2018ff4:	10c00005 	stb	r3,0(r2)
        return;
 2018ff8:	00003006 	br	20190bc <OSMemNameSet+0x100>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2018ffc:	e0bffe17 	ldw	r2,-8(fp)
 2019000:	1000041e 	bne	r2,zero,2019014 <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 2019004:	e0bfff17 	ldw	r2,-4(fp)
 2019008:	00c00304 	movi	r3,12
 201900c:	10c00005 	stb	r3,0(r2)
        return;
 2019010:	00002a06 	br	20190bc <OSMemNameSet+0x100>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2019014:	d0a75d03 	ldbu	r2,-25228(gp)
 2019018:	10803fcc 	andi	r2,r2,255
 201901c:	10000426 	beq	r2,zero,2019030 <OSMemNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 2019020:	e0bfff17 	ldw	r2,-4(fp)
 2019024:	00c00484 	movi	r3,18
 2019028:	10c00005 	stb	r3,0(r2)
        return;
 201902c:	00002306 	br	20190bc <OSMemNameSet+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019030:	0005303a 	rdctl	r2,status
 2019034:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019038:	e0fffc17 	ldw	r3,-16(fp)
 201903c:	00bfff84 	movi	r2,-2
 2019040:	1884703a 	and	r2,r3,r2
 2019044:	1001703a 	wrctl	status,r2
  
  return context;
 2019048:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201904c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 2019050:	e13ffe17 	ldw	r4,-8(fp)
 2019054:	20163800 	call	2016380 <OS_StrLen>
 2019058:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 201905c:	e0bffa03 	ldbu	r2,-24(fp)
 2019060:	10800830 	cmpltui	r2,r2,32
 2019064:	1000081e 	bne	r2,zero,2019088 <OSMemNameSet+0xcc>
 2019068:	e0bff817 	ldw	r2,-32(fp)
 201906c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019070:	e0bff917 	ldw	r2,-28(fp)
 2019074:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 2019078:	e0bfff17 	ldw	r2,-4(fp)
 201907c:	00c018c4 	movi	r3,99
 2019080:	10c00005 	stb	r3,0(r2)
        return;
 2019084:	00000d06 	br	20190bc <OSMemNameSet+0x100>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 2019088:	e0bffd17 	ldw	r2,-12(fp)
 201908c:	10800504 	addi	r2,r2,20
 2019090:	e17ffe17 	ldw	r5,-8(fp)
 2019094:	1009883a 	mov	r4,r2
 2019098:	201630c0 	call	201630c <OS_StrCopy>
 201909c:	e0bff817 	ldw	r2,-32(fp)
 20190a0:	e0bffb15 	stw	r2,-20(fp)
 20190a4:	e0bffb17 	ldw	r2,-20(fp)
 20190a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 20190ac:	e0bfff17 	ldw	r2,-4(fp)
 20190b0:	10000005 	stb	zero,0(r2)
 20190b4:	00000106 	br	20190bc <OSMemNameSet+0x100>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 20190b8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 20190bc:	e037883a 	mov	sp,fp
 20190c0:	dfc00117 	ldw	ra,4(sp)
 20190c4:	df000017 	ldw	fp,0(sp)
 20190c8:	dec00204 	addi	sp,sp,8
 20190cc:	f800283a 	ret

020190d0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 20190d0:	defff904 	addi	sp,sp,-28
 20190d4:	df000615 	stw	fp,24(sp)
 20190d8:	df000604 	addi	fp,sp,24
 20190dc:	e13ffe15 	stw	r4,-8(fp)
 20190e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20190e4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 20190e8:	e0bffe17 	ldw	r2,-8(fp)
 20190ec:	1000021e 	bne	r2,zero,20190f8 <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 20190f0:	00801804 	movi	r2,96
 20190f4:	00002806 	br	2019198 <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 20190f8:	e0bfff17 	ldw	r2,-4(fp)
 20190fc:	1000021e 	bne	r2,zero,2019108 <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 2019100:	008017c4 	movi	r2,95
 2019104:	00002406 	br	2019198 <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019108:	0005303a 	rdctl	r2,status
 201910c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019110:	e0fffd17 	ldw	r3,-12(fp)
 2019114:	00bfff84 	movi	r2,-2
 2019118:	1884703a 	and	r2,r3,r2
 201911c:	1001703a 	wrctl	status,r2
  
  return context;
 2019120:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 2019124:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 2019128:	e0bffe17 	ldw	r2,-8(fp)
 201912c:	10c00417 	ldw	r3,16(r2)
 2019130:	e0bffe17 	ldw	r2,-8(fp)
 2019134:	10800317 	ldw	r2,12(r2)
 2019138:	18800636 	bltu	r3,r2,2019154 <OSMemPut+0x84>
 201913c:	e0bffa17 	ldw	r2,-24(fp)
 2019140:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019144:	e0bffb17 	ldw	r2,-20(fp)
 2019148:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 201914c:	00801784 	movi	r2,94
 2019150:	00001106 	br	2019198 <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 2019154:	e0bffe17 	ldw	r2,-8(fp)
 2019158:	10c00117 	ldw	r3,4(r2)
 201915c:	e0bfff17 	ldw	r2,-4(fp)
 2019160:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 2019164:	e0bffe17 	ldw	r2,-8(fp)
 2019168:	e0ffff17 	ldw	r3,-4(fp)
 201916c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 2019170:	e0bffe17 	ldw	r2,-8(fp)
 2019174:	10800417 	ldw	r2,16(r2)
 2019178:	10c00044 	addi	r3,r2,1
 201917c:	e0bffe17 	ldw	r2,-8(fp)
 2019180:	10c00415 	stw	r3,16(r2)
 2019184:	e0bffa17 	ldw	r2,-24(fp)
 2019188:	e0bffc15 	stw	r2,-16(fp)
 201918c:	e0bffc17 	ldw	r2,-16(fp)
 2019190:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 2019194:	0005883a 	mov	r2,zero
}
 2019198:	e037883a 	mov	sp,fp
 201919c:	df000017 	ldw	fp,0(sp)
 20191a0:	dec00104 	addi	sp,sp,4
 20191a4:	f800283a 	ret

020191a8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 20191a8:	defffa04 	addi	sp,sp,-24
 20191ac:	df000515 	stw	fp,20(sp)
 20191b0:	df000504 	addi	fp,sp,20
 20191b4:	e13ffe15 	stw	r4,-8(fp)
 20191b8:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20191bc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 20191c0:	e0bffe17 	ldw	r2,-8(fp)
 20191c4:	1000021e 	bne	r2,zero,20191d0 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 20191c8:	00801804 	movi	r2,96
 20191cc:	00002c06 	br	2019280 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 20191d0:	e0bfff17 	ldw	r2,-4(fp)
 20191d4:	1000021e 	bne	r2,zero,20191e0 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 20191d8:	00801844 	movi	r2,97
 20191dc:	00002806 	br	2019280 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20191e0:	0005303a 	rdctl	r2,status
 20191e4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20191e8:	e0fffc17 	ldw	r3,-16(fp)
 20191ec:	00bfff84 	movi	r2,-2
 20191f0:	1884703a 	and	r2,r3,r2
 20191f4:	1001703a 	wrctl	status,r2
  
  return context;
 20191f8:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 20191fc:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 2019200:	e0bffe17 	ldw	r2,-8(fp)
 2019204:	10c00017 	ldw	r3,0(r2)
 2019208:	e0bfff17 	ldw	r2,-4(fp)
 201920c:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 2019210:	e0bffe17 	ldw	r2,-8(fp)
 2019214:	10c00117 	ldw	r3,4(r2)
 2019218:	e0bfff17 	ldw	r2,-4(fp)
 201921c:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 2019220:	e0bffe17 	ldw	r2,-8(fp)
 2019224:	10c00217 	ldw	r3,8(r2)
 2019228:	e0bfff17 	ldw	r2,-4(fp)
 201922c:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 2019230:	e0bffe17 	ldw	r2,-8(fp)
 2019234:	10c00317 	ldw	r3,12(r2)
 2019238:	e0bfff17 	ldw	r2,-4(fp)
 201923c:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 2019240:	e0bffe17 	ldw	r2,-8(fp)
 2019244:	10c00417 	ldw	r3,16(r2)
 2019248:	e0bfff17 	ldw	r2,-4(fp)
 201924c:	10c00415 	stw	r3,16(r2)
 2019250:	e0bffb17 	ldw	r2,-20(fp)
 2019254:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019258:	e0bffd17 	ldw	r2,-12(fp)
 201925c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 2019260:	e0bfff17 	ldw	r2,-4(fp)
 2019264:	10c00317 	ldw	r3,12(r2)
 2019268:	e0bfff17 	ldw	r2,-4(fp)
 201926c:	10800417 	ldw	r2,16(r2)
 2019270:	1887c83a 	sub	r3,r3,r2
 2019274:	e0bfff17 	ldw	r2,-4(fp)
 2019278:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 201927c:	0005883a 	mov	r2,zero
}
 2019280:	e037883a 	mov	sp,fp
 2019284:	df000017 	ldw	fp,0(sp)
 2019288:	dec00104 	addi	sp,sp,4
 201928c:	f800283a 	ret

02019290 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 2019290:	defffc04 	addi	sp,sp,-16
 2019294:	dfc00315 	stw	ra,12(sp)
 2019298:	df000215 	stw	fp,8(sp)
 201929c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 20192a0:	01430c04 	movi	r5,3120
 20192a4:	010080f4 	movhi	r4,515
 20192a8:	212de504 	addi	r4,r4,-18540
 20192ac:	201610c0 	call	201610c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 20192b0:	008080f4 	movhi	r2,515
 20192b4:	10ade504 	addi	r2,r2,-18540
 20192b8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 20192bc:	e03fff0d 	sth	zero,-4(fp)
 20192c0:	00001306 	br	2019310 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 20192c4:	e0bfff0b 	ldhu	r2,-4(fp)
 20192c8:	10800044 	addi	r2,r2,1
 20192cc:	10c00d24 	muli	r3,r2,52
 20192d0:	008080f4 	movhi	r2,515
 20192d4:	10ade504 	addi	r2,r2,-18540
 20192d8:	1887883a 	add	r3,r3,r2
 20192dc:	e0bffe17 	ldw	r2,-8(fp)
 20192e0:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 20192e4:	e0bffe17 	ldw	r2,-8(fp)
 20192e8:	00c00fc4 	movi	r3,63
 20192ec:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 20192f0:	e0bffe17 	ldw	r2,-8(fp)
 20192f4:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 20192f8:	e0bffe17 	ldw	r2,-8(fp)
 20192fc:	10800d04 	addi	r2,r2,52
 2019300:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 2019304:	e0bfff0b 	ldhu	r2,-4(fp)
 2019308:	10800044 	addi	r2,r2,1
 201930c:	e0bfff0d 	sth	r2,-4(fp)
 2019310:	e0bfff0b 	ldhu	r2,-4(fp)
 2019314:	10800ef0 	cmpltui	r2,r2,59
 2019318:	103fea1e 	bne	r2,zero,20192c4 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 201931c:	e0bffe17 	ldw	r2,-8(fp)
 2019320:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 2019324:	e0bffe17 	ldw	r2,-8(fp)
 2019328:	00c00fc4 	movi	r3,63
 201932c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 2019330:	e0bffe17 	ldw	r2,-8(fp)
 2019334:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 2019338:	008080f4 	movhi	r2,515
 201933c:	10ade504 	addi	r2,r2,-18540
 2019340:	d0a75815 	stw	r2,-25248(gp)
#endif
}
 2019344:	0001883a 	nop
 2019348:	e037883a 	mov	sp,fp
 201934c:	dfc00117 	ldw	ra,4(sp)
 2019350:	df000017 	ldw	fp,0(sp)
 2019354:	dec00204 	addi	sp,sp,8
 2019358:	f800283a 	ret

0201935c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 201935c:	defff804 	addi	sp,sp,-32
 2019360:	df000715 	stw	fp,28(sp)
 2019364:	df000704 	addi	fp,sp,28
 2019368:	e13ffe15 	stw	r4,-8(fp)
 201936c:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2019370:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2019374:	e0bfff17 	ldw	r2,-4(fp)
 2019378:	1000021e 	bne	r2,zero,2019384 <OSQAccept+0x28>
        return ((void *)0);
 201937c:	0005883a 	mov	r2,zero
 2019380:	00004206 	br	201948c <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 2019384:	e0bffe17 	ldw	r2,-8(fp)
 2019388:	1000051e 	bne	r2,zero,20193a0 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 201938c:	e0bfff17 	ldw	r2,-4(fp)
 2019390:	00c00104 	movi	r3,4
 2019394:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019398:	0005883a 	mov	r2,zero
 201939c:	00003b06 	br	201948c <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 20193a0:	e0bffe17 	ldw	r2,-8(fp)
 20193a4:	10800003 	ldbu	r2,0(r2)
 20193a8:	10803fcc 	andi	r2,r2,255
 20193ac:	108000a0 	cmpeqi	r2,r2,2
 20193b0:	1000051e 	bne	r2,zero,20193c8 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 20193b4:	e0bfff17 	ldw	r2,-4(fp)
 20193b8:	00c00044 	movi	r3,1
 20193bc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 20193c0:	0005883a 	mov	r2,zero
 20193c4:	00003106 	br	201948c <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20193c8:	0005303a 	rdctl	r2,status
 20193cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20193d0:	e0fffd17 	ldw	r3,-12(fp)
 20193d4:	00bfff84 	movi	r2,-2
 20193d8:	1884703a 	and	r2,r3,r2
 20193dc:	1001703a 	wrctl	status,r2
  
  return context;
 20193e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 20193e4:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 20193e8:	e0bffe17 	ldw	r2,-8(fp)
 20193ec:	10800117 	ldw	r2,4(r2)
 20193f0:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 20193f4:	e0bffc17 	ldw	r2,-16(fp)
 20193f8:	1080058b 	ldhu	r2,22(r2)
 20193fc:	10bfffcc 	andi	r2,r2,65535
 2019400:	10001926 	beq	r2,zero,2019468 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 2019404:	e0bffc17 	ldw	r2,-16(fp)
 2019408:	10800417 	ldw	r2,16(r2)
 201940c:	11000104 	addi	r4,r2,4
 2019410:	e0fffc17 	ldw	r3,-16(fp)
 2019414:	19000415 	stw	r4,16(r3)
 2019418:	10800017 	ldw	r2,0(r2)
 201941c:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 2019420:	e0bffc17 	ldw	r2,-16(fp)
 2019424:	1080058b 	ldhu	r2,22(r2)
 2019428:	10bfffc4 	addi	r2,r2,-1
 201942c:	1007883a 	mov	r3,r2
 2019430:	e0bffc17 	ldw	r2,-16(fp)
 2019434:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 2019438:	e0bffc17 	ldw	r2,-16(fp)
 201943c:	10c00417 	ldw	r3,16(r2)
 2019440:	e0bffc17 	ldw	r2,-16(fp)
 2019444:	10800217 	ldw	r2,8(r2)
 2019448:	1880041e 	bne	r3,r2,201945c <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 201944c:	e0bffc17 	ldw	r2,-16(fp)
 2019450:	10c00117 	ldw	r3,4(r2)
 2019454:	e0bffc17 	ldw	r2,-16(fp)
 2019458:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 201945c:	e0bfff17 	ldw	r2,-4(fp)
 2019460:	10000005 	stb	zero,0(r2)
 2019464:	00000406 	br	2019478 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 2019468:	e0bfff17 	ldw	r2,-4(fp)
 201946c:	00c007c4 	movi	r3,31
 2019470:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 2019474:	e03ff915 	stw	zero,-28(fp)
 2019478:	e0bffa17 	ldw	r2,-24(fp)
 201947c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019480:	e0bffb17 	ldw	r2,-20(fp)
 2019484:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 2019488:	e0bff917 	ldw	r2,-28(fp)
}
 201948c:	e037883a 	mov	sp,fp
 2019490:	df000017 	ldw	fp,0(sp)
 2019494:	dec00104 	addi	sp,sp,4
 2019498:	f800283a 	ret

0201949c <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 201949c:	defff404 	addi	sp,sp,-48
 20194a0:	dfc00b15 	stw	ra,44(sp)
 20194a4:	df000a15 	stw	fp,40(sp)
 20194a8:	df000a04 	addi	fp,sp,40
 20194ac:	e13ffe15 	stw	r4,-8(fp)
 20194b0:	2805883a 	mov	r2,r5
 20194b4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20194b8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 20194bc:	d0a75d03 	ldbu	r2,-25228(gp)
 20194c0:	10803fcc 	andi	r2,r2,255
 20194c4:	10000226 	beq	r2,zero,20194d0 <OSQCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 20194c8:	0005883a 	mov	r2,zero
 20194cc:	00005906 	br	2019634 <OSQCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20194d0:	0005303a 	rdctl	r2,status
 20194d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20194d8:	e0fffd17 	ldw	r3,-12(fp)
 20194dc:	00bfff84 	movi	r2,-2
 20194e0:	1884703a 	and	r2,r3,r2
 20194e4:	1001703a 	wrctl	status,r2
  
  return context;
 20194e8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 20194ec:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 20194f0:	d0a75c17 	ldw	r2,-25232(gp)
 20194f4:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 20194f8:	d0a75c17 	ldw	r2,-25232(gp)
 20194fc:	10000326 	beq	r2,zero,201950c <OSQCreate+0x70>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 2019500:	d0a75c17 	ldw	r2,-25232(gp)
 2019504:	10800117 	ldw	r2,4(r2)
 2019508:	d0a75c15 	stw	r2,-25232(gp)
 201950c:	e0bff717 	ldw	r2,-36(fp)
 2019510:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019514:	e0bff817 	ldw	r2,-32(fp)
 2019518:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 201951c:	e0bff617 	ldw	r2,-40(fp)
 2019520:	10004326 	beq	r2,zero,2019630 <OSQCreate+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019524:	0005303a 	rdctl	r2,status
 2019528:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201952c:	e0fff917 	ldw	r3,-28(fp)
 2019530:	00bfff84 	movi	r2,-2
 2019534:	1884703a 	and	r2,r3,r2
 2019538:	1001703a 	wrctl	status,r2
  
  return context;
 201953c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
 2019540:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 2019544:	d0a75a17 	ldw	r2,-25240(gp)
 2019548:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 201954c:	e0bffb17 	ldw	r2,-20(fp)
 2019550:	10002d26 	beq	r2,zero,2019608 <OSQCreate+0x16c>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 2019554:	d0a75a17 	ldw	r2,-25240(gp)
 2019558:	10800017 	ldw	r2,0(r2)
 201955c:	d0a75a15 	stw	r2,-25240(gp)
 2019560:	e0bff717 	ldw	r2,-36(fp)
 2019564:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019568:	e0bffa17 	ldw	r2,-24(fp)
 201956c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 2019570:	e0bffb17 	ldw	r2,-20(fp)
 2019574:	e0fffe17 	ldw	r3,-8(fp)
 2019578:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 201957c:	e0bfff0b 	ldhu	r2,-4(fp)
 2019580:	1085883a 	add	r2,r2,r2
 2019584:	1085883a 	add	r2,r2,r2
 2019588:	1007883a 	mov	r3,r2
 201958c:	e0bffe17 	ldw	r2,-8(fp)
 2019590:	10c7883a 	add	r3,r2,r3
 2019594:	e0bffb17 	ldw	r2,-20(fp)
 2019598:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 201959c:	e0bffb17 	ldw	r2,-20(fp)
 20195a0:	e0fffe17 	ldw	r3,-8(fp)
 20195a4:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 20195a8:	e0bffb17 	ldw	r2,-20(fp)
 20195ac:	e0fffe17 	ldw	r3,-8(fp)
 20195b0:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 20195b4:	e0bffb17 	ldw	r2,-20(fp)
 20195b8:	e0ffff0b 	ldhu	r3,-4(fp)
 20195bc:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 20195c0:	e0bffb17 	ldw	r2,-20(fp)
 20195c4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 20195c8:	e0bff617 	ldw	r2,-40(fp)
 20195cc:	00c00084 	movi	r3,2
 20195d0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 20195d4:	e0bff617 	ldw	r2,-40(fp)
 20195d8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 20195dc:	e0bff617 	ldw	r2,-40(fp)
 20195e0:	e0fffb17 	ldw	r3,-20(fp)
 20195e4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 20195e8:	e0bff617 	ldw	r2,-40(fp)
 20195ec:	00c00fc4 	movi	r3,63
 20195f0:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 20195f4:	e0bff617 	ldw	r2,-40(fp)
 20195f8:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 20195fc:	e13ff617 	ldw	r4,-40(fp)
 2019600:	2015d2c0 	call	2015d2c <OS_EventWaitListInit>
 2019604:	00000a06 	br	2019630 <OSQCreate+0x194>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 2019608:	d0e75c17 	ldw	r3,-25232(gp)
 201960c:	e0bff617 	ldw	r2,-40(fp)
 2019610:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 2019614:	e0bff617 	ldw	r2,-40(fp)
 2019618:	d0a75c15 	stw	r2,-25232(gp)
 201961c:	e0bff717 	ldw	r2,-36(fp)
 2019620:	e0bffc15 	stw	r2,-16(fp)
 2019624:	e0bffc17 	ldw	r2,-16(fp)
 2019628:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 201962c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 2019630:	e0bff617 	ldw	r2,-40(fp)
}
 2019634:	e037883a 	mov	sp,fp
 2019638:	dfc00117 	ldw	ra,4(sp)
 201963c:	df000017 	ldw	fp,0(sp)
 2019640:	dec00204 	addi	sp,sp,8
 2019644:	f800283a 	ret

02019648 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 2019648:	defff204 	addi	sp,sp,-56
 201964c:	dfc00d15 	stw	ra,52(sp)
 2019650:	df000c15 	stw	fp,48(sp)
 2019654:	df000c04 	addi	fp,sp,48
 2019658:	e13ffd15 	stw	r4,-12(fp)
 201965c:	2805883a 	mov	r2,r5
 2019660:	e1bfff15 	stw	r6,-4(fp)
 2019664:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2019668:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 201966c:	e0bfff17 	ldw	r2,-4(fp)
 2019670:	1000021e 	bne	r2,zero,201967c <OSQDel+0x34>
        return (pevent);
 2019674:	e0bffd17 	ldw	r2,-12(fp)
 2019678:	00008e06 	br	20198b4 <OSQDel+0x26c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201967c:	e0bffd17 	ldw	r2,-12(fp)
 2019680:	1000051e 	bne	r2,zero,2019698 <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 2019684:	e0bfff17 	ldw	r2,-4(fp)
 2019688:	00c00104 	movi	r3,4
 201968c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 2019690:	e0bffd17 	ldw	r2,-12(fp)
 2019694:	00008706 	br	20198b4 <OSQDel+0x26c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 2019698:	e0bffd17 	ldw	r2,-12(fp)
 201969c:	10800003 	ldbu	r2,0(r2)
 20196a0:	10803fcc 	andi	r2,r2,255
 20196a4:	108000a0 	cmpeqi	r2,r2,2
 20196a8:	1000051e 	bne	r2,zero,20196c0 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 20196ac:	e0bfff17 	ldw	r2,-4(fp)
 20196b0:	00c00044 	movi	r3,1
 20196b4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 20196b8:	e0bffd17 	ldw	r2,-12(fp)
 20196bc:	00007d06 	br	20198b4 <OSQDel+0x26c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 20196c0:	d0a75d03 	ldbu	r2,-25228(gp)
 20196c4:	10803fcc 	andi	r2,r2,255
 20196c8:	10000526 	beq	r2,zero,20196e0 <OSQDel+0x98>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 20196cc:	e0bfff17 	ldw	r2,-4(fp)
 20196d0:	00c003c4 	movi	r3,15
 20196d4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 20196d8:	e0bffd17 	ldw	r2,-12(fp)
 20196dc:	00007506 	br	20198b4 <OSQDel+0x26c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20196e0:	0005303a 	rdctl	r2,status
 20196e4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20196e8:	e0fffc17 	ldw	r3,-16(fp)
 20196ec:	00bfff84 	movi	r2,-2
 20196f0:	1884703a 	and	r2,r3,r2
 20196f4:	1001703a 	wrctl	status,r2
  
  return context;
 20196f8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 20196fc:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 2019700:	e0bffd17 	ldw	r2,-12(fp)
 2019704:	10800283 	ldbu	r2,10(r2)
 2019708:	10803fcc 	andi	r2,r2,255
 201970c:	10000326 	beq	r2,zero,201971c <OSQDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 2019710:	00800044 	movi	r2,1
 2019714:	e0bff405 	stb	r2,-48(fp)
 2019718:	00000106 	br	2019720 <OSQDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 201971c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 2019720:	e0bffe03 	ldbu	r2,-8(fp)
 2019724:	10000326 	beq	r2,zero,2019734 <OSQDel+0xec>
 2019728:	10800060 	cmpeqi	r2,r2,1
 201972c:	1000301e 	bne	r2,zero,20197f0 <OSQDel+0x1a8>
 2019730:	00005506 	br	2019888 <OSQDel+0x240>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 2019734:	e0bff403 	ldbu	r2,-48(fp)
 2019738:	10001e1e 	bne	r2,zero,20197b4 <OSQDel+0x16c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 201973c:	e0bffd17 	ldw	r2,-12(fp)
 2019740:	00c00fc4 	movi	r3,63
 2019744:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 2019748:	e0bffd17 	ldw	r2,-12(fp)
 201974c:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 2019750:	e0bffd17 	ldw	r2,-12(fp)
 2019754:	10800117 	ldw	r2,4(r2)
 2019758:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 201975c:	d0e75a17 	ldw	r3,-25240(gp)
 2019760:	e0bff817 	ldw	r2,-32(fp)
 2019764:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 2019768:	e0bff817 	ldw	r2,-32(fp)
 201976c:	d0a75a15 	stw	r2,-25240(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2019770:	e0bffd17 	ldw	r2,-12(fp)
 2019774:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 2019778:	d0e75c17 	ldw	r3,-25232(gp)
 201977c:	e0bffd17 	ldw	r2,-12(fp)
 2019780:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 2019784:	e0bffd17 	ldw	r2,-12(fp)
 2019788:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 201978c:	e0bffd17 	ldw	r2,-12(fp)
 2019790:	d0a75c15 	stw	r2,-25232(gp)
 2019794:	e0bff617 	ldw	r2,-40(fp)
 2019798:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201979c:	e0bff717 	ldw	r2,-36(fp)
 20197a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 20197a4:	e0bfff17 	ldw	r2,-4(fp)
 20197a8:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 20197ac:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 20197b0:	00003f06 	br	20198b0 <OSQDel+0x268>
 20197b4:	e0bff617 	ldw	r2,-40(fp)
 20197b8:	e0bff915 	stw	r2,-28(fp)
 20197bc:	e0bff917 	ldw	r2,-28(fp)
 20197c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 20197c4:	e0bfff17 	ldw	r2,-4(fp)
 20197c8:	00c01244 	movi	r3,73
 20197cc:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 20197d0:	e0bffd17 	ldw	r2,-12(fp)
 20197d4:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 20197d8:	00003506 	br	20198b0 <OSQDel+0x268>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 20197dc:	000f883a 	mov	r7,zero
 20197e0:	01800104 	movi	r6,4
 20197e4:	000b883a 	mov	r5,zero
 20197e8:	e13ffd17 	ldw	r4,-12(fp)
 20197ec:	201577c0 	call	201577c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 20197f0:	e0bffd17 	ldw	r2,-12(fp)
 20197f4:	10800283 	ldbu	r2,10(r2)
 20197f8:	10803fcc 	andi	r2,r2,255
 20197fc:	103ff71e 	bne	r2,zero,20197dc <OSQDel+0x194>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 2019800:	e0bffd17 	ldw	r2,-12(fp)
 2019804:	00c00fc4 	movi	r3,63
 2019808:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 201980c:	e0bffd17 	ldw	r2,-12(fp)
 2019810:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 2019814:	e0bffd17 	ldw	r2,-12(fp)
 2019818:	10800117 	ldw	r2,4(r2)
 201981c:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 2019820:	d0e75a17 	ldw	r3,-25240(gp)
 2019824:	e0bff817 	ldw	r2,-32(fp)
 2019828:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 201982c:	e0bff817 	ldw	r2,-32(fp)
 2019830:	d0a75a15 	stw	r2,-25240(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2019834:	e0bffd17 	ldw	r2,-12(fp)
 2019838:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 201983c:	d0e75c17 	ldw	r3,-25232(gp)
 2019840:	e0bffd17 	ldw	r2,-12(fp)
 2019844:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 2019848:	e0bffd17 	ldw	r2,-12(fp)
 201984c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 2019850:	e0bffd17 	ldw	r2,-12(fp)
 2019854:	d0a75c15 	stw	r2,-25232(gp)
 2019858:	e0bff617 	ldw	r2,-40(fp)
 201985c:	e0bffa15 	stw	r2,-24(fp)
 2019860:	e0bffa17 	ldw	r2,-24(fp)
 2019864:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 2019868:	e0bff403 	ldbu	r2,-48(fp)
 201986c:	10800058 	cmpnei	r2,r2,1
 2019870:	1000011e 	bne	r2,zero,2019878 <OSQDel+0x230>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 2019874:	20161c80 	call	20161c8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 2019878:	e0bfff17 	ldw	r2,-4(fp)
 201987c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 2019880:	e03ff515 	stw	zero,-44(fp)
             break;
 2019884:	00000a06 	br	20198b0 <OSQDel+0x268>
 2019888:	e0bff617 	ldw	r2,-40(fp)
 201988c:	e0bffb15 	stw	r2,-20(fp)
 2019890:	e0bffb17 	ldw	r2,-20(fp)
 2019894:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 2019898:	e0bfff17 	ldw	r2,-4(fp)
 201989c:	00c001c4 	movi	r3,7
 20198a0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 20198a4:	e0bffd17 	ldw	r2,-12(fp)
 20198a8:	e0bff515 	stw	r2,-44(fp)
             break;
 20198ac:	0001883a 	nop
    }
    return (pevent_return);
 20198b0:	e0bff517 	ldw	r2,-44(fp)
}
 20198b4:	e037883a 	mov	sp,fp
 20198b8:	dfc00117 	ldw	ra,4(sp)
 20198bc:	df000017 	ldw	fp,0(sp)
 20198c0:	dec00204 	addi	sp,sp,8
 20198c4:	f800283a 	ret

020198c8 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 20198c8:	defffa04 	addi	sp,sp,-24
 20198cc:	df000515 	stw	fp,20(sp)
 20198d0:	df000504 	addi	fp,sp,20
 20198d4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 20198d8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 20198dc:	e0bfff17 	ldw	r2,-4(fp)
 20198e0:	1000021e 	bne	r2,zero,20198ec <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 20198e4:	00800104 	movi	r2,4
 20198e8:	00002106 	br	2019970 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 20198ec:	e0bfff17 	ldw	r2,-4(fp)
 20198f0:	10800003 	ldbu	r2,0(r2)
 20198f4:	10803fcc 	andi	r2,r2,255
 20198f8:	108000a0 	cmpeqi	r2,r2,2
 20198fc:	1000021e 	bne	r2,zero,2019908 <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 2019900:	00800044 	movi	r2,1
 2019904:	00001a06 	br	2019970 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019908:	0005303a 	rdctl	r2,status
 201990c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019910:	e0fffd17 	ldw	r3,-12(fp)
 2019914:	00bfff84 	movi	r2,-2
 2019918:	1884703a 	and	r2,r3,r2
 201991c:	1001703a 	wrctl	status,r2
  
  return context;
 2019920:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 2019924:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 2019928:	e0bfff17 	ldw	r2,-4(fp)
 201992c:	10800117 	ldw	r2,4(r2)
 2019930:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 2019934:	e0bffc17 	ldw	r2,-16(fp)
 2019938:	10c00117 	ldw	r3,4(r2)
 201993c:	e0bffc17 	ldw	r2,-16(fp)
 2019940:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 2019944:	e0bffc17 	ldw	r2,-16(fp)
 2019948:	10c00117 	ldw	r3,4(r2)
 201994c:	e0bffc17 	ldw	r2,-16(fp)
 2019950:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 2019954:	e0bffc17 	ldw	r2,-16(fp)
 2019958:	1000058d 	sth	zero,22(r2)
 201995c:	e0bffb17 	ldw	r2,-20(fp)
 2019960:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019964:	e0bffe17 	ldw	r2,-8(fp)
 2019968:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201996c:	0005883a 	mov	r2,zero
}
 2019970:	e037883a 	mov	sp,fp
 2019974:	df000017 	ldw	fp,0(sp)
 2019978:	dec00104 	addi	sp,sp,4
 201997c:	f800283a 	ret

02019980 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 2019980:	defff304 	addi	sp,sp,-52
 2019984:	dfc00c15 	stw	ra,48(sp)
 2019988:	df000b15 	stw	fp,44(sp)
 201998c:	df000b04 	addi	fp,sp,44
 2019990:	e13ffd15 	stw	r4,-12(fp)
 2019994:	2805883a 	mov	r2,r5
 2019998:	e1bfff15 	stw	r6,-4(fp)
 201999c:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20199a0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 20199a4:	e0bfff17 	ldw	r2,-4(fp)
 20199a8:	1000021e 	bne	r2,zero,20199b4 <OSQPend+0x34>
        return ((void *)0);
 20199ac:	0005883a 	mov	r2,zero
 20199b0:	00009106 	br	2019bf8 <OSQPend+0x278>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 20199b4:	e0bffd17 	ldw	r2,-12(fp)
 20199b8:	1000051e 	bne	r2,zero,20199d0 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 20199bc:	e0bfff17 	ldw	r2,-4(fp)
 20199c0:	00c00104 	movi	r3,4
 20199c4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 20199c8:	0005883a 	mov	r2,zero
 20199cc:	00008a06 	br	2019bf8 <OSQPend+0x278>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 20199d0:	e0bffd17 	ldw	r2,-12(fp)
 20199d4:	10800003 	ldbu	r2,0(r2)
 20199d8:	10803fcc 	andi	r2,r2,255
 20199dc:	108000a0 	cmpeqi	r2,r2,2
 20199e0:	1000051e 	bne	r2,zero,20199f8 <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 20199e4:	e0bfff17 	ldw	r2,-4(fp)
 20199e8:	00c00044 	movi	r3,1
 20199ec:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 20199f0:	0005883a 	mov	r2,zero
 20199f4:	00008006 	br	2019bf8 <OSQPend+0x278>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 20199f8:	d0a75d03 	ldbu	r2,-25228(gp)
 20199fc:	10803fcc 	andi	r2,r2,255
 2019a00:	10000526 	beq	r2,zero,2019a18 <OSQPend+0x98>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 2019a04:	e0bfff17 	ldw	r2,-4(fp)
 2019a08:	00c00084 	movi	r3,2
 2019a0c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019a10:	0005883a 	mov	r2,zero
 2019a14:	00007806 	br	2019bf8 <OSQPend+0x278>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 2019a18:	d0a74f03 	ldbu	r2,-25284(gp)
 2019a1c:	10803fcc 	andi	r2,r2,255
 2019a20:	10000526 	beq	r2,zero,2019a38 <OSQPend+0xb8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 2019a24:	e0bfff17 	ldw	r2,-4(fp)
 2019a28:	00c00344 	movi	r3,13
 2019a2c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019a30:	0005883a 	mov	r2,zero
 2019a34:	00007006 	br	2019bf8 <OSQPend+0x278>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019a38:	0005303a 	rdctl	r2,status
 2019a3c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019a40:	e0fffc17 	ldw	r3,-16(fp)
 2019a44:	00bfff84 	movi	r2,-2
 2019a48:	1884703a 	and	r2,r3,r2
 2019a4c:	1001703a 	wrctl	status,r2
  
  return context;
 2019a50:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2019a54:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 2019a58:	e0bffd17 	ldw	r2,-12(fp)
 2019a5c:	10800117 	ldw	r2,4(r2)
 2019a60:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 2019a64:	e0bff817 	ldw	r2,-32(fp)
 2019a68:	1080058b 	ldhu	r2,22(r2)
 2019a6c:	10bfffcc 	andi	r2,r2,65535
 2019a70:	10001e26 	beq	r2,zero,2019aec <OSQPend+0x16c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 2019a74:	e0bff817 	ldw	r2,-32(fp)
 2019a78:	10800417 	ldw	r2,16(r2)
 2019a7c:	11000104 	addi	r4,r2,4
 2019a80:	e0fff817 	ldw	r3,-32(fp)
 2019a84:	19000415 	stw	r4,16(r3)
 2019a88:	10800017 	ldw	r2,0(r2)
 2019a8c:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 2019a90:	e0bff817 	ldw	r2,-32(fp)
 2019a94:	1080058b 	ldhu	r2,22(r2)
 2019a98:	10bfffc4 	addi	r2,r2,-1
 2019a9c:	1007883a 	mov	r3,r2
 2019aa0:	e0bff817 	ldw	r2,-32(fp)
 2019aa4:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 2019aa8:	e0bff817 	ldw	r2,-32(fp)
 2019aac:	10c00417 	ldw	r3,16(r2)
 2019ab0:	e0bff817 	ldw	r2,-32(fp)
 2019ab4:	10800217 	ldw	r2,8(r2)
 2019ab8:	1880041e 	bne	r3,r2,2019acc <OSQPend+0x14c>
            pq->OSQOut = pq->OSQStart;
 2019abc:	e0bff817 	ldw	r2,-32(fp)
 2019ac0:	10c00117 	ldw	r3,4(r2)
 2019ac4:	e0bff817 	ldw	r2,-32(fp)
 2019ac8:	10c00415 	stw	r3,16(r2)
 2019acc:	e0bff617 	ldw	r2,-40(fp)
 2019ad0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019ad4:	e0bff717 	ldw	r2,-36(fp)
 2019ad8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 2019adc:	e0bfff17 	ldw	r2,-4(fp)
 2019ae0:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 2019ae4:	e0bff517 	ldw	r2,-44(fp)
 2019ae8:	00004306 	br	2019bf8 <OSQPend+0x278>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 2019aec:	d0a75e17 	ldw	r2,-25224(gp)
 2019af0:	d0e75e17 	ldw	r3,-25224(gp)
 2019af4:	18c00c03 	ldbu	r3,48(r3)
 2019af8:	18c00114 	ori	r3,r3,4
 2019afc:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2019b00:	d0a75e17 	ldw	r2,-25224(gp)
 2019b04:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 2019b08:	d0a75e17 	ldw	r2,-25224(gp)
 2019b0c:	e0fffe0b 	ldhu	r3,-8(fp)
 2019b10:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 2019b14:	e13ffd17 	ldw	r4,-12(fp)
 2019b18:	20159140 	call	2015914 <OS_EventTaskWait>
 2019b1c:	e0bff617 	ldw	r2,-40(fp)
 2019b20:	e0bffb15 	stw	r2,-20(fp)
 2019b24:	e0bffb17 	ldw	r2,-20(fp)
 2019b28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 2019b2c:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019b30:	0005303a 	rdctl	r2,status
 2019b34:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019b38:	e0fff917 	ldw	r3,-28(fp)
 2019b3c:	00bfff84 	movi	r2,-2
 2019b40:	1884703a 	and	r2,r3,r2
 2019b44:	1001703a 	wrctl	status,r2
  
  return context;
 2019b48:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 2019b4c:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 2019b50:	d0a75e17 	ldw	r2,-25224(gp)
 2019b54:	10800c43 	ldbu	r2,49(r2)
 2019b58:	10803fcc 	andi	r2,r2,255
 2019b5c:	10000326 	beq	r2,zero,2019b6c <OSQPend+0x1ec>
 2019b60:	108000a0 	cmpeqi	r2,r2,2
 2019b64:	1000071e 	bne	r2,zero,2019b84 <OSQPend+0x204>
 2019b68:	00000b06 	br	2019b98 <OSQPend+0x218>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 2019b6c:	d0a75e17 	ldw	r2,-25224(gp)
 2019b70:	10800917 	ldw	r2,36(r2)
 2019b74:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 2019b78:	e0bfff17 	ldw	r2,-4(fp)
 2019b7c:	10000005 	stb	zero,0(r2)
             break;
 2019b80:	00000e06 	br	2019bbc <OSQPend+0x23c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 2019b84:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 2019b88:	e0bfff17 	ldw	r2,-4(fp)
 2019b8c:	00c00384 	movi	r3,14
 2019b90:	10c00005 	stb	r3,0(r2)
             break;
 2019b94:	00000906 	br	2019bbc <OSQPend+0x23c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 2019b98:	d0a75e17 	ldw	r2,-25224(gp)
 2019b9c:	e17ffd17 	ldw	r5,-12(fp)
 2019ba0:	1009883a 	mov	r4,r2
 2019ba4:	2015b740 	call	2015b74 <OS_EventTaskRemove>
             pmsg = (void *)0;
 2019ba8:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 2019bac:	e0bfff17 	ldw	r2,-4(fp)
 2019bb0:	00c00284 	movi	r3,10
 2019bb4:	10c00005 	stb	r3,0(r2)
             break;
 2019bb8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 2019bbc:	d0a75e17 	ldw	r2,-25224(gp)
 2019bc0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 2019bc4:	d0a75e17 	ldw	r2,-25224(gp)
 2019bc8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 2019bcc:	d0a75e17 	ldw	r2,-25224(gp)
 2019bd0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 2019bd4:	d0a75e17 	ldw	r2,-25224(gp)
 2019bd8:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 2019bdc:	d0a75e17 	ldw	r2,-25224(gp)
 2019be0:	10000915 	stw	zero,36(r2)
 2019be4:	e0bff617 	ldw	r2,-40(fp)
 2019be8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019bec:	e0bffa17 	ldw	r2,-24(fp)
 2019bf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 2019bf4:	e0bff517 	ldw	r2,-44(fp)
}
 2019bf8:	e037883a 	mov	sp,fp
 2019bfc:	dfc00117 	ldw	ra,4(sp)
 2019c00:	df000017 	ldw	fp,0(sp)
 2019c04:	dec00204 	addi	sp,sp,8
 2019c08:	f800283a 	ret

02019c0c <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 2019c0c:	defff604 	addi	sp,sp,-40
 2019c10:	dfc00915 	stw	ra,36(sp)
 2019c14:	df000815 	stw	fp,32(sp)
 2019c18:	df000804 	addi	fp,sp,32
 2019c1c:	e13ffd15 	stw	r4,-12(fp)
 2019c20:	2805883a 	mov	r2,r5
 2019c24:	e1bfff15 	stw	r6,-4(fp)
 2019c28:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2019c2c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2019c30:	e0bfff17 	ldw	r2,-4(fp)
 2019c34:	1000021e 	bne	r2,zero,2019c40 <OSQPendAbort+0x34>
        return (0);
 2019c38:	0005883a 	mov	r2,zero
 2019c3c:	00004906 	br	2019d64 <OSQPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 2019c40:	e0bffd17 	ldw	r2,-12(fp)
 2019c44:	1000051e 	bne	r2,zero,2019c5c <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 2019c48:	e0bfff17 	ldw	r2,-4(fp)
 2019c4c:	00c00104 	movi	r3,4
 2019c50:	10c00005 	stb	r3,0(r2)
        return (0);
 2019c54:	0005883a 	mov	r2,zero
 2019c58:	00004206 	br	2019d64 <OSQPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 2019c5c:	e0bffd17 	ldw	r2,-12(fp)
 2019c60:	10800003 	ldbu	r2,0(r2)
 2019c64:	10803fcc 	andi	r2,r2,255
 2019c68:	108000a0 	cmpeqi	r2,r2,2
 2019c6c:	1000051e 	bne	r2,zero,2019c84 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2019c70:	e0bfff17 	ldw	r2,-4(fp)
 2019c74:	00c00044 	movi	r3,1
 2019c78:	10c00005 	stb	r3,0(r2)
        return (0);
 2019c7c:	0005883a 	mov	r2,zero
 2019c80:	00003806 	br	2019d64 <OSQPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019c84:	0005303a 	rdctl	r2,status
 2019c88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019c8c:	e0fffc17 	ldw	r3,-16(fp)
 2019c90:	00bfff84 	movi	r2,-2
 2019c94:	1884703a 	and	r2,r3,r2
 2019c98:	1001703a 	wrctl	status,r2
  
  return context;
 2019c9c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2019ca0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 2019ca4:	e0bffd17 	ldw	r2,-12(fp)
 2019ca8:	10800283 	ldbu	r2,10(r2)
 2019cac:	10803fcc 	andi	r2,r2,255
 2019cb0:	10002526 	beq	r2,zero,2019d48 <OSQPendAbort+0x13c>
        nbr_tasks = 0;
 2019cb4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 2019cb8:	e0bffe03 	ldbu	r2,-8(fp)
 2019cbc:	10800060 	cmpeqi	r2,r2,1
 2019cc0:	10000e26 	beq	r2,zero,2019cfc <OSQPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 2019cc4:	00000806 	br	2019ce8 <OSQPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 2019cc8:	01c00084 	movi	r7,2
 2019ccc:	01800104 	movi	r6,4
 2019cd0:	000b883a 	mov	r5,zero
 2019cd4:	e13ffd17 	ldw	r4,-12(fp)
 2019cd8:	201577c0 	call	201577c <OS_EventTaskRdy>
                     nbr_tasks++;
 2019cdc:	e0bff803 	ldbu	r2,-32(fp)
 2019ce0:	10800044 	addi	r2,r2,1
 2019ce4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 2019ce8:	e0bffd17 	ldw	r2,-12(fp)
 2019cec:	10800283 	ldbu	r2,10(r2)
 2019cf0:	10803fcc 	andi	r2,r2,255
 2019cf4:	103ff41e 	bne	r2,zero,2019cc8 <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 2019cf8:	00000906 	br	2019d20 <OSQPendAbort+0x114>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 2019cfc:	01c00084 	movi	r7,2
 2019d00:	01800104 	movi	r6,4
 2019d04:	000b883a 	mov	r5,zero
 2019d08:	e13ffd17 	ldw	r4,-12(fp)
 2019d0c:	201577c0 	call	201577c <OS_EventTaskRdy>
                 nbr_tasks++;
 2019d10:	e0bff803 	ldbu	r2,-32(fp)
 2019d14:	10800044 	addi	r2,r2,1
 2019d18:	e0bff805 	stb	r2,-32(fp)
                 break;
 2019d1c:	0001883a 	nop
 2019d20:	e0bff917 	ldw	r2,-28(fp)
 2019d24:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019d28:	e0bffa17 	ldw	r2,-24(fp)
 2019d2c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 2019d30:	20161c80 	call	20161c8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 2019d34:	e0bfff17 	ldw	r2,-4(fp)
 2019d38:	00c00384 	movi	r3,14
 2019d3c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 2019d40:	e0bff803 	ldbu	r2,-32(fp)
 2019d44:	00000706 	br	2019d64 <OSQPendAbort+0x158>
 2019d48:	e0bff917 	ldw	r2,-28(fp)
 2019d4c:	e0bffb15 	stw	r2,-20(fp)
 2019d50:	e0bffb17 	ldw	r2,-20(fp)
 2019d54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2019d58:	e0bfff17 	ldw	r2,-4(fp)
 2019d5c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 2019d60:	0005883a 	mov	r2,zero
}
 2019d64:	e037883a 	mov	sp,fp
 2019d68:	dfc00117 	ldw	ra,4(sp)
 2019d6c:	df000017 	ldw	fp,0(sp)
 2019d70:	dec00204 	addi	sp,sp,8
 2019d74:	f800283a 	ret

02019d78 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 2019d78:	defff604 	addi	sp,sp,-40
 2019d7c:	dfc00915 	stw	ra,36(sp)
 2019d80:	df000815 	stw	fp,32(sp)
 2019d84:	df000804 	addi	fp,sp,32
 2019d88:	e13ffe15 	stw	r4,-8(fp)
 2019d8c:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 2019d90:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 2019d94:	e0bffe17 	ldw	r2,-8(fp)
 2019d98:	1000021e 	bne	r2,zero,2019da4 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 2019d9c:	00800104 	movi	r2,4
 2019da0:	00004a06 	br	2019ecc <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 2019da4:	e0bffe17 	ldw	r2,-8(fp)
 2019da8:	10800003 	ldbu	r2,0(r2)
 2019dac:	10803fcc 	andi	r2,r2,255
 2019db0:	108000a0 	cmpeqi	r2,r2,2
 2019db4:	1000021e 	bne	r2,zero,2019dc0 <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 2019db8:	00800044 	movi	r2,1
 2019dbc:	00004306 	br	2019ecc <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019dc0:	0005303a 	rdctl	r2,status
 2019dc4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019dc8:	e0fffd17 	ldw	r3,-12(fp)
 2019dcc:	00bfff84 	movi	r2,-2
 2019dd0:	1884703a 	and	r2,r3,r2
 2019dd4:	1001703a 	wrctl	status,r2
  
  return context;
 2019dd8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2019ddc:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 2019de0:	e0bffe17 	ldw	r2,-8(fp)
 2019de4:	10800283 	ldbu	r2,10(r2)
 2019de8:	10803fcc 	andi	r2,r2,255
 2019dec:	10000c26 	beq	r2,zero,2019e20 <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 2019df0:	000f883a 	mov	r7,zero
 2019df4:	01800104 	movi	r6,4
 2019df8:	e17fff17 	ldw	r5,-4(fp)
 2019dfc:	e13ffe17 	ldw	r4,-8(fp)
 2019e00:	201577c0 	call	201577c <OS_EventTaskRdy>
 2019e04:	e0bff817 	ldw	r2,-32(fp)
 2019e08:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019e0c:	e0bff917 	ldw	r2,-28(fp)
 2019e10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 2019e14:	20161c80 	call	20161c8 <OS_Sched>
        return (OS_ERR_NONE);
 2019e18:	0005883a 	mov	r2,zero
 2019e1c:	00002b06 	br	2019ecc <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 2019e20:	e0bffe17 	ldw	r2,-8(fp)
 2019e24:	10800117 	ldw	r2,4(r2)
 2019e28:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 2019e2c:	e0bffb17 	ldw	r2,-20(fp)
 2019e30:	10c0058b 	ldhu	r3,22(r2)
 2019e34:	e0bffb17 	ldw	r2,-20(fp)
 2019e38:	1080050b 	ldhu	r2,20(r2)
 2019e3c:	18ffffcc 	andi	r3,r3,65535
 2019e40:	10bfffcc 	andi	r2,r2,65535
 2019e44:	18800636 	bltu	r3,r2,2019e60 <OSQPost+0xe8>
 2019e48:	e0bff817 	ldw	r2,-32(fp)
 2019e4c:	e0bffa15 	stw	r2,-24(fp)
 2019e50:	e0bffa17 	ldw	r2,-24(fp)
 2019e54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 2019e58:	00800784 	movi	r2,30
 2019e5c:	00001b06 	br	2019ecc <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 2019e60:	e0bffb17 	ldw	r2,-20(fp)
 2019e64:	10800317 	ldw	r2,12(r2)
 2019e68:	11000104 	addi	r4,r2,4
 2019e6c:	e0fffb17 	ldw	r3,-20(fp)
 2019e70:	19000315 	stw	r4,12(r3)
 2019e74:	e0ffff17 	ldw	r3,-4(fp)
 2019e78:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 2019e7c:	e0bffb17 	ldw	r2,-20(fp)
 2019e80:	1080058b 	ldhu	r2,22(r2)
 2019e84:	10800044 	addi	r2,r2,1
 2019e88:	1007883a 	mov	r3,r2
 2019e8c:	e0bffb17 	ldw	r2,-20(fp)
 2019e90:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 2019e94:	e0bffb17 	ldw	r2,-20(fp)
 2019e98:	10c00317 	ldw	r3,12(r2)
 2019e9c:	e0bffb17 	ldw	r2,-20(fp)
 2019ea0:	10800217 	ldw	r2,8(r2)
 2019ea4:	1880041e 	bne	r3,r2,2019eb8 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 2019ea8:	e0bffb17 	ldw	r2,-20(fp)
 2019eac:	10c00117 	ldw	r3,4(r2)
 2019eb0:	e0bffb17 	ldw	r2,-20(fp)
 2019eb4:	10c00315 	stw	r3,12(r2)
 2019eb8:	e0bff817 	ldw	r2,-32(fp)
 2019ebc:	e0bffc15 	stw	r2,-16(fp)
 2019ec0:	e0bffc17 	ldw	r2,-16(fp)
 2019ec4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 2019ec8:	0005883a 	mov	r2,zero
}
 2019ecc:	e037883a 	mov	sp,fp
 2019ed0:	dfc00117 	ldw	ra,4(sp)
 2019ed4:	df000017 	ldw	fp,0(sp)
 2019ed8:	dec00204 	addi	sp,sp,8
 2019edc:	f800283a 	ret

02019ee0 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 2019ee0:	defff604 	addi	sp,sp,-40
 2019ee4:	dfc00915 	stw	ra,36(sp)
 2019ee8:	df000815 	stw	fp,32(sp)
 2019eec:	df000804 	addi	fp,sp,32
 2019ef0:	e13ffe15 	stw	r4,-8(fp)
 2019ef4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2019ef8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 2019efc:	e0bffe17 	ldw	r2,-8(fp)
 2019f00:	1000021e 	bne	r2,zero,2019f0c <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 2019f04:	00800104 	movi	r2,4
 2019f08:	00004c06 	br	201a03c <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 2019f0c:	e0bffe17 	ldw	r2,-8(fp)
 2019f10:	10800003 	ldbu	r2,0(r2)
 2019f14:	10803fcc 	andi	r2,r2,255
 2019f18:	108000a0 	cmpeqi	r2,r2,2
 2019f1c:	1000021e 	bne	r2,zero,2019f28 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 2019f20:	00800044 	movi	r2,1
 2019f24:	00004506 	br	201a03c <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019f28:	0005303a 	rdctl	r2,status
 2019f2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019f30:	e0fffd17 	ldw	r3,-12(fp)
 2019f34:	00bfff84 	movi	r2,-2
 2019f38:	1884703a 	and	r2,r3,r2
 2019f3c:	1001703a 	wrctl	status,r2
  
  return context;
 2019f40:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2019f44:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 2019f48:	e0bffe17 	ldw	r2,-8(fp)
 2019f4c:	10800283 	ldbu	r2,10(r2)
 2019f50:	10803fcc 	andi	r2,r2,255
 2019f54:	10000c26 	beq	r2,zero,2019f88 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 2019f58:	000f883a 	mov	r7,zero
 2019f5c:	01800104 	movi	r6,4
 2019f60:	e17fff17 	ldw	r5,-4(fp)
 2019f64:	e13ffe17 	ldw	r4,-8(fp)
 2019f68:	201577c0 	call	201577c <OS_EventTaskRdy>
 2019f6c:	e0bff817 	ldw	r2,-32(fp)
 2019f70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019f74:	e0bff917 	ldw	r2,-28(fp)
 2019f78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 2019f7c:	20161c80 	call	20161c8 <OS_Sched>
        return (OS_ERR_NONE);
 2019f80:	0005883a 	mov	r2,zero
 2019f84:	00002d06 	br	201a03c <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 2019f88:	e0bffe17 	ldw	r2,-8(fp)
 2019f8c:	10800117 	ldw	r2,4(r2)
 2019f90:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 2019f94:	e0bffb17 	ldw	r2,-20(fp)
 2019f98:	10c0058b 	ldhu	r3,22(r2)
 2019f9c:	e0bffb17 	ldw	r2,-20(fp)
 2019fa0:	1080050b 	ldhu	r2,20(r2)
 2019fa4:	18ffffcc 	andi	r3,r3,65535
 2019fa8:	10bfffcc 	andi	r2,r2,65535
 2019fac:	18800636 	bltu	r3,r2,2019fc8 <OSQPostFront+0xe8>
 2019fb0:	e0bff817 	ldw	r2,-32(fp)
 2019fb4:	e0bffa15 	stw	r2,-24(fp)
 2019fb8:	e0bffa17 	ldw	r2,-24(fp)
 2019fbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 2019fc0:	00800784 	movi	r2,30
 2019fc4:	00001d06 	br	201a03c <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 2019fc8:	e0bffb17 	ldw	r2,-20(fp)
 2019fcc:	10c00417 	ldw	r3,16(r2)
 2019fd0:	e0bffb17 	ldw	r2,-20(fp)
 2019fd4:	10800117 	ldw	r2,4(r2)
 2019fd8:	1880041e 	bne	r3,r2,2019fec <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 2019fdc:	e0bffb17 	ldw	r2,-20(fp)
 2019fe0:	10c00217 	ldw	r3,8(r2)
 2019fe4:	e0bffb17 	ldw	r2,-20(fp)
 2019fe8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 2019fec:	e0bffb17 	ldw	r2,-20(fp)
 2019ff0:	10800417 	ldw	r2,16(r2)
 2019ff4:	10ffff04 	addi	r3,r2,-4
 2019ff8:	e0bffb17 	ldw	r2,-20(fp)
 2019ffc:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 201a000:	e0bffb17 	ldw	r2,-20(fp)
 201a004:	10800417 	ldw	r2,16(r2)
 201a008:	e0ffff17 	ldw	r3,-4(fp)
 201a00c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 201a010:	e0bffb17 	ldw	r2,-20(fp)
 201a014:	1080058b 	ldhu	r2,22(r2)
 201a018:	10800044 	addi	r2,r2,1
 201a01c:	1007883a 	mov	r3,r2
 201a020:	e0bffb17 	ldw	r2,-20(fp)
 201a024:	10c0058d 	sth	r3,22(r2)
 201a028:	e0bff817 	ldw	r2,-32(fp)
 201a02c:	e0bffc15 	stw	r2,-16(fp)
 201a030:	e0bffc17 	ldw	r2,-16(fp)
 201a034:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201a038:	0005883a 	mov	r2,zero
}
 201a03c:	e037883a 	mov	sp,fp
 201a040:	dfc00117 	ldw	ra,4(sp)
 201a044:	df000017 	ldw	fp,0(sp)
 201a048:	dec00204 	addi	sp,sp,8
 201a04c:	f800283a 	ret

0201a050 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 201a050:	defff504 	addi	sp,sp,-44
 201a054:	dfc00a15 	stw	ra,40(sp)
 201a058:	df000915 	stw	fp,36(sp)
 201a05c:	df000904 	addi	fp,sp,36
 201a060:	e13ffd15 	stw	r4,-12(fp)
 201a064:	e17ffe15 	stw	r5,-8(fp)
 201a068:	3005883a 	mov	r2,r6
 201a06c:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201a070:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201a074:	e0bffd17 	ldw	r2,-12(fp)
 201a078:	1000021e 	bne	r2,zero,201a084 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 201a07c:	00800104 	movi	r2,4
 201a080:	00007106 	br	201a248 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 201a084:	e0bffd17 	ldw	r2,-12(fp)
 201a088:	10800003 	ldbu	r2,0(r2)
 201a08c:	10803fcc 	andi	r2,r2,255
 201a090:	108000a0 	cmpeqi	r2,r2,2
 201a094:	1000021e 	bne	r2,zero,201a0a0 <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 201a098:	00800044 	movi	r2,1
 201a09c:	00006a06 	br	201a248 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a0a0:	0005303a 	rdctl	r2,status
 201a0a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a0a8:	e0fffc17 	ldw	r3,-16(fp)
 201a0ac:	00bfff84 	movi	r2,-2
 201a0b0:	1884703a 	and	r2,r3,r2
 201a0b4:	1001703a 	wrctl	status,r2
  
  return context;
 201a0b8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201a0bc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 201a0c0:	e0bffd17 	ldw	r2,-12(fp)
 201a0c4:	10800283 	ldbu	r2,10(r2)
 201a0c8:	10803fcc 	andi	r2,r2,255
 201a0cc:	10001d26 	beq	r2,zero,201a144 <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 201a0d0:	e0bfff03 	ldbu	r2,-4(fp)
 201a0d4:	1080004c 	andi	r2,r2,1
 201a0d8:	10000b26 	beq	r2,zero,201a108 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 201a0dc:	00000506 	br	201a0f4 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201a0e0:	000f883a 	mov	r7,zero
 201a0e4:	01800104 	movi	r6,4
 201a0e8:	e17ffe17 	ldw	r5,-8(fp)
 201a0ec:	e13ffd17 	ldw	r4,-12(fp)
 201a0f0:	201577c0 	call	201577c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 201a0f4:	e0bffd17 	ldw	r2,-12(fp)
 201a0f8:	10800283 	ldbu	r2,10(r2)
 201a0fc:	10803fcc 	andi	r2,r2,255
 201a100:	103ff71e 	bne	r2,zero,201a0e0 <OSQPostOpt+0x90>
 201a104:	00000506 	br	201a11c <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201a108:	000f883a 	mov	r7,zero
 201a10c:	01800104 	movi	r6,4
 201a110:	e17ffe17 	ldw	r5,-8(fp)
 201a114:	e13ffd17 	ldw	r4,-12(fp)
 201a118:	201577c0 	call	201577c <OS_EventTaskRdy>
 201a11c:	e0bff717 	ldw	r2,-36(fp)
 201a120:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a124:	e0bff817 	ldw	r2,-32(fp)
 201a128:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 201a12c:	e0bfff03 	ldbu	r2,-4(fp)
 201a130:	1080010c 	andi	r2,r2,4
 201a134:	1000011e 	bne	r2,zero,201a13c <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 201a138:	20161c80 	call	20161c8 <OS_Sched>
        }
        return (OS_ERR_NONE);
 201a13c:	0005883a 	mov	r2,zero
 201a140:	00004106 	br	201a248 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 201a144:	e0bffd17 	ldw	r2,-12(fp)
 201a148:	10800117 	ldw	r2,4(r2)
 201a14c:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 201a150:	e0bffa17 	ldw	r2,-24(fp)
 201a154:	10c0058b 	ldhu	r3,22(r2)
 201a158:	e0bffa17 	ldw	r2,-24(fp)
 201a15c:	1080050b 	ldhu	r2,20(r2)
 201a160:	18ffffcc 	andi	r3,r3,65535
 201a164:	10bfffcc 	andi	r2,r2,65535
 201a168:	18800636 	bltu	r3,r2,201a184 <OSQPostOpt+0x134>
 201a16c:	e0bff717 	ldw	r2,-36(fp)
 201a170:	e0bff915 	stw	r2,-28(fp)
 201a174:	e0bff917 	ldw	r2,-28(fp)
 201a178:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 201a17c:	00800784 	movi	r2,30
 201a180:	00003106 	br	201a248 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 201a184:	e0bfff03 	ldbu	r2,-4(fp)
 201a188:	1080008c 	andi	r2,r2,2
 201a18c:	10001326 	beq	r2,zero,201a1dc <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 201a190:	e0bffa17 	ldw	r2,-24(fp)
 201a194:	10c00417 	ldw	r3,16(r2)
 201a198:	e0bffa17 	ldw	r2,-24(fp)
 201a19c:	10800117 	ldw	r2,4(r2)
 201a1a0:	1880041e 	bne	r3,r2,201a1b4 <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 201a1a4:	e0bffa17 	ldw	r2,-24(fp)
 201a1a8:	10c00217 	ldw	r3,8(r2)
 201a1ac:	e0bffa17 	ldw	r2,-24(fp)
 201a1b0:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 201a1b4:	e0bffa17 	ldw	r2,-24(fp)
 201a1b8:	10800417 	ldw	r2,16(r2)
 201a1bc:	10ffff04 	addi	r3,r2,-4
 201a1c0:	e0bffa17 	ldw	r2,-24(fp)
 201a1c4:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 201a1c8:	e0bffa17 	ldw	r2,-24(fp)
 201a1cc:	10800417 	ldw	r2,16(r2)
 201a1d0:	e0fffe17 	ldw	r3,-8(fp)
 201a1d4:	10c00015 	stw	r3,0(r2)
 201a1d8:	00001006 	br	201a21c <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 201a1dc:	e0bffa17 	ldw	r2,-24(fp)
 201a1e0:	10800317 	ldw	r2,12(r2)
 201a1e4:	11000104 	addi	r4,r2,4
 201a1e8:	e0fffa17 	ldw	r3,-24(fp)
 201a1ec:	19000315 	stw	r4,12(r3)
 201a1f0:	e0fffe17 	ldw	r3,-8(fp)
 201a1f4:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 201a1f8:	e0bffa17 	ldw	r2,-24(fp)
 201a1fc:	10c00317 	ldw	r3,12(r2)
 201a200:	e0bffa17 	ldw	r2,-24(fp)
 201a204:	10800217 	ldw	r2,8(r2)
 201a208:	1880041e 	bne	r3,r2,201a21c <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 201a20c:	e0bffa17 	ldw	r2,-24(fp)
 201a210:	10c00117 	ldw	r3,4(r2)
 201a214:	e0bffa17 	ldw	r2,-24(fp)
 201a218:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 201a21c:	e0bffa17 	ldw	r2,-24(fp)
 201a220:	1080058b 	ldhu	r2,22(r2)
 201a224:	10800044 	addi	r2,r2,1
 201a228:	1007883a 	mov	r3,r2
 201a22c:	e0bffa17 	ldw	r2,-24(fp)
 201a230:	10c0058d 	sth	r3,22(r2)
 201a234:	e0bff717 	ldw	r2,-36(fp)
 201a238:	e0bffb15 	stw	r2,-20(fp)
 201a23c:	e0bffb17 	ldw	r2,-20(fp)
 201a240:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201a244:	0005883a 	mov	r2,zero
}
 201a248:	e037883a 	mov	sp,fp
 201a24c:	dfc00117 	ldw	ra,4(sp)
 201a250:	df000017 	ldw	fp,0(sp)
 201a254:	dec00204 	addi	sp,sp,8
 201a258:	f800283a 	ret

0201a25c <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 201a25c:	defff604 	addi	sp,sp,-40
 201a260:	df000915 	stw	fp,36(sp)
 201a264:	df000904 	addi	fp,sp,36
 201a268:	e13ffe15 	stw	r4,-8(fp)
 201a26c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201a270:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 201a274:	e0bffe17 	ldw	r2,-8(fp)
 201a278:	1000021e 	bne	r2,zero,201a284 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 201a27c:	00800104 	movi	r2,4
 201a280:	00004906 	br	201a3a8 <OSQQuery+0x14c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 201a284:	e0bfff17 	ldw	r2,-4(fp)
 201a288:	1000021e 	bne	r2,zero,201a294 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 201a28c:	00800244 	movi	r2,9
 201a290:	00004506 	br	201a3a8 <OSQQuery+0x14c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 201a294:	e0bffe17 	ldw	r2,-8(fp)
 201a298:	10800003 	ldbu	r2,0(r2)
 201a29c:	10803fcc 	andi	r2,r2,255
 201a2a0:	108000a0 	cmpeqi	r2,r2,2
 201a2a4:	1000021e 	bne	r2,zero,201a2b0 <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 201a2a8:	00800044 	movi	r2,1
 201a2ac:	00003e06 	br	201a3a8 <OSQQuery+0x14c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a2b0:	0005303a 	rdctl	r2,status
 201a2b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a2b8:	e0fffd17 	ldw	r3,-12(fp)
 201a2bc:	00bfff84 	movi	r2,-2
 201a2c0:	1884703a 	and	r2,r3,r2
 201a2c4:	1001703a 	wrctl	status,r2
  
  return context;
 201a2c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 201a2cc:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 201a2d0:	e0bffe17 	ldw	r2,-8(fp)
 201a2d4:	10c00283 	ldbu	r3,10(r2)
 201a2d8:	e0bfff17 	ldw	r2,-4(fp)
 201a2dc:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 201a2e0:	e0bffe17 	ldw	r2,-8(fp)
 201a2e4:	108002c4 	addi	r2,r2,11
 201a2e8:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 201a2ec:	e0bfff17 	ldw	r2,-4(fp)
 201a2f0:	10800204 	addi	r2,r2,8
 201a2f4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201a2f8:	e03ff705 	stb	zero,-36(fp)
 201a2fc:	00000b06 	br	201a32c <OSQQuery+0xd0>
        *pdest++ = *psrc++;
 201a300:	e0bff917 	ldw	r2,-28(fp)
 201a304:	10c00044 	addi	r3,r2,1
 201a308:	e0fff915 	stw	r3,-28(fp)
 201a30c:	e0fff817 	ldw	r3,-32(fp)
 201a310:	19000044 	addi	r4,r3,1
 201a314:	e13ff815 	stw	r4,-32(fp)
 201a318:	18c00003 	ldbu	r3,0(r3)
 201a31c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201a320:	e0bff703 	ldbu	r2,-36(fp)
 201a324:	10800044 	addi	r2,r2,1
 201a328:	e0bff705 	stb	r2,-36(fp)
 201a32c:	e0bff703 	ldbu	r2,-36(fp)
 201a330:	108000f0 	cmpltui	r2,r2,3
 201a334:	103ff21e 	bne	r2,zero,201a300 <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 201a338:	e0bffe17 	ldw	r2,-8(fp)
 201a33c:	10800117 	ldw	r2,4(r2)
 201a340:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 201a344:	e0bffc17 	ldw	r2,-16(fp)
 201a348:	1080058b 	ldhu	r2,22(r2)
 201a34c:	10bfffcc 	andi	r2,r2,65535
 201a350:	10000626 	beq	r2,zero,201a36c <OSQQuery+0x110>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 201a354:	e0bffc17 	ldw	r2,-16(fp)
 201a358:	10800417 	ldw	r2,16(r2)
 201a35c:	10c00017 	ldw	r3,0(r2)
 201a360:	e0bfff17 	ldw	r2,-4(fp)
 201a364:	10c00015 	stw	r3,0(r2)
 201a368:	00000206 	br	201a374 <OSQQuery+0x118>
    } else {
        p_q_data->OSMsg = (void *)0;
 201a36c:	e0bfff17 	ldw	r2,-4(fp)
 201a370:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 201a374:	e0bffc17 	ldw	r2,-16(fp)
 201a378:	10c0058b 	ldhu	r3,22(r2)
 201a37c:	e0bfff17 	ldw	r2,-4(fp)
 201a380:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 201a384:	e0bffc17 	ldw	r2,-16(fp)
 201a388:	10c0050b 	ldhu	r3,20(r2)
 201a38c:	e0bfff17 	ldw	r2,-4(fp)
 201a390:	10c0018d 	sth	r3,6(r2)
 201a394:	e0bffa17 	ldw	r2,-24(fp)
 201a398:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a39c:	e0bffb17 	ldw	r2,-20(fp)
 201a3a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201a3a4:	0005883a 	mov	r2,zero
}
 201a3a8:	e037883a 	mov	sp,fp
 201a3ac:	df000017 	ldw	fp,0(sp)
 201a3b0:	dec00104 	addi	sp,sp,4
 201a3b4:	f800283a 	ret

0201a3b8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 201a3b8:	defffb04 	addi	sp,sp,-20
 201a3bc:	dfc00415 	stw	ra,16(sp)
 201a3c0:	df000315 	stw	fp,12(sp)
 201a3c4:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 201a3c8:	01407804 	movi	r5,480
 201a3cc:	010080f4 	movhi	r4,515
 201a3d0:	2132f104 	addi	r4,r4,-13372
 201a3d4:	201610c0 	call	201610c <OS_MemClr>
    pq1 = &OSQTbl[0];
 201a3d8:	008080f4 	movhi	r2,515
 201a3dc:	10b2f104 	addi	r2,r2,-13372
 201a3e0:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 201a3e4:	008080f4 	movhi	r2,515
 201a3e8:	10b2f704 	addi	r2,r2,-13348
 201a3ec:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 201a3f0:	e03ffd0d 	sth	zero,-12(fp)
 201a3f4:	00000c06 	br	201a428 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 201a3f8:	e0bffe17 	ldw	r2,-8(fp)
 201a3fc:	e0ffff17 	ldw	r3,-4(fp)
 201a400:	10c00015 	stw	r3,0(r2)
        pq1++;
 201a404:	e0bffe17 	ldw	r2,-8(fp)
 201a408:	10800604 	addi	r2,r2,24
 201a40c:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 201a410:	e0bfff17 	ldw	r2,-4(fp)
 201a414:	10800604 	addi	r2,r2,24
 201a418:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 201a41c:	e0bffd0b 	ldhu	r2,-12(fp)
 201a420:	10800044 	addi	r2,r2,1
 201a424:	e0bffd0d 	sth	r2,-12(fp)
 201a428:	e0bffd0b 	ldhu	r2,-12(fp)
 201a42c:	108004f0 	cmpltui	r2,r2,19
 201a430:	103ff11e 	bne	r2,zero,201a3f8 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 201a434:	e0bffe17 	ldw	r2,-8(fp)
 201a438:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 201a43c:	008080f4 	movhi	r2,515
 201a440:	10b2f104 	addi	r2,r2,-13372
 201a444:	d0a75a15 	stw	r2,-25240(gp)
#endif
}
 201a448:	0001883a 	nop
 201a44c:	e037883a 	mov	sp,fp
 201a450:	dfc00117 	ldw	ra,4(sp)
 201a454:	df000017 	ldw	fp,0(sp)
 201a458:	dec00204 	addi	sp,sp,8
 201a45c:	f800283a 	ret

0201a460 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 201a460:	defffa04 	addi	sp,sp,-24
 201a464:	df000515 	stw	fp,20(sp)
 201a468:	df000504 	addi	fp,sp,20
 201a46c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201a470:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201a474:	e0bfff17 	ldw	r2,-4(fp)
 201a478:	1000021e 	bne	r2,zero,201a484 <OSSemAccept+0x24>
        return (0);
 201a47c:	0005883a 	mov	r2,zero
 201a480:	00001f06 	br	201a500 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201a484:	e0bfff17 	ldw	r2,-4(fp)
 201a488:	10800003 	ldbu	r2,0(r2)
 201a48c:	10803fcc 	andi	r2,r2,255
 201a490:	108000e0 	cmpeqi	r2,r2,3
 201a494:	1000021e 	bne	r2,zero,201a4a0 <OSSemAccept+0x40>
        return (0);
 201a498:	0005883a 	mov	r2,zero
 201a49c:	00001806 	br	201a500 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a4a0:	0005303a 	rdctl	r2,status
 201a4a4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a4a8:	e0fffe17 	ldw	r3,-8(fp)
 201a4ac:	00bfff84 	movi	r2,-2
 201a4b0:	1884703a 	and	r2,r3,r2
 201a4b4:	1001703a 	wrctl	status,r2
  
  return context;
 201a4b8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 201a4bc:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 201a4c0:	e0bfff17 	ldw	r2,-4(fp)
 201a4c4:	1080020b 	ldhu	r2,8(r2)
 201a4c8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 201a4cc:	e0bffd0b 	ldhu	r2,-12(fp)
 201a4d0:	10000626 	beq	r2,zero,201a4ec <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 201a4d4:	e0bfff17 	ldw	r2,-4(fp)
 201a4d8:	1080020b 	ldhu	r2,8(r2)
 201a4dc:	10bfffc4 	addi	r2,r2,-1
 201a4e0:	1007883a 	mov	r3,r2
 201a4e4:	e0bfff17 	ldw	r2,-4(fp)
 201a4e8:	10c0020d 	sth	r3,8(r2)
 201a4ec:	e0bffb17 	ldw	r2,-20(fp)
 201a4f0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a4f4:	e0bffc17 	ldw	r2,-16(fp)
 201a4f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 201a4fc:	e0bffd0b 	ldhu	r2,-12(fp)
}
 201a500:	e037883a 	mov	sp,fp
 201a504:	df000017 	ldw	fp,0(sp)
 201a508:	dec00104 	addi	sp,sp,4
 201a50c:	f800283a 	ret

0201a510 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 201a510:	defff904 	addi	sp,sp,-28
 201a514:	dfc00615 	stw	ra,24(sp)
 201a518:	df000515 	stw	fp,20(sp)
 201a51c:	df000504 	addi	fp,sp,20
 201a520:	2005883a 	mov	r2,r4
 201a524:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201a528:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 201a52c:	d0a75d03 	ldbu	r2,-25228(gp)
 201a530:	10803fcc 	andi	r2,r2,255
 201a534:	10000226 	beq	r2,zero,201a540 <OSSemCreate+0x30>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 201a538:	0005883a 	mov	r2,zero
 201a53c:	00002506 	br	201a5d4 <OSSemCreate+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a540:	0005303a 	rdctl	r2,status
 201a544:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a548:	e0fffe17 	ldw	r3,-8(fp)
 201a54c:	00bfff84 	movi	r2,-2
 201a550:	1884703a 	and	r2,r3,r2
 201a554:	1001703a 	wrctl	status,r2
  
  return context;
 201a558:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 201a55c:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 201a560:	d0a75c17 	ldw	r2,-25232(gp)
 201a564:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 201a568:	d0a75c17 	ldw	r2,-25232(gp)
 201a56c:	10000326 	beq	r2,zero,201a57c <OSSemCreate+0x6c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 201a570:	d0a75c17 	ldw	r2,-25232(gp)
 201a574:	10800117 	ldw	r2,4(r2)
 201a578:	d0a75c15 	stw	r2,-25232(gp)
 201a57c:	e0bffb17 	ldw	r2,-20(fp)
 201a580:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a584:	e0bffc17 	ldw	r2,-16(fp)
 201a588:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 201a58c:	e0bffd17 	ldw	r2,-12(fp)
 201a590:	10000f26 	beq	r2,zero,201a5d0 <OSSemCreate+0xc0>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 201a594:	e0bffd17 	ldw	r2,-12(fp)
 201a598:	00c000c4 	movi	r3,3
 201a59c:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 201a5a0:	e0bffd17 	ldw	r2,-12(fp)
 201a5a4:	e0ffff0b 	ldhu	r3,-4(fp)
 201a5a8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 201a5ac:	e0bffd17 	ldw	r2,-12(fp)
 201a5b0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 201a5b4:	e0bffd17 	ldw	r2,-12(fp)
 201a5b8:	00c00fc4 	movi	r3,63
 201a5bc:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 201a5c0:	e0bffd17 	ldw	r2,-12(fp)
 201a5c4:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 201a5c8:	e13ffd17 	ldw	r4,-12(fp)
 201a5cc:	2015d2c0 	call	2015d2c <OS_EventWaitListInit>
    }
    return (pevent);
 201a5d0:	e0bffd17 	ldw	r2,-12(fp)
}
 201a5d4:	e037883a 	mov	sp,fp
 201a5d8:	dfc00117 	ldw	ra,4(sp)
 201a5dc:	df000017 	ldw	fp,0(sp)
 201a5e0:	dec00204 	addi	sp,sp,8
 201a5e4:	f800283a 	ret

0201a5e8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201a5e8:	defff304 	addi	sp,sp,-52
 201a5ec:	dfc00c15 	stw	ra,48(sp)
 201a5f0:	df000b15 	stw	fp,44(sp)
 201a5f4:	df000b04 	addi	fp,sp,44
 201a5f8:	e13ffd15 	stw	r4,-12(fp)
 201a5fc:	2805883a 	mov	r2,r5
 201a600:	e1bfff15 	stw	r6,-4(fp)
 201a604:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201a608:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 201a60c:	e0bfff17 	ldw	r2,-4(fp)
 201a610:	1000021e 	bne	r2,zero,201a61c <OSSemDel+0x34>
        return (pevent);
 201a614:	e0bffd17 	ldw	r2,-12(fp)
 201a618:	00007e06 	br	201a814 <OSSemDel+0x22c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201a61c:	e0bffd17 	ldw	r2,-12(fp)
 201a620:	1000051e 	bne	r2,zero,201a638 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201a624:	e0bfff17 	ldw	r2,-4(fp)
 201a628:	00c00104 	movi	r3,4
 201a62c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201a630:	e0bffd17 	ldw	r2,-12(fp)
 201a634:	00007706 	br	201a814 <OSSemDel+0x22c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 201a638:	e0bffd17 	ldw	r2,-12(fp)
 201a63c:	10800003 	ldbu	r2,0(r2)
 201a640:	10803fcc 	andi	r2,r2,255
 201a644:	108000e0 	cmpeqi	r2,r2,3
 201a648:	1000051e 	bne	r2,zero,201a660 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201a64c:	e0bfff17 	ldw	r2,-4(fp)
 201a650:	00c00044 	movi	r3,1
 201a654:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201a658:	e0bffd17 	ldw	r2,-12(fp)
 201a65c:	00006d06 	br	201a814 <OSSemDel+0x22c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 201a660:	d0a75d03 	ldbu	r2,-25228(gp)
 201a664:	10803fcc 	andi	r2,r2,255
 201a668:	10000526 	beq	r2,zero,201a680 <OSSemDel+0x98>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 201a66c:	e0bfff17 	ldw	r2,-4(fp)
 201a670:	00c003c4 	movi	r3,15
 201a674:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201a678:	e0bffd17 	ldw	r2,-12(fp)
 201a67c:	00006506 	br	201a814 <OSSemDel+0x22c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a680:	0005303a 	rdctl	r2,status
 201a684:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a688:	e0fffc17 	ldw	r3,-16(fp)
 201a68c:	00bfff84 	movi	r2,-2
 201a690:	1884703a 	and	r2,r3,r2
 201a694:	1001703a 	wrctl	status,r2
  
  return context;
 201a698:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201a69c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 201a6a0:	e0bffd17 	ldw	r2,-12(fp)
 201a6a4:	10800283 	ldbu	r2,10(r2)
 201a6a8:	10803fcc 	andi	r2,r2,255
 201a6ac:	10000326 	beq	r2,zero,201a6bc <OSSemDel+0xd4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 201a6b0:	00800044 	movi	r2,1
 201a6b4:	e0bff505 	stb	r2,-44(fp)
 201a6b8:	00000106 	br	201a6c0 <OSSemDel+0xd8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 201a6bc:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 201a6c0:	e0bffe03 	ldbu	r2,-8(fp)
 201a6c4:	10000326 	beq	r2,zero,201a6d4 <OSSemDel+0xec>
 201a6c8:	10800060 	cmpeqi	r2,r2,1
 201a6cc:	1000281e 	bne	r2,zero,201a770 <OSSemDel+0x188>
 201a6d0:	00004506 	br	201a7e8 <OSSemDel+0x200>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 201a6d4:	e0bff503 	ldbu	r2,-44(fp)
 201a6d8:	1000161e 	bne	r2,zero,201a734 <OSSemDel+0x14c>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 201a6dc:	e0bffd17 	ldw	r2,-12(fp)
 201a6e0:	00c00fc4 	movi	r3,63
 201a6e4:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 201a6e8:	e0bffd17 	ldw	r2,-12(fp)
 201a6ec:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201a6f0:	e0bffd17 	ldw	r2,-12(fp)
 201a6f4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 201a6f8:	d0e75c17 	ldw	r3,-25232(gp)
 201a6fc:	e0bffd17 	ldw	r2,-12(fp)
 201a700:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 201a704:	e0bffd17 	ldw	r2,-12(fp)
 201a708:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 201a70c:	e0bffd17 	ldw	r2,-12(fp)
 201a710:	d0a75c15 	stw	r2,-25232(gp)
 201a714:	e0bff717 	ldw	r2,-36(fp)
 201a718:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a71c:	e0bff817 	ldw	r2,-32(fp)
 201a720:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 201a724:	e0bfff17 	ldw	r2,-4(fp)
 201a728:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 201a72c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 201a730:	00003706 	br	201a810 <OSSemDel+0x228>
 201a734:	e0bff717 	ldw	r2,-36(fp)
 201a738:	e0bff915 	stw	r2,-28(fp)
 201a73c:	e0bff917 	ldw	r2,-28(fp)
 201a740:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 201a744:	e0bfff17 	ldw	r2,-4(fp)
 201a748:	00c01244 	movi	r3,73
 201a74c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 201a750:	e0bffd17 	ldw	r2,-12(fp)
 201a754:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 201a758:	00002d06 	br	201a810 <OSSemDel+0x228>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 201a75c:	000f883a 	mov	r7,zero
 201a760:	01800044 	movi	r6,1
 201a764:	000b883a 	mov	r5,zero
 201a768:	e13ffd17 	ldw	r4,-12(fp)
 201a76c:	201577c0 	call	201577c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 201a770:	e0bffd17 	ldw	r2,-12(fp)
 201a774:	10800283 	ldbu	r2,10(r2)
 201a778:	10803fcc 	andi	r2,r2,255
 201a77c:	103ff71e 	bne	r2,zero,201a75c <OSSemDel+0x174>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 201a780:	e0bffd17 	ldw	r2,-12(fp)
 201a784:	00c00fc4 	movi	r3,63
 201a788:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 201a78c:	e0bffd17 	ldw	r2,-12(fp)
 201a790:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201a794:	e0bffd17 	ldw	r2,-12(fp)
 201a798:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 201a79c:	d0e75c17 	ldw	r3,-25232(gp)
 201a7a0:	e0bffd17 	ldw	r2,-12(fp)
 201a7a4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 201a7a8:	e0bffd17 	ldw	r2,-12(fp)
 201a7ac:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 201a7b0:	e0bffd17 	ldw	r2,-12(fp)
 201a7b4:	d0a75c15 	stw	r2,-25232(gp)
 201a7b8:	e0bff717 	ldw	r2,-36(fp)
 201a7bc:	e0bffa15 	stw	r2,-24(fp)
 201a7c0:	e0bffa17 	ldw	r2,-24(fp)
 201a7c4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 201a7c8:	e0bff503 	ldbu	r2,-44(fp)
 201a7cc:	10800058 	cmpnei	r2,r2,1
 201a7d0:	1000011e 	bne	r2,zero,201a7d8 <OSSemDel+0x1f0>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 201a7d4:	20161c80 	call	20161c8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 201a7d8:	e0bfff17 	ldw	r2,-4(fp)
 201a7dc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 201a7e0:	e03ff615 	stw	zero,-40(fp)
             break;
 201a7e4:	00000a06 	br	201a810 <OSSemDel+0x228>
 201a7e8:	e0bff717 	ldw	r2,-36(fp)
 201a7ec:	e0bffb15 	stw	r2,-20(fp)
 201a7f0:	e0bffb17 	ldw	r2,-20(fp)
 201a7f4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 201a7f8:	e0bfff17 	ldw	r2,-4(fp)
 201a7fc:	00c001c4 	movi	r3,7
 201a800:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 201a804:	e0bffd17 	ldw	r2,-12(fp)
 201a808:	e0bff615 	stw	r2,-40(fp)
             break;
 201a80c:	0001883a 	nop
    }
    return (pevent_return);
 201a810:	e0bff617 	ldw	r2,-40(fp)
}
 201a814:	e037883a 	mov	sp,fp
 201a818:	dfc00117 	ldw	ra,4(sp)
 201a81c:	df000017 	ldw	fp,0(sp)
 201a820:	dec00204 	addi	sp,sp,8
 201a824:	f800283a 	ret

0201a828 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 201a828:	defff504 	addi	sp,sp,-44
 201a82c:	dfc00a15 	stw	ra,40(sp)
 201a830:	df000915 	stw	fp,36(sp)
 201a834:	df000904 	addi	fp,sp,36
 201a838:	e13ffd15 	stw	r4,-12(fp)
 201a83c:	2805883a 	mov	r2,r5
 201a840:	e1bfff15 	stw	r6,-4(fp)
 201a844:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201a848:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201a84c:	e0bfff17 	ldw	r2,-4(fp)
 201a850:	10007226 	beq	r2,zero,201aa1c <OSSemPend+0x1f4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201a854:	e0bffd17 	ldw	r2,-12(fp)
 201a858:	1000041e 	bne	r2,zero,201a86c <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 201a85c:	e0bfff17 	ldw	r2,-4(fp)
 201a860:	00c00104 	movi	r3,4
 201a864:	10c00005 	stb	r3,0(r2)
        return;
 201a868:	00006d06 	br	201aa20 <OSSemPend+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201a86c:	e0bffd17 	ldw	r2,-12(fp)
 201a870:	10800003 	ldbu	r2,0(r2)
 201a874:	10803fcc 	andi	r2,r2,255
 201a878:	108000e0 	cmpeqi	r2,r2,3
 201a87c:	1000041e 	bne	r2,zero,201a890 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 201a880:	e0bfff17 	ldw	r2,-4(fp)
 201a884:	00c00044 	movi	r3,1
 201a888:	10c00005 	stb	r3,0(r2)
        return;
 201a88c:	00006406 	br	201aa20 <OSSemPend+0x1f8>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 201a890:	d0a75d03 	ldbu	r2,-25228(gp)
 201a894:	10803fcc 	andi	r2,r2,255
 201a898:	10000426 	beq	r2,zero,201a8ac <OSSemPend+0x84>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 201a89c:	e0bfff17 	ldw	r2,-4(fp)
 201a8a0:	00c00084 	movi	r3,2
 201a8a4:	10c00005 	stb	r3,0(r2)
        return;
 201a8a8:	00005d06 	br	201aa20 <OSSemPend+0x1f8>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 201a8ac:	d0a74f03 	ldbu	r2,-25284(gp)
 201a8b0:	10803fcc 	andi	r2,r2,255
 201a8b4:	10000426 	beq	r2,zero,201a8c8 <OSSemPend+0xa0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 201a8b8:	e0bfff17 	ldw	r2,-4(fp)
 201a8bc:	00c00344 	movi	r3,13
 201a8c0:	10c00005 	stb	r3,0(r2)
        return;
 201a8c4:	00005606 	br	201aa20 <OSSemPend+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a8c8:	0005303a 	rdctl	r2,status
 201a8cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a8d0:	e0fffc17 	ldw	r3,-16(fp)
 201a8d4:	00bfff84 	movi	r2,-2
 201a8d8:	1884703a 	and	r2,r3,r2
 201a8dc:	1001703a 	wrctl	status,r2
  
  return context;
 201a8e0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201a8e4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 201a8e8:	e0bffd17 	ldw	r2,-12(fp)
 201a8ec:	1080020b 	ldhu	r2,8(r2)
 201a8f0:	10bfffcc 	andi	r2,r2,65535
 201a8f4:	10000d26 	beq	r2,zero,201a92c <OSSemPend+0x104>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 201a8f8:	e0bffd17 	ldw	r2,-12(fp)
 201a8fc:	1080020b 	ldhu	r2,8(r2)
 201a900:	10bfffc4 	addi	r2,r2,-1
 201a904:	1007883a 	mov	r3,r2
 201a908:	e0bffd17 	ldw	r2,-12(fp)
 201a90c:	10c0020d 	sth	r3,8(r2)
 201a910:	e0bff717 	ldw	r2,-36(fp)
 201a914:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a918:	e0bff817 	ldw	r2,-32(fp)
 201a91c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 201a920:	e0bfff17 	ldw	r2,-4(fp)
 201a924:	10000005 	stb	zero,0(r2)
        return;
 201a928:	00003d06 	br	201aa20 <OSSemPend+0x1f8>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 201a92c:	d0a75e17 	ldw	r2,-25224(gp)
 201a930:	d0e75e17 	ldw	r3,-25224(gp)
 201a934:	18c00c03 	ldbu	r3,48(r3)
 201a938:	18c00054 	ori	r3,r3,1
 201a93c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 201a940:	d0a75e17 	ldw	r2,-25224(gp)
 201a944:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 201a948:	d0a75e17 	ldw	r2,-25224(gp)
 201a94c:	e0fffe0b 	ldhu	r3,-8(fp)
 201a950:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 201a954:	e13ffd17 	ldw	r4,-12(fp)
 201a958:	20159140 	call	2015914 <OS_EventTaskWait>
 201a95c:	e0bff717 	ldw	r2,-36(fp)
 201a960:	e0bffb15 	stw	r2,-20(fp)
 201a964:	e0bffb17 	ldw	r2,-20(fp)
 201a968:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 201a96c:	20161c80 	call	20161c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a970:	0005303a 	rdctl	r2,status
 201a974:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a978:	e0fff917 	ldw	r3,-28(fp)
 201a97c:	00bfff84 	movi	r2,-2
 201a980:	1884703a 	and	r2,r3,r2
 201a984:	1001703a 	wrctl	status,r2
  
  return context;
 201a988:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 201a98c:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 201a990:	d0a75e17 	ldw	r2,-25224(gp)
 201a994:	10800c43 	ldbu	r2,49(r2)
 201a998:	10803fcc 	andi	r2,r2,255
 201a99c:	10000326 	beq	r2,zero,201a9ac <OSSemPend+0x184>
 201a9a0:	108000a0 	cmpeqi	r2,r2,2
 201a9a4:	1000041e 	bne	r2,zero,201a9b8 <OSSemPend+0x190>
 201a9a8:	00000706 	br	201a9c8 <OSSemPend+0x1a0>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 201a9ac:	e0bfff17 	ldw	r2,-4(fp)
 201a9b0:	10000005 	stb	zero,0(r2)
             break;
 201a9b4:	00000c06 	br	201a9e8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 201a9b8:	e0bfff17 	ldw	r2,-4(fp)
 201a9bc:	00c00384 	movi	r3,14
 201a9c0:	10c00005 	stb	r3,0(r2)
             break;
 201a9c4:	00000806 	br	201a9e8 <OSSemPend+0x1c0>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 201a9c8:	d0a75e17 	ldw	r2,-25224(gp)
 201a9cc:	e17ffd17 	ldw	r5,-12(fp)
 201a9d0:	1009883a 	mov	r4,r2
 201a9d4:	2015b740 	call	2015b74 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 201a9d8:	e0bfff17 	ldw	r2,-4(fp)
 201a9dc:	00c00284 	movi	r3,10
 201a9e0:	10c00005 	stb	r3,0(r2)
             break;
 201a9e4:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 201a9e8:	d0a75e17 	ldw	r2,-25224(gp)
 201a9ec:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 201a9f0:	d0a75e17 	ldw	r2,-25224(gp)
 201a9f4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 201a9f8:	d0a75e17 	ldw	r2,-25224(gp)
 201a9fc:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 201aa00:	d0a75e17 	ldw	r2,-25224(gp)
 201aa04:	10000815 	stw	zero,32(r2)
 201aa08:	e0bff717 	ldw	r2,-36(fp)
 201aa0c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201aa10:	e0bffa17 	ldw	r2,-24(fp)
 201aa14:	1001703a 	wrctl	status,r2
 201aa18:	00000106 	br	201aa20 <OSSemPend+0x1f8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 201aa1c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 201aa20:	e037883a 	mov	sp,fp
 201aa24:	dfc00117 	ldw	ra,4(sp)
 201aa28:	df000017 	ldw	fp,0(sp)
 201aa2c:	dec00204 	addi	sp,sp,8
 201aa30:	f800283a 	ret

0201aa34 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201aa34:	defff604 	addi	sp,sp,-40
 201aa38:	dfc00915 	stw	ra,36(sp)
 201aa3c:	df000815 	stw	fp,32(sp)
 201aa40:	df000804 	addi	fp,sp,32
 201aa44:	e13ffd15 	stw	r4,-12(fp)
 201aa48:	2805883a 	mov	r2,r5
 201aa4c:	e1bfff15 	stw	r6,-4(fp)
 201aa50:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201aa54:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201aa58:	e0bfff17 	ldw	r2,-4(fp)
 201aa5c:	1000021e 	bne	r2,zero,201aa68 <OSSemPendAbort+0x34>
        return (0);
 201aa60:	0005883a 	mov	r2,zero
 201aa64:	00004906 	br	201ab8c <OSSemPendAbort+0x158>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201aa68:	e0bffd17 	ldw	r2,-12(fp)
 201aa6c:	1000051e 	bne	r2,zero,201aa84 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201aa70:	e0bfff17 	ldw	r2,-4(fp)
 201aa74:	00c00104 	movi	r3,4
 201aa78:	10c00005 	stb	r3,0(r2)
        return (0);
 201aa7c:	0005883a 	mov	r2,zero
 201aa80:	00004206 	br	201ab8c <OSSemPendAbort+0x158>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201aa84:	e0bffd17 	ldw	r2,-12(fp)
 201aa88:	10800003 	ldbu	r2,0(r2)
 201aa8c:	10803fcc 	andi	r2,r2,255
 201aa90:	108000e0 	cmpeqi	r2,r2,3
 201aa94:	1000051e 	bne	r2,zero,201aaac <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201aa98:	e0bfff17 	ldw	r2,-4(fp)
 201aa9c:	00c00044 	movi	r3,1
 201aaa0:	10c00005 	stb	r3,0(r2)
        return (0);
 201aaa4:	0005883a 	mov	r2,zero
 201aaa8:	00003806 	br	201ab8c <OSSemPendAbort+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201aaac:	0005303a 	rdctl	r2,status
 201aab0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201aab4:	e0fffc17 	ldw	r3,-16(fp)
 201aab8:	00bfff84 	movi	r2,-2
 201aabc:	1884703a 	and	r2,r3,r2
 201aac0:	1001703a 	wrctl	status,r2
  
  return context;
 201aac4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201aac8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 201aacc:	e0bffd17 	ldw	r2,-12(fp)
 201aad0:	10800283 	ldbu	r2,10(r2)
 201aad4:	10803fcc 	andi	r2,r2,255
 201aad8:	10002526 	beq	r2,zero,201ab70 <OSSemPendAbort+0x13c>
        nbr_tasks = 0;
 201aadc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 201aae0:	e0bffe03 	ldbu	r2,-8(fp)
 201aae4:	10800060 	cmpeqi	r2,r2,1
 201aae8:	10000e26 	beq	r2,zero,201ab24 <OSSemPendAbort+0xf0>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 201aaec:	00000806 	br	201ab10 <OSSemPendAbort+0xdc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 201aaf0:	01c00084 	movi	r7,2
 201aaf4:	01800044 	movi	r6,1
 201aaf8:	000b883a 	mov	r5,zero
 201aafc:	e13ffd17 	ldw	r4,-12(fp)
 201ab00:	201577c0 	call	201577c <OS_EventTaskRdy>
                     nbr_tasks++;
 201ab04:	e0bff803 	ldbu	r2,-32(fp)
 201ab08:	10800044 	addi	r2,r2,1
 201ab0c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 201ab10:	e0bffd17 	ldw	r2,-12(fp)
 201ab14:	10800283 	ldbu	r2,10(r2)
 201ab18:	10803fcc 	andi	r2,r2,255
 201ab1c:	103ff41e 	bne	r2,zero,201aaf0 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 201ab20:	00000906 	br	201ab48 <OSSemPendAbort+0x114>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 201ab24:	01c00084 	movi	r7,2
 201ab28:	01800044 	movi	r6,1
 201ab2c:	000b883a 	mov	r5,zero
 201ab30:	e13ffd17 	ldw	r4,-12(fp)
 201ab34:	201577c0 	call	201577c <OS_EventTaskRdy>
                 nbr_tasks++;
 201ab38:	e0bff803 	ldbu	r2,-32(fp)
 201ab3c:	10800044 	addi	r2,r2,1
 201ab40:	e0bff805 	stb	r2,-32(fp)
                 break;
 201ab44:	0001883a 	nop
 201ab48:	e0bff917 	ldw	r2,-28(fp)
 201ab4c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ab50:	e0bffa17 	ldw	r2,-24(fp)
 201ab54:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 201ab58:	20161c80 	call	20161c8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 201ab5c:	e0bfff17 	ldw	r2,-4(fp)
 201ab60:	00c00384 	movi	r3,14
 201ab64:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 201ab68:	e0bff803 	ldbu	r2,-32(fp)
 201ab6c:	00000706 	br	201ab8c <OSSemPendAbort+0x158>
 201ab70:	e0bff917 	ldw	r2,-28(fp)
 201ab74:	e0bffb15 	stw	r2,-20(fp)
 201ab78:	e0bffb17 	ldw	r2,-20(fp)
 201ab7c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201ab80:	e0bfff17 	ldw	r2,-4(fp)
 201ab84:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 201ab88:	0005883a 	mov	r2,zero
}
 201ab8c:	e037883a 	mov	sp,fp
 201ab90:	dfc00117 	ldw	ra,4(sp)
 201ab94:	df000017 	ldw	fp,0(sp)
 201ab98:	dec00204 	addi	sp,sp,8
 201ab9c:	f800283a 	ret

0201aba0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 201aba0:	defff804 	addi	sp,sp,-32
 201aba4:	dfc00715 	stw	ra,28(sp)
 201aba8:	df000615 	stw	fp,24(sp)
 201abac:	df000604 	addi	fp,sp,24
 201abb0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201abb4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201abb8:	e0bfff17 	ldw	r2,-4(fp)
 201abbc:	1000021e 	bne	r2,zero,201abc8 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 201abc0:	00800104 	movi	r2,4
 201abc4:	00003506 	br	201ac9c <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201abc8:	e0bfff17 	ldw	r2,-4(fp)
 201abcc:	10800003 	ldbu	r2,0(r2)
 201abd0:	10803fcc 	andi	r2,r2,255
 201abd4:	108000e0 	cmpeqi	r2,r2,3
 201abd8:	1000021e 	bne	r2,zero,201abe4 <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 201abdc:	00800044 	movi	r2,1
 201abe0:	00002e06 	br	201ac9c <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201abe4:	0005303a 	rdctl	r2,status
 201abe8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201abec:	e0fffe17 	ldw	r3,-8(fp)
 201abf0:	00bfff84 	movi	r2,-2
 201abf4:	1884703a 	and	r2,r3,r2
 201abf8:	1001703a 	wrctl	status,r2
  
  return context;
 201abfc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 201ac00:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 201ac04:	e0bfff17 	ldw	r2,-4(fp)
 201ac08:	10800283 	ldbu	r2,10(r2)
 201ac0c:	10803fcc 	andi	r2,r2,255
 201ac10:	10000c26 	beq	r2,zero,201ac44 <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 201ac14:	000f883a 	mov	r7,zero
 201ac18:	01800044 	movi	r6,1
 201ac1c:	000b883a 	mov	r5,zero
 201ac20:	e13fff17 	ldw	r4,-4(fp)
 201ac24:	201577c0 	call	201577c <OS_EventTaskRdy>
 201ac28:	e0bffa17 	ldw	r2,-24(fp)
 201ac2c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ac30:	e0bffb17 	ldw	r2,-20(fp)
 201ac34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 201ac38:	20161c80 	call	20161c8 <OS_Sched>
        return (OS_ERR_NONE);
 201ac3c:	0005883a 	mov	r2,zero
 201ac40:	00001606 	br	201ac9c <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 201ac44:	e0bfff17 	ldw	r2,-4(fp)
 201ac48:	1080020b 	ldhu	r2,8(r2)
 201ac4c:	10ffffcc 	andi	r3,r2,65535
 201ac50:	00bfffd4 	movui	r2,65535
 201ac54:	18800c26 	beq	r3,r2,201ac88 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 201ac58:	e0bfff17 	ldw	r2,-4(fp)
 201ac5c:	1080020b 	ldhu	r2,8(r2)
 201ac60:	10800044 	addi	r2,r2,1
 201ac64:	1007883a 	mov	r3,r2
 201ac68:	e0bfff17 	ldw	r2,-4(fp)
 201ac6c:	10c0020d 	sth	r3,8(r2)
 201ac70:	e0bffa17 	ldw	r2,-24(fp)
 201ac74:	e0bffc15 	stw	r2,-16(fp)
 201ac78:	e0bffc17 	ldw	r2,-16(fp)
 201ac7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 201ac80:	0005883a 	mov	r2,zero
 201ac84:	00000506 	br	201ac9c <OSSemPost+0xfc>
 201ac88:	e0bffa17 	ldw	r2,-24(fp)
 201ac8c:	e0bffd15 	stw	r2,-12(fp)
 201ac90:	e0bffd17 	ldw	r2,-12(fp)
 201ac94:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 201ac98:	00800c84 	movi	r2,50
}
 201ac9c:	e037883a 	mov	sp,fp
 201aca0:	dfc00117 	ldw	ra,4(sp)
 201aca4:	df000017 	ldw	fp,0(sp)
 201aca8:	dec00204 	addi	sp,sp,8
 201acac:	f800283a 	ret

0201acb0 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 201acb0:	defff704 	addi	sp,sp,-36
 201acb4:	df000815 	stw	fp,32(sp)
 201acb8:	df000804 	addi	fp,sp,32
 201acbc:	e13ffe15 	stw	r4,-8(fp)
 201acc0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201acc4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201acc8:	e0bffe17 	ldw	r2,-8(fp)
 201accc:	1000021e 	bne	r2,zero,201acd8 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 201acd0:	00800104 	movi	r2,4
 201acd4:	00003606 	br	201adb0 <OSSemQuery+0x100>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 201acd8:	e0bfff17 	ldw	r2,-4(fp)
 201acdc:	1000021e 	bne	r2,zero,201ace8 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 201ace0:	00800244 	movi	r2,9
 201ace4:	00003206 	br	201adb0 <OSSemQuery+0x100>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 201ace8:	e0bffe17 	ldw	r2,-8(fp)
 201acec:	10800003 	ldbu	r2,0(r2)
 201acf0:	10803fcc 	andi	r2,r2,255
 201acf4:	108000e0 	cmpeqi	r2,r2,3
 201acf8:	1000021e 	bne	r2,zero,201ad04 <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 201acfc:	00800044 	movi	r2,1
 201ad00:	00002b06 	br	201adb0 <OSSemQuery+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ad04:	0005303a 	rdctl	r2,status
 201ad08:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ad0c:	e0fffd17 	ldw	r3,-12(fp)
 201ad10:	00bfff84 	movi	r2,-2
 201ad14:	1884703a 	and	r2,r3,r2
 201ad18:	1001703a 	wrctl	status,r2
  
  return context;
 201ad1c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 201ad20:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 201ad24:	e0bffe17 	ldw	r2,-8(fp)
 201ad28:	10c00283 	ldbu	r3,10(r2)
 201ad2c:	e0bfff17 	ldw	r2,-4(fp)
 201ad30:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 201ad34:	e0bffe17 	ldw	r2,-8(fp)
 201ad38:	108002c4 	addi	r2,r2,11
 201ad3c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 201ad40:	e0bfff17 	ldw	r2,-4(fp)
 201ad44:	10800084 	addi	r2,r2,2
 201ad48:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201ad4c:	e03ffa05 	stb	zero,-24(fp)
 201ad50:	00000b06 	br	201ad80 <OSSemQuery+0xd0>
        *pdest++ = *psrc++;
 201ad54:	e0bff917 	ldw	r2,-28(fp)
 201ad58:	10c00044 	addi	r3,r2,1
 201ad5c:	e0fff915 	stw	r3,-28(fp)
 201ad60:	e0fff817 	ldw	r3,-32(fp)
 201ad64:	19000044 	addi	r4,r3,1
 201ad68:	e13ff815 	stw	r4,-32(fp)
 201ad6c:	18c00003 	ldbu	r3,0(r3)
 201ad70:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201ad74:	e0bffa03 	ldbu	r2,-24(fp)
 201ad78:	10800044 	addi	r2,r2,1
 201ad7c:	e0bffa05 	stb	r2,-24(fp)
 201ad80:	e0bffa03 	ldbu	r2,-24(fp)
 201ad84:	108000f0 	cmpltui	r2,r2,3
 201ad88:	103ff21e 	bne	r2,zero,201ad54 <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 201ad8c:	e0bffe17 	ldw	r2,-8(fp)
 201ad90:	10c0020b 	ldhu	r3,8(r2)
 201ad94:	e0bfff17 	ldw	r2,-4(fp)
 201ad98:	10c0000d 	sth	r3,0(r2)
 201ad9c:	e0bffb17 	ldw	r2,-20(fp)
 201ada0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ada4:	e0bffc17 	ldw	r2,-16(fp)
 201ada8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201adac:	0005883a 	mov	r2,zero
}
 201adb0:	e037883a 	mov	sp,fp
 201adb4:	df000017 	ldw	fp,0(sp)
 201adb8:	dec00104 	addi	sp,sp,4
 201adbc:	f800283a 	ret

0201adc0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 201adc0:	defff904 	addi	sp,sp,-28
 201adc4:	df000615 	stw	fp,24(sp)
 201adc8:	df000604 	addi	fp,sp,24
 201adcc:	e13ffd15 	stw	r4,-12(fp)
 201add0:	2805883a 	mov	r2,r5
 201add4:	e1bfff15 	stw	r6,-4(fp)
 201add8:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201addc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201ade0:	e0bfff17 	ldw	r2,-4(fp)
 201ade4:	10003126 	beq	r2,zero,201aeac <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201ade8:	e0bffd17 	ldw	r2,-12(fp)
 201adec:	1000041e 	bne	r2,zero,201ae00 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 201adf0:	e0bfff17 	ldw	r2,-4(fp)
 201adf4:	00c00104 	movi	r3,4
 201adf8:	10c00005 	stb	r3,0(r2)
        return;
 201adfc:	00002c06 	br	201aeb0 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201ae00:	e0bffd17 	ldw	r2,-12(fp)
 201ae04:	10800003 	ldbu	r2,0(r2)
 201ae08:	10803fcc 	andi	r2,r2,255
 201ae0c:	108000e0 	cmpeqi	r2,r2,3
 201ae10:	1000041e 	bne	r2,zero,201ae24 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 201ae14:	e0bfff17 	ldw	r2,-4(fp)
 201ae18:	00c00044 	movi	r3,1
 201ae1c:	10c00005 	stb	r3,0(r2)
        return;
 201ae20:	00002306 	br	201aeb0 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ae24:	0005303a 	rdctl	r2,status
 201ae28:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ae2c:	e0fffc17 	ldw	r3,-16(fp)
 201ae30:	00bfff84 	movi	r2,-2
 201ae34:	1884703a 	and	r2,r3,r2
 201ae38:	1001703a 	wrctl	status,r2
  
  return context;
 201ae3c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201ae40:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 201ae44:	e0bfff17 	ldw	r2,-4(fp)
 201ae48:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 201ae4c:	e0bffd17 	ldw	r2,-12(fp)
 201ae50:	1080020b 	ldhu	r2,8(r2)
 201ae54:	10bfffcc 	andi	r2,r2,65535
 201ae58:	10000426 	beq	r2,zero,201ae6c <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 201ae5c:	e0bffd17 	ldw	r2,-12(fp)
 201ae60:	e0fffe0b 	ldhu	r3,-8(fp)
 201ae64:	10c0020d 	sth	r3,8(r2)
 201ae68:	00000b06 	br	201ae98 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 201ae6c:	e0bffd17 	ldw	r2,-12(fp)
 201ae70:	10800283 	ldbu	r2,10(r2)
 201ae74:	10803fcc 	andi	r2,r2,255
 201ae78:	1000041e 	bne	r2,zero,201ae8c <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 201ae7c:	e0bffd17 	ldw	r2,-12(fp)
 201ae80:	e0fffe0b 	ldhu	r3,-8(fp)
 201ae84:	10c0020d 	sth	r3,8(r2)
 201ae88:	00000306 	br	201ae98 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 201ae8c:	e0bfff17 	ldw	r2,-4(fp)
 201ae90:	00c01244 	movi	r3,73
 201ae94:	10c00005 	stb	r3,0(r2)
 201ae98:	e0bffa17 	ldw	r2,-24(fp)
 201ae9c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201aea0:	e0bffb17 	ldw	r2,-20(fp)
 201aea4:	1001703a 	wrctl	status,r2
 201aea8:	00000106 	br	201aeb0 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 201aeac:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 201aeb0:	e037883a 	mov	sp,fp
 201aeb4:	df000017 	ldw	fp,0(sp)
 201aeb8:	dec00104 	addi	sp,sp,4
 201aebc:	f800283a 	ret

0201aec0 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 201aec0:	defff104 	addi	sp,sp,-60
 201aec4:	dfc00e15 	stw	ra,56(sp)
 201aec8:	df000d15 	stw	fp,52(sp)
 201aecc:	df000d04 	addi	fp,sp,52
 201aed0:	2007883a 	mov	r3,r4
 201aed4:	2805883a 	mov	r2,r5
 201aed8:	e0fffe05 	stb	r3,-8(fp)
 201aedc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 201aee0:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 201aee4:	e0bffe03 	ldbu	r2,-8(fp)
 201aee8:	10800530 	cmpltui	r2,r2,20
 201aeec:	1000051e 	bne	r2,zero,201af04 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 201aef0:	e0bffe03 	ldbu	r2,-8(fp)
 201aef4:	10803fe0 	cmpeqi	r2,r2,255
 201aef8:	1000021e 	bne	r2,zero,201af04 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 201aefc:	00800a84 	movi	r2,42
 201af00:	00012606 	br	201b39c <OSTaskChangePrio+0x4dc>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 201af04:	e0bfff03 	ldbu	r2,-4(fp)
 201af08:	10800530 	cmpltui	r2,r2,20
 201af0c:	1000021e 	bne	r2,zero,201af18 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 201af10:	00800a84 	movi	r2,42
 201af14:	00012106 	br	201b39c <OSTaskChangePrio+0x4dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201af18:	0005303a 	rdctl	r2,status
 201af1c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201af20:	e0fffd17 	ldw	r3,-12(fp)
 201af24:	00bfff84 	movi	r2,-2
 201af28:	1884703a 	and	r2,r3,r2
 201af2c:	1001703a 	wrctl	status,r2
  
  return context;
 201af30:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201af34:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 201af38:	e0ffff03 	ldbu	r3,-4(fp)
 201af3c:	008080f4 	movhi	r2,515
 201af40:	10b97d04 	addi	r2,r2,-6668
 201af44:	18c7883a 	add	r3,r3,r3
 201af48:	18c7883a 	add	r3,r3,r3
 201af4c:	10c5883a 	add	r2,r2,r3
 201af50:	10800017 	ldw	r2,0(r2)
 201af54:	10000626 	beq	r2,zero,201af70 <OSTaskChangePrio+0xb0>
 201af58:	e0bff517 	ldw	r2,-44(fp)
 201af5c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201af60:	e0bff617 	ldw	r2,-40(fp)
 201af64:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 201af68:	00800a04 	movi	r2,40
 201af6c:	00010b06 	br	201b39c <OSTaskChangePrio+0x4dc>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 201af70:	e0bffe03 	ldbu	r2,-8(fp)
 201af74:	10803fd8 	cmpnei	r2,r2,255
 201af78:	1000031e 	bne	r2,zero,201af88 <OSTaskChangePrio+0xc8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 201af7c:	d0a75e17 	ldw	r2,-25224(gp)
 201af80:	10800c83 	ldbu	r2,50(r2)
 201af84:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 201af88:	e0fffe03 	ldbu	r3,-8(fp)
 201af8c:	008080f4 	movhi	r2,515
 201af90:	10b97d04 	addi	r2,r2,-6668
 201af94:	18c7883a 	add	r3,r3,r3
 201af98:	18c7883a 	add	r3,r3,r3
 201af9c:	10c5883a 	add	r2,r2,r3
 201afa0:	10800017 	ldw	r2,0(r2)
 201afa4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 201afa8:	e0bff817 	ldw	r2,-32(fp)
 201afac:	1000061e 	bne	r2,zero,201afc8 <OSTaskChangePrio+0x108>
 201afb0:	e0bff517 	ldw	r2,-44(fp)
 201afb4:	e0bff715 	stw	r2,-36(fp)
 201afb8:	e0bff717 	ldw	r2,-36(fp)
 201afbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 201afc0:	00800a44 	movi	r2,41
 201afc4:	0000f506 	br	201b39c <OSTaskChangePrio+0x4dc>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 201afc8:	e0bff817 	ldw	r2,-32(fp)
 201afcc:	10800058 	cmpnei	r2,r2,1
 201afd0:	1000061e 	bne	r2,zero,201afec <OSTaskChangePrio+0x12c>
 201afd4:	e0bff517 	ldw	r2,-44(fp)
 201afd8:	e0bff915 	stw	r2,-28(fp)
 201afdc:	e0bff917 	ldw	r2,-28(fp)
 201afe0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 201afe4:	008010c4 	movi	r2,67
 201afe8:	0000ec06 	br	201b39c <OSTaskChangePrio+0x4dc>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 201afec:	e0bfff03 	ldbu	r2,-4(fp)
 201aff0:	1004d0fa 	srli	r2,r2,3
 201aff4:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 201aff8:	e0bfff03 	ldbu	r2,-4(fp)
 201affc:	108001cc 	andi	r2,r2,7
 201b000:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
 201b004:	e0bffb03 	ldbu	r2,-20(fp)
 201b008:	00c00044 	movi	r3,1
 201b00c:	1884983a 	sll	r2,r3,r2
 201b010:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
 201b014:	e0bffb43 	ldbu	r2,-19(fp)
 201b018:	00c00044 	movi	r3,1
 201b01c:	1884983a 	sll	r2,r3,r2
 201b020:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 201b024:	e0fffe03 	ldbu	r3,-8(fp)
 201b028:	008080f4 	movhi	r2,515
 201b02c:	10b97d04 	addi	r2,r2,-6668
 201b030:	18c7883a 	add	r3,r3,r3
 201b034:	18c7883a 	add	r3,r3,r3
 201b038:	10c5883a 	add	r2,r2,r3
 201b03c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 201b040:	e0ffff03 	ldbu	r3,-4(fp)
 201b044:	008080f4 	movhi	r2,515
 201b048:	10b97d04 	addi	r2,r2,-6668
 201b04c:	18c7883a 	add	r3,r3,r3
 201b050:	18c7883a 	add	r3,r3,r3
 201b054:	10c5883a 	add	r2,r2,r3
 201b058:	e0fff817 	ldw	r3,-32(fp)
 201b05c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 201b060:	e0bff817 	ldw	r2,-32(fp)
 201b064:	10800d03 	ldbu	r2,52(r2)
 201b068:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
 201b06c:	e0bff817 	ldw	r2,-32(fp)
 201b070:	10800d83 	ldbu	r2,54(r2)
 201b074:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 201b078:	e0bff817 	ldw	r2,-32(fp)
 201b07c:	10800d43 	ldbu	r2,53(r2)
 201b080:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 201b084:	e0fffc03 	ldbu	r3,-16(fp)
 201b088:	d0a75b44 	addi	r2,gp,-25235
 201b08c:	1885883a 	add	r2,r3,r2
 201b090:	10c00003 	ldbu	r3,0(r2)
 201b094:	e0bffc83 	ldbu	r2,-14(fp)
 201b098:	1884703a 	and	r2,r3,r2
 201b09c:	10803fcc 	andi	r2,r2,255
 201b0a0:	10002826 	beq	r2,zero,201b144 <OSTaskChangePrio+0x284>
         OSRdyTbl[y_old] &= ~bitx_old;
 201b0a4:	e0fffc03 	ldbu	r3,-16(fp)
 201b0a8:	e13ffc03 	ldbu	r4,-16(fp)
 201b0ac:	d0a75b44 	addi	r2,gp,-25235
 201b0b0:	2085883a 	add	r2,r4,r2
 201b0b4:	10800003 	ldbu	r2,0(r2)
 201b0b8:	1009883a 	mov	r4,r2
 201b0bc:	e0bffc83 	ldbu	r2,-14(fp)
 201b0c0:	0084303a 	nor	r2,zero,r2
 201b0c4:	2084703a 	and	r2,r4,r2
 201b0c8:	1009883a 	mov	r4,r2
 201b0cc:	d0a75b44 	addi	r2,gp,-25235
 201b0d0:	1885883a 	add	r2,r3,r2
 201b0d4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 201b0d8:	e0fffc03 	ldbu	r3,-16(fp)
 201b0dc:	d0a75b44 	addi	r2,gp,-25235
 201b0e0:	1885883a 	add	r2,r3,r2
 201b0e4:	10800003 	ldbu	r2,0(r2)
 201b0e8:	10803fcc 	andi	r2,r2,255
 201b0ec:	1000061e 	bne	r2,zero,201b108 <OSTaskChangePrio+0x248>
             OSRdyGrp &= ~bity_old;
 201b0f0:	e0bffc43 	ldbu	r2,-15(fp)
 201b0f4:	0084303a 	nor	r2,zero,r2
 201b0f8:	1007883a 	mov	r3,r2
 201b0fc:	d0a75b03 	ldbu	r2,-25236(gp)
 201b100:	1884703a 	and	r2,r3,r2
 201b104:	d0a75b05 	stb	r2,-25236(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 201b108:	d0e75b03 	ldbu	r3,-25236(gp)
 201b10c:	e0bffb83 	ldbu	r2,-18(fp)
 201b110:	1884b03a 	or	r2,r3,r2
 201b114:	d0a75b05 	stb	r2,-25236(gp)
         OSRdyTbl[y_new] |= bitx_new;
 201b118:	e0fffb03 	ldbu	r3,-20(fp)
 201b11c:	e13ffb03 	ldbu	r4,-20(fp)
 201b120:	d0a75b44 	addi	r2,gp,-25235
 201b124:	2085883a 	add	r2,r4,r2
 201b128:	11000003 	ldbu	r4,0(r2)
 201b12c:	e0bffbc3 	ldbu	r2,-17(fp)
 201b130:	2084b03a 	or	r2,r4,r2
 201b134:	1009883a 	mov	r4,r2
 201b138:	d0a75b44 	addi	r2,gp,-25235
 201b13c:	1885883a 	add	r2,r3,r2
 201b140:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 201b144:	e0bff817 	ldw	r2,-32(fp)
 201b148:	10800717 	ldw	r2,28(r2)
 201b14c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 201b150:	e0bff317 	ldw	r2,-52(fp)
 201b154:	10003326 	beq	r2,zero,201b224 <OSTaskChangePrio+0x364>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 201b158:	e0bffc03 	ldbu	r2,-16(fp)
 201b15c:	e0fffc03 	ldbu	r3,-16(fp)
 201b160:	e13ff317 	ldw	r4,-52(fp)
 201b164:	20c7883a 	add	r3,r4,r3
 201b168:	18c002c4 	addi	r3,r3,11
 201b16c:	18c00003 	ldbu	r3,0(r3)
 201b170:	1809883a 	mov	r4,r3
 201b174:	e0fffc83 	ldbu	r3,-14(fp)
 201b178:	00c6303a 	nor	r3,zero,r3
 201b17c:	20c6703a 	and	r3,r4,r3
 201b180:	1809883a 	mov	r4,r3
 201b184:	e0fff317 	ldw	r3,-52(fp)
 201b188:	1885883a 	add	r2,r3,r2
 201b18c:	108002c4 	addi	r2,r2,11
 201b190:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 201b194:	e0bffc03 	ldbu	r2,-16(fp)
 201b198:	e0fff317 	ldw	r3,-52(fp)
 201b19c:	1885883a 	add	r2,r3,r2
 201b1a0:	108002c4 	addi	r2,r2,11
 201b1a4:	10800003 	ldbu	r2,0(r2)
 201b1a8:	10803fcc 	andi	r2,r2,255
 201b1ac:	1000091e 	bne	r2,zero,201b1d4 <OSTaskChangePrio+0x314>
            pevent->OSEventGrp    &= ~bity_old;
 201b1b0:	e0bff317 	ldw	r2,-52(fp)
 201b1b4:	10800283 	ldbu	r2,10(r2)
 201b1b8:	1007883a 	mov	r3,r2
 201b1bc:	e0bffc43 	ldbu	r2,-15(fp)
 201b1c0:	0084303a 	nor	r2,zero,r2
 201b1c4:	1884703a 	and	r2,r3,r2
 201b1c8:	1007883a 	mov	r3,r2
 201b1cc:	e0bff317 	ldw	r2,-52(fp)
 201b1d0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 201b1d4:	e0bff317 	ldw	r2,-52(fp)
 201b1d8:	10c00283 	ldbu	r3,10(r2)
 201b1dc:	e0bffb83 	ldbu	r2,-18(fp)
 201b1e0:	1884b03a 	or	r2,r3,r2
 201b1e4:	1007883a 	mov	r3,r2
 201b1e8:	e0bff317 	ldw	r2,-52(fp)
 201b1ec:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 201b1f0:	e0bffb03 	ldbu	r2,-20(fp)
 201b1f4:	e0fffb03 	ldbu	r3,-20(fp)
 201b1f8:	e13ff317 	ldw	r4,-52(fp)
 201b1fc:	20c7883a 	add	r3,r4,r3
 201b200:	18c002c4 	addi	r3,r3,11
 201b204:	19000003 	ldbu	r4,0(r3)
 201b208:	e0fffbc3 	ldbu	r3,-17(fp)
 201b20c:	20c6b03a 	or	r3,r4,r3
 201b210:	1809883a 	mov	r4,r3
 201b214:	e0fff317 	ldw	r3,-52(fp)
 201b218:	1885883a 	add	r2,r3,r2
 201b21c:	108002c4 	addi	r2,r2,11
 201b220:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 201b224:	e0bff817 	ldw	r2,-32(fp)
 201b228:	10800817 	ldw	r2,32(r2)
 201b22c:	10004226 	beq	r2,zero,201b338 <OSTaskChangePrio+0x478>
        pevents =  ptcb->OSTCBEventMultiPtr;
 201b230:	e0bff817 	ldw	r2,-32(fp)
 201b234:	10800817 	ldw	r2,32(r2)
 201b238:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 201b23c:	e0bff417 	ldw	r2,-48(fp)
 201b240:	10800017 	ldw	r2,0(r2)
 201b244:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 201b248:	00003906 	br	201b330 <OSTaskChangePrio+0x470>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 201b24c:	e0bffc03 	ldbu	r2,-16(fp)
 201b250:	e0fffc03 	ldbu	r3,-16(fp)
 201b254:	e13ff317 	ldw	r4,-52(fp)
 201b258:	20c7883a 	add	r3,r4,r3
 201b25c:	18c002c4 	addi	r3,r3,11
 201b260:	18c00003 	ldbu	r3,0(r3)
 201b264:	1809883a 	mov	r4,r3
 201b268:	e0fffc83 	ldbu	r3,-14(fp)
 201b26c:	00c6303a 	nor	r3,zero,r3
 201b270:	20c6703a 	and	r3,r4,r3
 201b274:	1809883a 	mov	r4,r3
 201b278:	e0fff317 	ldw	r3,-52(fp)
 201b27c:	1885883a 	add	r2,r3,r2
 201b280:	108002c4 	addi	r2,r2,11
 201b284:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 201b288:	e0bffc03 	ldbu	r2,-16(fp)
 201b28c:	e0fff317 	ldw	r3,-52(fp)
 201b290:	1885883a 	add	r2,r3,r2
 201b294:	108002c4 	addi	r2,r2,11
 201b298:	10800003 	ldbu	r2,0(r2)
 201b29c:	10803fcc 	andi	r2,r2,255
 201b2a0:	1000091e 	bne	r2,zero,201b2c8 <OSTaskChangePrio+0x408>
                pevent->OSEventGrp    &= ~bity_old;
 201b2a4:	e0bff317 	ldw	r2,-52(fp)
 201b2a8:	10800283 	ldbu	r2,10(r2)
 201b2ac:	1007883a 	mov	r3,r2
 201b2b0:	e0bffc43 	ldbu	r2,-15(fp)
 201b2b4:	0084303a 	nor	r2,zero,r2
 201b2b8:	1884703a 	and	r2,r3,r2
 201b2bc:	1007883a 	mov	r3,r2
 201b2c0:	e0bff317 	ldw	r2,-52(fp)
 201b2c4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 201b2c8:	e0bff317 	ldw	r2,-52(fp)
 201b2cc:	10c00283 	ldbu	r3,10(r2)
 201b2d0:	e0bffb83 	ldbu	r2,-18(fp)
 201b2d4:	1884b03a 	or	r2,r3,r2
 201b2d8:	1007883a 	mov	r3,r2
 201b2dc:	e0bff317 	ldw	r2,-52(fp)
 201b2e0:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 201b2e4:	e0bffb03 	ldbu	r2,-20(fp)
 201b2e8:	e0fffb03 	ldbu	r3,-20(fp)
 201b2ec:	e13ff317 	ldw	r4,-52(fp)
 201b2f0:	20c7883a 	add	r3,r4,r3
 201b2f4:	18c002c4 	addi	r3,r3,11
 201b2f8:	19000003 	ldbu	r4,0(r3)
 201b2fc:	e0fffbc3 	ldbu	r3,-17(fp)
 201b300:	20c6b03a 	or	r3,r4,r3
 201b304:	1809883a 	mov	r4,r3
 201b308:	e0fff317 	ldw	r3,-52(fp)
 201b30c:	1885883a 	add	r2,r3,r2
 201b310:	108002c4 	addi	r2,r2,11
 201b314:	11000005 	stb	r4,0(r2)
            pevents++;
 201b318:	e0bff417 	ldw	r2,-48(fp)
 201b31c:	10800104 	addi	r2,r2,4
 201b320:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 201b324:	e0bff417 	ldw	r2,-48(fp)
 201b328:	10800017 	ldw	r2,0(r2)
 201b32c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 201b330:	e0bff317 	ldw	r2,-52(fp)
 201b334:	103fc51e 	bne	r2,zero,201b24c <OSTaskChangePrio+0x38c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 201b338:	e0bff817 	ldw	r2,-32(fp)
 201b33c:	e0ffff03 	ldbu	r3,-4(fp)
 201b340:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 201b344:	e0bff817 	ldw	r2,-32(fp)
 201b348:	e0fffb03 	ldbu	r3,-20(fp)
 201b34c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 201b350:	e0bff817 	ldw	r2,-32(fp)
 201b354:	e0fffb43 	ldbu	r3,-19(fp)
 201b358:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 201b35c:	e0bff817 	ldw	r2,-32(fp)
 201b360:	e0fffb83 	ldbu	r3,-18(fp)
 201b364:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 201b368:	e0bff817 	ldw	r2,-32(fp)
 201b36c:	e0fffbc3 	ldbu	r3,-17(fp)
 201b370:	10c00d45 	stb	r3,53(r2)
 201b374:	e0bff517 	ldw	r2,-44(fp)
 201b378:	e0bffa15 	stw	r2,-24(fp)
 201b37c:	e0bffa17 	ldw	r2,-24(fp)
 201b380:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 201b384:	d0a74f43 	ldbu	r2,-25283(gp)
 201b388:	10803fcc 	andi	r2,r2,255
 201b38c:	10800058 	cmpnei	r2,r2,1
 201b390:	1000011e 	bne	r2,zero,201b398 <OSTaskChangePrio+0x4d8>
        OS_Sched();                                         /* Find new highest priority task          */
 201b394:	20161c80 	call	20161c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201b398:	0005883a 	mov	r2,zero
}
 201b39c:	e037883a 	mov	sp,fp
 201b3a0:	dfc00117 	ldw	ra,4(sp)
 201b3a4:	df000017 	ldw	fp,0(sp)
 201b3a8:	dec00204 	addi	sp,sp,8
 201b3ac:	f800283a 	ret

0201b3b0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 201b3b0:	deffee04 	addi	sp,sp,-72
 201b3b4:	dfc01115 	stw	ra,68(sp)
 201b3b8:	df001015 	stw	fp,64(sp)
 201b3bc:	df001004 	addi	fp,sp,64
 201b3c0:	e13ffc15 	stw	r4,-16(fp)
 201b3c4:	e17ffd15 	stw	r5,-12(fp)
 201b3c8:	e1bffe15 	stw	r6,-8(fp)
 201b3cc:	3805883a 	mov	r2,r7
 201b3d0:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 201b3d4:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 201b3d8:	e0bfff03 	ldbu	r2,-4(fp)
 201b3dc:	10800570 	cmpltui	r2,r2,21
 201b3e0:	1000021e 	bne	r2,zero,201b3ec <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 201b3e4:	00800a84 	movi	r2,42
 201b3e8:	00005706 	br	201b548 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b3ec:	0005303a 	rdctl	r2,status
 201b3f0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b3f4:	e0fffb17 	ldw	r3,-20(fp)
 201b3f8:	00bfff84 	movi	r2,-2
 201b3fc:	1884703a 	and	r2,r3,r2
 201b400:	1001703a 	wrctl	status,r2
  
  return context;
 201b404:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201b408:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 201b40c:	d0a75d03 	ldbu	r2,-25228(gp)
 201b410:	10803fcc 	andi	r2,r2,255
 201b414:	10000626 	beq	r2,zero,201b430 <OSTaskCreate+0x80>
 201b418:	e0bff317 	ldw	r2,-52(fp)
 201b41c:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b420:	e0bff417 	ldw	r2,-48(fp)
 201b424:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 201b428:	00800f04 	movi	r2,60
 201b42c:	00004606 	br	201b548 <OSTaskCreate+0x198>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 201b430:	e0ffff03 	ldbu	r3,-4(fp)
 201b434:	008080f4 	movhi	r2,515
 201b438:	10b97d04 	addi	r2,r2,-6668
 201b43c:	18c7883a 	add	r3,r3,r3
 201b440:	18c7883a 	add	r3,r3,r3
 201b444:	10c5883a 	add	r2,r2,r3
 201b448:	10800017 	ldw	r2,0(r2)
 201b44c:	1000391e 	bne	r2,zero,201b534 <OSTaskCreate+0x184>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 201b450:	e0ffff03 	ldbu	r3,-4(fp)
 201b454:	008080f4 	movhi	r2,515
 201b458:	10b97d04 	addi	r2,r2,-6668
 201b45c:	18c7883a 	add	r3,r3,r3
 201b460:	18c7883a 	add	r3,r3,r3
 201b464:	10c5883a 	add	r2,r2,r3
 201b468:	00c00044 	movi	r3,1
 201b46c:	10c00015 	stw	r3,0(r2)
 201b470:	e0bff317 	ldw	r2,-52(fp)
 201b474:	e0bff515 	stw	r2,-44(fp)
 201b478:	e0bff517 	ldw	r2,-44(fp)
 201b47c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 201b480:	000f883a 	mov	r7,zero
 201b484:	e1bffe17 	ldw	r6,-8(fp)
 201b488:	e17ffd17 	ldw	r5,-12(fp)
 201b48c:	e13ffc17 	ldw	r4,-16(fp)
 201b490:	201e9340 	call	201e934 <OSTaskStkInit>
 201b494:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 201b498:	e0bfff03 	ldbu	r2,-4(fp)
 201b49c:	d8000215 	stw	zero,8(sp)
 201b4a0:	d8000115 	stw	zero,4(sp)
 201b4a4:	d8000015 	stw	zero,0(sp)
 201b4a8:	000f883a 	mov	r7,zero
 201b4ac:	000d883a 	mov	r6,zero
 201b4b0:	e17ff717 	ldw	r5,-36(fp)
 201b4b4:	1009883a 	mov	r4,r2
 201b4b8:	20165c80 	call	20165c8 <OS_TCBInit>
 201b4bc:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
 201b4c0:	e0bff803 	ldbu	r2,-32(fp)
 201b4c4:	1000061e 	bne	r2,zero,201b4e0 <OSTaskCreate+0x130>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 201b4c8:	d0a74f43 	ldbu	r2,-25283(gp)
 201b4cc:	10803fcc 	andi	r2,r2,255
 201b4d0:	10800058 	cmpnei	r2,r2,1
 201b4d4:	1000151e 	bne	r2,zero,201b52c <OSTaskCreate+0x17c>
                OS_Sched();
 201b4d8:	20161c80 	call	20161c8 <OS_Sched>
 201b4dc:	00001306 	br	201b52c <OSTaskCreate+0x17c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b4e0:	0005303a 	rdctl	r2,status
 201b4e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b4e8:	e0fffa17 	ldw	r3,-24(fp)
 201b4ec:	00bfff84 	movi	r2,-2
 201b4f0:	1884703a 	and	r2,r3,r2
 201b4f4:	1001703a 	wrctl	status,r2
  
  return context;
 201b4f8:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 201b4fc:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 201b500:	e0ffff03 	ldbu	r3,-4(fp)
 201b504:	008080f4 	movhi	r2,515
 201b508:	10b97d04 	addi	r2,r2,-6668
 201b50c:	18c7883a 	add	r3,r3,r3
 201b510:	18c7883a 	add	r3,r3,r3
 201b514:	10c5883a 	add	r2,r2,r3
 201b518:	10000015 	stw	zero,0(r2)
 201b51c:	e0bff317 	ldw	r2,-52(fp)
 201b520:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b524:	e0bff617 	ldw	r2,-40(fp)
 201b528:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 201b52c:	e0bff803 	ldbu	r2,-32(fp)
 201b530:	00000506 	br	201b548 <OSTaskCreate+0x198>
 201b534:	e0bff317 	ldw	r2,-52(fp)
 201b538:	e0bff915 	stw	r2,-28(fp)
 201b53c:	e0bff917 	ldw	r2,-28(fp)
 201b540:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 201b544:	00800a04 	movi	r2,40
}
 201b548:	e037883a 	mov	sp,fp
 201b54c:	dfc00117 	ldw	ra,4(sp)
 201b550:	df000017 	ldw	fp,0(sp)
 201b554:	dec00204 	addi	sp,sp,8
 201b558:	f800283a 	ret

0201b55c <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 201b55c:	deffec04 	addi	sp,sp,-80
 201b560:	dfc01315 	stw	ra,76(sp)
 201b564:	df001215 	stw	fp,72(sp)
 201b568:	df001204 	addi	fp,sp,72
 201b56c:	e13ffa15 	stw	r4,-24(fp)
 201b570:	e17ffb15 	stw	r5,-20(fp)
 201b574:	e1bffc15 	stw	r6,-16(fp)
 201b578:	3809883a 	mov	r4,r7
 201b57c:	e0c00217 	ldw	r3,8(fp)
 201b580:	e0800617 	ldw	r2,24(fp)
 201b584:	e13ffd05 	stb	r4,-12(fp)
 201b588:	e0fffe0d 	sth	r3,-8(fp)
 201b58c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 201b590:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 201b594:	e0bffd03 	ldbu	r2,-12(fp)
 201b598:	10800570 	cmpltui	r2,r2,21
 201b59c:	1000021e 	bne	r2,zero,201b5a8 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 201b5a0:	00800a84 	movi	r2,42
 201b5a4:	00006106 	br	201b72c <OSTaskCreateExt+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b5a8:	0005303a 	rdctl	r2,status
 201b5ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b5b0:	e0fff917 	ldw	r3,-28(fp)
 201b5b4:	00bfff84 	movi	r2,-2
 201b5b8:	1884703a 	and	r2,r3,r2
 201b5bc:	1001703a 	wrctl	status,r2
  
  return context;
 201b5c0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201b5c4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 201b5c8:	d0a75d03 	ldbu	r2,-25228(gp)
 201b5cc:	10803fcc 	andi	r2,r2,255
 201b5d0:	10000626 	beq	r2,zero,201b5ec <OSTaskCreateExt+0x90>
 201b5d4:	e0bff117 	ldw	r2,-60(fp)
 201b5d8:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b5dc:	e0bff217 	ldw	r2,-56(fp)
 201b5e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 201b5e4:	00800f04 	movi	r2,60
 201b5e8:	00005006 	br	201b72c <OSTaskCreateExt+0x1d0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 201b5ec:	e0fffd03 	ldbu	r3,-12(fp)
 201b5f0:	008080f4 	movhi	r2,515
 201b5f4:	10b97d04 	addi	r2,r2,-6668
 201b5f8:	18c7883a 	add	r3,r3,r3
 201b5fc:	18c7883a 	add	r3,r3,r3
 201b600:	10c5883a 	add	r2,r2,r3
 201b604:	10800017 	ldw	r2,0(r2)
 201b608:	1000431e 	bne	r2,zero,201b718 <OSTaskCreateExt+0x1bc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 201b60c:	e0fffd03 	ldbu	r3,-12(fp)
 201b610:	008080f4 	movhi	r2,515
 201b614:	10b97d04 	addi	r2,r2,-6668
 201b618:	18c7883a 	add	r3,r3,r3
 201b61c:	18c7883a 	add	r3,r3,r3
 201b620:	10c5883a 	add	r2,r2,r3
 201b624:	00c00044 	movi	r3,1
 201b628:	10c00015 	stw	r3,0(r2)
 201b62c:	e0bff117 	ldw	r2,-60(fp)
 201b630:	e0bff315 	stw	r2,-52(fp)
 201b634:	e0bff317 	ldw	r2,-52(fp)
 201b638:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 201b63c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b640:	100d883a 	mov	r6,r2
 201b644:	e1400417 	ldw	r5,16(fp)
 201b648:	e1000317 	ldw	r4,12(fp)
 201b64c:	201c5bc0 	call	201c5bc <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 201b650:	e0bfff0b 	ldhu	r2,-4(fp)
 201b654:	100f883a 	mov	r7,r2
 201b658:	e1bffc17 	ldw	r6,-16(fp)
 201b65c:	e17ffb17 	ldw	r5,-20(fp)
 201b660:	e13ffa17 	ldw	r4,-24(fp)
 201b664:	201e9340 	call	201e934 <OSTaskStkInit>
 201b668:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 201b66c:	e0fffd03 	ldbu	r3,-12(fp)
 201b670:	e13ffe0b 	ldhu	r4,-8(fp)
 201b674:	e0bfff0b 	ldhu	r2,-4(fp)
 201b678:	d8800215 	stw	r2,8(sp)
 201b67c:	e0800517 	ldw	r2,20(fp)
 201b680:	d8800115 	stw	r2,4(sp)
 201b684:	e0800417 	ldw	r2,16(fp)
 201b688:	d8800015 	stw	r2,0(sp)
 201b68c:	200f883a 	mov	r7,r4
 201b690:	e1800317 	ldw	r6,12(fp)
 201b694:	e17ff517 	ldw	r5,-44(fp)
 201b698:	1809883a 	mov	r4,r3
 201b69c:	20165c80 	call	20165c8 <OS_TCBInit>
 201b6a0:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
 201b6a4:	e0bff603 	ldbu	r2,-40(fp)
 201b6a8:	1000061e 	bne	r2,zero,201b6c4 <OSTaskCreateExt+0x168>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 201b6ac:	d0a74f43 	ldbu	r2,-25283(gp)
 201b6b0:	10803fcc 	andi	r2,r2,255
 201b6b4:	10800058 	cmpnei	r2,r2,1
 201b6b8:	1000151e 	bne	r2,zero,201b710 <OSTaskCreateExt+0x1b4>
                OS_Sched();
 201b6bc:	20161c80 	call	20161c8 <OS_Sched>
 201b6c0:	00001306 	br	201b710 <OSTaskCreateExt+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b6c4:	0005303a 	rdctl	r2,status
 201b6c8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b6cc:	e0fff817 	ldw	r3,-32(fp)
 201b6d0:	00bfff84 	movi	r2,-2
 201b6d4:	1884703a 	and	r2,r3,r2
 201b6d8:	1001703a 	wrctl	status,r2
  
  return context;
 201b6dc:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 201b6e0:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 201b6e4:	e0fffd03 	ldbu	r3,-12(fp)
 201b6e8:	008080f4 	movhi	r2,515
 201b6ec:	10b97d04 	addi	r2,r2,-6668
 201b6f0:	18c7883a 	add	r3,r3,r3
 201b6f4:	18c7883a 	add	r3,r3,r3
 201b6f8:	10c5883a 	add	r2,r2,r3
 201b6fc:	10000015 	stw	zero,0(r2)
 201b700:	e0bff117 	ldw	r2,-60(fp)
 201b704:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b708:	e0bff417 	ldw	r2,-48(fp)
 201b70c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 201b710:	e0bff603 	ldbu	r2,-40(fp)
 201b714:	00000506 	br	201b72c <OSTaskCreateExt+0x1d0>
 201b718:	e0bff117 	ldw	r2,-60(fp)
 201b71c:	e0bff715 	stw	r2,-36(fp)
 201b720:	e0bff717 	ldw	r2,-36(fp)
 201b724:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 201b728:	00800a04 	movi	r2,40
}
 201b72c:	e037883a 	mov	sp,fp
 201b730:	dfc00117 	ldw	ra,4(sp)
 201b734:	df000017 	ldw	fp,0(sp)
 201b738:	dec00204 	addi	sp,sp,8
 201b73c:	f800283a 	ret

0201b740 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 201b740:	defff404 	addi	sp,sp,-48
 201b744:	dfc00b15 	stw	ra,44(sp)
 201b748:	df000a15 	stw	fp,40(sp)
 201b74c:	df000a04 	addi	fp,sp,40
 201b750:	2005883a 	mov	r2,r4
 201b754:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 201b758:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 201b75c:	d0a75d03 	ldbu	r2,-25228(gp)
 201b760:	10803fcc 	andi	r2,r2,255
 201b764:	10000226 	beq	r2,zero,201b770 <OSTaskDel+0x30>
        return (OS_ERR_TASK_DEL_ISR);
 201b768:	00801004 	movi	r2,64
 201b76c:	0000c006 	br	201ba70 <OSTaskDel+0x330>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 201b770:	e0bfff03 	ldbu	r2,-4(fp)
 201b774:	10800518 	cmpnei	r2,r2,20
 201b778:	1000021e 	bne	r2,zero,201b784 <OSTaskDel+0x44>
        return (OS_ERR_TASK_DEL_IDLE);
 201b77c:	00800f84 	movi	r2,62
 201b780:	0000bb06 	br	201ba70 <OSTaskDel+0x330>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 201b784:	e0bfff03 	ldbu	r2,-4(fp)
 201b788:	10800530 	cmpltui	r2,r2,20
 201b78c:	1000051e 	bne	r2,zero,201b7a4 <OSTaskDel+0x64>
        if (prio != OS_PRIO_SELF) {
 201b790:	e0bfff03 	ldbu	r2,-4(fp)
 201b794:	10803fe0 	cmpeqi	r2,r2,255
 201b798:	1000021e 	bne	r2,zero,201b7a4 <OSTaskDel+0x64>
            return (OS_ERR_PRIO_INVALID);
 201b79c:	00800a84 	movi	r2,42
 201b7a0:	0000b306 	br	201ba70 <OSTaskDel+0x330>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b7a4:	0005303a 	rdctl	r2,status
 201b7a8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b7ac:	e0fffe17 	ldw	r3,-8(fp)
 201b7b0:	00bfff84 	movi	r2,-2
 201b7b4:	1884703a 	and	r2,r3,r2
 201b7b8:	1001703a 	wrctl	status,r2
  
  return context;
 201b7bc:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 201b7c0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 201b7c4:	e0bfff03 	ldbu	r2,-4(fp)
 201b7c8:	10803fd8 	cmpnei	r2,r2,255
 201b7cc:	1000031e 	bne	r2,zero,201b7dc <OSTaskDel+0x9c>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 201b7d0:	d0a75e17 	ldw	r2,-25224(gp)
 201b7d4:	10800c83 	ldbu	r2,50(r2)
 201b7d8:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201b7dc:	e0ffff03 	ldbu	r3,-4(fp)
 201b7e0:	008080f4 	movhi	r2,515
 201b7e4:	10b97d04 	addi	r2,r2,-6668
 201b7e8:	18c7883a 	add	r3,r3,r3
 201b7ec:	18c7883a 	add	r3,r3,r3
 201b7f0:	10c5883a 	add	r2,r2,r3
 201b7f4:	10800017 	ldw	r2,0(r2)
 201b7f8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 201b7fc:	e0bff817 	ldw	r2,-32(fp)
 201b800:	1000061e 	bne	r2,zero,201b81c <OSTaskDel+0xdc>
 201b804:	e0bff617 	ldw	r2,-40(fp)
 201b808:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b80c:	e0bff717 	ldw	r2,-36(fp)
 201b810:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201b814:	008010c4 	movi	r2,67
 201b818:	00009506 	br	201ba70 <OSTaskDel+0x330>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 201b81c:	e0bff817 	ldw	r2,-32(fp)
 201b820:	10800058 	cmpnei	r2,r2,1
 201b824:	1000061e 	bne	r2,zero,201b840 <OSTaskDel+0x100>
 201b828:	e0bff617 	ldw	r2,-40(fp)
 201b82c:	e0bff915 	stw	r2,-28(fp)
 201b830:	e0bff917 	ldw	r2,-28(fp)
 201b834:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 201b838:	00800f44 	movi	r2,61
 201b83c:	00008c06 	br	201ba70 <OSTaskDel+0x330>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 201b840:	e0bff817 	ldw	r2,-32(fp)
 201b844:	10800d03 	ldbu	r2,52(r2)
 201b848:	10c03fcc 	andi	r3,r2,255
 201b84c:	e0bff817 	ldw	r2,-32(fp)
 201b850:	10800d03 	ldbu	r2,52(r2)
 201b854:	11003fcc 	andi	r4,r2,255
 201b858:	d0a75b44 	addi	r2,gp,-25235
 201b85c:	2085883a 	add	r2,r4,r2
 201b860:	10800003 	ldbu	r2,0(r2)
 201b864:	1009883a 	mov	r4,r2
 201b868:	e0bff817 	ldw	r2,-32(fp)
 201b86c:	10800d43 	ldbu	r2,53(r2)
 201b870:	0084303a 	nor	r2,zero,r2
 201b874:	2084703a 	and	r2,r4,r2
 201b878:	1009883a 	mov	r4,r2
 201b87c:	d0a75b44 	addi	r2,gp,-25235
 201b880:	1885883a 	add	r2,r3,r2
 201b884:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 201b888:	e0bff817 	ldw	r2,-32(fp)
 201b88c:	10800d03 	ldbu	r2,52(r2)
 201b890:	10c03fcc 	andi	r3,r2,255
 201b894:	d0a75b44 	addi	r2,gp,-25235
 201b898:	1885883a 	add	r2,r3,r2
 201b89c:	10800003 	ldbu	r2,0(r2)
 201b8a0:	10803fcc 	andi	r2,r2,255
 201b8a4:	1000071e 	bne	r2,zero,201b8c4 <OSTaskDel+0x184>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 201b8a8:	e0bff817 	ldw	r2,-32(fp)
 201b8ac:	10800d83 	ldbu	r2,54(r2)
 201b8b0:	0084303a 	nor	r2,zero,r2
 201b8b4:	1007883a 	mov	r3,r2
 201b8b8:	d0a75b03 	ldbu	r2,-25236(gp)
 201b8bc:	1884703a 	and	r2,r3,r2
 201b8c0:	d0a75b05 	stb	r2,-25236(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 201b8c4:	e0bff817 	ldw	r2,-32(fp)
 201b8c8:	10800717 	ldw	r2,28(r2)
 201b8cc:	10000526 	beq	r2,zero,201b8e4 <OSTaskDel+0x1a4>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 201b8d0:	e0bff817 	ldw	r2,-32(fp)
 201b8d4:	10800717 	ldw	r2,28(r2)
 201b8d8:	100b883a 	mov	r5,r2
 201b8dc:	e13ff817 	ldw	r4,-32(fp)
 201b8e0:	2015b740 	call	2015b74 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 201b8e4:	e0bff817 	ldw	r2,-32(fp)
 201b8e8:	10800817 	ldw	r2,32(r2)
 201b8ec:	10000526 	beq	r2,zero,201b904 <OSTaskDel+0x1c4>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 201b8f0:	e0bff817 	ldw	r2,-32(fp)
 201b8f4:	10800817 	ldw	r2,32(r2)
 201b8f8:	100b883a 	mov	r5,r2
 201b8fc:	e13ff817 	ldw	r4,-32(fp)
 201b900:	2015c2c0 	call	2015c2c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 201b904:	e0bff817 	ldw	r2,-32(fp)
 201b908:	10800a17 	ldw	r2,40(r2)
 201b90c:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 201b910:	e0bffb17 	ldw	r2,-20(fp)
 201b914:	10000226 	beq	r2,zero,201b920 <OSTaskDel+0x1e0>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 201b918:	e13ffb17 	ldw	r4,-20(fp)
 201b91c:	201809c0 	call	201809c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 201b920:	e0bff817 	ldw	r2,-32(fp)
 201b924:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 201b928:	e0bff817 	ldw	r2,-32(fp)
 201b92c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 201b930:	e0bff817 	ldw	r2,-32(fp)
 201b934:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 201b938:	d0a74f03 	ldbu	r2,-25284(gp)
 201b93c:	10803fcc 	andi	r2,r2,255
 201b940:	10803fe0 	cmpeqi	r2,r2,255
 201b944:	1000031e 	bne	r2,zero,201b954 <OSTaskDel+0x214>
        OSLockNesting++;
 201b948:	d0a74f03 	ldbu	r2,-25284(gp)
 201b94c:	10800044 	addi	r2,r2,1
 201b950:	d0a74f05 	stb	r2,-25284(gp)
 201b954:	e0bff617 	ldw	r2,-40(fp)
 201b958:	e0bffd15 	stw	r2,-12(fp)
 201b95c:	e0bffd17 	ldw	r2,-12(fp)
 201b960:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 201b964:	201575c0 	call	201575c <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b968:	0005303a 	rdctl	r2,status
 201b96c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b970:	e0fffa17 	ldw	r3,-24(fp)
 201b974:	00bfff84 	movi	r2,-2
 201b978:	1884703a 	and	r2,r3,r2
 201b97c:	1001703a 	wrctl	status,r2
  
  return context;
 201b980:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 201b984:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 201b988:	d0a74f03 	ldbu	r2,-25284(gp)
 201b98c:	10803fcc 	andi	r2,r2,255
 201b990:	10000326 	beq	r2,zero,201b9a0 <OSTaskDel+0x260>
        OSLockNesting--;
 201b994:	d0a74f03 	ldbu	r2,-25284(gp)
 201b998:	10bfffc4 	addi	r2,r2,-1
 201b99c:	d0a74f05 	stb	r2,-25284(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 201b9a0:	e13ff817 	ldw	r4,-32(fp)
 201b9a4:	201eab40 	call	201eab4 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 201b9a8:	d0a75743 	ldbu	r2,-25251(gp)
 201b9ac:	10bfffc4 	addi	r2,r2,-1
 201b9b0:	d0a75745 	stb	r2,-25251(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 201b9b4:	e0ffff03 	ldbu	r3,-4(fp)
 201b9b8:	008080f4 	movhi	r2,515
 201b9bc:	10b97d04 	addi	r2,r2,-6668
 201b9c0:	18c7883a 	add	r3,r3,r3
 201b9c4:	18c7883a 	add	r3,r3,r3
 201b9c8:	10c5883a 	add	r2,r2,r3
 201b9cc:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 201b9d0:	e0bff817 	ldw	r2,-32(fp)
 201b9d4:	10800617 	ldw	r2,24(r2)
 201b9d8:	1000071e 	bne	r2,zero,201b9f8 <OSTaskDel+0x2b8>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 201b9dc:	e0bff817 	ldw	r2,-32(fp)
 201b9e0:	10800517 	ldw	r2,20(r2)
 201b9e4:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 201b9e8:	e0bff817 	ldw	r2,-32(fp)
 201b9ec:	10800517 	ldw	r2,20(r2)
 201b9f0:	d0a75215 	stw	r2,-25272(gp)
 201b9f4:	00000a06 	br	201ba20 <OSTaskDel+0x2e0>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 201b9f8:	e0bff817 	ldw	r2,-32(fp)
 201b9fc:	10800617 	ldw	r2,24(r2)
 201ba00:	e0fff817 	ldw	r3,-32(fp)
 201ba04:	18c00517 	ldw	r3,20(r3)
 201ba08:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 201ba0c:	e0bff817 	ldw	r2,-32(fp)
 201ba10:	10800517 	ldw	r2,20(r2)
 201ba14:	e0fff817 	ldw	r3,-32(fp)
 201ba18:	18c00617 	ldw	r3,24(r3)
 201ba1c:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 201ba20:	d0e75617 	ldw	r3,-25256(gp)
 201ba24:	e0bff817 	ldw	r2,-32(fp)
 201ba28:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 201ba2c:	e0bff817 	ldw	r2,-32(fp)
 201ba30:	d0a75615 	stw	r2,-25256(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 201ba34:	e0bff817 	ldw	r2,-32(fp)
 201ba38:	00c00fc4 	movi	r3,63
 201ba3c:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 201ba40:	e0bff817 	ldw	r2,-32(fp)
 201ba44:	10001345 	stb	zero,77(r2)
 201ba48:	e0bff617 	ldw	r2,-40(fp)
 201ba4c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ba50:	e0bffc17 	ldw	r2,-16(fp)
 201ba54:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 201ba58:	d0a74f43 	ldbu	r2,-25283(gp)
 201ba5c:	10803fcc 	andi	r2,r2,255
 201ba60:	10800058 	cmpnei	r2,r2,1
 201ba64:	1000011e 	bne	r2,zero,201ba6c <OSTaskDel+0x32c>
        OS_Sched();                                     /* Find new highest priority task              */
 201ba68:	20161c80 	call	20161c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201ba6c:	0005883a 	mov	r2,zero
}
 201ba70:	e037883a 	mov	sp,fp
 201ba74:	dfc00117 	ldw	ra,4(sp)
 201ba78:	df000017 	ldw	fp,0(sp)
 201ba7c:	dec00204 	addi	sp,sp,8
 201ba80:	f800283a 	ret

0201ba84 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 201ba84:	defff504 	addi	sp,sp,-44
 201ba88:	df000a15 	stw	fp,40(sp)
 201ba8c:	df000a04 	addi	fp,sp,40
 201ba90:	2005883a 	mov	r2,r4
 201ba94:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201ba98:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 201ba9c:	e0bfff03 	ldbu	r2,-4(fp)
 201baa0:	10800518 	cmpnei	r2,r2,20
 201baa4:	1000021e 	bne	r2,zero,201bab0 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 201baa8:	00800f84 	movi	r2,62
 201baac:	00004506 	br	201bbc4 <OSTaskDelReq+0x140>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 201bab0:	e0bfff03 	ldbu	r2,-4(fp)
 201bab4:	10800530 	cmpltui	r2,r2,20
 201bab8:	1000051e 	bne	r2,zero,201bad0 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 201babc:	e0bfff03 	ldbu	r2,-4(fp)
 201bac0:	10803fe0 	cmpeqi	r2,r2,255
 201bac4:	1000021e 	bne	r2,zero,201bad0 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 201bac8:	00800a84 	movi	r2,42
 201bacc:	00003d06 	br	201bbc4 <OSTaskDelReq+0x140>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 201bad0:	e0bfff03 	ldbu	r2,-4(fp)
 201bad4:	10803fd8 	cmpnei	r2,r2,255
 201bad8:	1000111e 	bne	r2,zero,201bb20 <OSTaskDelReq+0x9c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201badc:	0005303a 	rdctl	r2,status
 201bae0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bae4:	e0fff917 	ldw	r3,-28(fp)
 201bae8:	00bfff84 	movi	r2,-2
 201baec:	1884703a 	and	r2,r3,r2
 201baf0:	1001703a 	wrctl	status,r2
  
  return context;
 201baf4:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 201baf8:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 201bafc:	d0a75e17 	ldw	r2,-25224(gp)
 201bb00:	10800dc3 	ldbu	r2,55(r2)
 201bb04:	e0bff805 	stb	r2,-32(fp)
 201bb08:	e0bff617 	ldw	r2,-40(fp)
 201bb0c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bb10:	e0bffe17 	ldw	r2,-8(fp)
 201bb14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 201bb18:	e0bff803 	ldbu	r2,-32(fp)
 201bb1c:	00002906 	br	201bbc4 <OSTaskDelReq+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bb20:	0005303a 	rdctl	r2,status
 201bb24:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bb28:	e0fff717 	ldw	r3,-36(fp)
 201bb2c:	00bfff84 	movi	r2,-2
 201bb30:	1884703a 	and	r2,r3,r2
 201bb34:	1001703a 	wrctl	status,r2
  
  return context;
 201bb38:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 201bb3c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 201bb40:	e0ffff03 	ldbu	r3,-4(fp)
 201bb44:	008080f4 	movhi	r2,515
 201bb48:	10b97d04 	addi	r2,r2,-6668
 201bb4c:	18c7883a 	add	r3,r3,r3
 201bb50:	18c7883a 	add	r3,r3,r3
 201bb54:	10c5883a 	add	r2,r2,r3
 201bb58:	10800017 	ldw	r2,0(r2)
 201bb5c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 201bb60:	e0bffb17 	ldw	r2,-20(fp)
 201bb64:	1000061e 	bne	r2,zero,201bb80 <OSTaskDelReq+0xfc>
 201bb68:	e0bff617 	ldw	r2,-40(fp)
 201bb6c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bb70:	e0bffa17 	ldw	r2,-24(fp)
 201bb74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 201bb78:	008010c4 	movi	r2,67
 201bb7c:	00001106 	br	201bbc4 <OSTaskDelReq+0x140>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 201bb80:	e0bffb17 	ldw	r2,-20(fp)
 201bb84:	10800058 	cmpnei	r2,r2,1
 201bb88:	1000061e 	bne	r2,zero,201bba4 <OSTaskDelReq+0x120>
 201bb8c:	e0bff617 	ldw	r2,-40(fp)
 201bb90:	e0bffc15 	stw	r2,-16(fp)
 201bb94:	e0bffc17 	ldw	r2,-16(fp)
 201bb98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 201bb9c:	00800f44 	movi	r2,61
 201bba0:	00000806 	br	201bbc4 <OSTaskDelReq+0x140>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 201bba4:	e0bffb17 	ldw	r2,-20(fp)
 201bba8:	00c00fc4 	movi	r3,63
 201bbac:	10c00dc5 	stb	r3,55(r2)
 201bbb0:	e0bff617 	ldw	r2,-40(fp)
 201bbb4:	e0bffd15 	stw	r2,-12(fp)
 201bbb8:	e0bffd17 	ldw	r2,-12(fp)
 201bbbc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201bbc0:	0005883a 	mov	r2,zero
}
 201bbc4:	e037883a 	mov	sp,fp
 201bbc8:	df000017 	ldw	fp,0(sp)
 201bbcc:	dec00104 	addi	sp,sp,4
 201bbd0:	f800283a 	ret

0201bbd4 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 201bbd4:	defff404 	addi	sp,sp,-48
 201bbd8:	dfc00b15 	stw	ra,44(sp)
 201bbdc:	df000a15 	stw	fp,40(sp)
 201bbe0:	df000a04 	addi	fp,sp,40
 201bbe4:	2005883a 	mov	r2,r4
 201bbe8:	e17ffe15 	stw	r5,-8(fp)
 201bbec:	e1bfff15 	stw	r6,-4(fp)
 201bbf0:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 201bbf4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 201bbf8:	e0bfff17 	ldw	r2,-4(fp)
 201bbfc:	1000021e 	bne	r2,zero,201bc08 <OSTaskNameGet+0x34>
        return (0);
 201bc00:	0005883a 	mov	r2,zero
 201bc04:	00005406 	br	201bd58 <OSTaskNameGet+0x184>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 201bc08:	e0bffd03 	ldbu	r2,-12(fp)
 201bc0c:	10800570 	cmpltui	r2,r2,21
 201bc10:	1000081e 	bne	r2,zero,201bc34 <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 201bc14:	e0bffd03 	ldbu	r2,-12(fp)
 201bc18:	10803fe0 	cmpeqi	r2,r2,255
 201bc1c:	1000051e 	bne	r2,zero,201bc34 <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 201bc20:	e0bfff17 	ldw	r2,-4(fp)
 201bc24:	00c00a84 	movi	r3,42
 201bc28:	10c00005 	stb	r3,0(r2)
            return (0);
 201bc2c:	0005883a 	mov	r2,zero
 201bc30:	00004906 	br	201bd58 <OSTaskNameGet+0x184>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 201bc34:	e0bffe17 	ldw	r2,-8(fp)
 201bc38:	1000051e 	bne	r2,zero,201bc50 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 201bc3c:	e0bfff17 	ldw	r2,-4(fp)
 201bc40:	00c00304 	movi	r3,12
 201bc44:	10c00005 	stb	r3,0(r2)
        return (0);
 201bc48:	0005883a 	mov	r2,zero
 201bc4c:	00004206 	br	201bd58 <OSTaskNameGet+0x184>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 201bc50:	d0a75d03 	ldbu	r2,-25228(gp)
 201bc54:	10803fcc 	andi	r2,r2,255
 201bc58:	10000526 	beq	r2,zero,201bc70 <OSTaskNameGet+0x9c>
        *perr = OS_ERR_NAME_GET_ISR;
 201bc5c:	e0bfff17 	ldw	r2,-4(fp)
 201bc60:	00c00444 	movi	r3,17
 201bc64:	10c00005 	stb	r3,0(r2)
        return (0);
 201bc68:	0005883a 	mov	r2,zero
 201bc6c:	00003a06 	br	201bd58 <OSTaskNameGet+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bc70:	0005303a 	rdctl	r2,status
 201bc74:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bc78:	e0fffc17 	ldw	r3,-16(fp)
 201bc7c:	00bfff84 	movi	r2,-2
 201bc80:	1884703a 	and	r2,r3,r2
 201bc84:	1001703a 	wrctl	status,r2
  
  return context;
 201bc88:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201bc8c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 201bc90:	e0bffd03 	ldbu	r2,-12(fp)
 201bc94:	10803fd8 	cmpnei	r2,r2,255
 201bc98:	1000031e 	bne	r2,zero,201bca8 <OSTaskNameGet+0xd4>
        prio = OSTCBCur->OSTCBPrio;
 201bc9c:	d0a75e17 	ldw	r2,-25224(gp)
 201bca0:	10800c83 	ldbu	r2,50(r2)
 201bca4:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201bca8:	e0fffd03 	ldbu	r3,-12(fp)
 201bcac:	008080f4 	movhi	r2,515
 201bcb0:	10b97d04 	addi	r2,r2,-6668
 201bcb4:	18c7883a 	add	r3,r3,r3
 201bcb8:	18c7883a 	add	r3,r3,r3
 201bcbc:	10c5883a 	add	r2,r2,r3
 201bcc0:	10800017 	ldw	r2,0(r2)
 201bcc4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 201bcc8:	e0bff817 	ldw	r2,-32(fp)
 201bccc:	1000091e 	bne	r2,zero,201bcf4 <OSTaskNameGet+0x120>
 201bcd0:	e0bff617 	ldw	r2,-40(fp)
 201bcd4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bcd8:	e0bff717 	ldw	r2,-36(fp)
 201bcdc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201bce0:	e0bfff17 	ldw	r2,-4(fp)
 201bce4:	00c010c4 	movi	r3,67
 201bce8:	10c00005 	stb	r3,0(r2)
        return (0);
 201bcec:	0005883a 	mov	r2,zero
 201bcf0:	00001906 	br	201bd58 <OSTaskNameGet+0x184>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 201bcf4:	e0bff817 	ldw	r2,-32(fp)
 201bcf8:	10800058 	cmpnei	r2,r2,1
 201bcfc:	1000091e 	bne	r2,zero,201bd24 <OSTaskNameGet+0x150>
 201bd00:	e0bff617 	ldw	r2,-40(fp)
 201bd04:	e0bff915 	stw	r2,-28(fp)
 201bd08:	e0bff917 	ldw	r2,-28(fp)
 201bd0c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201bd10:	e0bfff17 	ldw	r2,-4(fp)
 201bd14:	00c010c4 	movi	r3,67
 201bd18:	10c00005 	stb	r3,0(r2)
        return (0);
 201bd1c:	0005883a 	mov	r2,zero
 201bd20:	00000d06 	br	201bd58 <OSTaskNameGet+0x184>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 201bd24:	e0bff817 	ldw	r2,-32(fp)
 201bd28:	10801304 	addi	r2,r2,76
 201bd2c:	100b883a 	mov	r5,r2
 201bd30:	e13ffe17 	ldw	r4,-8(fp)
 201bd34:	201630c0 	call	201630c <OS_StrCopy>
 201bd38:	e0bffb05 	stb	r2,-20(fp)
 201bd3c:	e0bff617 	ldw	r2,-40(fp)
 201bd40:	e0bffa15 	stw	r2,-24(fp)
 201bd44:	e0bffa17 	ldw	r2,-24(fp)
 201bd48:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201bd4c:	e0bfff17 	ldw	r2,-4(fp)
 201bd50:	10000005 	stb	zero,0(r2)
    return (len);
 201bd54:	e0bffb03 	ldbu	r2,-20(fp)
}
 201bd58:	e037883a 	mov	sp,fp
 201bd5c:	dfc00117 	ldw	ra,4(sp)
 201bd60:	df000017 	ldw	fp,0(sp)
 201bd64:	dec00204 	addi	sp,sp,8
 201bd68:	f800283a 	ret

0201bd6c <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 201bd6c:	defff304 	addi	sp,sp,-52
 201bd70:	dfc00c15 	stw	ra,48(sp)
 201bd74:	df000b15 	stw	fp,44(sp)
 201bd78:	df000b04 	addi	fp,sp,44
 201bd7c:	2005883a 	mov	r2,r4
 201bd80:	e17ffe15 	stw	r5,-8(fp)
 201bd84:	e1bfff15 	stw	r6,-4(fp)
 201bd88:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 201bd8c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 201bd90:	e0bfff17 	ldw	r2,-4(fp)
 201bd94:	10005c26 	beq	r2,zero,201bf08 <OSTaskNameSet+0x19c>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 201bd98:	e0bffd03 	ldbu	r2,-12(fp)
 201bd9c:	10800570 	cmpltui	r2,r2,21
 201bda0:	1000071e 	bne	r2,zero,201bdc0 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 201bda4:	e0bffd03 	ldbu	r2,-12(fp)
 201bda8:	10803fe0 	cmpeqi	r2,r2,255
 201bdac:	1000041e 	bne	r2,zero,201bdc0 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 201bdb0:	e0bfff17 	ldw	r2,-4(fp)
 201bdb4:	00c00a84 	movi	r3,42
 201bdb8:	10c00005 	stb	r3,0(r2)
            return;
 201bdbc:	00005306 	br	201bf0c <OSTaskNameSet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 201bdc0:	e0bffe17 	ldw	r2,-8(fp)
 201bdc4:	1000041e 	bne	r2,zero,201bdd8 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 201bdc8:	e0bfff17 	ldw	r2,-4(fp)
 201bdcc:	00c00304 	movi	r3,12
 201bdd0:	10c00005 	stb	r3,0(r2)
        return;
 201bdd4:	00004d06 	br	201bf0c <OSTaskNameSet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 201bdd8:	d0a75d03 	ldbu	r2,-25228(gp)
 201bddc:	10803fcc 	andi	r2,r2,255
 201bde0:	10000426 	beq	r2,zero,201bdf4 <OSTaskNameSet+0x88>
        *perr = OS_ERR_NAME_SET_ISR;
 201bde4:	e0bfff17 	ldw	r2,-4(fp)
 201bde8:	00c00484 	movi	r3,18
 201bdec:	10c00005 	stb	r3,0(r2)
        return;
 201bdf0:	00004606 	br	201bf0c <OSTaskNameSet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bdf4:	0005303a 	rdctl	r2,status
 201bdf8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bdfc:	e0fffc17 	ldw	r3,-16(fp)
 201be00:	00bfff84 	movi	r2,-2
 201be04:	1884703a 	and	r2,r3,r2
 201be08:	1001703a 	wrctl	status,r2
  
  return context;
 201be0c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201be10:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 201be14:	e0bffd03 	ldbu	r2,-12(fp)
 201be18:	10803fd8 	cmpnei	r2,r2,255
 201be1c:	1000031e 	bne	r2,zero,201be2c <OSTaskNameSet+0xc0>
        prio = OSTCBCur->OSTCBPrio;
 201be20:	d0a75e17 	ldw	r2,-25224(gp)
 201be24:	10800c83 	ldbu	r2,50(r2)
 201be28:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201be2c:	e0fffd03 	ldbu	r3,-12(fp)
 201be30:	008080f4 	movhi	r2,515
 201be34:	10b97d04 	addi	r2,r2,-6668
 201be38:	18c7883a 	add	r3,r3,r3
 201be3c:	18c7883a 	add	r3,r3,r3
 201be40:	10c5883a 	add	r2,r2,r3
 201be44:	10800017 	ldw	r2,0(r2)
 201be48:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 201be4c:	e0bff717 	ldw	r2,-36(fp)
 201be50:	1000081e 	bne	r2,zero,201be74 <OSTaskNameSet+0x108>
 201be54:	e0bff517 	ldw	r2,-44(fp)
 201be58:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201be5c:	e0bff617 	ldw	r2,-40(fp)
 201be60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201be64:	e0bfff17 	ldw	r2,-4(fp)
 201be68:	00c010c4 	movi	r3,67
 201be6c:	10c00005 	stb	r3,0(r2)
        return;
 201be70:	00002606 	br	201bf0c <OSTaskNameSet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 201be74:	e0bff717 	ldw	r2,-36(fp)
 201be78:	10800058 	cmpnei	r2,r2,1
 201be7c:	1000081e 	bne	r2,zero,201bea0 <OSTaskNameSet+0x134>
 201be80:	e0bff517 	ldw	r2,-44(fp)
 201be84:	e0bff815 	stw	r2,-32(fp)
 201be88:	e0bff817 	ldw	r2,-32(fp)
 201be8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201be90:	e0bfff17 	ldw	r2,-4(fp)
 201be94:	00c010c4 	movi	r3,67
 201be98:	10c00005 	stb	r3,0(r2)
        return;
 201be9c:	00001b06 	br	201bf0c <OSTaskNameSet+0x1a0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 201bea0:	e13ffe17 	ldw	r4,-8(fp)
 201bea4:	20163800 	call	2016380 <OS_StrLen>
 201bea8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 201beac:	e0bffa03 	ldbu	r2,-24(fp)
 201beb0:	10800830 	cmpltui	r2,r2,32
 201beb4:	1000081e 	bne	r2,zero,201bed8 <OSTaskNameSet+0x16c>
 201beb8:	e0bff517 	ldw	r2,-44(fp)
 201bebc:	e0bff915 	stw	r2,-28(fp)
 201bec0:	e0bff917 	ldw	r2,-28(fp)
 201bec4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 201bec8:	e0bfff17 	ldw	r2,-4(fp)
 201becc:	00c01044 	movi	r3,65
 201bed0:	10c00005 	stb	r3,0(r2)
        return;
 201bed4:	00000d06 	br	201bf0c <OSTaskNameSet+0x1a0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 201bed8:	e0bff717 	ldw	r2,-36(fp)
 201bedc:	10801304 	addi	r2,r2,76
 201bee0:	e17ffe17 	ldw	r5,-8(fp)
 201bee4:	1009883a 	mov	r4,r2
 201bee8:	201630c0 	call	201630c <OS_StrCopy>
 201beec:	e0bff517 	ldw	r2,-44(fp)
 201bef0:	e0bffb15 	stw	r2,-20(fp)
 201bef4:	e0bffb17 	ldw	r2,-20(fp)
 201bef8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201befc:	e0bfff17 	ldw	r2,-4(fp)
 201bf00:	10000005 	stb	zero,0(r2)
 201bf04:	00000106 	br	201bf0c <OSTaskNameSet+0x1a0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 201bf08:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 201bf0c:	e037883a 	mov	sp,fp
 201bf10:	dfc00117 	ldw	ra,4(sp)
 201bf14:	df000017 	ldw	fp,0(sp)
 201bf18:	dec00204 	addi	sp,sp,8
 201bf1c:	f800283a 	ret

0201bf20 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 201bf20:	defff404 	addi	sp,sp,-48
 201bf24:	dfc00b15 	stw	ra,44(sp)
 201bf28:	df000a15 	stw	fp,40(sp)
 201bf2c:	df000a04 	addi	fp,sp,40
 201bf30:	2005883a 	mov	r2,r4
 201bf34:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 201bf38:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 201bf3c:	e0bfff03 	ldbu	r2,-4(fp)
 201bf40:	10800530 	cmpltui	r2,r2,20
 201bf44:	1000021e 	bne	r2,zero,201bf50 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 201bf48:	00800a84 	movi	r2,42
 201bf4c:	00006406 	br	201c0e0 <OSTaskResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bf50:	0005303a 	rdctl	r2,status
 201bf54:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bf58:	e0fffe17 	ldw	r3,-8(fp)
 201bf5c:	00bfff84 	movi	r2,-2
 201bf60:	1884703a 	and	r2,r3,r2
 201bf64:	1001703a 	wrctl	status,r2
  
  return context;
 201bf68:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201bf6c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 201bf70:	e0ffff03 	ldbu	r3,-4(fp)
 201bf74:	008080f4 	movhi	r2,515
 201bf78:	10b97d04 	addi	r2,r2,-6668
 201bf7c:	18c7883a 	add	r3,r3,r3
 201bf80:	18c7883a 	add	r3,r3,r3
 201bf84:	10c5883a 	add	r2,r2,r3
 201bf88:	10800017 	ldw	r2,0(r2)
 201bf8c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 201bf90:	e0bff817 	ldw	r2,-32(fp)
 201bf94:	1000061e 	bne	r2,zero,201bfb0 <OSTaskResume+0x90>
 201bf98:	e0bff617 	ldw	r2,-40(fp)
 201bf9c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bfa0:	e0bff717 	ldw	r2,-36(fp)
 201bfa4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 201bfa8:	00801184 	movi	r2,70
 201bfac:	00004c06 	br	201c0e0 <OSTaskResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 201bfb0:	e0bff817 	ldw	r2,-32(fp)
 201bfb4:	10800058 	cmpnei	r2,r2,1
 201bfb8:	1000061e 	bne	r2,zero,201bfd4 <OSTaskResume+0xb4>
 201bfbc:	e0bff617 	ldw	r2,-40(fp)
 201bfc0:	e0bff915 	stw	r2,-28(fp)
 201bfc4:	e0bff917 	ldw	r2,-28(fp)
 201bfc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201bfcc:	008010c4 	movi	r2,67
 201bfd0:	00004306 	br	201c0e0 <OSTaskResume+0x1c0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 201bfd4:	e0bff817 	ldw	r2,-32(fp)
 201bfd8:	10800c03 	ldbu	r2,48(r2)
 201bfdc:	10803fcc 	andi	r2,r2,255
 201bfe0:	1080020c 	andi	r2,r2,8
 201bfe4:	10003926 	beq	r2,zero,201c0cc <OSTaskResume+0x1ac>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 201bfe8:	e0bff817 	ldw	r2,-32(fp)
 201bfec:	10c00c03 	ldbu	r3,48(r2)
 201bff0:	00bffdc4 	movi	r2,-9
 201bff4:	1884703a 	and	r2,r3,r2
 201bff8:	1007883a 	mov	r3,r2
 201bffc:	e0bff817 	ldw	r2,-32(fp)
 201c000:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 201c004:	e0bff817 	ldw	r2,-32(fp)
 201c008:	10800c03 	ldbu	r2,48(r2)
 201c00c:	10803fcc 	andi	r2,r2,255
 201c010:	1000281e 	bne	r2,zero,201c0b4 <OSTaskResume+0x194>
            if (ptcb->OSTCBDly == 0) {
 201c014:	e0bff817 	ldw	r2,-32(fp)
 201c018:	10800b8b 	ldhu	r2,46(r2)
 201c01c:	10bfffcc 	andi	r2,r2,65535
 201c020:	10001f1e 	bne	r2,zero,201c0a0 <OSTaskResume+0x180>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 201c024:	e0bff817 	ldw	r2,-32(fp)
 201c028:	10c00d83 	ldbu	r3,54(r2)
 201c02c:	d0a75b03 	ldbu	r2,-25236(gp)
 201c030:	1884b03a 	or	r2,r3,r2
 201c034:	d0a75b05 	stb	r2,-25236(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 201c038:	e0bff817 	ldw	r2,-32(fp)
 201c03c:	10800d03 	ldbu	r2,52(r2)
 201c040:	10c03fcc 	andi	r3,r2,255
 201c044:	e0bff817 	ldw	r2,-32(fp)
 201c048:	10800d03 	ldbu	r2,52(r2)
 201c04c:	11003fcc 	andi	r4,r2,255
 201c050:	d0a75b44 	addi	r2,gp,-25235
 201c054:	2085883a 	add	r2,r4,r2
 201c058:	11000003 	ldbu	r4,0(r2)
 201c05c:	e0bff817 	ldw	r2,-32(fp)
 201c060:	10800d43 	ldbu	r2,53(r2)
 201c064:	2084b03a 	or	r2,r4,r2
 201c068:	1009883a 	mov	r4,r2
 201c06c:	d0a75b44 	addi	r2,gp,-25235
 201c070:	1885883a 	add	r2,r3,r2
 201c074:	11000005 	stb	r4,0(r2)
 201c078:	e0bff617 	ldw	r2,-40(fp)
 201c07c:	e0bffa15 	stw	r2,-24(fp)
 201c080:	e0bffa17 	ldw	r2,-24(fp)
 201c084:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 201c088:	d0a74f43 	ldbu	r2,-25283(gp)
 201c08c:	10803fcc 	andi	r2,r2,255
 201c090:	10800058 	cmpnei	r2,r2,1
 201c094:	10000b1e 	bne	r2,zero,201c0c4 <OSTaskResume+0x1a4>
                    OS_Sched();                               /* Find new highest priority task        */
 201c098:	20161c80 	call	20161c8 <OS_Sched>
 201c09c:	00000906 	br	201c0c4 <OSTaskResume+0x1a4>
 201c0a0:	e0bff617 	ldw	r2,-40(fp)
 201c0a4:	e0bffb15 	stw	r2,-20(fp)
 201c0a8:	e0bffb17 	ldw	r2,-20(fp)
 201c0ac:	1001703a 	wrctl	status,r2
 201c0b0:	00000406 	br	201c0c4 <OSTaskResume+0x1a4>
 201c0b4:	e0bff617 	ldw	r2,-40(fp)
 201c0b8:	e0bffc15 	stw	r2,-16(fp)
 201c0bc:	e0bffc17 	ldw	r2,-16(fp)
 201c0c0:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 201c0c4:	0005883a 	mov	r2,zero
 201c0c8:	00000506 	br	201c0e0 <OSTaskResume+0x1c0>
 201c0cc:	e0bff617 	ldw	r2,-40(fp)
 201c0d0:	e0bffd15 	stw	r2,-12(fp)
 201c0d4:	e0bffd17 	ldw	r2,-12(fp)
 201c0d8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 201c0dc:	00801104 	movi	r2,68
}
 201c0e0:	e037883a 	mov	sp,fp
 201c0e4:	dfc00117 	ldw	ra,4(sp)
 201c0e8:	df000017 	ldw	fp,0(sp)
 201c0ec:	dec00204 	addi	sp,sp,8
 201c0f0:	f800283a 	ret

0201c0f4 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 201c0f4:	defff304 	addi	sp,sp,-52
 201c0f8:	df000c15 	stw	fp,48(sp)
 201c0fc:	df000c04 	addi	fp,sp,48
 201c100:	2005883a 	mov	r2,r4
 201c104:	e17fff15 	stw	r5,-4(fp)
 201c108:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201c10c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 201c110:	e0bffe03 	ldbu	r2,-8(fp)
 201c114:	10800570 	cmpltui	r2,r2,21
 201c118:	1000051e 	bne	r2,zero,201c130 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 201c11c:	e0bffe03 	ldbu	r2,-8(fp)
 201c120:	10803fe0 	cmpeqi	r2,r2,255
 201c124:	1000021e 	bne	r2,zero,201c130 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 201c128:	00800a84 	movi	r2,42
 201c12c:	00005d06 	br	201c2a4 <OSTaskStkChk+0x1b0>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 201c130:	e0bfff17 	ldw	r2,-4(fp)
 201c134:	1000021e 	bne	r2,zero,201c140 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 201c138:	00800244 	movi	r2,9
 201c13c:	00005906 	br	201c2a4 <OSTaskStkChk+0x1b0>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 201c140:	e0bfff17 	ldw	r2,-4(fp)
 201c144:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 201c148:	e0bfff17 	ldw	r2,-4(fp)
 201c14c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c150:	0005303a 	rdctl	r2,status
 201c154:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c158:	e0fffd17 	ldw	r3,-12(fp)
 201c15c:	00bfff84 	movi	r2,-2
 201c160:	1884703a 	and	r2,r3,r2
 201c164:	1001703a 	wrctl	status,r2
  
  return context;
 201c168:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
 201c16c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 201c170:	e0bffe03 	ldbu	r2,-8(fp)
 201c174:	10803fd8 	cmpnei	r2,r2,255
 201c178:	1000031e 	bne	r2,zero,201c188 <OSTaskStkChk+0x94>
        prio = OSTCBCur->OSTCBPrio;
 201c17c:	d0a75e17 	ldw	r2,-25224(gp)
 201c180:	10800c83 	ldbu	r2,50(r2)
 201c184:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201c188:	e0fffe03 	ldbu	r3,-8(fp)
 201c18c:	008080f4 	movhi	r2,515
 201c190:	10b97d04 	addi	r2,r2,-6668
 201c194:	18c7883a 	add	r3,r3,r3
 201c198:	18c7883a 	add	r3,r3,r3
 201c19c:	10c5883a 	add	r2,r2,r3
 201c1a0:	10800017 	ldw	r2,0(r2)
 201c1a4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 201c1a8:	e0bff817 	ldw	r2,-32(fp)
 201c1ac:	1000061e 	bne	r2,zero,201c1c8 <OSTaskStkChk+0xd4>
 201c1b0:	e0bff617 	ldw	r2,-40(fp)
 201c1b4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c1b8:	e0bff717 	ldw	r2,-36(fp)
 201c1bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201c1c0:	008010c4 	movi	r2,67
 201c1c4:	00003706 	br	201c2a4 <OSTaskStkChk+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 201c1c8:	e0bff817 	ldw	r2,-32(fp)
 201c1cc:	10800058 	cmpnei	r2,r2,1
 201c1d0:	1000061e 	bne	r2,zero,201c1ec <OSTaskStkChk+0xf8>
 201c1d4:	e0bff617 	ldw	r2,-40(fp)
 201c1d8:	e0bff915 	stw	r2,-28(fp)
 201c1dc:	e0bff917 	ldw	r2,-28(fp)
 201c1e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201c1e4:	008010c4 	movi	r2,67
 201c1e8:	00002e06 	br	201c2a4 <OSTaskStkChk+0x1b0>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 201c1ec:	e0bff817 	ldw	r2,-32(fp)
 201c1f0:	1080040b 	ldhu	r2,16(r2)
 201c1f4:	10bfffcc 	andi	r2,r2,65535
 201c1f8:	1080004c 	andi	r2,r2,1
 201c1fc:	1000061e 	bne	r2,zero,201c218 <OSTaskStkChk+0x124>
 201c200:	e0bff617 	ldw	r2,-40(fp)
 201c204:	e0bffa15 	stw	r2,-24(fp)
 201c208:	e0bffa17 	ldw	r2,-24(fp)
 201c20c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 201c210:	00801144 	movi	r2,69
 201c214:	00002306 	br	201c2a4 <OSTaskStkChk+0x1b0>
    }
    nfree = 0;
 201c218:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 201c21c:	e0bff817 	ldw	r2,-32(fp)
 201c220:	10800317 	ldw	r2,12(r2)
 201c224:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
 201c228:	e0bff817 	ldw	r2,-32(fp)
 201c22c:	10800217 	ldw	r2,8(r2)
 201c230:	e0bff415 	stw	r2,-48(fp)
 201c234:	e0bff617 	ldw	r2,-40(fp)
 201c238:	e0bffb15 	stw	r2,-20(fp)
 201c23c:	e0bffb17 	ldw	r2,-20(fp)
 201c240:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 201c244:	00000306 	br	201c254 <OSTaskStkChk+0x160>
        nfree++;
 201c248:	e0bff517 	ldw	r2,-44(fp)
 201c24c:	10800044 	addi	r2,r2,1
 201c250:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 201c254:	e0bff417 	ldw	r2,-48(fp)
 201c258:	10c00104 	addi	r3,r2,4
 201c25c:	e0fff415 	stw	r3,-48(fp)
 201c260:	10800017 	ldw	r2,0(r2)
 201c264:	103ff826 	beq	r2,zero,201c248 <OSTaskStkChk+0x154>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 201c268:	e0bff517 	ldw	r2,-44(fp)
 201c26c:	1085883a 	add	r2,r2,r2
 201c270:	1085883a 	add	r2,r2,r2
 201c274:	1007883a 	mov	r3,r2
 201c278:	e0bfff17 	ldw	r2,-4(fp)
 201c27c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 201c280:	e0fffc17 	ldw	r3,-16(fp)
 201c284:	e0bff517 	ldw	r2,-44(fp)
 201c288:	1885c83a 	sub	r2,r3,r2
 201c28c:	1085883a 	add	r2,r2,r2
 201c290:	1085883a 	add	r2,r2,r2
 201c294:	1007883a 	mov	r3,r2
 201c298:	e0bfff17 	ldw	r2,-4(fp)
 201c29c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 201c2a0:	0005883a 	mov	r2,zero
}
 201c2a4:	e037883a 	mov	sp,fp
 201c2a8:	df000017 	ldw	fp,0(sp)
 201c2ac:	dec00104 	addi	sp,sp,4
 201c2b0:	f800283a 	ret

0201c2b4 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 201c2b4:	defff504 	addi	sp,sp,-44
 201c2b8:	dfc00a15 	stw	ra,40(sp)
 201c2bc:	df000915 	stw	fp,36(sp)
 201c2c0:	df000904 	addi	fp,sp,36
 201c2c4:	2005883a 	mov	r2,r4
 201c2c8:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201c2cc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 201c2d0:	e0bfff03 	ldbu	r2,-4(fp)
 201c2d4:	10800518 	cmpnei	r2,r2,20
 201c2d8:	1000021e 	bne	r2,zero,201c2e4 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 201c2dc:	008011c4 	movi	r2,71
 201c2e0:	00006806 	br	201c484 <OSTaskSuspend+0x1d0>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 201c2e4:	e0bfff03 	ldbu	r2,-4(fp)
 201c2e8:	10800530 	cmpltui	r2,r2,20
 201c2ec:	1000051e 	bne	r2,zero,201c304 <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 201c2f0:	e0bfff03 	ldbu	r2,-4(fp)
 201c2f4:	10803fe0 	cmpeqi	r2,r2,255
 201c2f8:	1000021e 	bne	r2,zero,201c304 <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 201c2fc:	00800a84 	movi	r2,42
 201c300:	00006006 	br	201c484 <OSTaskSuspend+0x1d0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c304:	0005303a 	rdctl	r2,status
 201c308:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c30c:	e0fffe17 	ldw	r3,-8(fp)
 201c310:	00bfff84 	movi	r2,-2
 201c314:	1884703a 	and	r2,r3,r2
 201c318:	1001703a 	wrctl	status,r2
  
  return context;
 201c31c:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 201c320:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 201c324:	e0bfff03 	ldbu	r2,-4(fp)
 201c328:	10803fd8 	cmpnei	r2,r2,255
 201c32c:	1000061e 	bne	r2,zero,201c348 <OSTaskSuspend+0x94>
        prio = OSTCBCur->OSTCBPrio;
 201c330:	d0a75e17 	ldw	r2,-25224(gp)
 201c334:	10800c83 	ldbu	r2,50(r2)
 201c338:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 201c33c:	00800044 	movi	r2,1
 201c340:	e0bff705 	stb	r2,-36(fp)
 201c344:	00000906 	br	201c36c <OSTaskSuspend+0xb8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 201c348:	d0a75e17 	ldw	r2,-25224(gp)
 201c34c:	10800c83 	ldbu	r2,50(r2)
 201c350:	10c03fcc 	andi	r3,r2,255
 201c354:	e0bfff03 	ldbu	r2,-4(fp)
 201c358:	1880031e 	bne	r3,r2,201c368 <OSTaskSuspend+0xb4>
        self = OS_TRUE;
 201c35c:	00800044 	movi	r2,1
 201c360:	e0bff705 	stb	r2,-36(fp)
 201c364:	00000106 	br	201c36c <OSTaskSuspend+0xb8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 201c368:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201c36c:	e0ffff03 	ldbu	r3,-4(fp)
 201c370:	008080f4 	movhi	r2,515
 201c374:	10b97d04 	addi	r2,r2,-6668
 201c378:	18c7883a 	add	r3,r3,r3
 201c37c:	18c7883a 	add	r3,r3,r3
 201c380:	10c5883a 	add	r2,r2,r3
 201c384:	10800017 	ldw	r2,0(r2)
 201c388:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 201c38c:	e0bffa17 	ldw	r2,-24(fp)
 201c390:	1000061e 	bne	r2,zero,201c3ac <OSTaskSuspend+0xf8>
 201c394:	e0bff817 	ldw	r2,-32(fp)
 201c398:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c39c:	e0bff917 	ldw	r2,-28(fp)
 201c3a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 201c3a4:	00801204 	movi	r2,72
 201c3a8:	00003606 	br	201c484 <OSTaskSuspend+0x1d0>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 201c3ac:	e0bffa17 	ldw	r2,-24(fp)
 201c3b0:	10800058 	cmpnei	r2,r2,1
 201c3b4:	1000061e 	bne	r2,zero,201c3d0 <OSTaskSuspend+0x11c>
 201c3b8:	e0bff817 	ldw	r2,-32(fp)
 201c3bc:	e0bffb15 	stw	r2,-20(fp)
 201c3c0:	e0bffb17 	ldw	r2,-20(fp)
 201c3c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201c3c8:	008010c4 	movi	r2,67
 201c3cc:	00002d06 	br	201c484 <OSTaskSuspend+0x1d0>
    }
    y            = ptcb->OSTCBY;
 201c3d0:	e0bffa17 	ldw	r2,-24(fp)
 201c3d4:	10800d03 	ldbu	r2,52(r2)
 201c3d8:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 201c3dc:	e0fffd03 	ldbu	r3,-12(fp)
 201c3e0:	e13ffd03 	ldbu	r4,-12(fp)
 201c3e4:	d0a75b44 	addi	r2,gp,-25235
 201c3e8:	2085883a 	add	r2,r4,r2
 201c3ec:	10800003 	ldbu	r2,0(r2)
 201c3f0:	1009883a 	mov	r4,r2
 201c3f4:	e0bffa17 	ldw	r2,-24(fp)
 201c3f8:	10800d43 	ldbu	r2,53(r2)
 201c3fc:	0084303a 	nor	r2,zero,r2
 201c400:	2084703a 	and	r2,r4,r2
 201c404:	1009883a 	mov	r4,r2
 201c408:	d0a75b44 	addi	r2,gp,-25235
 201c40c:	1885883a 	add	r2,r3,r2
 201c410:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
 201c414:	e0fffd03 	ldbu	r3,-12(fp)
 201c418:	d0a75b44 	addi	r2,gp,-25235
 201c41c:	1885883a 	add	r2,r3,r2
 201c420:	10800003 	ldbu	r2,0(r2)
 201c424:	10803fcc 	andi	r2,r2,255
 201c428:	1000071e 	bne	r2,zero,201c448 <OSTaskSuspend+0x194>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 201c42c:	e0bffa17 	ldw	r2,-24(fp)
 201c430:	10800d83 	ldbu	r2,54(r2)
 201c434:	0084303a 	nor	r2,zero,r2
 201c438:	1007883a 	mov	r3,r2
 201c43c:	d0a75b03 	ldbu	r2,-25236(gp)
 201c440:	1884703a 	and	r2,r3,r2
 201c444:	d0a75b05 	stb	r2,-25236(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 201c448:	e0bffa17 	ldw	r2,-24(fp)
 201c44c:	10800c03 	ldbu	r2,48(r2)
 201c450:	10800214 	ori	r2,r2,8
 201c454:	1007883a 	mov	r3,r2
 201c458:	e0bffa17 	ldw	r2,-24(fp)
 201c45c:	10c00c05 	stb	r3,48(r2)
 201c460:	e0bff817 	ldw	r2,-32(fp)
 201c464:	e0bffc15 	stw	r2,-16(fp)
 201c468:	e0bffc17 	ldw	r2,-16(fp)
 201c46c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 201c470:	e0bff703 	ldbu	r2,-36(fp)
 201c474:	10800058 	cmpnei	r2,r2,1
 201c478:	1000011e 	bne	r2,zero,201c480 <OSTaskSuspend+0x1cc>
        OS_Sched();                                             /* Find new highest priority task      */
 201c47c:	20161c80 	call	20161c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201c480:	0005883a 	mov	r2,zero
}
 201c484:	e037883a 	mov	sp,fp
 201c488:	dfc00117 	ldw	ra,4(sp)
 201c48c:	df000017 	ldw	fp,0(sp)
 201c490:	dec00204 	addi	sp,sp,8
 201c494:	f800283a 	ret

0201c498 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 201c498:	defff604 	addi	sp,sp,-40
 201c49c:	dfc00915 	stw	ra,36(sp)
 201c4a0:	df000815 	stw	fp,32(sp)
 201c4a4:	df000804 	addi	fp,sp,32
 201c4a8:	2005883a 	mov	r2,r4
 201c4ac:	e17fff15 	stw	r5,-4(fp)
 201c4b0:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201c4b4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 201c4b8:	e0bffe03 	ldbu	r2,-8(fp)
 201c4bc:	10800570 	cmpltui	r2,r2,21
 201c4c0:	1000051e 	bne	r2,zero,201c4d8 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 201c4c4:	e0bffe03 	ldbu	r2,-8(fp)
 201c4c8:	10803fe0 	cmpeqi	r2,r2,255
 201c4cc:	1000021e 	bne	r2,zero,201c4d8 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 201c4d0:	00800a84 	movi	r2,42
 201c4d4:	00003406 	br	201c5a8 <OSTaskQuery+0x110>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 201c4d8:	e0bfff17 	ldw	r2,-4(fp)
 201c4dc:	1000021e 	bne	r2,zero,201c4e8 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 201c4e0:	00800244 	movi	r2,9
 201c4e4:	00003006 	br	201c5a8 <OSTaskQuery+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c4e8:	0005303a 	rdctl	r2,status
 201c4ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c4f0:	e0fffd17 	ldw	r3,-12(fp)
 201c4f4:	00bfff84 	movi	r2,-2
 201c4f8:	1884703a 	and	r2,r3,r2
 201c4fc:	1001703a 	wrctl	status,r2
  
  return context;
 201c500:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201c504:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 201c508:	e0bffe03 	ldbu	r2,-8(fp)
 201c50c:	10803fd8 	cmpnei	r2,r2,255
 201c510:	1000031e 	bne	r2,zero,201c520 <OSTaskQuery+0x88>
        prio = OSTCBCur->OSTCBPrio;
 201c514:	d0a75e17 	ldw	r2,-25224(gp)
 201c518:	10800c83 	ldbu	r2,50(r2)
 201c51c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201c520:	e0fffe03 	ldbu	r3,-8(fp)
 201c524:	008080f4 	movhi	r2,515
 201c528:	10b97d04 	addi	r2,r2,-6668
 201c52c:	18c7883a 	add	r3,r3,r3
 201c530:	18c7883a 	add	r3,r3,r3
 201c534:	10c5883a 	add	r2,r2,r3
 201c538:	10800017 	ldw	r2,0(r2)
 201c53c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 201c540:	e0bffa17 	ldw	r2,-24(fp)
 201c544:	1000061e 	bne	r2,zero,201c560 <OSTaskQuery+0xc8>
 201c548:	e0bff817 	ldw	r2,-32(fp)
 201c54c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c550:	e0bff917 	ldw	r2,-28(fp)
 201c554:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 201c558:	00800a44 	movi	r2,41
 201c55c:	00001206 	br	201c5a8 <OSTaskQuery+0x110>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 201c560:	e0bffa17 	ldw	r2,-24(fp)
 201c564:	10800058 	cmpnei	r2,r2,1
 201c568:	1000061e 	bne	r2,zero,201c584 <OSTaskQuery+0xec>
 201c56c:	e0bff817 	ldw	r2,-32(fp)
 201c570:	e0bffb15 	stw	r2,-20(fp)
 201c574:	e0bffb17 	ldw	r2,-20(fp)
 201c578:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201c57c:	008010c4 	movi	r2,67
 201c580:	00000906 	br	201c5a8 <OSTaskQuery+0x110>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 201c584:	01801b04 	movi	r6,108
 201c588:	e17ffa17 	ldw	r5,-24(fp)
 201c58c:	e13fff17 	ldw	r4,-4(fp)
 201c590:	20161600 	call	2016160 <OS_MemCopy>
 201c594:	e0bff817 	ldw	r2,-32(fp)
 201c598:	e0bffc15 	stw	r2,-16(fp)
 201c59c:	e0bffc17 	ldw	r2,-16(fp)
 201c5a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201c5a4:	0005883a 	mov	r2,zero
}
 201c5a8:	e037883a 	mov	sp,fp
 201c5ac:	dfc00117 	ldw	ra,4(sp)
 201c5b0:	df000017 	ldw	fp,0(sp)
 201c5b4:	dec00204 	addi	sp,sp,8
 201c5b8:	f800283a 	ret

0201c5bc <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 201c5bc:	defffc04 	addi	sp,sp,-16
 201c5c0:	df000315 	stw	fp,12(sp)
 201c5c4:	df000304 	addi	fp,sp,12
 201c5c8:	e13ffd15 	stw	r4,-12(fp)
 201c5cc:	e17ffe15 	stw	r5,-8(fp)
 201c5d0:	3005883a 	mov	r2,r6
 201c5d4:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 201c5d8:	e0bfff0b 	ldhu	r2,-4(fp)
 201c5dc:	1080004c 	andi	r2,r2,1
 201c5e0:	10000d26 	beq	r2,zero,201c618 <OS_TaskStkClr+0x5c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 201c5e4:	e0bfff0b 	ldhu	r2,-4(fp)
 201c5e8:	1080008c 	andi	r2,r2,2
 201c5ec:	10000a26 	beq	r2,zero,201c618 <OS_TaskStkClr+0x5c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 201c5f0:	00000706 	br	201c610 <OS_TaskStkClr+0x54>
                size--;
 201c5f4:	e0bffe17 	ldw	r2,-8(fp)
 201c5f8:	10bfffc4 	addi	r2,r2,-1
 201c5fc:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 201c600:	e0bffd17 	ldw	r2,-12(fp)
 201c604:	10c00104 	addi	r3,r2,4
 201c608:	e0fffd15 	stw	r3,-12(fp)
 201c60c:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 201c610:	e0bffe17 	ldw	r2,-8(fp)
 201c614:	103ff71e 	bne	r2,zero,201c5f4 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 201c618:	0001883a 	nop
 201c61c:	e037883a 	mov	sp,fp
 201c620:	df000017 	ldw	fp,0(sp)
 201c624:	dec00104 	addi	sp,sp,4
 201c628:	f800283a 	ret

0201c62c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 201c62c:	defff904 	addi	sp,sp,-28
 201c630:	dfc00615 	stw	ra,24(sp)
 201c634:	df000515 	stw	fp,20(sp)
 201c638:	df000504 	addi	fp,sp,20
 201c63c:	2005883a 	mov	r2,r4
 201c640:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201c644:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201c648:	d0a75d03 	ldbu	r2,-25228(gp)
 201c64c:	10803fcc 	andi	r2,r2,255
 201c650:	1000311e 	bne	r2,zero,201c718 <OSTimeDly+0xec>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 201c654:	e0bfff0b 	ldhu	r2,-4(fp)
 201c658:	10003026 	beq	r2,zero,201c71c <OSTimeDly+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c65c:	0005303a 	rdctl	r2,status
 201c660:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c664:	e0fffe17 	ldw	r3,-8(fp)
 201c668:	00bfff84 	movi	r2,-2
 201c66c:	1884703a 	and	r2,r3,r2
 201c670:	1001703a 	wrctl	status,r2
  
  return context;
 201c674:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 201c678:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 201c67c:	d0a75e17 	ldw	r2,-25224(gp)
 201c680:	10800d03 	ldbu	r2,52(r2)
 201c684:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 201c688:	e0fffd03 	ldbu	r3,-12(fp)
 201c68c:	e13ffd03 	ldbu	r4,-12(fp)
 201c690:	d0a75b44 	addi	r2,gp,-25235
 201c694:	2085883a 	add	r2,r4,r2
 201c698:	10800003 	ldbu	r2,0(r2)
 201c69c:	1009883a 	mov	r4,r2
 201c6a0:	d0a75e17 	ldw	r2,-25224(gp)
 201c6a4:	10800d43 	ldbu	r2,53(r2)
 201c6a8:	0084303a 	nor	r2,zero,r2
 201c6ac:	2084703a 	and	r2,r4,r2
 201c6b0:	1009883a 	mov	r4,r2
 201c6b4:	d0a75b44 	addi	r2,gp,-25235
 201c6b8:	1885883a 	add	r2,r3,r2
 201c6bc:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
 201c6c0:	e0fffd03 	ldbu	r3,-12(fp)
 201c6c4:	d0a75b44 	addi	r2,gp,-25235
 201c6c8:	1885883a 	add	r2,r3,r2
 201c6cc:	10800003 	ldbu	r2,0(r2)
 201c6d0:	10803fcc 	andi	r2,r2,255
 201c6d4:	1000071e 	bne	r2,zero,201c6f4 <OSTimeDly+0xc8>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 201c6d8:	d0a75e17 	ldw	r2,-25224(gp)
 201c6dc:	10800d83 	ldbu	r2,54(r2)
 201c6e0:	0084303a 	nor	r2,zero,r2
 201c6e4:	1007883a 	mov	r3,r2
 201c6e8:	d0a75b03 	ldbu	r2,-25236(gp)
 201c6ec:	1884703a 	and	r2,r3,r2
 201c6f0:	d0a75b05 	stb	r2,-25236(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 201c6f4:	d0a75e17 	ldw	r2,-25224(gp)
 201c6f8:	e0ffff0b 	ldhu	r3,-4(fp)
 201c6fc:	10c00b8d 	sth	r3,46(r2)
 201c700:	e0bffb17 	ldw	r2,-20(fp)
 201c704:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c708:	e0bffc17 	ldw	r2,-16(fp)
 201c70c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 201c710:	20161c80 	call	20161c8 <OS_Sched>
 201c714:	00000106 	br	201c71c <OSTimeDly+0xf0>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 201c718:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 201c71c:	e037883a 	mov	sp,fp
 201c720:	dfc00117 	ldw	ra,4(sp)
 201c724:	df000017 	ldw	fp,0(sp)
 201c728:	dec00204 	addi	sp,sp,8
 201c72c:	f800283a 	ret

0201c730 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 201c730:	defff704 	addi	sp,sp,-36
 201c734:	dfc00815 	stw	ra,32(sp)
 201c738:	df000715 	stw	fp,28(sp)
 201c73c:	dc000615 	stw	r16,24(sp)
 201c740:	df000704 	addi	fp,sp,28
 201c744:	2011883a 	mov	r8,r4
 201c748:	2809883a 	mov	r4,r5
 201c74c:	3007883a 	mov	r3,r6
 201c750:	3805883a 	mov	r2,r7
 201c754:	e23ffb05 	stb	r8,-20(fp)
 201c758:	e13ffc05 	stb	r4,-16(fp)
 201c75c:	e0fffd05 	stb	r3,-12(fp)
 201c760:	e0bffe0d 	sth	r2,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201c764:	d0a75d03 	ldbu	r2,-25228(gp)
 201c768:	10803fcc 	andi	r2,r2,255
 201c76c:	10000226 	beq	r2,zero,201c778 <OSTimeDlyHMSM+0x48>
        return (OS_ERR_TIME_DLY_ISR);
 201c770:	00801544 	movi	r2,85
 201c774:	00003d06 	br	201c86c <OSTimeDlyHMSM+0x13c>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 201c778:	e0bffb03 	ldbu	r2,-20(fp)
 201c77c:	1000081e 	bne	r2,zero,201c7a0 <OSTimeDlyHMSM+0x70>
        if (minutes == 0) {
 201c780:	e0bffc03 	ldbu	r2,-16(fp)
 201c784:	1000061e 	bne	r2,zero,201c7a0 <OSTimeDlyHMSM+0x70>
            if (seconds == 0) {
 201c788:	e0bffd03 	ldbu	r2,-12(fp)
 201c78c:	1000041e 	bne	r2,zero,201c7a0 <OSTimeDlyHMSM+0x70>
                if (ms == 0) {
 201c790:	e0bffe0b 	ldhu	r2,-8(fp)
 201c794:	1000021e 	bne	r2,zero,201c7a0 <OSTimeDlyHMSM+0x70>
                    return (OS_ERR_TIME_ZERO_DLY);
 201c798:	00801504 	movi	r2,84
 201c79c:	00003306 	br	201c86c <OSTimeDlyHMSM+0x13c>
                }
            }
        }
    }
    if (minutes > 59) {
 201c7a0:	e0bffc03 	ldbu	r2,-16(fp)
 201c7a4:	10800f30 	cmpltui	r2,r2,60
 201c7a8:	1000021e 	bne	r2,zero,201c7b4 <OSTimeDlyHMSM+0x84>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 201c7ac:	00801444 	movi	r2,81
 201c7b0:	00002e06 	br	201c86c <OSTimeDlyHMSM+0x13c>
    }
    if (seconds > 59) {
 201c7b4:	e0bffd03 	ldbu	r2,-12(fp)
 201c7b8:	10800f30 	cmpltui	r2,r2,60
 201c7bc:	1000021e 	bne	r2,zero,201c7c8 <OSTimeDlyHMSM+0x98>
        return (OS_ERR_TIME_INVALID_SECONDS);
 201c7c0:	00801484 	movi	r2,82
 201c7c4:	00002906 	br	201c86c <OSTimeDlyHMSM+0x13c>
    }
    if (ms > 999) {
 201c7c8:	e0bffe0b 	ldhu	r2,-8(fp)
 201c7cc:	1080fa30 	cmpltui	r2,r2,1000
 201c7d0:	1000021e 	bne	r2,zero,201c7dc <OSTimeDlyHMSM+0xac>
        return (OS_ERR_TIME_INVALID_MS);
 201c7d4:	008014c4 	movi	r2,83
 201c7d8:	00002406 	br	201c86c <OSTimeDlyHMSM+0x13c>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 201c7dc:	e0bffb03 	ldbu	r2,-20(fp)
 201c7e0:	10c38424 	muli	r3,r2,3600
 201c7e4:	e0bffc03 	ldbu	r2,-16(fp)
 201c7e8:	10800f24 	muli	r2,r2,60
 201c7ec:	1887883a 	add	r3,r3,r2
 201c7f0:	e0bffd03 	ldbu	r2,-12(fp)
 201c7f4:	1885883a 	add	r2,r3,r2
 201c7f8:	1400fa24 	muli	r16,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 201c7fc:	e0bffe0b 	ldhu	r2,-8(fp)
 201c800:	1080fa24 	muli	r2,r2,1000
 201c804:	0140fa04 	movi	r5,1000
 201c808:	1009883a 	mov	r4,r2
 201c80c:	2003fd80 	call	2003fd8 <__udivsi3>
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 201c810:	8085883a 	add	r2,r16,r2
 201c814:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 201c818:	e0bffa17 	ldw	r2,-24(fp)
 201c81c:	1004d43a 	srli	r2,r2,16
 201c820:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 201c824:	e0bffa17 	ldw	r2,-24(fp)
 201c828:	10bfffcc 	andi	r2,r2,65535
 201c82c:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 201c830:	e0bffa17 	ldw	r2,-24(fp)
 201c834:	10bfffcc 	andi	r2,r2,65535
 201c838:	1009883a 	mov	r4,r2
 201c83c:	201c62c0 	call	201c62c <OSTimeDly>
    while (loops > 0) {
 201c840:	00000706 	br	201c860 <OSTimeDlyHMSM+0x130>
        OSTimeDly((INT16U)32768u);
 201c844:	01200014 	movui	r4,32768
 201c848:	201c62c0 	call	201c62c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 201c84c:	01200014 	movui	r4,32768
 201c850:	201c62c0 	call	201c62c <OSTimeDly>
        loops--;
 201c854:	e0bff90b 	ldhu	r2,-28(fp)
 201c858:	10bfffc4 	addi	r2,r2,-1
 201c85c:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 201c860:	e0bff90b 	ldhu	r2,-28(fp)
 201c864:	103ff71e 	bne	r2,zero,201c844 <OSTimeDlyHMSM+0x114>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 201c868:	0005883a 	mov	r2,zero
}
 201c86c:	e6ffff04 	addi	sp,fp,-4
 201c870:	dfc00217 	ldw	ra,8(sp)
 201c874:	df000117 	ldw	fp,4(sp)
 201c878:	dc000017 	ldw	r16,0(sp)
 201c87c:	dec00304 	addi	sp,sp,12
 201c880:	f800283a 	ret

0201c884 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 201c884:	defff504 	addi	sp,sp,-44
 201c888:	dfc00a15 	stw	ra,40(sp)
 201c88c:	df000915 	stw	fp,36(sp)
 201c890:	df000904 	addi	fp,sp,36
 201c894:	2005883a 	mov	r2,r4
 201c898:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201c89c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 201c8a0:	e0bfff03 	ldbu	r2,-4(fp)
 201c8a4:	10800530 	cmpltui	r2,r2,20
 201c8a8:	1000021e 	bne	r2,zero,201c8b4 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 201c8ac:	00800a84 	movi	r2,42
 201c8b0:	00006406 	br	201ca44 <OSTimeDlyResume+0x1c0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c8b4:	0005303a 	rdctl	r2,status
 201c8b8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c8bc:	e0fffe17 	ldw	r3,-8(fp)
 201c8c0:	00bfff84 	movi	r2,-2
 201c8c4:	1884703a 	and	r2,r3,r2
 201c8c8:	1001703a 	wrctl	status,r2
  
  return context;
 201c8cc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
 201c8d0:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 201c8d4:	e0ffff03 	ldbu	r3,-4(fp)
 201c8d8:	008080f4 	movhi	r2,515
 201c8dc:	10b97d04 	addi	r2,r2,-6668
 201c8e0:	18c7883a 	add	r3,r3,r3
 201c8e4:	18c7883a 	add	r3,r3,r3
 201c8e8:	10c5883a 	add	r2,r2,r3
 201c8ec:	10800017 	ldw	r2,0(r2)
 201c8f0:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
 201c8f4:	e0bff917 	ldw	r2,-28(fp)
 201c8f8:	1000061e 	bne	r2,zero,201c914 <OSTimeDlyResume+0x90>
 201c8fc:	e0bff717 	ldw	r2,-36(fp)
 201c900:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c904:	e0bff817 	ldw	r2,-32(fp)
 201c908:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 201c90c:	008010c4 	movi	r2,67
 201c910:	00004c06 	br	201ca44 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb == OS_TCB_RESERVED) {
 201c914:	e0bff917 	ldw	r2,-28(fp)
 201c918:	10800058 	cmpnei	r2,r2,1
 201c91c:	1000061e 	bne	r2,zero,201c938 <OSTimeDlyResume+0xb4>
 201c920:	e0bff717 	ldw	r2,-36(fp)
 201c924:	e0bffa15 	stw	r2,-24(fp)
 201c928:	e0bffa17 	ldw	r2,-24(fp)
 201c92c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 201c930:	008010c4 	movi	r2,67
 201c934:	00004306 	br	201ca44 <OSTimeDlyResume+0x1c0>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 201c938:	e0bff917 	ldw	r2,-28(fp)
 201c93c:	10800b8b 	ldhu	r2,46(r2)
 201c940:	10bfffcc 	andi	r2,r2,65535
 201c944:	1000061e 	bne	r2,zero,201c960 <OSTimeDlyResume+0xdc>
 201c948:	e0bff717 	ldw	r2,-36(fp)
 201c94c:	e0bffb15 	stw	r2,-20(fp)
 201c950:	e0bffb17 	ldw	r2,-20(fp)
 201c954:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 201c958:	00801404 	movi	r2,80
 201c95c:	00003906 	br	201ca44 <OSTimeDlyResume+0x1c0>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 201c960:	e0bff917 	ldw	r2,-28(fp)
 201c964:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 201c968:	e0bff917 	ldw	r2,-28(fp)
 201c96c:	10800c03 	ldbu	r2,48(r2)
 201c970:	10803fcc 	andi	r2,r2,255
 201c974:	10800dcc 	andi	r2,r2,55
 201c978:	10000b26 	beq	r2,zero,201c9a8 <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 201c97c:	e0bff917 	ldw	r2,-28(fp)
 201c980:	10c00c03 	ldbu	r3,48(r2)
 201c984:	00bff204 	movi	r2,-56
 201c988:	1884703a 	and	r2,r3,r2
 201c98c:	1007883a 	mov	r3,r2
 201c990:	e0bff917 	ldw	r2,-28(fp)
 201c994:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 201c998:	e0bff917 	ldw	r2,-28(fp)
 201c99c:	00c00044 	movi	r3,1
 201c9a0:	10c00c45 	stb	r3,49(r2)
 201c9a4:	00000206 	br	201c9b0 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 201c9a8:	e0bff917 	ldw	r2,-28(fp)
 201c9ac:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 201c9b0:	e0bff917 	ldw	r2,-28(fp)
 201c9b4:	10800c03 	ldbu	r2,48(r2)
 201c9b8:	10803fcc 	andi	r2,r2,255
 201c9bc:	1080020c 	andi	r2,r2,8
 201c9c0:	10001b1e 	bne	r2,zero,201ca30 <OSTimeDlyResume+0x1ac>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 201c9c4:	e0bff917 	ldw	r2,-28(fp)
 201c9c8:	10c00d83 	ldbu	r3,54(r2)
 201c9cc:	d0a75b03 	ldbu	r2,-25236(gp)
 201c9d0:	1884b03a 	or	r2,r3,r2
 201c9d4:	d0a75b05 	stb	r2,-25236(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 201c9d8:	e0bff917 	ldw	r2,-28(fp)
 201c9dc:	10800d03 	ldbu	r2,52(r2)
 201c9e0:	10c03fcc 	andi	r3,r2,255
 201c9e4:	e0bff917 	ldw	r2,-28(fp)
 201c9e8:	10800d03 	ldbu	r2,52(r2)
 201c9ec:	11003fcc 	andi	r4,r2,255
 201c9f0:	d0a75b44 	addi	r2,gp,-25235
 201c9f4:	2085883a 	add	r2,r4,r2
 201c9f8:	11000003 	ldbu	r4,0(r2)
 201c9fc:	e0bff917 	ldw	r2,-28(fp)
 201ca00:	10800d43 	ldbu	r2,53(r2)
 201ca04:	2084b03a 	or	r2,r4,r2
 201ca08:	1009883a 	mov	r4,r2
 201ca0c:	d0a75b44 	addi	r2,gp,-25235
 201ca10:	1885883a 	add	r2,r3,r2
 201ca14:	11000005 	stb	r4,0(r2)
 201ca18:	e0bff717 	ldw	r2,-36(fp)
 201ca1c:	e0bffc15 	stw	r2,-16(fp)
 201ca20:	e0bffc17 	ldw	r2,-16(fp)
 201ca24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 201ca28:	20161c80 	call	20161c8 <OS_Sched>
 201ca2c:	00000406 	br	201ca40 <OSTimeDlyResume+0x1bc>
 201ca30:	e0bff717 	ldw	r2,-36(fp)
 201ca34:	e0bffd15 	stw	r2,-12(fp)
 201ca38:	e0bffd17 	ldw	r2,-12(fp)
 201ca3c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 201ca40:	0005883a 	mov	r2,zero
}
 201ca44:	e037883a 	mov	sp,fp
 201ca48:	dfc00117 	ldw	ra,4(sp)
 201ca4c:	df000017 	ldw	fp,0(sp)
 201ca50:	dec00204 	addi	sp,sp,8
 201ca54:	f800283a 	ret

0201ca58 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 201ca58:	defffb04 	addi	sp,sp,-20
 201ca5c:	df000415 	stw	fp,16(sp)
 201ca60:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201ca64:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ca68:	0005303a 	rdctl	r2,status
 201ca6c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ca70:	e0fffe17 	ldw	r3,-8(fp)
 201ca74:	00bfff84 	movi	r2,-2
 201ca78:	1884703a 	and	r2,r3,r2
 201ca7c:	1001703a 	wrctl	status,r2
  
  return context;
 201ca80:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 201ca84:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 201ca88:	d0a75f17 	ldw	r2,-25220(gp)
 201ca8c:	e0bffd15 	stw	r2,-12(fp)
 201ca90:	e0bffc17 	ldw	r2,-16(fp)
 201ca94:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ca98:	e0bfff17 	ldw	r2,-4(fp)
 201ca9c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 201caa0:	e0bffd17 	ldw	r2,-12(fp)
}
 201caa4:	e037883a 	mov	sp,fp
 201caa8:	df000017 	ldw	fp,0(sp)
 201caac:	dec00104 	addi	sp,sp,4
 201cab0:	f800283a 	ret

0201cab4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 201cab4:	defffb04 	addi	sp,sp,-20
 201cab8:	df000415 	stw	fp,16(sp)
 201cabc:	df000404 	addi	fp,sp,16
 201cac0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201cac4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201cac8:	0005303a 	rdctl	r2,status
 201cacc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201cad0:	e0fffd17 	ldw	r3,-12(fp)
 201cad4:	00bfff84 	movi	r2,-2
 201cad8:	1884703a 	and	r2,r3,r2
 201cadc:	1001703a 	wrctl	status,r2
  
  return context;
 201cae0:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 201cae4:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 201cae8:	e0bfff17 	ldw	r2,-4(fp)
 201caec:	d0a75f15 	stw	r2,-25220(gp)
 201caf0:	e0bffc17 	ldw	r2,-16(fp)
 201caf4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201caf8:	e0bffe17 	ldw	r2,-8(fp)
 201cafc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 201cb00:	0001883a 	nop
 201cb04:	e037883a 	mov	sp,fp
 201cb08:	df000017 	ldw	fp,0(sp)
 201cb0c:	dec00104 	addi	sp,sp,4
 201cb10:	f800283a 	ret

0201cb14 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 201cb14:	defffd04 	addi	sp,sp,-12
 201cb18:	dfc00215 	stw	ra,8(sp)
 201cb1c:	df000115 	stw	fp,4(sp)
 201cb20:	df000104 	addi	fp,sp,4
 201cb24:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 201cb28:	d1600e04 	addi	r5,gp,-32712
 201cb2c:	e13fff17 	ldw	r4,-4(fp)
 201cb30:	201df600 	call	201df60 <alt_dev_llist_insert>
}
 201cb34:	e037883a 	mov	sp,fp
 201cb38:	dfc00117 	ldw	ra,4(sp)
 201cb3c:	df000017 	ldw	fp,0(sp)
 201cb40:	dec00204 	addi	sp,sp,8
 201cb44:	f800283a 	ret

0201cb48 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 201cb48:	defffd04 	addi	sp,sp,-12
 201cb4c:	dfc00215 	stw	ra,8(sp)
 201cb50:	df000115 	stw	fp,4(sp)
 201cb54:	df000104 	addi	fp,sp,4
 201cb58:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU, cpu);
 201cb5c:	201e8400 	call	201e840 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 201cb60:	00800044 	movi	r2,1
 201cb64:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 201cb68:	0001883a 	nop
 201cb6c:	e037883a 	mov	sp,fp
 201cb70:	dfc00117 	ldw	ra,4(sp)
 201cb74:	df000017 	ldw	fp,0(sp)
 201cb78:	dec00204 	addi	sp,sp,8
 201cb7c:	f800283a 	ret

0201cb80 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 201cb80:	defffe04 	addi	sp,sp,-8
 201cb84:	dfc00115 	stw	ra,4(sp)
 201cb88:	df000015 	stw	fp,0(sp)
 201cb8c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_SYSTEM, timer_system);
 201cb90:	01c0fa04 	movi	r7,1000
 201cb94:	01800044 	movi	r6,1
 201cb98:	000b883a 	mov	r5,zero
 201cb9c:	0009883a 	mov	r4,zero
 201cba0:	201d98c0 	call	201d98c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_TIMESTAMP, timer_timestamp);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 201cba4:	000d883a 	mov	r6,zero
 201cba8:	000b883a 	mov	r5,zero
 201cbac:	010080b4 	movhi	r4,514
 201cbb0:	21017b04 	addi	r4,r4,1516
 201cbb4:	201cd500 	call	201cd50 <altera_avalon_jtag_uart_init>
 201cbb8:	010080b4 	movhi	r4,514
 201cbbc:	21017104 	addi	r4,r4,1476
 201cbc0:	201cb140 	call	201cb14 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
 201cbc4:	0001883a 	nop
    ALTERA_UP_AVALON_ACCELEROMETER_SPI_INIT ( ACCELEROMETER_SPI_0, accelerometer_spi_0);
 201cbc8:	010080b4 	movhi	r4,514
 201cbcc:	21058c04 	addi	r4,r4,5680
 201cbd0:	201cb140 	call	201cb14 <alt_dev_reg>
}
 201cbd4:	0001883a 	nop
 201cbd8:	e037883a 	mov	sp,fp
 201cbdc:	dfc00117 	ldw	ra,4(sp)
 201cbe0:	df000017 	ldw	fp,0(sp)
 201cbe4:	dec00204 	addi	sp,sp,8
 201cbe8:	f800283a 	ret

0201cbec <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 201cbec:	defffa04 	addi	sp,sp,-24
 201cbf0:	dfc00515 	stw	ra,20(sp)
 201cbf4:	df000415 	stw	fp,16(sp)
 201cbf8:	df000404 	addi	fp,sp,16
 201cbfc:	e13ffd15 	stw	r4,-12(fp)
 201cc00:	e17ffe15 	stw	r5,-8(fp)
 201cc04:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201cc08:	e0bffd17 	ldw	r2,-12(fp)
 201cc0c:	10800017 	ldw	r2,0(r2)
 201cc10:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 201cc14:	e0bffc17 	ldw	r2,-16(fp)
 201cc18:	10c00a04 	addi	r3,r2,40
 201cc1c:	e0bffd17 	ldw	r2,-12(fp)
 201cc20:	10800217 	ldw	r2,8(r2)
 201cc24:	100f883a 	mov	r7,r2
 201cc28:	e1bfff17 	ldw	r6,-4(fp)
 201cc2c:	e17ffe17 	ldw	r5,-8(fp)
 201cc30:	1809883a 	mov	r4,r3
 201cc34:	201d3900 	call	201d390 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 201cc38:	e037883a 	mov	sp,fp
 201cc3c:	dfc00117 	ldw	ra,4(sp)
 201cc40:	df000017 	ldw	fp,0(sp)
 201cc44:	dec00204 	addi	sp,sp,8
 201cc48:	f800283a 	ret

0201cc4c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 201cc4c:	defffa04 	addi	sp,sp,-24
 201cc50:	dfc00515 	stw	ra,20(sp)
 201cc54:	df000415 	stw	fp,16(sp)
 201cc58:	df000404 	addi	fp,sp,16
 201cc5c:	e13ffd15 	stw	r4,-12(fp)
 201cc60:	e17ffe15 	stw	r5,-8(fp)
 201cc64:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201cc68:	e0bffd17 	ldw	r2,-12(fp)
 201cc6c:	10800017 	ldw	r2,0(r2)
 201cc70:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 201cc74:	e0bffc17 	ldw	r2,-16(fp)
 201cc78:	10c00a04 	addi	r3,r2,40
 201cc7c:	e0bffd17 	ldw	r2,-12(fp)
 201cc80:	10800217 	ldw	r2,8(r2)
 201cc84:	100f883a 	mov	r7,r2
 201cc88:	e1bfff17 	ldw	r6,-4(fp)
 201cc8c:	e17ffe17 	ldw	r5,-8(fp)
 201cc90:	1809883a 	mov	r4,r3
 201cc94:	201d64c0 	call	201d64c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 201cc98:	e037883a 	mov	sp,fp
 201cc9c:	dfc00117 	ldw	ra,4(sp)
 201cca0:	df000017 	ldw	fp,0(sp)
 201cca4:	dec00204 	addi	sp,sp,8
 201cca8:	f800283a 	ret

0201ccac <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 201ccac:	defffc04 	addi	sp,sp,-16
 201ccb0:	dfc00315 	stw	ra,12(sp)
 201ccb4:	df000215 	stw	fp,8(sp)
 201ccb8:	df000204 	addi	fp,sp,8
 201ccbc:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201ccc0:	e0bfff17 	ldw	r2,-4(fp)
 201ccc4:	10800017 	ldw	r2,0(r2)
 201ccc8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 201cccc:	e0bffe17 	ldw	r2,-8(fp)
 201ccd0:	10c00a04 	addi	r3,r2,40
 201ccd4:	e0bfff17 	ldw	r2,-4(fp)
 201ccd8:	10800217 	ldw	r2,8(r2)
 201ccdc:	100b883a 	mov	r5,r2
 201cce0:	1809883a 	mov	r4,r3
 201cce4:	201d2380 	call	201d238 <altera_avalon_jtag_uart_close>
}
 201cce8:	e037883a 	mov	sp,fp
 201ccec:	dfc00117 	ldw	ra,4(sp)
 201ccf0:	df000017 	ldw	fp,0(sp)
 201ccf4:	dec00204 	addi	sp,sp,8
 201ccf8:	f800283a 	ret

0201ccfc <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 201ccfc:	defffa04 	addi	sp,sp,-24
 201cd00:	dfc00515 	stw	ra,20(sp)
 201cd04:	df000415 	stw	fp,16(sp)
 201cd08:	df000404 	addi	fp,sp,16
 201cd0c:	e13ffd15 	stw	r4,-12(fp)
 201cd10:	e17ffe15 	stw	r5,-8(fp)
 201cd14:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 201cd18:	e0bffd17 	ldw	r2,-12(fp)
 201cd1c:	10800017 	ldw	r2,0(r2)
 201cd20:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 201cd24:	e0bffc17 	ldw	r2,-16(fp)
 201cd28:	10800a04 	addi	r2,r2,40
 201cd2c:	e1bfff17 	ldw	r6,-4(fp)
 201cd30:	e17ffe17 	ldw	r5,-8(fp)
 201cd34:	1009883a 	mov	r4,r2
 201cd38:	201d2a00 	call	201d2a0 <altera_avalon_jtag_uart_ioctl>
}
 201cd3c:	e037883a 	mov	sp,fp
 201cd40:	dfc00117 	ldw	ra,4(sp)
 201cd44:	df000017 	ldw	fp,0(sp)
 201cd48:	dec00204 	addi	sp,sp,8
 201cd4c:	f800283a 	ret

0201cd50 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 201cd50:	defff204 	addi	sp,sp,-56
 201cd54:	dfc00d15 	stw	ra,52(sp)
 201cd58:	df000c15 	stw	fp,48(sp)
 201cd5c:	df000c04 	addi	fp,sp,48
 201cd60:	e13ff915 	stw	r4,-28(fp)
 201cd64:	e17ffa15 	stw	r5,-24(fp)
 201cd68:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 201cd6c:	e0bff917 	ldw	r2,-28(fp)
 201cd70:	10800c04 	addi	r2,r2,48
 201cd74:	e0bff415 	stw	r2,-48(fp)
 201cd78:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 201cd7c:	e0bff80b 	ldhu	r2,-32(fp)
 201cd80:	e0fff884 	addi	r3,fp,-30
 201cd84:	180b883a 	mov	r5,r3
 201cd88:	1009883a 	mov	r4,r2
 201cd8c:	2016d340 	call	2016d34 <OSFlagCreate>
 201cd90:	1007883a 	mov	r3,r2
 201cd94:	e0bff417 	ldw	r2,-48(fp)
 201cd98:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 201cd9c:	e0bff917 	ldw	r2,-28(fp)
 201cda0:	10800a04 	addi	r2,r2,40
 201cda4:	e0bff515 	stw	r2,-44(fp)
 201cda8:	00800044 	movi	r2,1
 201cdac:	e0bff78d 	sth	r2,-34(fp)
 201cdb0:	e0bff78b 	ldhu	r2,-34(fp)
 201cdb4:	1009883a 	mov	r4,r2
 201cdb8:	201a5100 	call	201a510 <OSSemCreate>
 201cdbc:	1007883a 	mov	r3,r2
 201cdc0:	e0bff517 	ldw	r2,-44(fp)
 201cdc4:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 201cdc8:	e0bff917 	ldw	r2,-28(fp)
 201cdcc:	10800b04 	addi	r2,r2,44
 201cdd0:	e0bff615 	stw	r2,-40(fp)
 201cdd4:	00800044 	movi	r2,1
 201cdd8:	e0bff70d 	sth	r2,-36(fp)
 201cddc:	e0bff70b 	ldhu	r2,-36(fp)
 201cde0:	1009883a 	mov	r4,r2
 201cde4:	201a5100 	call	201a510 <OSSemCreate>
 201cde8:	1007883a 	mov	r3,r2
 201cdec:	e0bff617 	ldw	r2,-40(fp)
 201cdf0:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201cdf4:	e0bff917 	ldw	r2,-28(fp)
 201cdf8:	00c00044 	movi	r3,1
 201cdfc:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 201ce00:	e0bff917 	ldw	r2,-28(fp)
 201ce04:	10800017 	ldw	r2,0(r2)
 201ce08:	10800104 	addi	r2,r2,4
 201ce0c:	1007883a 	mov	r3,r2
 201ce10:	e0bff917 	ldw	r2,-28(fp)
 201ce14:	10800817 	ldw	r2,32(r2)
 201ce18:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 201ce1c:	e0bffb17 	ldw	r2,-20(fp)
 201ce20:	018080b4 	movhi	r6,514
 201ce24:	31b3a304 	addi	r6,r6,-12660
 201ce28:	e17ff917 	ldw	r5,-28(fp)
 201ce2c:	1009883a 	mov	r4,r2
 201ce30:	201e2c80 	call	201e2c8 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 201ce34:	e0bff917 	ldw	r2,-28(fp)
 201ce38:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 201ce3c:	e0bff917 	ldw	r2,-28(fp)
 201ce40:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 201ce44:	d0e76417 	ldw	r3,-25200(gp)
 201ce48:	e1fff917 	ldw	r7,-28(fp)
 201ce4c:	018080b4 	movhi	r6,514
 201ce50:	31b44d04 	addi	r6,r6,-11980
 201ce54:	180b883a 	mov	r5,r3
 201ce58:	1009883a 	mov	r4,r2
 201ce5c:	201ddb00 	call	201ddb0 <alt_alarm_start>
 201ce60:	1000040e 	bge	r2,zero,201ce74 <altera_avalon_jtag_uart_init+0x124>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 201ce64:	e0fff917 	ldw	r3,-28(fp)
 201ce68:	00a00034 	movhi	r2,32768
 201ce6c:	10bfffc4 	addi	r2,r2,-1
 201ce70:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 201ce74:	0001883a 	nop
 201ce78:	e037883a 	mov	sp,fp
 201ce7c:	dfc00117 	ldw	ra,4(sp)
 201ce80:	df000017 	ldw	fp,0(sp)
 201ce84:	dec00204 	addi	sp,sp,8
 201ce88:	f800283a 	ret

0201ce8c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 201ce8c:	defff104 	addi	sp,sp,-60
 201ce90:	dfc00e15 	stw	ra,56(sp)
 201ce94:	df000d15 	stw	fp,52(sp)
 201ce98:	df000d04 	addi	fp,sp,52
 201ce9c:	e13ffe15 	stw	r4,-8(fp)
 201cea0:	e17fff15 	stw	r5,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 201cea4:	e0bffe17 	ldw	r2,-8(fp)
 201cea8:	e0bff515 	stw	r2,-44(fp)
  unsigned int base = sp->base;
 201ceac:	e0bff517 	ldw	r2,-44(fp)
 201ceb0:	10800017 	ldw	r2,0(r2)
 201ceb4:	e0bff615 	stw	r2,-40(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201ceb8:	e0bff617 	ldw	r2,-40(fp)
 201cebc:	10800104 	addi	r2,r2,4
 201cec0:	10800037 	ldwio	r2,0(r2)
 201cec4:	e0bff715 	stw	r2,-36(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 201cec8:	e0bff717 	ldw	r2,-36(fp)
 201cecc:	1080c00c 	andi	r2,r2,768
 201ced0:	10009126 	beq	r2,zero,201d118 <altera_avalon_jtag_uart_irq+0x28c>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 201ced4:	e0bff717 	ldw	r2,-36(fp)
 201ced8:	1080400c 	andi	r2,r2,256
 201cedc:	10004726 	beq	r2,zero,201cffc <altera_avalon_jtag_uart_irq+0x170>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 201cee0:	00800074 	movhi	r2,1
 201cee4:	e0bff315 	stw	r2,-52(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201cee8:	e0bff517 	ldw	r2,-44(fp)
 201ceec:	10800d17 	ldw	r2,52(r2)
 201cef0:	10800044 	addi	r2,r2,1
 201cef4:	1081ffcc 	andi	r2,r2,2047
 201cef8:	e0bff815 	stw	r2,-32(fp)
        if (next == sp->rx_out)
 201cefc:	e0bff517 	ldw	r2,-44(fp)
 201cf00:	10c00e17 	ldw	r3,56(r2)
 201cf04:	e0bff817 	ldw	r2,-32(fp)
 201cf08:	18802726 	beq	r3,r2,201cfa8 <altera_avalon_jtag_uart_irq+0x11c>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 201cf0c:	e0bff617 	ldw	r2,-40(fp)
 201cf10:	10800037 	ldwio	r2,0(r2)
 201cf14:	e0bff315 	stw	r2,-52(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 201cf18:	e0bff317 	ldw	r2,-52(fp)
 201cf1c:	10a0000c 	andi	r2,r2,32768
 201cf20:	10002326 	beq	r2,zero,201cfb0 <altera_avalon_jtag_uart_irq+0x124>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 201cf24:	e0bff517 	ldw	r2,-44(fp)
 201cf28:	10800d17 	ldw	r2,52(r2)
 201cf2c:	e0fff317 	ldw	r3,-52(fp)
 201cf30:	1809883a 	mov	r4,r3
 201cf34:	e0fff517 	ldw	r3,-44(fp)
 201cf38:	1885883a 	add	r2,r3,r2
 201cf3c:	10801104 	addi	r2,r2,68
 201cf40:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201cf44:	e0bff517 	ldw	r2,-44(fp)
 201cf48:	10800d17 	ldw	r2,52(r2)
 201cf4c:	10800044 	addi	r2,r2,1
 201cf50:	10c1ffcc 	andi	r3,r2,2047
 201cf54:	e0bff517 	ldw	r2,-44(fp)
 201cf58:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 201cf5c:	e0bff517 	ldw	r2,-44(fp)
 201cf60:	10800c17 	ldw	r2,48(r2)
 201cf64:	e0bffa15 	stw	r2,-24(fp)
 201cf68:	00800044 	movi	r2,1
 201cf6c:	e0bffb0d 	sth	r2,-20(fp)
 201cf70:	00800044 	movi	r2,1
 201cf74:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201cf78:	d0a74f43 	ldbu	r2,-25283(gp)
 201cf7c:	10803fcc 	andi	r2,r2,255
 201cf80:	103fd926 	beq	r2,zero,201cee8 <altera_avalon_jtag_uart_irq+0x5c>
  {
    OSFlagPost (group, flags, opt, &err);
 201cf84:	e0bffb0b 	ldhu	r2,-20(fp)
 201cf88:	e0fffb83 	ldbu	r3,-18(fp)
 201cf8c:	e13ffcc4 	addi	r4,fp,-13
 201cf90:	200f883a 	mov	r7,r4
 201cf94:	180d883a 	mov	r6,r3
 201cf98:	100b883a 	mov	r5,r2
 201cf9c:	e13ffa17 	ldw	r4,-24(fp)
 201cfa0:	20179100 	call	2017910 <OSFlagPost>
      }
 201cfa4:	003fd006 	br	201cee8 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 201cfa8:	0001883a 	nop
 201cfac:	00000106 	br	201cfb4 <altera_avalon_jtag_uart_irq+0x128>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 201cfb0:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 201cfb4:	e0bff317 	ldw	r2,-52(fp)
 201cfb8:	10bfffec 	andhi	r2,r2,65535
 201cfbc:	10000f26 	beq	r2,zero,201cffc <altera_avalon_jtag_uart_irq+0x170>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201cfc0:	e0bff517 	ldw	r2,-44(fp)
 201cfc4:	10c00817 	ldw	r3,32(r2)
 201cfc8:	00bfff84 	movi	r2,-2
 201cfcc:	1886703a 	and	r3,r3,r2
 201cfd0:	e0bff517 	ldw	r2,-44(fp)
 201cfd4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 201cfd8:	e0bff617 	ldw	r2,-40(fp)
 201cfdc:	10800104 	addi	r2,r2,4
 201cfe0:	1007883a 	mov	r3,r2
 201cfe4:	e0bff517 	ldw	r2,-44(fp)
 201cfe8:	10800817 	ldw	r2,32(r2)
 201cfec:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201cff0:	e0bff617 	ldw	r2,-40(fp)
 201cff4:	10800104 	addi	r2,r2,4
 201cff8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 201cffc:	e0bff717 	ldw	r2,-36(fp)
 201d000:	1080800c 	andi	r2,r2,512
 201d004:	103fac26 	beq	r2,zero,201ceb8 <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 201d008:	e0bff717 	ldw	r2,-36(fp)
 201d00c:	1004d43a 	srli	r2,r2,16
 201d010:	e0bff415 	stw	r2,-48(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 201d014:	00002606 	br	201d0b0 <altera_avalon_jtag_uart_irq+0x224>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 201d018:	e0bff617 	ldw	r2,-40(fp)
 201d01c:	e0fff517 	ldw	r3,-44(fp)
 201d020:	18c01017 	ldw	r3,64(r3)
 201d024:	e13ff517 	ldw	r4,-44(fp)
 201d028:	20c7883a 	add	r3,r4,r3
 201d02c:	18c21104 	addi	r3,r3,2116
 201d030:	18c00003 	ldbu	r3,0(r3)
 201d034:	18c03fcc 	andi	r3,r3,255
 201d038:	18c0201c 	xori	r3,r3,128
 201d03c:	18ffe004 	addi	r3,r3,-128
 201d040:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201d044:	e0bff517 	ldw	r2,-44(fp)
 201d048:	10801017 	ldw	r2,64(r2)
 201d04c:	10800044 	addi	r2,r2,1
 201d050:	10c1ffcc 	andi	r3,r2,2047
 201d054:	e0bff517 	ldw	r2,-44(fp)
 201d058:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 201d05c:	e0bff517 	ldw	r2,-44(fp)
 201d060:	10800c17 	ldw	r2,48(r2)
 201d064:	e0bff915 	stw	r2,-28(fp)
 201d068:	00800084 	movi	r2,2
 201d06c:	e0bffc0d 	sth	r2,-16(fp)
 201d070:	00800044 	movi	r2,1
 201d074:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201d078:	d0a74f43 	ldbu	r2,-25283(gp)
 201d07c:	10803fcc 	andi	r2,r2,255
 201d080:	10000826 	beq	r2,zero,201d0a4 <altera_avalon_jtag_uart_irq+0x218>
  {
    OSFlagPost (group, flags, opt, &err);
 201d084:	e0bffc0b 	ldhu	r2,-16(fp)
 201d088:	e0fffc83 	ldbu	r3,-14(fp)
 201d08c:	e13ffd04 	addi	r4,fp,-12
 201d090:	200f883a 	mov	r7,r4
 201d094:	180d883a 	mov	r6,r3
 201d098:	100b883a 	mov	r5,r2
 201d09c:	e13ff917 	ldw	r4,-28(fp)
 201d0a0:	20179100 	call	2017910 <OSFlagPost>

        space--;
 201d0a4:	e0bff417 	ldw	r2,-48(fp)
 201d0a8:	10bfffc4 	addi	r2,r2,-1
 201d0ac:	e0bff415 	stw	r2,-48(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 201d0b0:	e0bff417 	ldw	r2,-48(fp)
 201d0b4:	10000526 	beq	r2,zero,201d0cc <altera_avalon_jtag_uart_irq+0x240>
 201d0b8:	e0bff517 	ldw	r2,-44(fp)
 201d0bc:	10c01017 	ldw	r3,64(r2)
 201d0c0:	e0bff517 	ldw	r2,-44(fp)
 201d0c4:	10800f17 	ldw	r2,60(r2)
 201d0c8:	18bfd31e 	bne	r3,r2,201d018 <altera_avalon_jtag_uart_irq+0x18c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 201d0cc:	e0bff417 	ldw	r2,-48(fp)
 201d0d0:	103f7926 	beq	r2,zero,201ceb8 <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 201d0d4:	e0bff517 	ldw	r2,-44(fp)
 201d0d8:	10c00817 	ldw	r3,32(r2)
 201d0dc:	00bfff44 	movi	r2,-3
 201d0e0:	1886703a 	and	r3,r3,r2
 201d0e4:	e0bff517 	ldw	r2,-44(fp)
 201d0e8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201d0ec:	e0bff517 	ldw	r2,-44(fp)
 201d0f0:	10800017 	ldw	r2,0(r2)
 201d0f4:	10800104 	addi	r2,r2,4
 201d0f8:	1007883a 	mov	r3,r2
 201d0fc:	e0bff517 	ldw	r2,-44(fp)
 201d100:	10800817 	ldw	r2,32(r2)
 201d104:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201d108:	e0bff617 	ldw	r2,-40(fp)
 201d10c:	10800104 	addi	r2,r2,4
 201d110:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 201d114:	003f6806 	br	201ceb8 <altera_avalon_jtag_uart_irq+0x2c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 201d118:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 201d11c:	0001883a 	nop
 201d120:	e037883a 	mov	sp,fp
 201d124:	dfc00117 	ldw	ra,4(sp)
 201d128:	df000017 	ldw	fp,0(sp)
 201d12c:	dec00204 	addi	sp,sp,8
 201d130:	f800283a 	ret

0201d134 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 201d134:	defff904 	addi	sp,sp,-28
 201d138:	dfc00615 	stw	ra,24(sp)
 201d13c:	df000515 	stw	fp,20(sp)
 201d140:	df000504 	addi	fp,sp,20
 201d144:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 201d148:	e0bfff17 	ldw	r2,-4(fp)
 201d14c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 201d150:	e0bffb17 	ldw	r2,-20(fp)
 201d154:	10800017 	ldw	r2,0(r2)
 201d158:	10800104 	addi	r2,r2,4
 201d15c:	10800037 	ldwio	r2,0(r2)
 201d160:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 201d164:	e0bffc17 	ldw	r2,-16(fp)
 201d168:	1081000c 	andi	r2,r2,1024
 201d16c:	10000b26 	beq	r2,zero,201d19c <altera_avalon_jtag_uart_timeout+0x68>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 201d170:	e0bffb17 	ldw	r2,-20(fp)
 201d174:	10800017 	ldw	r2,0(r2)
 201d178:	10800104 	addi	r2,r2,4
 201d17c:	1007883a 	mov	r3,r2
 201d180:	e0bffb17 	ldw	r2,-20(fp)
 201d184:	10800817 	ldw	r2,32(r2)
 201d188:	10810014 	ori	r2,r2,1024
 201d18c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 201d190:	e0bffb17 	ldw	r2,-20(fp)
 201d194:	10000915 	stw	zero,36(r2)
 201d198:	00002106 	br	201d220 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 201d19c:	e0bffb17 	ldw	r2,-20(fp)
 201d1a0:	10c00917 	ldw	r3,36(r2)
 201d1a4:	00a00034 	movhi	r2,32768
 201d1a8:	10bfff04 	addi	r2,r2,-4
 201d1ac:	10c01c36 	bltu	r2,r3,201d220 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 201d1b0:	e0bffb17 	ldw	r2,-20(fp)
 201d1b4:	10800917 	ldw	r2,36(r2)
 201d1b8:	10c00044 	addi	r3,r2,1
 201d1bc:	e0bffb17 	ldw	r2,-20(fp)
 201d1c0:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 201d1c4:	e0bffb17 	ldw	r2,-20(fp)
 201d1c8:	10c00917 	ldw	r3,36(r2)
 201d1cc:	e0bffb17 	ldw	r2,-20(fp)
 201d1d0:	10800117 	ldw	r2,4(r2)
 201d1d4:	18801236 	bltu	r3,r2,201d220 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 201d1d8:	e0bffb17 	ldw	r2,-20(fp)
 201d1dc:	10800c17 	ldw	r2,48(r2)
 201d1e0:	e0bffd15 	stw	r2,-12(fp)
 201d1e4:	00800104 	movi	r2,4
 201d1e8:	e0bffe0d 	sth	r2,-8(fp)
 201d1ec:	00800044 	movi	r2,1
 201d1f0:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201d1f4:	d0a74f43 	ldbu	r2,-25283(gp)
 201d1f8:	10803fcc 	andi	r2,r2,255
 201d1fc:	10000826 	beq	r2,zero,201d220 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 201d200:	e0bffe0b 	ldhu	r2,-8(fp)
 201d204:	e0fffe83 	ldbu	r3,-6(fp)
 201d208:	e13ffec4 	addi	r4,fp,-5
 201d20c:	200f883a 	mov	r7,r4
 201d210:	180d883a 	mov	r6,r3
 201d214:	100b883a 	mov	r5,r2
 201d218:	e13ffd17 	ldw	r4,-12(fp)
 201d21c:	20179100 	call	2017910 <OSFlagPost>
 201d220:	d0a76417 	ldw	r2,-25200(gp)
    }
  }

  return alt_ticks_per_second();
}
 201d224:	e037883a 	mov	sp,fp
 201d228:	dfc00117 	ldw	ra,4(sp)
 201d22c:	df000017 	ldw	fp,0(sp)
 201d230:	dec00204 	addi	sp,sp,8
 201d234:	f800283a 	ret

0201d238 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 201d238:	defffd04 	addi	sp,sp,-12
 201d23c:	df000215 	stw	fp,8(sp)
 201d240:	df000204 	addi	fp,sp,8
 201d244:	e13ffe15 	stw	r4,-8(fp)
 201d248:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 201d24c:	00000506 	br	201d264 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 201d250:	e0bfff17 	ldw	r2,-4(fp)
 201d254:	1090000c 	andi	r2,r2,16384
 201d258:	10000226 	beq	r2,zero,201d264 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 201d25c:	00bffd44 	movi	r2,-11
 201d260:	00000b06 	br	201d290 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 201d264:	e0bffe17 	ldw	r2,-8(fp)
 201d268:	10c01017 	ldw	r3,64(r2)
 201d26c:	e0bffe17 	ldw	r2,-8(fp)
 201d270:	10800f17 	ldw	r2,60(r2)
 201d274:	18800526 	beq	r3,r2,201d28c <altera_avalon_jtag_uart_close+0x54>
 201d278:	e0bffe17 	ldw	r2,-8(fp)
 201d27c:	10c00917 	ldw	r3,36(r2)
 201d280:	e0bffe17 	ldw	r2,-8(fp)
 201d284:	10800117 	ldw	r2,4(r2)
 201d288:	18bff136 	bltu	r3,r2,201d250 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 201d28c:	0005883a 	mov	r2,zero
}
 201d290:	e037883a 	mov	sp,fp
 201d294:	df000017 	ldw	fp,0(sp)
 201d298:	dec00104 	addi	sp,sp,4
 201d29c:	f800283a 	ret

0201d2a0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 201d2a0:	defffa04 	addi	sp,sp,-24
 201d2a4:	df000515 	stw	fp,20(sp)
 201d2a8:	df000504 	addi	fp,sp,20
 201d2ac:	e13ffd15 	stw	r4,-12(fp)
 201d2b0:	e17ffe15 	stw	r5,-8(fp)
 201d2b4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 201d2b8:	00bff9c4 	movi	r2,-25
 201d2bc:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 201d2c0:	e0bffe17 	ldw	r2,-8(fp)
 201d2c4:	10da8060 	cmpeqi	r3,r2,27137
 201d2c8:	1800031e 	bne	r3,zero,201d2d8 <altera_avalon_jtag_uart_ioctl+0x38>
 201d2cc:	109a80a0 	cmpeqi	r2,r2,27138
 201d2d0:	1000181e 	bne	r2,zero,201d334 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 201d2d4:	00002906 	br	201d37c <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 201d2d8:	e0bffd17 	ldw	r2,-12(fp)
 201d2dc:	10c00117 	ldw	r3,4(r2)
 201d2e0:	00a00034 	movhi	r2,32768
 201d2e4:	10bfffc4 	addi	r2,r2,-1
 201d2e8:	18802126 	beq	r3,r2,201d370 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 201d2ec:	e0bfff17 	ldw	r2,-4(fp)
 201d2f0:	10800017 	ldw	r2,0(r2)
 201d2f4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 201d2f8:	e0bffc17 	ldw	r2,-16(fp)
 201d2fc:	10800090 	cmplti	r2,r2,2
 201d300:	1000061e 	bne	r2,zero,201d31c <altera_avalon_jtag_uart_ioctl+0x7c>
 201d304:	e0fffc17 	ldw	r3,-16(fp)
 201d308:	00a00034 	movhi	r2,32768
 201d30c:	10bfffc4 	addi	r2,r2,-1
 201d310:	18800226 	beq	r3,r2,201d31c <altera_avalon_jtag_uart_ioctl+0x7c>
 201d314:	e0bffc17 	ldw	r2,-16(fp)
 201d318:	00000206 	br	201d324 <altera_avalon_jtag_uart_ioctl+0x84>
 201d31c:	00a00034 	movhi	r2,32768
 201d320:	10bfff84 	addi	r2,r2,-2
 201d324:	e0fffd17 	ldw	r3,-12(fp)
 201d328:	18800115 	stw	r2,4(r3)
      rc = 0;
 201d32c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 201d330:	00000f06 	br	201d370 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 201d334:	e0bffd17 	ldw	r2,-12(fp)
 201d338:	10c00117 	ldw	r3,4(r2)
 201d33c:	00a00034 	movhi	r2,32768
 201d340:	10bfffc4 	addi	r2,r2,-1
 201d344:	18800c26 	beq	r3,r2,201d378 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 201d348:	e0bffd17 	ldw	r2,-12(fp)
 201d34c:	10c00917 	ldw	r3,36(r2)
 201d350:	e0bffd17 	ldw	r2,-12(fp)
 201d354:	10800117 	ldw	r2,4(r2)
 201d358:	1885803a 	cmpltu	r2,r3,r2
 201d35c:	10c03fcc 	andi	r3,r2,255
 201d360:	e0bfff17 	ldw	r2,-4(fp)
 201d364:	10c00015 	stw	r3,0(r2)
      rc = 0;
 201d368:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 201d36c:	00000206 	br	201d378 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 201d370:	0001883a 	nop
 201d374:	00000106 	br	201d37c <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 201d378:	0001883a 	nop

  default:
    break;
  }

  return rc;
 201d37c:	e0bffb17 	ldw	r2,-20(fp)
}
 201d380:	e037883a 	mov	sp,fp
 201d384:	df000017 	ldw	fp,0(sp)
 201d388:	dec00104 	addi	sp,sp,4
 201d38c:	f800283a 	ret

0201d390 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 201d390:	deffed04 	addi	sp,sp,-76
 201d394:	dfc01215 	stw	ra,72(sp)
 201d398:	df001115 	stw	fp,68(sp)
 201d39c:	df001104 	addi	fp,sp,68
 201d3a0:	e13ffc15 	stw	r4,-16(fp)
 201d3a4:	e17ffd15 	stw	r5,-12(fp)
 201d3a8:	e1bffe15 	stw	r6,-8(fp)
 201d3ac:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 201d3b0:	e0bffd17 	ldw	r2,-12(fp)
 201d3b4:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 201d3b8:	e0bffc17 	ldw	r2,-16(fp)
 201d3bc:	10800a17 	ldw	r2,40(r2)
 201d3c0:	e0bff815 	stw	r2,-32(fp)
 201d3c4:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 201d3c8:	e0bff90b 	ldhu	r2,-28(fp)
 201d3cc:	e0fffb04 	addi	r3,fp,-20
 201d3d0:	180d883a 	mov	r6,r3
 201d3d4:	100b883a 	mov	r5,r2
 201d3d8:	e13ff817 	ldw	r4,-32(fp)
 201d3dc:	201a8280 	call	201a828 <OSSemPend>

  while (space > 0)
 201d3e0:	00006106 	br	201d568 <altera_avalon_jtag_uart_read+0x1d8>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 201d3e4:	e0bffc17 	ldw	r2,-16(fp)
 201d3e8:	10800d17 	ldw	r2,52(r2)
 201d3ec:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
 201d3f0:	e0bffc17 	ldw	r2,-16(fp)
 201d3f4:	10800e17 	ldw	r2,56(r2)
 201d3f8:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
 201d3fc:	e0fff317 	ldw	r3,-52(fp)
 201d400:	e0bff417 	ldw	r2,-48(fp)
 201d404:	18800536 	bltu	r3,r2,201d41c <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 201d408:	e0fff317 	ldw	r3,-52(fp)
 201d40c:	e0bff417 	ldw	r2,-48(fp)
 201d410:	1885c83a 	sub	r2,r3,r2
 201d414:	e0bff115 	stw	r2,-60(fp)
 201d418:	00000406 	br	201d42c <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 201d41c:	00c20004 	movi	r3,2048
 201d420:	e0bff417 	ldw	r2,-48(fp)
 201d424:	1885c83a 	sub	r2,r3,r2
 201d428:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 201d42c:	e0bff117 	ldw	r2,-60(fp)
 201d430:	10001e26 	beq	r2,zero,201d4ac <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 201d434:	e0fffe17 	ldw	r3,-8(fp)
 201d438:	e0bff117 	ldw	r2,-60(fp)
 201d43c:	1880022e 	bgeu	r3,r2,201d448 <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 201d440:	e0bffe17 	ldw	r2,-8(fp)
 201d444:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 201d448:	e0bffc17 	ldw	r2,-16(fp)
 201d44c:	10c01104 	addi	r3,r2,68
 201d450:	e0bff417 	ldw	r2,-48(fp)
 201d454:	1885883a 	add	r2,r3,r2
 201d458:	e1bff117 	ldw	r6,-60(fp)
 201d45c:	100b883a 	mov	r5,r2
 201d460:	e13ff017 	ldw	r4,-64(fp)
 201d464:	20067d00 	call	20067d0 <memcpy>
      ptr   += n;
 201d468:	e0fff017 	ldw	r3,-64(fp)
 201d46c:	e0bff117 	ldw	r2,-60(fp)
 201d470:	1885883a 	add	r2,r3,r2
 201d474:	e0bff015 	stw	r2,-64(fp)
      space -= n;
 201d478:	e0fffe17 	ldw	r3,-8(fp)
 201d47c:	e0bff117 	ldw	r2,-60(fp)
 201d480:	1885c83a 	sub	r2,r3,r2
 201d484:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201d488:	e0fff417 	ldw	r3,-48(fp)
 201d48c:	e0bff117 	ldw	r2,-60(fp)
 201d490:	1885883a 	add	r2,r3,r2
 201d494:	10c1ffcc 	andi	r3,r2,2047
 201d498:	e0bffc17 	ldw	r2,-16(fp)
 201d49c:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 201d4a0:	e0bffe17 	ldw	r2,-8(fp)
 201d4a4:	00bfcf16 	blt	zero,r2,201d3e4 <altera_avalon_jtag_uart_read+0x54>
 201d4a8:	00000106 	br	201d4b0 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 201d4ac:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 201d4b0:	e0fff017 	ldw	r3,-64(fp)
 201d4b4:	e0bffd17 	ldw	r2,-12(fp)
 201d4b8:	18802e1e 	bne	r3,r2,201d574 <altera_avalon_jtag_uart_read+0x1e4>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 201d4bc:	e0bfff17 	ldw	r2,-4(fp)
 201d4c0:	1090000c 	andi	r2,r2,16384
 201d4c4:	10002d1e 	bne	r2,zero,201d57c <altera_avalon_jtag_uart_read+0x1ec>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 201d4c8:	d0a74f43 	ldbu	r2,-25283(gp)
 201d4cc:	10803fcc 	andi	r2,r2,255
 201d4d0:	10800058 	cmpnei	r2,r2,1
 201d4d4:	1000161e 	bne	r2,zero,201d530 <altera_avalon_jtag_uart_read+0x1a0>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 201d4d8:	e0bffc17 	ldw	r2,-16(fp)
 201d4dc:	10800c17 	ldw	r2,48(r2)
 201d4e0:	e0bff215 	stw	r2,-56(fp)
 201d4e4:	00800144 	movi	r2,5
 201d4e8:	e0bff98d 	sth	r2,-26(fp)
 201d4ec:	00bfe0c4 	movi	r2,-125
 201d4f0:	e0bffa05 	stb	r2,-24(fp)
 201d4f4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 201d4f8:	d0a74f43 	ldbu	r2,-25283(gp)
 201d4fc:	10803fcc 	andi	r2,r2,255
 201d500:	10001526 	beq	r2,zero,201d558 <altera_avalon_jtag_uart_read+0x1c8>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 201d504:	e0fff98b 	ldhu	r3,-26(fp)
 201d508:	e13ffa03 	ldbu	r4,-24(fp)
 201d50c:	e17ffa8b 	ldhu	r5,-22(fp)
 201d510:	e0bffb44 	addi	r2,fp,-19
 201d514:	d8800015 	stw	r2,0(sp)
 201d518:	280f883a 	mov	r7,r5
 201d51c:	200d883a 	mov	r6,r4
 201d520:	180b883a 	mov	r5,r3
 201d524:	e13ff217 	ldw	r4,-56(fp)
 201d528:	20172f80 	call	20172f8 <OSFlagPend>
 201d52c:	00000a06 	br	201d558 <altera_avalon_jtag_uart_read+0x1c8>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 201d530:	0001883a 	nop
 201d534:	e0bffc17 	ldw	r2,-16(fp)
 201d538:	10c00d17 	ldw	r3,52(r2)
 201d53c:	e0bff317 	ldw	r2,-52(fp)
 201d540:	1880051e 	bne	r3,r2,201d558 <altera_avalon_jtag_uart_read+0x1c8>
 201d544:	e0bffc17 	ldw	r2,-16(fp)
 201d548:	10c00917 	ldw	r3,36(r2)
 201d54c:	e0bffc17 	ldw	r2,-16(fp)
 201d550:	10800117 	ldw	r2,4(r2)
 201d554:	18bff736 	bltu	r3,r2,201d534 <altera_avalon_jtag_uart_read+0x1a4>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 201d558:	e0bffc17 	ldw	r2,-16(fp)
 201d55c:	10c00d17 	ldw	r3,52(r2)
 201d560:	e0bff317 	ldw	r2,-52(fp)
 201d564:	18800726 	beq	r3,r2,201d584 <altera_avalon_jtag_uart_read+0x1f4>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 201d568:	e0bffe17 	ldw	r2,-8(fp)
 201d56c:	00bf9d16 	blt	zero,r2,201d3e4 <altera_avalon_jtag_uart_read+0x54>
 201d570:	00000506 	br	201d588 <altera_avalon_jtag_uart_read+0x1f8>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 201d574:	0001883a 	nop
 201d578:	00000306 	br	201d588 <altera_avalon_jtag_uart_read+0x1f8>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 201d57c:	0001883a 	nop
 201d580:	00000106 	br	201d588 <altera_avalon_jtag_uart_read+0x1f8>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 201d584:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 201d588:	e0bffc17 	ldw	r2,-16(fp)
 201d58c:	10800a17 	ldw	r2,40(r2)
 201d590:	1009883a 	mov	r4,r2
 201d594:	201aba00 	call	201aba0 <OSSemPost>

  if (ptr != buffer)
 201d598:	e0fff017 	ldw	r3,-64(fp)
 201d59c:	e0bffd17 	ldw	r2,-12(fp)
 201d5a0:	18801826 	beq	r3,r2,201d604 <altera_avalon_jtag_uart_read+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d5a4:	0005303a 	rdctl	r2,status
 201d5a8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d5ac:	e0fff717 	ldw	r3,-36(fp)
 201d5b0:	00bfff84 	movi	r2,-2
 201d5b4:	1884703a 	and	r2,r3,r2
 201d5b8:	1001703a 	wrctl	status,r2
  
  return context;
 201d5bc:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 201d5c0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201d5c4:	e0bffc17 	ldw	r2,-16(fp)
 201d5c8:	10800817 	ldw	r2,32(r2)
 201d5cc:	10c00054 	ori	r3,r2,1
 201d5d0:	e0bffc17 	ldw	r2,-16(fp)
 201d5d4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201d5d8:	e0bffc17 	ldw	r2,-16(fp)
 201d5dc:	10800017 	ldw	r2,0(r2)
 201d5e0:	10800104 	addi	r2,r2,4
 201d5e4:	1007883a 	mov	r3,r2
 201d5e8:	e0bffc17 	ldw	r2,-16(fp)
 201d5ec:	10800817 	ldw	r2,32(r2)
 201d5f0:	18800035 	stwio	r2,0(r3)
 201d5f4:	e0bff617 	ldw	r2,-40(fp)
 201d5f8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d5fc:	e0bff517 	ldw	r2,-44(fp)
 201d600:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 201d604:	e0fff017 	ldw	r3,-64(fp)
 201d608:	e0bffd17 	ldw	r2,-12(fp)
 201d60c:	18800426 	beq	r3,r2,201d620 <altera_avalon_jtag_uart_read+0x290>
    return ptr - buffer;
 201d610:	e0fff017 	ldw	r3,-64(fp)
 201d614:	e0bffd17 	ldw	r2,-12(fp)
 201d618:	1885c83a 	sub	r2,r3,r2
 201d61c:	00000606 	br	201d638 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 201d620:	e0bfff17 	ldw	r2,-4(fp)
 201d624:	1090000c 	andi	r2,r2,16384
 201d628:	10000226 	beq	r2,zero,201d634 <altera_avalon_jtag_uart_read+0x2a4>
    return -EWOULDBLOCK;
 201d62c:	00bffd44 	movi	r2,-11
 201d630:	00000106 	br	201d638 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 201d634:	00bffec4 	movi	r2,-5
}
 201d638:	e037883a 	mov	sp,fp
 201d63c:	dfc00117 	ldw	ra,4(sp)
 201d640:	df000017 	ldw	fp,0(sp)
 201d644:	dec00204 	addi	sp,sp,8
 201d648:	f800283a 	ret

0201d64c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 201d64c:	deffed04 	addi	sp,sp,-76
 201d650:	dfc01215 	stw	ra,72(sp)
 201d654:	df001115 	stw	fp,68(sp)
 201d658:	df001104 	addi	fp,sp,68
 201d65c:	e13ffc15 	stw	r4,-16(fp)
 201d660:	e17ffd15 	stw	r5,-12(fp)
 201d664:	e1bffe15 	stw	r6,-8(fp)
 201d668:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 201d66c:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 201d670:	e0bffd17 	ldw	r2,-12(fp)
 201d674:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 201d678:	e0bffc17 	ldw	r2,-16(fp)
 201d67c:	10800b17 	ldw	r2,44(r2)
 201d680:	e0bff815 	stw	r2,-32(fp)
 201d684:	e03ff90d 	sth	zero,-28(fp)
 201d688:	e0bff90b 	ldhu	r2,-28(fp)
 201d68c:	e0fffb44 	addi	r3,fp,-19
 201d690:	180d883a 	mov	r6,r3
 201d694:	100b883a 	mov	r5,r2
 201d698:	e13ff817 	ldw	r4,-32(fp)
 201d69c:	201a8280 	call	201a828 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 201d6a0:	00003706 	br	201d780 <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 201d6a4:	e0bffc17 	ldw	r2,-16(fp)
 201d6a8:	10800f17 	ldw	r2,60(r2)
 201d6ac:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
 201d6b0:	e0bffc17 	ldw	r2,-16(fp)
 201d6b4:	10801017 	ldw	r2,64(r2)
 201d6b8:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 201d6bc:	e0fff417 	ldw	r3,-48(fp)
 201d6c0:	e0bff017 	ldw	r2,-64(fp)
 201d6c4:	1880062e 	bgeu	r3,r2,201d6e0 <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 201d6c8:	e0fff017 	ldw	r3,-64(fp)
 201d6cc:	e0bff417 	ldw	r2,-48(fp)
 201d6d0:	1885c83a 	sub	r2,r3,r2
 201d6d4:	10bfffc4 	addi	r2,r2,-1
 201d6d8:	e0bff115 	stw	r2,-60(fp)
 201d6dc:	00000b06 	br	201d70c <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 201d6e0:	e0bff017 	ldw	r2,-64(fp)
 201d6e4:	10000526 	beq	r2,zero,201d6fc <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 201d6e8:	00c20004 	movi	r3,2048
 201d6ec:	e0bff417 	ldw	r2,-48(fp)
 201d6f0:	1885c83a 	sub	r2,r3,r2
 201d6f4:	e0bff115 	stw	r2,-60(fp)
 201d6f8:	00000406 	br	201d70c <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 201d6fc:	00c1ffc4 	movi	r3,2047
 201d700:	e0bff417 	ldw	r2,-48(fp)
 201d704:	1885c83a 	sub	r2,r3,r2
 201d708:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 201d70c:	e0bff117 	ldw	r2,-60(fp)
 201d710:	10001e26 	beq	r2,zero,201d78c <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 201d714:	e0fffe17 	ldw	r3,-8(fp)
 201d718:	e0bff117 	ldw	r2,-60(fp)
 201d71c:	1880022e 	bgeu	r3,r2,201d728 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 201d720:	e0bffe17 	ldw	r2,-8(fp)
 201d724:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 201d728:	e0bffc17 	ldw	r2,-16(fp)
 201d72c:	10c21104 	addi	r3,r2,2116
 201d730:	e0bff417 	ldw	r2,-48(fp)
 201d734:	1885883a 	add	r2,r3,r2
 201d738:	e1bff117 	ldw	r6,-60(fp)
 201d73c:	e17ffd17 	ldw	r5,-12(fp)
 201d740:	1009883a 	mov	r4,r2
 201d744:	20067d00 	call	20067d0 <memcpy>
      ptr   += n;
 201d748:	e0fffd17 	ldw	r3,-12(fp)
 201d74c:	e0bff117 	ldw	r2,-60(fp)
 201d750:	1885883a 	add	r2,r3,r2
 201d754:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 201d758:	e0fffe17 	ldw	r3,-8(fp)
 201d75c:	e0bff117 	ldw	r2,-60(fp)
 201d760:	1885c83a 	sub	r2,r3,r2
 201d764:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201d768:	e0fff417 	ldw	r3,-48(fp)
 201d76c:	e0bff117 	ldw	r2,-60(fp)
 201d770:	1885883a 	add	r2,r3,r2
 201d774:	10c1ffcc 	andi	r3,r2,2047
 201d778:	e0bffc17 	ldw	r2,-16(fp)
 201d77c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 201d780:	e0bffe17 	ldw	r2,-8(fp)
 201d784:	00bfc716 	blt	zero,r2,201d6a4 <altera_avalon_jtag_uart_write+0x58>
 201d788:	00000106 	br	201d790 <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 201d78c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d790:	0005303a 	rdctl	r2,status
 201d794:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d798:	e0fff717 	ldw	r3,-36(fp)
 201d79c:	00bfff84 	movi	r2,-2
 201d7a0:	1884703a 	and	r2,r3,r2
 201d7a4:	1001703a 	wrctl	status,r2
  
  return context;
 201d7a8:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 201d7ac:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 201d7b0:	e0bffc17 	ldw	r2,-16(fp)
 201d7b4:	10800817 	ldw	r2,32(r2)
 201d7b8:	10c00094 	ori	r3,r2,2
 201d7bc:	e0bffc17 	ldw	r2,-16(fp)
 201d7c0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201d7c4:	e0bffc17 	ldw	r2,-16(fp)
 201d7c8:	10800017 	ldw	r2,0(r2)
 201d7cc:	10800104 	addi	r2,r2,4
 201d7d0:	1007883a 	mov	r3,r2
 201d7d4:	e0bffc17 	ldw	r2,-16(fp)
 201d7d8:	10800817 	ldw	r2,32(r2)
 201d7dc:	18800035 	stwio	r2,0(r3)
 201d7e0:	e0bff617 	ldw	r2,-40(fp)
 201d7e4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d7e8:	e0bff317 	ldw	r2,-52(fp)
 201d7ec:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 201d7f0:	e0bffe17 	ldw	r2,-8(fp)
 201d7f4:	00802a0e 	bge	zero,r2,201d8a0 <altera_avalon_jtag_uart_write+0x254>
    {
      if (flags & O_NONBLOCK)
 201d7f8:	e0bfff17 	ldw	r2,-4(fp)
 201d7fc:	1090000c 	andi	r2,r2,16384
 201d800:	10002a1e 	bne	r2,zero,201d8ac <altera_avalon_jtag_uart_write+0x260>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 201d804:	d0a74f43 	ldbu	r2,-25283(gp)
 201d808:	10803fcc 	andi	r2,r2,255
 201d80c:	10800058 	cmpnei	r2,r2,1
 201d810:	1000161e 	bne	r2,zero,201d86c <altera_avalon_jtag_uart_write+0x220>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 201d814:	e0bffc17 	ldw	r2,-16(fp)
 201d818:	10800c17 	ldw	r2,48(r2)
 201d81c:	e0bff515 	stw	r2,-44(fp)
 201d820:	00800184 	movi	r2,6
 201d824:	e0bff98d 	sth	r2,-26(fp)
 201d828:	00bfe0c4 	movi	r2,-125
 201d82c:	e0bffa05 	stb	r2,-24(fp)
 201d830:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 201d834:	d0a74f43 	ldbu	r2,-25283(gp)
 201d838:	10803fcc 	andi	r2,r2,255
 201d83c:	10001526 	beq	r2,zero,201d894 <altera_avalon_jtag_uart_write+0x248>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 201d840:	e0fff98b 	ldhu	r3,-26(fp)
 201d844:	e13ffa03 	ldbu	r4,-24(fp)
 201d848:	e17ffa8b 	ldhu	r5,-22(fp)
 201d84c:	e0bffb04 	addi	r2,fp,-20
 201d850:	d8800015 	stw	r2,0(sp)
 201d854:	280f883a 	mov	r7,r5
 201d858:	200d883a 	mov	r6,r4
 201d85c:	180b883a 	mov	r5,r3
 201d860:	e13ff517 	ldw	r4,-44(fp)
 201d864:	20172f80 	call	20172f8 <OSFlagPend>
 201d868:	00000a06 	br	201d894 <altera_avalon_jtag_uart_write+0x248>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 201d86c:	0001883a 	nop
 201d870:	e0bffc17 	ldw	r2,-16(fp)
 201d874:	10c01017 	ldw	r3,64(r2)
 201d878:	e0bff017 	ldw	r2,-64(fp)
 201d87c:	1880051e 	bne	r3,r2,201d894 <altera_avalon_jtag_uart_write+0x248>
 201d880:	e0bffc17 	ldw	r2,-16(fp)
 201d884:	10c00917 	ldw	r3,36(r2)
 201d888:	e0bffc17 	ldw	r2,-16(fp)
 201d88c:	10800117 	ldw	r2,4(r2)
 201d890:	18bff736 	bltu	r3,r2,201d870 <altera_avalon_jtag_uart_write+0x224>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 201d894:	e0bffc17 	ldw	r2,-16(fp)
 201d898:	10800917 	ldw	r2,36(r2)
 201d89c:	1000051e 	bne	r2,zero,201d8b4 <altera_avalon_jtag_uart_write+0x268>
         break;
    }
  }
  while (count > 0);
 201d8a0:	e0bffe17 	ldw	r2,-8(fp)
 201d8a4:	00bfb616 	blt	zero,r2,201d780 <altera_avalon_jtag_uart_write+0x134>
 201d8a8:	00000306 	br	201d8b8 <altera_avalon_jtag_uart_write+0x26c>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 201d8ac:	0001883a 	nop
 201d8b0:	00000106 	br	201d8b8 <altera_avalon_jtag_uart_write+0x26c>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 201d8b4:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 201d8b8:	e0bffc17 	ldw	r2,-16(fp)
 201d8bc:	10800b17 	ldw	r2,44(r2)
 201d8c0:	1009883a 	mov	r4,r2
 201d8c4:	201aba00 	call	201aba0 <OSSemPost>

  if (ptr != start)
 201d8c8:	e0fffd17 	ldw	r3,-12(fp)
 201d8cc:	e0bff217 	ldw	r2,-56(fp)
 201d8d0:	18800426 	beq	r3,r2,201d8e4 <altera_avalon_jtag_uart_write+0x298>
    return ptr - start;
 201d8d4:	e0fffd17 	ldw	r3,-12(fp)
 201d8d8:	e0bff217 	ldw	r2,-56(fp)
 201d8dc:	1885c83a 	sub	r2,r3,r2
 201d8e0:	00000606 	br	201d8fc <altera_avalon_jtag_uart_write+0x2b0>
  else if (flags & O_NONBLOCK)
 201d8e4:	e0bfff17 	ldw	r2,-4(fp)
 201d8e8:	1090000c 	andi	r2,r2,16384
 201d8ec:	10000226 	beq	r2,zero,201d8f8 <altera_avalon_jtag_uart_write+0x2ac>
    return -EWOULDBLOCK;
 201d8f0:	00bffd44 	movi	r2,-11
 201d8f4:	00000106 	br	201d8fc <altera_avalon_jtag_uart_write+0x2b0>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 201d8f8:	00bffec4 	movi	r2,-5
}
 201d8fc:	e037883a 	mov	sp,fp
 201d900:	dfc00117 	ldw	ra,4(sp)
 201d904:	df000017 	ldw	fp,0(sp)
 201d908:	dec00204 	addi	sp,sp,8
 201d90c:	f800283a 	ret

0201d910 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 201d910:	defff904 	addi	sp,sp,-28
 201d914:	dfc00615 	stw	ra,24(sp)
 201d918:	df000515 	stw	fp,20(sp)
 201d91c:	df000504 	addi	fp,sp,20
 201d920:	e13ffe15 	stw	r4,-8(fp)
 201d924:	e17fff15 	stw	r5,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 201d928:	0007883a 	mov	r3,zero
 201d92c:	e0bffe17 	ldw	r2,-8(fp)
 201d930:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 201d934:	e0bffe17 	ldw	r2,-8(fp)
 201d938:	10800104 	addi	r2,r2,4
 201d93c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d940:	0005303a 	rdctl	r2,status
 201d944:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d948:	e0fffc17 	ldw	r3,-16(fp)
 201d94c:	00bfff84 	movi	r2,-2
 201d950:	1884703a 	and	r2,r3,r2
 201d954:	1001703a 	wrctl	status,r2
  
  return context;
 201d958:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 201d95c:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
 201d960:	201e7380 	call	201e738 <alt_tick>
 201d964:	e0bffb17 	ldw	r2,-20(fp)
 201d968:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d96c:	e0bffd17 	ldw	r2,-12(fp)
 201d970:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 201d974:	0001883a 	nop
 201d978:	e037883a 	mov	sp,fp
 201d97c:	dfc00117 	ldw	ra,4(sp)
 201d980:	df000017 	ldw	fp,0(sp)
 201d984:	dec00204 	addi	sp,sp,8
 201d988:	f800283a 	ret

0201d98c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 201d98c:	defff904 	addi	sp,sp,-28
 201d990:	dfc00615 	stw	ra,24(sp)
 201d994:	df000515 	stw	fp,20(sp)
 201d998:	df000504 	addi	fp,sp,20
 201d99c:	e13ffc15 	stw	r4,-16(fp)
 201d9a0:	e17ffd15 	stw	r5,-12(fp)
 201d9a4:	e1bffe15 	stw	r6,-8(fp)
 201d9a8:	e1ffff15 	stw	r7,-4(fp)
 201d9ac:	e0bfff17 	ldw	r2,-4(fp)
 201d9b0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 201d9b4:	d0a76417 	ldw	r2,-25200(gp)
 201d9b8:	1000021e 	bne	r2,zero,201d9c4 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 201d9bc:	e0bffb17 	ldw	r2,-20(fp)
 201d9c0:	d0a76415 	stw	r2,-25200(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 201d9c4:	e0bffc17 	ldw	r2,-16(fp)
 201d9c8:	10800104 	addi	r2,r2,4
 201d9cc:	00c001c4 	movi	r3,7
 201d9d0:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 201d9d4:	018080b4 	movhi	r6,514
 201d9d8:	31b64404 	addi	r6,r6,-9968
 201d9dc:	e17ffc17 	ldw	r5,-16(fp)
 201d9e0:	e13ffe17 	ldw	r4,-8(fp)
 201d9e4:	201e2c80 	call	201e2c8 <alt_irq_register>
#endif  
}
 201d9e8:	0001883a 	nop
 201d9ec:	e037883a 	mov	sp,fp
 201d9f0:	dfc00117 	ldw	ra,4(sp)
 201d9f4:	df000017 	ldw	fp,0(sp)
 201d9f8:	dec00204 	addi	sp,sp,8
 201d9fc:	f800283a 	ret

0201da00 <alt_up_accelerometer_spi_open_dev>:

#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_up_avalon_accelerometer_spi_regs.h"

alt_up_accelerometer_spi_dev* alt_up_accelerometer_spi_open_dev(const char* name)
{
 201da00:	defffc04 	addi	sp,sp,-16
 201da04:	dfc00315 	stw	ra,12(sp)
 201da08:	df000215 	stw	fp,8(sp)
 201da0c:	df000204 	addi	fp,sp,8
 201da10:	e13fff15 	stw	r4,-4(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_accelerometer_spi_dev *dev = (alt_up_accelerometer_spi_dev*)alt_find_dev(name, &alt_dev_list);
 201da14:	d1600e04 	addi	r5,gp,-32712
 201da18:	e13fff17 	ldw	r4,-4(fp)
 201da1c:	201e0c40 	call	201e0c4 <alt_find_dev>
 201da20:	e0bffe15 	stw	r2,-8(fp)

  return dev;
 201da24:	e0bffe17 	ldw	r2,-8(fp)
}
 201da28:	e037883a 	mov	sp,fp
 201da2c:	dfc00117 	ldw	ra,4(sp)
 201da30:	df000017 	ldw	fp,0(sp)
 201da34:	dec00204 	addi	sp,sp,8
 201da38:	f800283a 	ret

0201da3c <alt_up_accelerometer_spi_read_address_register>:
 * @param addr -- a pointer to the location where the read address should be stored
 *
 * @return 0 for success 
 **/
int alt_up_accelerometer_spi_read_address_register(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 *addr)
{
 201da3c:	defffd04 	addi	sp,sp,-12
 201da40:	df000215 	stw	fp,8(sp)
 201da44:	df000204 	addi	fp,sp,8
 201da48:	e13ffe15 	stw	r4,-8(fp)
 201da4c:	e17fff15 	stw	r5,-4(fp)
	// reads data from the device Address register
	*(addr) = IORD_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base); 
 201da50:	e0bffe17 	ldw	r2,-8(fp)
 201da54:	10800a17 	ldw	r2,40(r2)
 201da58:	10800023 	ldbuio	r2,0(r2)
 201da5c:	10803fcc 	andi	r2,r2,255
 201da60:	1007883a 	mov	r3,r2
 201da64:	e0bfff17 	ldw	r2,-4(fp)
 201da68:	10c00005 	stb	r3,0(r2)

	return 0;
 201da6c:	0005883a 	mov	r2,zero
}
 201da70:	e037883a 	mov	sp,fp
 201da74:	df000017 	ldw	fp,0(sp)
 201da78:	dec00104 	addi	sp,sp,4
 201da7c:	f800283a 	ret

0201da80 <alt_up_accelerometer_spi_read>:
 * @param data -- a pointer to the location where the read data should be stored
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_read(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 *data)
{
 201da80:	defffc04 	addi	sp,sp,-16
 201da84:	df000315 	stw	fp,12(sp)
 201da88:	df000304 	addi	fp,sp,12
 201da8c:	e13ffd15 	stw	r4,-12(fp)
 201da90:	2805883a 	mov	r2,r5
 201da94:	e1bfff15 	stw	r6,-4(fp)
 201da98:	e0bffe05 	stb	r2,-8(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201da9c:	e0bffd17 	ldw	r2,-12(fp)
 201daa0:	10800a17 	ldw	r2,40(r2)
 201daa4:	1007883a 	mov	r3,r2
 201daa8:	e0bffe03 	ldbu	r2,-8(fp)
 201daac:	10800fcc 	andi	r2,r2,63
 201dab0:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(data) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 201dab4:	e0bffd17 	ldw	r2,-12(fp)
 201dab8:	10800a17 	ldw	r2,40(r2)
 201dabc:	10800044 	addi	r2,r2,1
 201dac0:	10800023 	ldbuio	r2,0(r2)
 201dac4:	10803fcc 	andi	r2,r2,255
 201dac8:	1007883a 	mov	r3,r2
 201dacc:	e0bfff17 	ldw	r2,-4(fp)
 201dad0:	10c00005 	stb	r3,0(r2)

	return 0;
 201dad4:	0005883a 	mov	r2,zero
}
 201dad8:	e037883a 	mov	sp,fp
 201dadc:	df000017 	ldw	fp,0(sp)
 201dae0:	dec00104 	addi	sp,sp,4
 201dae4:	f800283a 	ret

0201dae8 <alt_up_accelerometer_spi_write>:
 * @param data -- the data to be written
 *
 * @return 0 for success
 **/
int alt_up_accelerometer_spi_write(alt_up_accelerometer_spi_dev *accel_spi, alt_u8 addr, alt_u8 data)
{
 201dae8:	defffc04 	addi	sp,sp,-16
 201daec:	df000315 	stw	fp,12(sp)
 201daf0:	df000304 	addi	fp,sp,12
 201daf4:	e13ffd15 	stw	r4,-12(fp)
 201daf8:	2807883a 	mov	r3,r5
 201dafc:	3005883a 	mov	r2,r6
 201db00:	e0fffe05 	stb	r3,-8(fp)
 201db04:	e0bfff05 	stb	r2,-4(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, addr & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201db08:	e0bffd17 	ldw	r2,-12(fp)
 201db0c:	10800a17 	ldw	r2,40(r2)
 201db10:	1007883a 	mov	r3,r2
 201db14:	e0bffe03 	ldbu	r2,-8(fp)
 201db18:	10800fcc 	andi	r2,r2,63
 201db1c:	18800025 	stbio	r2,0(r3)

	// write data to the device Data register
	IOWR_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base, data & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK); 
 201db20:	e0bffd17 	ldw	r2,-12(fp)
 201db24:	10800a17 	ldw	r2,40(r2)
 201db28:	10800044 	addi	r2,r2,1
 201db2c:	1007883a 	mov	r3,r2
 201db30:	e0bfff03 	ldbu	r2,-4(fp)
 201db34:	18800025 	stbio	r2,0(r3)

	return 0;
 201db38:	0005883a 	mov	r2,zero
}
 201db3c:	e037883a 	mov	sp,fp
 201db40:	df000017 	ldw	fp,0(sp)
 201db44:	dec00104 	addi	sp,sp,4
 201db48:	f800283a 	ret

0201db4c <alt_up_accelerometer_spi_read_x_axis>:
 * @param x_axis -- a pointer to the location where the x axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_x_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *x_axis)
{
 201db4c:	defffd04 	addi	sp,sp,-12
 201db50:	df000215 	stw	fp,8(sp)
 201db54:	df000204 	addi	fp,sp,8
 201db58:	e13ffe15 	stw	r4,-8(fp)
 201db5c:	e17fff15 	stw	r5,-4(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201db60:	e0bffe17 	ldw	r2,-8(fp)
 201db64:	10800a17 	ldw	r2,40(r2)
 201db68:	1007883a 	mov	r3,r2
 201db6c:	00800c84 	movi	r2,50
 201db70:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 201db74:	e0bffe17 	ldw	r2,-8(fp)
 201db78:	10800a17 	ldw	r2,40(r2)
 201db7c:	10800044 	addi	r2,r2,1
 201db80:	10800023 	ldbuio	r2,0(r2)
 201db84:	10803fcc 	andi	r2,r2,255
 201db88:	10ffffcc 	andi	r3,r2,65535
 201db8c:	e0bfff17 	ldw	r2,-4(fp)
 201db90:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_X_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201db94:	e0bffe17 	ldw	r2,-8(fp)
 201db98:	10800a17 	ldw	r2,40(r2)
 201db9c:	1007883a 	mov	r3,r2
 201dba0:	00800cc4 	movi	r2,51
 201dba4:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(x_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 201dba8:	e0bffe17 	ldw	r2,-8(fp)
 201dbac:	10800a17 	ldw	r2,40(r2)
 201dbb0:	10800044 	addi	r2,r2,1
 201dbb4:	10800023 	ldbuio	r2,0(r2)
 201dbb8:	10803fcc 	andi	r2,r2,255
 201dbbc:	10bfffcc 	andi	r2,r2,65535
 201dbc0:	1004923a 	slli	r2,r2,8
 201dbc4:	e0ffff17 	ldw	r3,-4(fp)
 201dbc8:	18c00017 	ldw	r3,0(r3)
 201dbcc:	1885883a 	add	r2,r3,r2
 201dbd0:	1007883a 	mov	r3,r2
 201dbd4:	e0bfff17 	ldw	r2,-4(fp)
 201dbd8:	10c00015 	stw	r3,0(r2)

	if (*(x_axis) & 0x00008000)
 201dbdc:	e0bfff17 	ldw	r2,-4(fp)
 201dbe0:	10800017 	ldw	r2,0(r2)
 201dbe4:	10a0000c 	andi	r2,r2,32768
 201dbe8:	10000626 	beq	r2,zero,201dc04 <alt_up_accelerometer_spi_read_x_axis+0xb8>
	{
		*(x_axis) |= 0xFFFF0000;
 201dbec:	e0bfff17 	ldw	r2,-4(fp)
 201dbf0:	10800017 	ldw	r2,0(r2)
 201dbf4:	10bffff4 	orhi	r2,r2,65535
 201dbf8:	1007883a 	mov	r3,r2
 201dbfc:	e0bfff17 	ldw	r2,-4(fp)
 201dc00:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 201dc04:	0005883a 	mov	r2,zero
}
 201dc08:	e037883a 	mov	sp,fp
 201dc0c:	df000017 	ldw	fp,0(sp)
 201dc10:	dec00104 	addi	sp,sp,4
 201dc14:	f800283a 	ret

0201dc18 <alt_up_accelerometer_spi_read_y_axis>:
 * @param y_axis -- a pointer to the location where the y axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_y_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *y_axis)
{
 201dc18:	defffd04 	addi	sp,sp,-12
 201dc1c:	df000215 	stw	fp,8(sp)
 201dc20:	df000204 	addi	fp,sp,8
 201dc24:	e13ffe15 	stw	r4,-8(fp)
 201dc28:	e17fff15 	stw	r5,-4(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201dc2c:	e0bffe17 	ldw	r2,-8(fp)
 201dc30:	10800a17 	ldw	r2,40(r2)
 201dc34:	1007883a 	mov	r3,r2
 201dc38:	00800d04 	movi	r2,52
 201dc3c:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 201dc40:	e0bffe17 	ldw	r2,-8(fp)
 201dc44:	10800a17 	ldw	r2,40(r2)
 201dc48:	10800044 	addi	r2,r2,1
 201dc4c:	10800023 	ldbuio	r2,0(r2)
 201dc50:	10803fcc 	andi	r2,r2,255
 201dc54:	10ffffcc 	andi	r3,r2,65535
 201dc58:	e0bfff17 	ldw	r2,-4(fp)
 201dc5c:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Y_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201dc60:	e0bffe17 	ldw	r2,-8(fp)
 201dc64:	10800a17 	ldw	r2,40(r2)
 201dc68:	1007883a 	mov	r3,r2
 201dc6c:	00800d44 	movi	r2,53
 201dc70:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(y_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 201dc74:	e0bffe17 	ldw	r2,-8(fp)
 201dc78:	10800a17 	ldw	r2,40(r2)
 201dc7c:	10800044 	addi	r2,r2,1
 201dc80:	10800023 	ldbuio	r2,0(r2)
 201dc84:	10803fcc 	andi	r2,r2,255
 201dc88:	10bfffcc 	andi	r2,r2,65535
 201dc8c:	1004923a 	slli	r2,r2,8
 201dc90:	e0ffff17 	ldw	r3,-4(fp)
 201dc94:	18c00017 	ldw	r3,0(r3)
 201dc98:	1885883a 	add	r2,r3,r2
 201dc9c:	1007883a 	mov	r3,r2
 201dca0:	e0bfff17 	ldw	r2,-4(fp)
 201dca4:	10c00015 	stw	r3,0(r2)

	if (*(y_axis) & 0x00008000)
 201dca8:	e0bfff17 	ldw	r2,-4(fp)
 201dcac:	10800017 	ldw	r2,0(r2)
 201dcb0:	10a0000c 	andi	r2,r2,32768
 201dcb4:	10000626 	beq	r2,zero,201dcd0 <alt_up_accelerometer_spi_read_y_axis+0xb8>
	{
		*(y_axis) |= 0xFFFF0000;
 201dcb8:	e0bfff17 	ldw	r2,-4(fp)
 201dcbc:	10800017 	ldw	r2,0(r2)
 201dcc0:	10bffff4 	orhi	r2,r2,65535
 201dcc4:	1007883a 	mov	r3,r2
 201dcc8:	e0bfff17 	ldw	r2,-4(fp)
 201dccc:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 201dcd0:	0005883a 	mov	r2,zero
}
 201dcd4:	e037883a 	mov	sp,fp
 201dcd8:	df000017 	ldw	fp,0(sp)
 201dcdc:	dec00104 	addi	sp,sp,4
 201dce0:	f800283a 	ret

0201dce4 <alt_up_accelerometer_spi_read_z_axis>:
 * @param z_axis -- a pointer to the location where the z axis data should be stored
 *
 * @return 0 for success or -1 for failure
 **/
int alt_up_accelerometer_spi_read_z_axis(alt_up_accelerometer_spi_dev *accel_spi, alt_32 *z_axis)
{
 201dce4:	defffd04 	addi	sp,sp,-12
 201dce8:	df000215 	stw	fp,8(sp)
 201dcec:	df000204 	addi	fp,sp,8
 201dcf0:	e13ffe15 	stw	r4,-8(fp)
 201dcf4:	e17fff15 	stw	r5,-4(fp)
	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_LOWER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201dcf8:	e0bffe17 	ldw	r2,-8(fp)
 201dcfc:	10800a17 	ldw	r2,40(r2)
 201dd00:	1007883a 	mov	r3,r2
 201dd04:	00800d84 	movi	r2,54
 201dd08:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) = IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK;
 201dd0c:	e0bffe17 	ldw	r2,-8(fp)
 201dd10:	10800a17 	ldw	r2,40(r2)
 201dd14:	10800044 	addi	r2,r2,1
 201dd18:	10800023 	ldbuio	r2,0(r2)
 201dd1c:	10803fcc 	andi	r2,r2,255
 201dd20:	10ffffcc 	andi	r3,r2,65535
 201dd24:	e0bfff17 	ldw	r2,-4(fp)
 201dd28:	10c00015 	stw	r3,0(r2)

	// set the register address in the Address register
	IOWR_ALT_UP_ACCELEROMETER_SPI_ADDRESS(accel_spi->base, ACCELEROMETER_SPI_Z_AXIS_UPPER_BYTE & ALT_UP_ACCELEROMETER_SPI_ADDRESS_ADDR_MSK); 
 201dd2c:	e0bffe17 	ldw	r2,-8(fp)
 201dd30:	10800a17 	ldw	r2,40(r2)
 201dd34:	1007883a 	mov	r3,r2
 201dd38:	00800dc4 	movi	r2,55
 201dd3c:	18800025 	stbio	r2,0(r3)

	// read data to the device Data register
	*(z_axis) += (IORD_ALT_UP_ACCELEROMETER_SPI_DATA(accel_spi->base) & ALT_UP_ACCELEROMETER_SPI_DATA_DATA_MSK) << 8;
 201dd40:	e0bffe17 	ldw	r2,-8(fp)
 201dd44:	10800a17 	ldw	r2,40(r2)
 201dd48:	10800044 	addi	r2,r2,1
 201dd4c:	10800023 	ldbuio	r2,0(r2)
 201dd50:	10803fcc 	andi	r2,r2,255
 201dd54:	10bfffcc 	andi	r2,r2,65535
 201dd58:	1004923a 	slli	r2,r2,8
 201dd5c:	e0ffff17 	ldw	r3,-4(fp)
 201dd60:	18c00017 	ldw	r3,0(r3)
 201dd64:	1885883a 	add	r2,r3,r2
 201dd68:	1007883a 	mov	r3,r2
 201dd6c:	e0bfff17 	ldw	r2,-4(fp)
 201dd70:	10c00015 	stw	r3,0(r2)

	if (*(z_axis) & 0x00008000)
 201dd74:	e0bfff17 	ldw	r2,-4(fp)
 201dd78:	10800017 	ldw	r2,0(r2)
 201dd7c:	10a0000c 	andi	r2,r2,32768
 201dd80:	10000626 	beq	r2,zero,201dd9c <alt_up_accelerometer_spi_read_z_axis+0xb8>
	{
		*(z_axis) |= 0xFFFF0000;
 201dd84:	e0bfff17 	ldw	r2,-4(fp)
 201dd88:	10800017 	ldw	r2,0(r2)
 201dd8c:	10bffff4 	orhi	r2,r2,65535
 201dd90:	1007883a 	mov	r3,r2
 201dd94:	e0bfff17 	ldw	r2,-4(fp)
 201dd98:	10c00015 	stw	r3,0(r2)
	}

	return 0;
 201dd9c:	0005883a 	mov	r2,zero
}
 201dda0:	e037883a 	mov	sp,fp
 201dda4:	df000017 	ldw	fp,0(sp)
 201dda8:	dec00104 	addi	sp,sp,4
 201ddac:	f800283a 	ret

0201ddb0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 201ddb0:	defff504 	addi	sp,sp,-44
 201ddb4:	df000a15 	stw	fp,40(sp)
 201ddb8:	df000a04 	addi	fp,sp,40
 201ddbc:	e13ffc15 	stw	r4,-16(fp)
 201ddc0:	e17ffd15 	stw	r5,-12(fp)
 201ddc4:	e1bffe15 	stw	r6,-8(fp)
 201ddc8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 201ddcc:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 201ddd0:	d0a76417 	ldw	r2,-25200(gp)
  
  if (alt_ticks_per_second ())
 201ddd4:	10003c26 	beq	r2,zero,201dec8 <alt_alarm_start+0x118>
  {
    if (alarm)
 201ddd8:	e0bffc17 	ldw	r2,-16(fp)
 201dddc:	10003826 	beq	r2,zero,201dec0 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 201dde0:	e0bffc17 	ldw	r2,-16(fp)
 201dde4:	e0fffe17 	ldw	r3,-8(fp)
 201dde8:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 201ddec:	e0bffc17 	ldw	r2,-16(fp)
 201ddf0:	e0ffff17 	ldw	r3,-4(fp)
 201ddf4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ddf8:	0005303a 	rdctl	r2,status
 201ddfc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201de00:	e0fff917 	ldw	r3,-28(fp)
 201de04:	00bfff84 	movi	r2,-2
 201de08:	1884703a 	and	r2,r3,r2
 201de0c:	1001703a 	wrctl	status,r2
  
  return context;
 201de10:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 201de14:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 201de18:	d0a76517 	ldw	r2,-25196(gp)
      
      current_nticks = alt_nticks();
 201de1c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 201de20:	e0fffd17 	ldw	r3,-12(fp)
 201de24:	e0bff617 	ldw	r2,-40(fp)
 201de28:	1885883a 	add	r2,r3,r2
 201de2c:	10c00044 	addi	r3,r2,1
 201de30:	e0bffc17 	ldw	r2,-16(fp)
 201de34:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 201de38:	e0bffc17 	ldw	r2,-16(fp)
 201de3c:	10c00217 	ldw	r3,8(r2)
 201de40:	e0bff617 	ldw	r2,-40(fp)
 201de44:	1880042e 	bgeu	r3,r2,201de58 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 201de48:	e0bffc17 	ldw	r2,-16(fp)
 201de4c:	00c00044 	movi	r3,1
 201de50:	10c00405 	stb	r3,16(r2)
 201de54:	00000206 	br	201de60 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 201de58:	e0bffc17 	ldw	r2,-16(fp)
 201de5c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 201de60:	e0bffc17 	ldw	r2,-16(fp)
 201de64:	d0e03304 	addi	r3,gp,-32564
 201de68:	e0fffa15 	stw	r3,-24(fp)
 201de6c:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 201de70:	e0bffb17 	ldw	r2,-20(fp)
 201de74:	e0fffa17 	ldw	r3,-24(fp)
 201de78:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 201de7c:	e0bffa17 	ldw	r2,-24(fp)
 201de80:	10c00017 	ldw	r3,0(r2)
 201de84:	e0bffb17 	ldw	r2,-20(fp)
 201de88:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 201de8c:	e0bffa17 	ldw	r2,-24(fp)
 201de90:	10800017 	ldw	r2,0(r2)
 201de94:	e0fffb17 	ldw	r3,-20(fp)
 201de98:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 201de9c:	e0bffa17 	ldw	r2,-24(fp)
 201dea0:	e0fffb17 	ldw	r3,-20(fp)
 201dea4:	10c00015 	stw	r3,0(r2)
 201dea8:	e0bff817 	ldw	r2,-32(fp)
 201deac:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201deb0:	e0bff717 	ldw	r2,-36(fp)
 201deb4:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 201deb8:	0005883a 	mov	r2,zero
 201debc:	00000306 	br	201decc <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 201dec0:	00bffa84 	movi	r2,-22
 201dec4:	00000106 	br	201decc <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 201dec8:	00bfde84 	movi	r2,-134
  }
}
 201decc:	e037883a 	mov	sp,fp
 201ded0:	df000017 	ldw	fp,0(sp)
 201ded4:	dec00104 	addi	sp,sp,4
 201ded8:	f800283a 	ret

0201dedc <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 201dedc:	defffe04 	addi	sp,sp,-8
 201dee0:	df000115 	stw	fp,4(sp)
 201dee4:	df000104 	addi	fp,sp,4
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 201dee8:	e03fff15 	stw	zero,-4(fp)
 201deec:	00000506 	br	201df04 <alt_dcache_flush_all+0x28>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
 201def0:	e0bfff17 	ldw	r2,-4(fp)
 201def4:	1000003b 	flushd	0(r2)
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
 201def8:	e0bfff17 	ldw	r2,-4(fp)
 201defc:	10800804 	addi	r2,r2,32
 201df00:	e0bfff15 	stw	r2,-4(fp)
 201df04:	e0bfff17 	ldw	r2,-4(fp)
 201df08:	10820030 	cmpltui	r2,r2,2048
 201df0c:	103ff81e 	bne	r2,zero,201def0 <alt_dcache_flush_all+0x14>
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 201df10:	0001883a 	nop
 201df14:	e037883a 	mov	sp,fp
 201df18:	df000017 	ldw	fp,0(sp)
 201df1c:	dec00104 	addi	sp,sp,4
 201df20:	f800283a 	ret

0201df24 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 201df24:	defffe04 	addi	sp,sp,-8
 201df28:	dfc00115 	stw	ra,4(sp)
 201df2c:	df000015 	stw	fp,0(sp)
 201df30:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 201df34:	d0a01117 	ldw	r2,-32700(gp)
 201df38:	10000326 	beq	r2,zero,201df48 <alt_get_errno+0x24>
 201df3c:	d0a01117 	ldw	r2,-32700(gp)
 201df40:	103ee83a 	callr	r2
 201df44:	00000106 	br	201df4c <alt_get_errno+0x28>
 201df48:	d0a74604 	addi	r2,gp,-25320
}
 201df4c:	e037883a 	mov	sp,fp
 201df50:	dfc00117 	ldw	ra,4(sp)
 201df54:	df000017 	ldw	fp,0(sp)
 201df58:	dec00204 	addi	sp,sp,8
 201df5c:	f800283a 	ret

0201df60 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 201df60:	defffa04 	addi	sp,sp,-24
 201df64:	dfc00515 	stw	ra,20(sp)
 201df68:	df000415 	stw	fp,16(sp)
 201df6c:	df000404 	addi	fp,sp,16
 201df70:	e13ffe15 	stw	r4,-8(fp)
 201df74:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 201df78:	e0bffe17 	ldw	r2,-8(fp)
 201df7c:	10000326 	beq	r2,zero,201df8c <alt_dev_llist_insert+0x2c>
 201df80:	e0bffe17 	ldw	r2,-8(fp)
 201df84:	10800217 	ldw	r2,8(r2)
 201df88:	1000061e 	bne	r2,zero,201dfa4 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 201df8c:	201df240 	call	201df24 <alt_get_errno>
 201df90:	1007883a 	mov	r3,r2
 201df94:	00800584 	movi	r2,22
 201df98:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 201df9c:	00bffa84 	movi	r2,-22
 201dfa0:	00001306 	br	201dff0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 201dfa4:	e0bffe17 	ldw	r2,-8(fp)
 201dfa8:	e0ffff17 	ldw	r3,-4(fp)
 201dfac:	e0fffc15 	stw	r3,-16(fp)
 201dfb0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 201dfb4:	e0bffd17 	ldw	r2,-12(fp)
 201dfb8:	e0fffc17 	ldw	r3,-16(fp)
 201dfbc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 201dfc0:	e0bffc17 	ldw	r2,-16(fp)
 201dfc4:	10c00017 	ldw	r3,0(r2)
 201dfc8:	e0bffd17 	ldw	r2,-12(fp)
 201dfcc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 201dfd0:	e0bffc17 	ldw	r2,-16(fp)
 201dfd4:	10800017 	ldw	r2,0(r2)
 201dfd8:	e0fffd17 	ldw	r3,-12(fp)
 201dfdc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 201dfe0:	e0bffc17 	ldw	r2,-16(fp)
 201dfe4:	e0fffd17 	ldw	r3,-12(fp)
 201dfe8:	10c00015 	stw	r3,0(r2)

  return 0;  
 201dfec:	0005883a 	mov	r2,zero
}
 201dff0:	e037883a 	mov	sp,fp
 201dff4:	dfc00117 	ldw	ra,4(sp)
 201dff8:	df000017 	ldw	fp,0(sp)
 201dffc:	dec00204 	addi	sp,sp,8
 201e000:	f800283a 	ret

0201e004 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 201e004:	defffd04 	addi	sp,sp,-12
 201e008:	dfc00215 	stw	ra,8(sp)
 201e00c:	df000115 	stw	fp,4(sp)
 201e010:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 201e014:	008080b4 	movhi	r2,514
 201e018:	10bd0404 	addi	r2,r2,-3056
 201e01c:	e0bfff15 	stw	r2,-4(fp)
 201e020:	00000606 	br	201e03c <_do_ctors+0x38>
        (*ctor) (); 
 201e024:	e0bfff17 	ldw	r2,-4(fp)
 201e028:	10800017 	ldw	r2,0(r2)
 201e02c:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 201e030:	e0bfff17 	ldw	r2,-4(fp)
 201e034:	10bfff04 	addi	r2,r2,-4
 201e038:	e0bfff15 	stw	r2,-4(fp)
 201e03c:	e0ffff17 	ldw	r3,-4(fp)
 201e040:	008080b4 	movhi	r2,514
 201e044:	10bd0504 	addi	r2,r2,-3052
 201e048:	18bff62e 	bgeu	r3,r2,201e024 <_do_ctors+0x20>
        (*ctor) (); 
}
 201e04c:	0001883a 	nop
 201e050:	e037883a 	mov	sp,fp
 201e054:	dfc00117 	ldw	ra,4(sp)
 201e058:	df000017 	ldw	fp,0(sp)
 201e05c:	dec00204 	addi	sp,sp,8
 201e060:	f800283a 	ret

0201e064 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 201e064:	defffd04 	addi	sp,sp,-12
 201e068:	dfc00215 	stw	ra,8(sp)
 201e06c:	df000115 	stw	fp,4(sp)
 201e070:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 201e074:	008080b4 	movhi	r2,514
 201e078:	10bd0404 	addi	r2,r2,-3056
 201e07c:	e0bfff15 	stw	r2,-4(fp)
 201e080:	00000606 	br	201e09c <_do_dtors+0x38>
        (*dtor) (); 
 201e084:	e0bfff17 	ldw	r2,-4(fp)
 201e088:	10800017 	ldw	r2,0(r2)
 201e08c:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 201e090:	e0bfff17 	ldw	r2,-4(fp)
 201e094:	10bfff04 	addi	r2,r2,-4
 201e098:	e0bfff15 	stw	r2,-4(fp)
 201e09c:	e0ffff17 	ldw	r3,-4(fp)
 201e0a0:	008080b4 	movhi	r2,514
 201e0a4:	10bd0504 	addi	r2,r2,-3052
 201e0a8:	18bff62e 	bgeu	r3,r2,201e084 <_do_dtors+0x20>
        (*dtor) (); 
}
 201e0ac:	0001883a 	nop
 201e0b0:	e037883a 	mov	sp,fp
 201e0b4:	dfc00117 	ldw	ra,4(sp)
 201e0b8:	df000017 	ldw	fp,0(sp)
 201e0bc:	dec00204 	addi	sp,sp,8
 201e0c0:	f800283a 	ret

0201e0c4 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 201e0c4:	defffa04 	addi	sp,sp,-24
 201e0c8:	dfc00515 	stw	ra,20(sp)
 201e0cc:	df000415 	stw	fp,16(sp)
 201e0d0:	df000404 	addi	fp,sp,16
 201e0d4:	e13ffe15 	stw	r4,-8(fp)
 201e0d8:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 201e0dc:	e0bfff17 	ldw	r2,-4(fp)
 201e0e0:	10800017 	ldw	r2,0(r2)
 201e0e4:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 201e0e8:	e13ffe17 	ldw	r4,-8(fp)
 201e0ec:	2006d380 	call	2006d38 <strlen>
 201e0f0:	10800044 	addi	r2,r2,1
 201e0f4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 201e0f8:	00000d06 	br	201e130 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 201e0fc:	e0bffc17 	ldw	r2,-16(fp)
 201e100:	10800217 	ldw	r2,8(r2)
 201e104:	e0fffd17 	ldw	r3,-12(fp)
 201e108:	180d883a 	mov	r6,r3
 201e10c:	e17ffe17 	ldw	r5,-8(fp)
 201e110:	1009883a 	mov	r4,r2
 201e114:	201ef500 	call	201ef50 <memcmp>
 201e118:	1000021e 	bne	r2,zero,201e124 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 201e11c:	e0bffc17 	ldw	r2,-16(fp)
 201e120:	00000706 	br	201e140 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 201e124:	e0bffc17 	ldw	r2,-16(fp)
 201e128:	10800017 	ldw	r2,0(r2)
 201e12c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 201e130:	e0fffc17 	ldw	r3,-16(fp)
 201e134:	e0bfff17 	ldw	r2,-4(fp)
 201e138:	18bff01e 	bne	r3,r2,201e0fc <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 201e13c:	0005883a 	mov	r2,zero
}
 201e140:	e037883a 	mov	sp,fp
 201e144:	dfc00117 	ldw	ra,4(sp)
 201e148:	df000017 	ldw	fp,0(sp)
 201e14c:	dec00204 	addi	sp,sp,8
 201e150:	f800283a 	ret

0201e154 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 201e154:	defffe04 	addi	sp,sp,-8
 201e158:	dfc00115 	stw	ra,4(sp)
 201e15c:	df000015 	stw	fp,0(sp)
 201e160:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 201e164:	01440004 	movi	r5,4096
 201e168:	0009883a 	mov	r4,zero
 201e16c:	201eda00 	call	201eda0 <alt_icache_flush>
#endif
}
 201e170:	0001883a 	nop
 201e174:	e037883a 	mov	sp,fp
 201e178:	dfc00117 	ldw	ra,4(sp)
 201e17c:	df000017 	ldw	fp,0(sp)
 201e180:	dec00204 	addi	sp,sp,8
 201e184:	f800283a 	ret

0201e188 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 201e188:	defff904 	addi	sp,sp,-28
 201e18c:	dfc00615 	stw	ra,24(sp)
 201e190:	df000515 	stw	fp,20(sp)
 201e194:	df000504 	addi	fp,sp,20
 201e198:	e13ffc15 	stw	r4,-16(fp)
 201e19c:	e17ffd15 	stw	r5,-12(fp)
 201e1a0:	e1bffe15 	stw	r6,-8(fp)
 201e1a4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 201e1a8:	e1bfff17 	ldw	r6,-4(fp)
 201e1ac:	e17ffe17 	ldw	r5,-8(fp)
 201e1b0:	e13ffd17 	ldw	r4,-12(fp)
 201e1b4:	201e5480 	call	201e548 <open>
 201e1b8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 201e1bc:	e0bffb17 	ldw	r2,-20(fp)
 201e1c0:	10001c16 	blt	r2,zero,201e234 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 201e1c4:	008080b4 	movhi	r2,514
 201e1c8:	10811104 	addi	r2,r2,1092
 201e1cc:	e0fffb17 	ldw	r3,-20(fp)
 201e1d0:	18c00324 	muli	r3,r3,12
 201e1d4:	10c5883a 	add	r2,r2,r3
 201e1d8:	10c00017 	ldw	r3,0(r2)
 201e1dc:	e0bffc17 	ldw	r2,-16(fp)
 201e1e0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 201e1e4:	008080b4 	movhi	r2,514
 201e1e8:	10811104 	addi	r2,r2,1092
 201e1ec:	e0fffb17 	ldw	r3,-20(fp)
 201e1f0:	18c00324 	muli	r3,r3,12
 201e1f4:	10c5883a 	add	r2,r2,r3
 201e1f8:	10800104 	addi	r2,r2,4
 201e1fc:	10c00017 	ldw	r3,0(r2)
 201e200:	e0bffc17 	ldw	r2,-16(fp)
 201e204:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 201e208:	008080b4 	movhi	r2,514
 201e20c:	10811104 	addi	r2,r2,1092
 201e210:	e0fffb17 	ldw	r3,-20(fp)
 201e214:	18c00324 	muli	r3,r3,12
 201e218:	10c5883a 	add	r2,r2,r3
 201e21c:	10800204 	addi	r2,r2,8
 201e220:	10c00017 	ldw	r3,0(r2)
 201e224:	e0bffc17 	ldw	r2,-16(fp)
 201e228:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 201e22c:	e13ffb17 	ldw	r4,-20(fp)
 201e230:	20143300 	call	2014330 <alt_release_fd>
  }
} 
 201e234:	0001883a 	nop
 201e238:	e037883a 	mov	sp,fp
 201e23c:	dfc00117 	ldw	ra,4(sp)
 201e240:	df000017 	ldw	fp,0(sp)
 201e244:	dec00204 	addi	sp,sp,8
 201e248:	f800283a 	ret

0201e24c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 201e24c:	defffb04 	addi	sp,sp,-20
 201e250:	dfc00415 	stw	ra,16(sp)
 201e254:	df000315 	stw	fp,12(sp)
 201e258:	df000304 	addi	fp,sp,12
 201e25c:	e13ffd15 	stw	r4,-12(fp)
 201e260:	e17ffe15 	stw	r5,-8(fp)
 201e264:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 201e268:	01c07fc4 	movi	r7,511
 201e26c:	01800044 	movi	r6,1
 201e270:	e17ffd17 	ldw	r5,-12(fp)
 201e274:	010080b4 	movhi	r4,514
 201e278:	21011404 	addi	r4,r4,1104
 201e27c:	201e1880 	call	201e188 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 201e280:	01c07fc4 	movi	r7,511
 201e284:	000d883a 	mov	r6,zero
 201e288:	e17ffe17 	ldw	r5,-8(fp)
 201e28c:	010080b4 	movhi	r4,514
 201e290:	21011104 	addi	r4,r4,1092
 201e294:	201e1880 	call	201e188 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 201e298:	01c07fc4 	movi	r7,511
 201e29c:	01800044 	movi	r6,1
 201e2a0:	e17fff17 	ldw	r5,-4(fp)
 201e2a4:	010080b4 	movhi	r4,514
 201e2a8:	21011704 	addi	r4,r4,1116
 201e2ac:	201e1880 	call	201e188 <alt_open_fd>
}  
 201e2b0:	0001883a 	nop
 201e2b4:	e037883a 	mov	sp,fp
 201e2b8:	dfc00117 	ldw	ra,4(sp)
 201e2bc:	df000017 	ldw	fp,0(sp)
 201e2c0:	dec00204 	addi	sp,sp,8
 201e2c4:	f800283a 	ret

0201e2c8 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 201e2c8:	defff004 	addi	sp,sp,-64
 201e2cc:	df000f15 	stw	fp,60(sp)
 201e2d0:	df000f04 	addi	fp,sp,60
 201e2d4:	e13ffd15 	stw	r4,-12(fp)
 201e2d8:	e17ffe15 	stw	r5,-8(fp)
 201e2dc:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
 201e2e0:	00bffa84 	movi	r2,-22
 201e2e4:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 201e2e8:	e0bffd17 	ldw	r2,-12(fp)
 201e2ec:	10800828 	cmpgeui	r2,r2,32
 201e2f0:	1000501e 	bne	r2,zero,201e434 <alt_irq_register+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e2f4:	0005303a 	rdctl	r2,status
 201e2f8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e2fc:	e0fff617 	ldw	r3,-40(fp)
 201e300:	00bfff84 	movi	r2,-2
 201e304:	1884703a 	and	r2,r3,r2
 201e308:	1001703a 	wrctl	status,r2
  
  return context;
 201e30c:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
 201e310:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
 201e314:	008080f4 	movhi	r2,515
 201e318:	10b99204 	addi	r2,r2,-6584
 201e31c:	e0fffd17 	ldw	r3,-12(fp)
 201e320:	180690fa 	slli	r3,r3,3
 201e324:	10c5883a 	add	r2,r2,r3
 201e328:	e0ffff17 	ldw	r3,-4(fp)
 201e32c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
 201e330:	008080f4 	movhi	r2,515
 201e334:	10b99204 	addi	r2,r2,-6584
 201e338:	e0fffd17 	ldw	r3,-12(fp)
 201e33c:	180690fa 	slli	r3,r3,3
 201e340:	10c5883a 	add	r2,r2,r3
 201e344:	10800104 	addi	r2,r2,4
 201e348:	e0fffe17 	ldw	r3,-8(fp)
 201e34c:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 201e350:	e0bfff17 	ldw	r2,-4(fp)
 201e354:	10001926 	beq	r2,zero,201e3bc <alt_irq_register+0xf4>
 201e358:	e0bffd17 	ldw	r2,-12(fp)
 201e35c:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e360:	0005303a 	rdctl	r2,status
 201e364:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e368:	e0fff717 	ldw	r3,-36(fp)
 201e36c:	00bfff84 	movi	r2,-2
 201e370:	1884703a 	and	r2,r3,r2
 201e374:	1001703a 	wrctl	status,r2
  
  return context;
 201e378:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 201e37c:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 201e380:	00c00044 	movi	r3,1
 201e384:	e0bff217 	ldw	r2,-56(fp)
 201e388:	1884983a 	sll	r2,r3,r2
 201e38c:	1007883a 	mov	r3,r2
 201e390:	d0a76317 	ldw	r2,-25204(gp)
 201e394:	1884b03a 	or	r2,r3,r2
 201e398:	d0a76315 	stw	r2,-25204(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 201e39c:	d0a76317 	ldw	r2,-25204(gp)
 201e3a0:	100170fa 	wrctl	ienable,r2
 201e3a4:	e0bff817 	ldw	r2,-32(fp)
 201e3a8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e3ac:	e0bff917 	ldw	r2,-28(fp)
 201e3b0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 201e3b4:	0005883a 	mov	r2,zero
 201e3b8:	00001906 	br	201e420 <alt_irq_register+0x158>
 201e3bc:	e0bffd17 	ldw	r2,-12(fp)
 201e3c0:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e3c4:	0005303a 	rdctl	r2,status
 201e3c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e3cc:	e0fffa17 	ldw	r3,-24(fp)
 201e3d0:	00bfff84 	movi	r2,-2
 201e3d4:	1884703a 	and	r2,r3,r2
 201e3d8:	1001703a 	wrctl	status,r2
  
  return context;
 201e3dc:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 201e3e0:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 201e3e4:	00c00044 	movi	r3,1
 201e3e8:	e0bff417 	ldw	r2,-48(fp)
 201e3ec:	1884983a 	sll	r2,r3,r2
 201e3f0:	0084303a 	nor	r2,zero,r2
 201e3f4:	1007883a 	mov	r3,r2
 201e3f8:	d0a76317 	ldw	r2,-25204(gp)
 201e3fc:	1884703a 	and	r2,r3,r2
 201e400:	d0a76315 	stw	r2,-25204(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 201e404:	d0a76317 	ldw	r2,-25204(gp)
 201e408:	100170fa 	wrctl	ienable,r2
 201e40c:	e0bffb17 	ldw	r2,-20(fp)
 201e410:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e414:	e0bffc17 	ldw	r2,-16(fp)
 201e418:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 201e41c:	0005883a 	mov	r2,zero
 201e420:	e0bff115 	stw	r2,-60(fp)
 201e424:	e0bff317 	ldw	r2,-52(fp)
 201e428:	e0bff515 	stw	r2,-44(fp)
 201e42c:	e0bff517 	ldw	r2,-44(fp)
 201e430:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
 201e434:	e0bff117 	ldw	r2,-60(fp)
}
 201e438:	e037883a 	mov	sp,fp
 201e43c:	df000017 	ldw	fp,0(sp)
 201e440:	dec00104 	addi	sp,sp,4
 201e444:	f800283a 	ret

0201e448 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 201e448:	defffe04 	addi	sp,sp,-8
 201e44c:	dfc00115 	stw	ra,4(sp)
 201e450:	df000015 	stw	fp,0(sp)
 201e454:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 201e458:	d0a01117 	ldw	r2,-32700(gp)
 201e45c:	10000326 	beq	r2,zero,201e46c <alt_get_errno+0x24>
 201e460:	d0a01117 	ldw	r2,-32700(gp)
 201e464:	103ee83a 	callr	r2
 201e468:	00000106 	br	201e470 <alt_get_errno+0x28>
 201e46c:	d0a74604 	addi	r2,gp,-25320
}
 201e470:	e037883a 	mov	sp,fp
 201e474:	dfc00117 	ldw	ra,4(sp)
 201e478:	df000017 	ldw	fp,0(sp)
 201e47c:	dec00204 	addi	sp,sp,8
 201e480:	f800283a 	ret

0201e484 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 201e484:	defffd04 	addi	sp,sp,-12
 201e488:	df000215 	stw	fp,8(sp)
 201e48c:	df000204 	addi	fp,sp,8
 201e490:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 201e494:	e0bfff17 	ldw	r2,-4(fp)
 201e498:	10800217 	ldw	r2,8(r2)
 201e49c:	10d00034 	orhi	r3,r2,16384
 201e4a0:	e0bfff17 	ldw	r2,-4(fp)
 201e4a4:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 201e4a8:	e03ffe15 	stw	zero,-8(fp)
 201e4ac:	00001d06 	br	201e524 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 201e4b0:	008080b4 	movhi	r2,514
 201e4b4:	10811104 	addi	r2,r2,1092
 201e4b8:	e0fffe17 	ldw	r3,-8(fp)
 201e4bc:	18c00324 	muli	r3,r3,12
 201e4c0:	10c5883a 	add	r2,r2,r3
 201e4c4:	10c00017 	ldw	r3,0(r2)
 201e4c8:	e0bfff17 	ldw	r2,-4(fp)
 201e4cc:	10800017 	ldw	r2,0(r2)
 201e4d0:	1880111e 	bne	r3,r2,201e518 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 201e4d4:	008080b4 	movhi	r2,514
 201e4d8:	10811104 	addi	r2,r2,1092
 201e4dc:	e0fffe17 	ldw	r3,-8(fp)
 201e4e0:	18c00324 	muli	r3,r3,12
 201e4e4:	10c5883a 	add	r2,r2,r3
 201e4e8:	10800204 	addi	r2,r2,8
 201e4ec:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 201e4f0:	1000090e 	bge	r2,zero,201e518 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 201e4f4:	e0bffe17 	ldw	r2,-8(fp)
 201e4f8:	10c00324 	muli	r3,r2,12
 201e4fc:	008080b4 	movhi	r2,514
 201e500:	10811104 	addi	r2,r2,1092
 201e504:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 201e508:	e0bfff17 	ldw	r2,-4(fp)
 201e50c:	18800226 	beq	r3,r2,201e518 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 201e510:	00bffcc4 	movi	r2,-13
 201e514:	00000806 	br	201e538 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 201e518:	e0bffe17 	ldw	r2,-8(fp)
 201e51c:	10800044 	addi	r2,r2,1
 201e520:	e0bffe15 	stw	r2,-8(fp)
 201e524:	d0a01017 	ldw	r2,-32704(gp)
 201e528:	1007883a 	mov	r3,r2
 201e52c:	e0bffe17 	ldw	r2,-8(fp)
 201e530:	18bfdf2e 	bgeu	r3,r2,201e4b0 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 201e534:	0005883a 	mov	r2,zero
}
 201e538:	e037883a 	mov	sp,fp
 201e53c:	df000017 	ldw	fp,0(sp)
 201e540:	dec00104 	addi	sp,sp,4
 201e544:	f800283a 	ret

0201e548 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 201e548:	defff604 	addi	sp,sp,-40
 201e54c:	dfc00915 	stw	ra,36(sp)
 201e550:	df000815 	stw	fp,32(sp)
 201e554:	df000804 	addi	fp,sp,32
 201e558:	e13ffd15 	stw	r4,-12(fp)
 201e55c:	e17ffe15 	stw	r5,-8(fp)
 201e560:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 201e564:	00bfffc4 	movi	r2,-1
 201e568:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 201e56c:	00bffb44 	movi	r2,-19
 201e570:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 201e574:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 201e578:	d1600e04 	addi	r5,gp,-32712
 201e57c:	e13ffd17 	ldw	r4,-12(fp)
 201e580:	201e0c40 	call	201e0c4 <alt_find_dev>
 201e584:	e0bff815 	stw	r2,-32(fp)
 201e588:	e0bff817 	ldw	r2,-32(fp)
 201e58c:	1000051e 	bne	r2,zero,201e5a4 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 201e590:	e13ffd17 	ldw	r4,-12(fp)
 201e594:	201ebbc0 	call	201ebbc <alt_find_file>
 201e598:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 201e59c:	00800044 	movi	r2,1
 201e5a0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 201e5a4:	e0bff817 	ldw	r2,-32(fp)
 201e5a8:	10002926 	beq	r2,zero,201e650 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 201e5ac:	e13ff817 	ldw	r4,-32(fp)
 201e5b0:	201ecc40 	call	201ecc4 <alt_get_fd>
 201e5b4:	e0bff915 	stw	r2,-28(fp)
 201e5b8:	e0bff917 	ldw	r2,-28(fp)
 201e5bc:	1000030e 	bge	r2,zero,201e5cc <open+0x84>
    {
      status = index;
 201e5c0:	e0bff917 	ldw	r2,-28(fp)
 201e5c4:	e0bffa15 	stw	r2,-24(fp)
 201e5c8:	00002306 	br	201e658 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 201e5cc:	e0bff917 	ldw	r2,-28(fp)
 201e5d0:	10c00324 	muli	r3,r2,12
 201e5d4:	008080b4 	movhi	r2,514
 201e5d8:	10811104 	addi	r2,r2,1092
 201e5dc:	1885883a 	add	r2,r3,r2
 201e5e0:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 201e5e4:	e0fffe17 	ldw	r3,-8(fp)
 201e5e8:	00900034 	movhi	r2,16384
 201e5ec:	10bfffc4 	addi	r2,r2,-1
 201e5f0:	1886703a 	and	r3,r3,r2
 201e5f4:	e0bffc17 	ldw	r2,-16(fp)
 201e5f8:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 201e5fc:	e0bffb17 	ldw	r2,-20(fp)
 201e600:	1000051e 	bne	r2,zero,201e618 <open+0xd0>
 201e604:	e13ffc17 	ldw	r4,-16(fp)
 201e608:	201e4840 	call	201e484 <alt_file_locked>
 201e60c:	e0bffa15 	stw	r2,-24(fp)
 201e610:	e0bffa17 	ldw	r2,-24(fp)
 201e614:	10001016 	blt	r2,zero,201e658 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 201e618:	e0bff817 	ldw	r2,-32(fp)
 201e61c:	10800317 	ldw	r2,12(r2)
 201e620:	10000826 	beq	r2,zero,201e644 <open+0xfc>
 201e624:	e0bff817 	ldw	r2,-32(fp)
 201e628:	10800317 	ldw	r2,12(r2)
 201e62c:	e1ffff17 	ldw	r7,-4(fp)
 201e630:	e1bffe17 	ldw	r6,-8(fp)
 201e634:	e17ffd17 	ldw	r5,-12(fp)
 201e638:	e13ffc17 	ldw	r4,-16(fp)
 201e63c:	103ee83a 	callr	r2
 201e640:	00000106 	br	201e648 <open+0x100>
 201e644:	0005883a 	mov	r2,zero
 201e648:	e0bffa15 	stw	r2,-24(fp)
 201e64c:	00000206 	br	201e658 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 201e650:	00bffb44 	movi	r2,-19
 201e654:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 201e658:	e0bffa17 	ldw	r2,-24(fp)
 201e65c:	1000090e 	bge	r2,zero,201e684 <open+0x13c>
  {
    alt_release_fd (index);  
 201e660:	e13ff917 	ldw	r4,-28(fp)
 201e664:	20143300 	call	2014330 <alt_release_fd>
    ALT_ERRNO = -status;
 201e668:	201e4480 	call	201e448 <alt_get_errno>
 201e66c:	1007883a 	mov	r3,r2
 201e670:	e0bffa17 	ldw	r2,-24(fp)
 201e674:	0085c83a 	sub	r2,zero,r2
 201e678:	18800015 	stw	r2,0(r3)
    return -1;
 201e67c:	00bfffc4 	movi	r2,-1
 201e680:	00000106 	br	201e688 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 201e684:	e0bff917 	ldw	r2,-28(fp)
}
 201e688:	e037883a 	mov	sp,fp
 201e68c:	dfc00117 	ldw	ra,4(sp)
 201e690:	df000017 	ldw	fp,0(sp)
 201e694:	dec00204 	addi	sp,sp,8
 201e698:	f800283a 	ret

0201e69c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 201e69c:	defffa04 	addi	sp,sp,-24
 201e6a0:	df000515 	stw	fp,20(sp)
 201e6a4:	df000504 	addi	fp,sp,20
 201e6a8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e6ac:	0005303a 	rdctl	r2,status
 201e6b0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e6b4:	e0fffc17 	ldw	r3,-16(fp)
 201e6b8:	00bfff84 	movi	r2,-2
 201e6bc:	1884703a 	and	r2,r3,r2
 201e6c0:	1001703a 	wrctl	status,r2
  
  return context;
 201e6c4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 201e6c8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 201e6cc:	e0bfff17 	ldw	r2,-4(fp)
 201e6d0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 201e6d4:	e0bffd17 	ldw	r2,-12(fp)
 201e6d8:	10800017 	ldw	r2,0(r2)
 201e6dc:	e0fffd17 	ldw	r3,-12(fp)
 201e6e0:	18c00117 	ldw	r3,4(r3)
 201e6e4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 201e6e8:	e0bffd17 	ldw	r2,-12(fp)
 201e6ec:	10800117 	ldw	r2,4(r2)
 201e6f0:	e0fffd17 	ldw	r3,-12(fp)
 201e6f4:	18c00017 	ldw	r3,0(r3)
 201e6f8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 201e6fc:	e0bffd17 	ldw	r2,-12(fp)
 201e700:	e0fffd17 	ldw	r3,-12(fp)
 201e704:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 201e708:	e0bffd17 	ldw	r2,-12(fp)
 201e70c:	e0fffd17 	ldw	r3,-12(fp)
 201e710:	10c00015 	stw	r3,0(r2)
 201e714:	e0bffb17 	ldw	r2,-20(fp)
 201e718:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e71c:	e0bffe17 	ldw	r2,-8(fp)
 201e720:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 201e724:	0001883a 	nop
 201e728:	e037883a 	mov	sp,fp
 201e72c:	df000017 	ldw	fp,0(sp)
 201e730:	dec00104 	addi	sp,sp,4
 201e734:	f800283a 	ret

0201e738 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 201e738:	defffb04 	addi	sp,sp,-20
 201e73c:	dfc00415 	stw	ra,16(sp)
 201e740:	df000315 	stw	fp,12(sp)
 201e744:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 201e748:	d0a03317 	ldw	r2,-32564(gp)
 201e74c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 201e750:	d0a76517 	ldw	r2,-25196(gp)
 201e754:	10800044 	addi	r2,r2,1
 201e758:	d0a76515 	stw	r2,-25196(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 201e75c:	00002e06 	br	201e818 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 201e760:	e0bffd17 	ldw	r2,-12(fp)
 201e764:	10800017 	ldw	r2,0(r2)
 201e768:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 201e76c:	e0bffd17 	ldw	r2,-12(fp)
 201e770:	10800403 	ldbu	r2,16(r2)
 201e774:	10803fcc 	andi	r2,r2,255
 201e778:	10000426 	beq	r2,zero,201e78c <alt_tick+0x54>
 201e77c:	d0a76517 	ldw	r2,-25196(gp)
 201e780:	1000021e 	bne	r2,zero,201e78c <alt_tick+0x54>
    {
      alarm->rollover = 0;
 201e784:	e0bffd17 	ldw	r2,-12(fp)
 201e788:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 201e78c:	e0bffd17 	ldw	r2,-12(fp)
 201e790:	10800217 	ldw	r2,8(r2)
 201e794:	d0e76517 	ldw	r3,-25196(gp)
 201e798:	18801d36 	bltu	r3,r2,201e810 <alt_tick+0xd8>
 201e79c:	e0bffd17 	ldw	r2,-12(fp)
 201e7a0:	10800403 	ldbu	r2,16(r2)
 201e7a4:	10803fcc 	andi	r2,r2,255
 201e7a8:	1000191e 	bne	r2,zero,201e810 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 201e7ac:	e0bffd17 	ldw	r2,-12(fp)
 201e7b0:	10800317 	ldw	r2,12(r2)
 201e7b4:	e0fffd17 	ldw	r3,-12(fp)
 201e7b8:	18c00517 	ldw	r3,20(r3)
 201e7bc:	1809883a 	mov	r4,r3
 201e7c0:	103ee83a 	callr	r2
 201e7c4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 201e7c8:	e0bfff17 	ldw	r2,-4(fp)
 201e7cc:	1000031e 	bne	r2,zero,201e7dc <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 201e7d0:	e13ffd17 	ldw	r4,-12(fp)
 201e7d4:	201e69c0 	call	201e69c <alt_alarm_stop>
 201e7d8:	00000d06 	br	201e810 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 201e7dc:	e0bffd17 	ldw	r2,-12(fp)
 201e7e0:	10c00217 	ldw	r3,8(r2)
 201e7e4:	e0bfff17 	ldw	r2,-4(fp)
 201e7e8:	1887883a 	add	r3,r3,r2
 201e7ec:	e0bffd17 	ldw	r2,-12(fp)
 201e7f0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 201e7f4:	e0bffd17 	ldw	r2,-12(fp)
 201e7f8:	10c00217 	ldw	r3,8(r2)
 201e7fc:	d0a76517 	ldw	r2,-25196(gp)
 201e800:	1880032e 	bgeu	r3,r2,201e810 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 201e804:	e0bffd17 	ldw	r2,-12(fp)
 201e808:	00c00044 	movi	r3,1
 201e80c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 201e810:	e0bffe17 	ldw	r2,-8(fp)
 201e814:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 201e818:	e0fffd17 	ldw	r3,-12(fp)
 201e81c:	d0a03304 	addi	r2,gp,-32564
 201e820:	18bfcf1e 	bne	r3,r2,201e760 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 201e824:	201551c0 	call	201551c <OSTimeTick>
}
 201e828:	0001883a 	nop
 201e82c:	e037883a 	mov	sp,fp
 201e830:	dfc00117 	ldw	ra,4(sp)
 201e834:	df000017 	ldw	fp,0(sp)
 201e838:	dec00204 	addi	sp,sp,8
 201e83c:	f800283a 	ret

0201e840 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 201e840:	deffff04 	addi	sp,sp,-4
 201e844:	df000015 	stw	fp,0(sp)
 201e848:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 201e84c:	000170fa 	wrctl	ienable,zero
}
 201e850:	0001883a 	nop
 201e854:	e037883a 	mov	sp,fp
 201e858:	df000017 	ldw	fp,0(sp)
 201e85c:	dec00104 	addi	sp,sp,4
 201e860:	f800283a 	ret

0201e864 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 201e864:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 201e868:	d0e00617 	ldw	r3,-32744(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 201e86c:	d1275e17 	ldw	r4,-25224(gp)

      stw ra,  0(sp)
 201e870:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 201e874:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 201e878:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 201e87c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 201e880:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 201e884:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 201e888:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 201e88c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 201e890:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 201e894:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 201e898:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 201e89c:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 201e8a0:	201ead80 	call	201ead8 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 201e8a4:	d1275917 	ldw	r4,-25244(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 201e8a8:	d1675107 	ldb	r5,-25276(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 201e8ac:	d1275e15 	stw	r4,-25224(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 201e8b0:	d1675145 	stb	r5,-25275(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 201e8b4:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 201e8b8:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 201e8bc:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 201e8c0:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 201e8c4:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 201e8c8:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 201e8cc:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 201e8d0:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 201e8d4:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 201e8d8:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 201e8dc:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 201e8e0:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 201e8e4:	d0e00615 	stw	r3,-32744(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 201e8e8:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 201e8ec:	f800283a 	ret

0201e8f0 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 201e8f0:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 201e8f4:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 201e8f8:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 201e8fc:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 201e900:	201ead80 	call	201ead8 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 201e904:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 201e908:	d4a74f45 	stb	r18,-25283(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 201e90c:	003fe506 	br	201e8a4 <OSCtxSw+0x40>

0201e910 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 201e910:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 201e914:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 201e918:	10800054 	ori	r2,r2,1
      wrctl status, r2
 201e91c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 201e920:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 201e924:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 201e928:	dec00204 	addi	sp,sp,8

      callr r2
 201e92c:	103ee83a 	callr	r2

      nop
 201e930:	0001883a 	nop

0201e934 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 201e934:	defff704 	addi	sp,sp,-36
 201e938:	dfc00815 	stw	ra,32(sp)
 201e93c:	df000715 	stw	fp,28(sp)
 201e940:	df000704 	addi	fp,sp,28
 201e944:	e13ffc15 	stw	r4,-16(fp)
 201e948:	e17ffd15 	stw	r5,-12(fp)
 201e94c:	e1bffe15 	stw	r6,-8(fp)
 201e950:	3805883a 	mov	r2,r7
 201e954:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 201e958:	e0fffe17 	ldw	r3,-8(fp)
 201e95c:	00bfff04 	movi	r2,-4
 201e960:	1884703a 	and	r2,r3,r2
 201e964:	10bef704 	addi	r2,r2,-1060
 201e968:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 201e96c:	01810904 	movi	r6,1060
 201e970:	000b883a 	mov	r5,zero
 201e974:	e13ff917 	ldw	r4,-28(fp)
 201e978:	20069580 	call	2006958 <memset>
 201e97c:	e0bff917 	ldw	r2,-28(fp)
 201e980:	10c0bb04 	addi	r3,r2,748
 201e984:	e0bff917 	ldw	r2,-28(fp)
 201e988:	10c00115 	stw	r3,4(r2)
 201e98c:	e0bff917 	ldw	r2,-28(fp)
 201e990:	10c0d504 	addi	r3,r2,852
 201e994:	e0bff917 	ldw	r2,-28(fp)
 201e998:	10c00215 	stw	r3,8(r2)
 201e99c:	e0bff917 	ldw	r2,-28(fp)
 201e9a0:	10c0ef04 	addi	r3,r2,956
 201e9a4:	e0bff917 	ldw	r2,-28(fp)
 201e9a8:	10c00315 	stw	r3,12(r2)
 201e9ac:	e0fff917 	ldw	r3,-28(fp)
 201e9b0:	008080b4 	movhi	r2,514
 201e9b4:	10bed104 	addi	r2,r2,-1212
 201e9b8:	18800d15 	stw	r2,52(r3)
 201e9bc:	e0bff917 	ldw	r2,-28(fp)
 201e9c0:	00c00044 	movi	r3,1
 201e9c4:	10c02915 	stw	r3,164(r2)
 201e9c8:	10002a15 	stw	zero,168(r2)
 201e9cc:	e0bff917 	ldw	r2,-28(fp)
 201e9d0:	00ccc384 	movi	r3,13070
 201e9d4:	10c02b0d 	sth	r3,172(r2)
 201e9d8:	e0bff917 	ldw	r2,-28(fp)
 201e9dc:	00eaf344 	movi	r3,-21555
 201e9e0:	10c02b8d 	sth	r3,174(r2)
 201e9e4:	e0bff917 	ldw	r2,-28(fp)
 201e9e8:	00c48d04 	movi	r3,4660
 201e9ec:	10c02c0d 	sth	r3,176(r2)
 201e9f0:	e0bff917 	ldw	r2,-28(fp)
 201e9f4:	00f99b44 	movi	r3,-6547
 201e9f8:	10c02c8d 	sth	r3,178(r2)
 201e9fc:	e0bff917 	ldw	r2,-28(fp)
 201ea00:	00f7bb04 	movi	r3,-8468
 201ea04:	10c02d0d 	sth	r3,180(r2)
 201ea08:	e0bff917 	ldw	r2,-28(fp)
 201ea0c:	00c00144 	movi	r3,5
 201ea10:	10c02d8d 	sth	r3,182(r2)
 201ea14:	e0bff917 	ldw	r2,-28(fp)
 201ea18:	00c002c4 	movi	r3,11
 201ea1c:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 201ea20:	e0bff917 	ldw	r2,-28(fp)
 201ea24:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 201ea28:	e0bffa17 	ldw	r2,-24(fp)
 201ea2c:	10bff304 	addi	r2,r2,-52
 201ea30:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 201ea34:	e0bffb17 	ldw	r2,-20(fp)
 201ea38:	10800c04 	addi	r2,r2,48
 201ea3c:	e0fffc17 	ldw	r3,-16(fp)
 201ea40:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 201ea44:	e0bffb17 	ldw	r2,-20(fp)
 201ea48:	10800b04 	addi	r2,r2,44
 201ea4c:	e0fffd17 	ldw	r3,-12(fp)
 201ea50:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 201ea54:	e0bffb17 	ldw	r2,-20(fp)
 201ea58:	10800a04 	addi	r2,r2,40
 201ea5c:	e0fff917 	ldw	r3,-28(fp)
 201ea60:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 201ea64:	008080b4 	movhi	r2,514
 201ea68:	10ba4404 	addi	r2,r2,-5872
 201ea6c:	10c00104 	addi	r3,r2,4
 201ea70:	e0bffb17 	ldw	r2,-20(fp)
 201ea74:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 201ea78:	e0bffb17 	ldw	r2,-20(fp)
}
 201ea7c:	e037883a 	mov	sp,fp
 201ea80:	dfc00117 	ldw	ra,4(sp)
 201ea84:	df000017 	ldw	fp,0(sp)
 201ea88:	dec00204 	addi	sp,sp,8
 201ea8c:	f800283a 	ret

0201ea90 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 201ea90:	defffe04 	addi	sp,sp,-8
 201ea94:	df000115 	stw	fp,4(sp)
 201ea98:	df000104 	addi	fp,sp,4
 201ea9c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 201eaa0:	0001883a 	nop
 201eaa4:	e037883a 	mov	sp,fp
 201eaa8:	df000017 	ldw	fp,0(sp)
 201eaac:	dec00104 	addi	sp,sp,4
 201eab0:	f800283a 	ret

0201eab4 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 201eab4:	defffe04 	addi	sp,sp,-8
 201eab8:	df000115 	stw	fp,4(sp)
 201eabc:	df000104 	addi	fp,sp,4
 201eac0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 201eac4:	0001883a 	nop
 201eac8:	e037883a 	mov	sp,fp
 201eacc:	df000017 	ldw	fp,0(sp)
 201ead0:	dec00104 	addi	sp,sp,4
 201ead4:	f800283a 	ret

0201ead8 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 201ead8:	deffff04 	addi	sp,sp,-4
 201eadc:	df000015 	stw	fp,0(sp)
 201eae0:	d839883a 	mov	fp,sp
}
 201eae4:	0001883a 	nop
 201eae8:	e037883a 	mov	sp,fp
 201eaec:	df000017 	ldw	fp,0(sp)
 201eaf0:	dec00104 	addi	sp,sp,4
 201eaf4:	f800283a 	ret

0201eaf8 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 201eaf8:	deffff04 	addi	sp,sp,-4
 201eafc:	df000015 	stw	fp,0(sp)
 201eb00:	d839883a 	mov	fp,sp
}
 201eb04:	0001883a 	nop
 201eb08:	e037883a 	mov	sp,fp
 201eb0c:	df000017 	ldw	fp,0(sp)
 201eb10:	dec00104 	addi	sp,sp,4
 201eb14:	f800283a 	ret

0201eb18 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 201eb18:	deffff04 	addi	sp,sp,-4
 201eb1c:	df000015 	stw	fp,0(sp)
 201eb20:	d839883a 	mov	fp,sp
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
 201eb24:	0001883a 	nop
 201eb28:	e037883a 	mov	sp,fp
 201eb2c:	df000017 	ldw	fp,0(sp)
 201eb30:	dec00104 	addi	sp,sp,4
 201eb34:	f800283a 	ret

0201eb38 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 201eb38:	deffff04 	addi	sp,sp,-4
 201eb3c:	df000015 	stw	fp,0(sp)
 201eb40:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 201eb44:	0001883a 	nop
 201eb48:	e037883a 	mov	sp,fp
 201eb4c:	df000017 	ldw	fp,0(sp)
 201eb50:	dec00104 	addi	sp,sp,4
 201eb54:	f800283a 	ret

0201eb58 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 201eb58:	deffff04 	addi	sp,sp,-4
 201eb5c:	df000015 	stw	fp,0(sp)
 201eb60:	d839883a 	mov	fp,sp
}
 201eb64:	0001883a 	nop
 201eb68:	e037883a 	mov	sp,fp
 201eb6c:	df000017 	ldw	fp,0(sp)
 201eb70:	dec00104 	addi	sp,sp,4
 201eb74:	f800283a 	ret

0201eb78 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 201eb78:	deffff04 	addi	sp,sp,-4
 201eb7c:	df000015 	stw	fp,0(sp)
 201eb80:	d839883a 	mov	fp,sp
}
 201eb84:	0001883a 	nop
 201eb88:	e037883a 	mov	sp,fp
 201eb8c:	df000017 	ldw	fp,0(sp)
 201eb90:	dec00104 	addi	sp,sp,4
 201eb94:	f800283a 	ret

0201eb98 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 201eb98:	defffe04 	addi	sp,sp,-8
 201eb9c:	df000115 	stw	fp,4(sp)
 201eba0:	df000104 	addi	fp,sp,4
 201eba4:	e13fff15 	stw	r4,-4(fp)
}
 201eba8:	0001883a 	nop
 201ebac:	e037883a 	mov	sp,fp
 201ebb0:	df000017 	ldw	fp,0(sp)
 201ebb4:	dec00104 	addi	sp,sp,4
 201ebb8:	f800283a 	ret

0201ebbc <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 201ebbc:	defffb04 	addi	sp,sp,-20
 201ebc0:	dfc00415 	stw	ra,16(sp)
 201ebc4:	df000315 	stw	fp,12(sp)
 201ebc8:	df000304 	addi	fp,sp,12
 201ebcc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 201ebd0:	d0a00c17 	ldw	r2,-32720(gp)
 201ebd4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 201ebd8:	00003106 	br	201eca0 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 201ebdc:	e0bffd17 	ldw	r2,-12(fp)
 201ebe0:	10800217 	ldw	r2,8(r2)
 201ebe4:	1009883a 	mov	r4,r2
 201ebe8:	2006d380 	call	2006d38 <strlen>
 201ebec:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 201ebf0:	e0bffd17 	ldw	r2,-12(fp)
 201ebf4:	10c00217 	ldw	r3,8(r2)
 201ebf8:	e0bffe17 	ldw	r2,-8(fp)
 201ebfc:	10bfffc4 	addi	r2,r2,-1
 201ec00:	1885883a 	add	r2,r3,r2
 201ec04:	10800003 	ldbu	r2,0(r2)
 201ec08:	10803fcc 	andi	r2,r2,255
 201ec0c:	1080201c 	xori	r2,r2,128
 201ec10:	10bfe004 	addi	r2,r2,-128
 201ec14:	10800bd8 	cmpnei	r2,r2,47
 201ec18:	1000031e 	bne	r2,zero,201ec28 <alt_find_file+0x6c>
    {
      len -= 1;
 201ec1c:	e0bffe17 	ldw	r2,-8(fp)
 201ec20:	10bfffc4 	addi	r2,r2,-1
 201ec24:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 201ec28:	e0bffe17 	ldw	r2,-8(fp)
 201ec2c:	e0ffff17 	ldw	r3,-4(fp)
 201ec30:	1885883a 	add	r2,r3,r2
 201ec34:	10800003 	ldbu	r2,0(r2)
 201ec38:	10803fcc 	andi	r2,r2,255
 201ec3c:	1080201c 	xori	r2,r2,128
 201ec40:	10bfe004 	addi	r2,r2,-128
 201ec44:	10800be0 	cmpeqi	r2,r2,47
 201ec48:	1000081e 	bne	r2,zero,201ec6c <alt_find_file+0xb0>
 201ec4c:	e0bffe17 	ldw	r2,-8(fp)
 201ec50:	e0ffff17 	ldw	r3,-4(fp)
 201ec54:	1885883a 	add	r2,r3,r2
 201ec58:	10800003 	ldbu	r2,0(r2)
 201ec5c:	10803fcc 	andi	r2,r2,255
 201ec60:	1080201c 	xori	r2,r2,128
 201ec64:	10bfe004 	addi	r2,r2,-128
 201ec68:	10000a1e 	bne	r2,zero,201ec94 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 201ec6c:	e0bffd17 	ldw	r2,-12(fp)
 201ec70:	10800217 	ldw	r2,8(r2)
 201ec74:	e0fffe17 	ldw	r3,-8(fp)
 201ec78:	180d883a 	mov	r6,r3
 201ec7c:	e17fff17 	ldw	r5,-4(fp)
 201ec80:	1009883a 	mov	r4,r2
 201ec84:	201ef500 	call	201ef50 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 201ec88:	1000021e 	bne	r2,zero,201ec94 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 201ec8c:	e0bffd17 	ldw	r2,-12(fp)
 201ec90:	00000706 	br	201ecb0 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 201ec94:	e0bffd17 	ldw	r2,-12(fp)
 201ec98:	10800017 	ldw	r2,0(r2)
 201ec9c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 201eca0:	e0fffd17 	ldw	r3,-12(fp)
 201eca4:	d0a00c04 	addi	r2,gp,-32720
 201eca8:	18bfcc1e 	bne	r3,r2,201ebdc <alt_find_file+0x20>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 201ecac:	0005883a 	mov	r2,zero
}
 201ecb0:	e037883a 	mov	sp,fp
 201ecb4:	dfc00117 	ldw	ra,4(sp)
 201ecb8:	df000017 	ldw	fp,0(sp)
 201ecbc:	dec00204 	addi	sp,sp,8
 201ecc0:	f800283a 	ret

0201ecc4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 201ecc4:	defff904 	addi	sp,sp,-28
 201ecc8:	dfc00615 	stw	ra,24(sp)
 201eccc:	df000515 	stw	fp,20(sp)
 201ecd0:	df000504 	addi	fp,sp,20
 201ecd4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 201ecd8:	00bffa04 	movi	r2,-24
 201ecdc:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 201ece0:	d0a74717 	ldw	r2,-25316(gp)
 201ece4:	e0bffd15 	stw	r2,-12(fp)
 201ece8:	e03ffe0d 	sth	zero,-8(fp)
 201ecec:	e0bffe0b 	ldhu	r2,-8(fp)
 201ecf0:	e0fffe84 	addi	r3,fp,-6
 201ecf4:	180d883a 	mov	r6,r3
 201ecf8:	100b883a 	mov	r5,r2
 201ecfc:	e13ffd17 	ldw	r4,-12(fp)
 201ed00:	201a8280 	call	201a828 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 201ed04:	e03ffb15 	stw	zero,-20(fp)
 201ed08:	00001906 	br	201ed70 <alt_get_fd+0xac>
  {
    if (!alt_fd_list[i].dev)
 201ed0c:	008080b4 	movhi	r2,514
 201ed10:	10811104 	addi	r2,r2,1092
 201ed14:	e0fffb17 	ldw	r3,-20(fp)
 201ed18:	18c00324 	muli	r3,r3,12
 201ed1c:	10c5883a 	add	r2,r2,r3
 201ed20:	10800017 	ldw	r2,0(r2)
 201ed24:	10000f1e 	bne	r2,zero,201ed64 <alt_get_fd+0xa0>
    {
      alt_fd_list[i].dev = dev;
 201ed28:	008080b4 	movhi	r2,514
 201ed2c:	10811104 	addi	r2,r2,1092
 201ed30:	e0fffb17 	ldw	r3,-20(fp)
 201ed34:	18c00324 	muli	r3,r3,12
 201ed38:	10c5883a 	add	r2,r2,r3
 201ed3c:	e0ffff17 	ldw	r3,-4(fp)
 201ed40:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 201ed44:	d0e01017 	ldw	r3,-32704(gp)
 201ed48:	e0bffb17 	ldw	r2,-20(fp)
 201ed4c:	1880020e 	bge	r3,r2,201ed58 <alt_get_fd+0x94>
      {
        alt_max_fd = i;
 201ed50:	e0bffb17 	ldw	r2,-20(fp)
 201ed54:	d0a01015 	stw	r2,-32704(gp)
      }
      rc = i;
 201ed58:	e0bffb17 	ldw	r2,-20(fp)
 201ed5c:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 201ed60:	00000606 	br	201ed7c <alt_get_fd+0xb8>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 201ed64:	e0bffb17 	ldw	r2,-20(fp)
 201ed68:	10800044 	addi	r2,r2,1
 201ed6c:	e0bffb15 	stw	r2,-20(fp)
 201ed70:	e0bffb17 	ldw	r2,-20(fp)
 201ed74:	10800810 	cmplti	r2,r2,32
 201ed78:	103fe41e 	bne	r2,zero,201ed0c <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 201ed7c:	d0a74717 	ldw	r2,-25316(gp)
 201ed80:	1009883a 	mov	r4,r2
 201ed84:	201aba00 	call	201aba0 <OSSemPost>

  return rc;
 201ed88:	e0bffc17 	ldw	r2,-16(fp)
}
 201ed8c:	e037883a 	mov	sp,fp
 201ed90:	dfc00117 	ldw	ra,4(sp)
 201ed94:	df000017 	ldw	fp,0(sp)
 201ed98:	dec00204 	addi	sp,sp,8
 201ed9c:	f800283a 	ret

0201eda0 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 201eda0:	defffb04 	addi	sp,sp,-20
 201eda4:	df000415 	stw	fp,16(sp)
 201eda8:	df000404 	addi	fp,sp,16
 201edac:	e13ffe15 	stw	r4,-8(fp)
 201edb0:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 201edb4:	e0bfff17 	ldw	r2,-4(fp)
 201edb8:	10840070 	cmpltui	r2,r2,4097
 201edbc:	1000021e 	bne	r2,zero,201edc8 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 201edc0:	00840004 	movi	r2,4096
 201edc4:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 201edc8:	e0fffe17 	ldw	r3,-8(fp)
 201edcc:	e0bfff17 	ldw	r2,-4(fp)
 201edd0:	1885883a 	add	r2,r3,r2
 201edd4:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 201edd8:	e0bffe17 	ldw	r2,-8(fp)
 201eddc:	e0bffc15 	stw	r2,-16(fp)
 201ede0:	00000506 	br	201edf8 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 201ede4:	e0bffc17 	ldw	r2,-16(fp)
 201ede8:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 201edec:	e0bffc17 	ldw	r2,-16(fp)
 201edf0:	10800804 	addi	r2,r2,32
 201edf4:	e0bffc15 	stw	r2,-16(fp)
 201edf8:	e0fffc17 	ldw	r3,-16(fp)
 201edfc:	e0bffd17 	ldw	r2,-12(fp)
 201ee00:	18bff836 	bltu	r3,r2,201ede4 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 201ee04:	e0bffe17 	ldw	r2,-8(fp)
 201ee08:	108007cc 	andi	r2,r2,31
 201ee0c:	10000226 	beq	r2,zero,201ee18 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 201ee10:	e0bffc17 	ldw	r2,-16(fp)
 201ee14:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 201ee18:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 201ee1c:	0001883a 	nop
 201ee20:	e037883a 	mov	sp,fp
 201ee24:	df000017 	ldw	fp,0(sp)
 201ee28:	dec00104 	addi	sp,sp,4
 201ee2c:	f800283a 	ret

0201ee30 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 201ee30:	defffe04 	addi	sp,sp,-8
 201ee34:	df000115 	stw	fp,4(sp)
 201ee38:	df000104 	addi	fp,sp,4
 201ee3c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
 201ee40:	e0bfff17 	ldw	r2,-4(fp)
 201ee44:	10bffe84 	addi	r2,r2,-6
 201ee48:	10c00428 	cmpgeui	r3,r2,16
 201ee4c:	18001a1e 	bne	r3,zero,201eeb8 <alt_exception_cause_generated_bad_addr+0x88>
 201ee50:	100690ba 	slli	r3,r2,2
 201ee54:	008080b4 	movhi	r2,514
 201ee58:	10bb9a04 	addi	r2,r2,-4504
 201ee5c:	1885883a 	add	r2,r3,r2
 201ee60:	10800017 	ldw	r2,0(r2)
 201ee64:	1000683a 	jmp	r2
 201ee68:	0201eea8 	cmpgeui	r8,zero,1978
 201ee6c:	0201eea8 	cmpgeui	r8,zero,1978
 201ee70:	0201eeb8 	rdprs	r8,zero,1978
 201ee74:	0201eeb8 	rdprs	r8,zero,1978
 201ee78:	0201eeb8 	rdprs	r8,zero,1978
 201ee7c:	0201eea8 	cmpgeui	r8,zero,1978
 201ee80:	0201eeb0 	cmpltui	r8,zero,1978
 201ee84:	0201eeb8 	rdprs	r8,zero,1978
 201ee88:	0201eea8 	cmpgeui	r8,zero,1978
 201ee8c:	0201eea8 	cmpgeui	r8,zero,1978
 201ee90:	0201eeb8 	rdprs	r8,zero,1978
 201ee94:	0201eea8 	cmpgeui	r8,zero,1978
 201ee98:	0201eeb0 	cmpltui	r8,zero,1978
 201ee9c:	0201eeb8 	rdprs	r8,zero,1978
 201eea0:	0201eeb8 	rdprs	r8,zero,1978
 201eea4:	0201eea8 	cmpgeui	r8,zero,1978
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 201eea8:	00800044 	movi	r2,1
 201eeac:	00000306 	br	201eebc <alt_exception_cause_generated_bad_addr+0x8c>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 201eeb0:	0005883a 	mov	r2,zero
 201eeb4:	00000106 	br	201eebc <alt_exception_cause_generated_bad_addr+0x8c>

  default:
    return 0;
 201eeb8:	0005883a 	mov	r2,zero
  }
}
 201eebc:	e037883a 	mov	sp,fp
 201eec0:	df000017 	ldw	fp,0(sp)
 201eec4:	dec00104 	addi	sp,sp,4
 201eec8:	f800283a 	ret

0201eecc <atexit>:

int
_DEFUN (atexit,
	(fn),
	_VOID _EXFNPTR(fn, (_VOID)))
{
 201eecc:	defffd04 	addi	sp,sp,-12
 201eed0:	dfc00215 	stw	ra,8(sp)
 201eed4:	df000115 	stw	fp,4(sp)
 201eed8:	df000104 	addi	fp,sp,4
 201eedc:	e13fff15 	stw	r4,-4(fp)
  return __register_exitproc (__et_atexit, fn, NULL, NULL);
 201eee0:	000f883a 	mov	r7,zero
 201eee4:	000d883a 	mov	r6,zero
 201eee8:	e17fff17 	ldw	r5,-4(fp)
 201eeec:	0009883a 	mov	r4,zero
 201eef0:	201f0840 	call	201f084 <__register_exitproc>
}
 201eef4:	e037883a 	mov	sp,fp
 201eef8:	dfc00117 	ldw	ra,4(sp)
 201eefc:	df000017 	ldw	fp,0(sp)
 201ef00:	dec00204 	addi	sp,sp,8
 201ef04:	f800283a 	ret

0201ef08 <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
 201ef08:	defffd04 	addi	sp,sp,-12
 201ef0c:	dfc00215 	stw	ra,8(sp)
 201ef10:	df000115 	stw	fp,4(sp)
 201ef14:	df000104 	addi	fp,sp,4
 201ef18:	e13fff15 	stw	r4,-4(fp)
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
 201ef1c:	000b883a 	mov	r5,zero
 201ef20:	e13fff17 	ldw	r4,-4(fp)
 201ef24:	201f1f40 	call	201f1f4 <__call_exitprocs>

#ifndef WANT_SMALL_STDIO				/* AlteraSpecific */
  if (_GLOBAL_REENT->__cleanup)
 201ef28:	d0a00717 	ldw	r2,-32740(gp)
 201ef2c:	10800f17 	ldw	r2,60(r2)
 201ef30:	10000526 	beq	r2,zero,201ef48 <exit+0x40>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
 201ef34:	d0a00717 	ldw	r2,-32740(gp)
 201ef38:	10800f17 	ldw	r2,60(r2)
 201ef3c:	d0e00717 	ldw	r3,-32740(gp)
 201ef40:	1809883a 	mov	r4,r3
 201ef44:	103ee83a 	callr	r2
#endif							/* AlteraSpecific */
  _exit (code);
 201ef48:	e13fff17 	ldw	r4,-4(fp)
 201ef4c:	201f3e00 	call	201f3e0 <_exit>

0201ef50 <memcmp>:
int
_DEFUN (memcmp, (m1, m2, n),
	_CONST _PTR m1 _AND
	_CONST _PTR m2 _AND
	size_t n)
{
 201ef50:	defff804 	addi	sp,sp,-32
 201ef54:	df000715 	stw	fp,28(sp)
 201ef58:	df000704 	addi	fp,sp,28
 201ef5c:	e13ffd15 	stw	r4,-12(fp)
 201ef60:	e17ffe15 	stw	r5,-8(fp)
 201ef64:	e1bfff15 	stw	r6,-4(fp)
      s1++;
      s2++;
    }
  return 0;
#else  
  unsigned char *s1 = (unsigned char *) m1;
 201ef68:	e0bffd17 	ldw	r2,-12(fp)
 201ef6c:	e0bff915 	stw	r2,-28(fp)
  unsigned char *s2 = (unsigned char *) m2;
 201ef70:	e0bffe17 	ldw	r2,-8(fp)
 201ef74:	e0bffa15 	stw	r2,-24(fp)
  unsigned long *a2;

  /* If the size is too small, or either pointer is unaligned,
     then we punt to the byte compare loop.  Hopefully this will
     not turn up in inner loops.  */
  if (!TOO_SMALL(n) && !UNALIGNED(s1,s2))
 201ef78:	e0bfff17 	ldw	r2,-4(fp)
 201ef7c:	10800130 	cmpltui	r2,r2,4
 201ef80:	1000371e 	bne	r2,zero,201f060 <memcmp+0x110>
 201ef84:	e0fff917 	ldw	r3,-28(fp)
 201ef88:	e0bffa17 	ldw	r2,-24(fp)
 201ef8c:	1884b03a 	or	r2,r3,r2
 201ef90:	108000cc 	andi	r2,r2,3
 201ef94:	1000321e 	bne	r2,zero,201f060 <memcmp+0x110>
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
 201ef98:	e0bff917 	ldw	r2,-28(fp)
 201ef9c:	e0bffb15 	stw	r2,-20(fp)
      a2 = (unsigned long*) s2;
 201efa0:	e0bffa17 	ldw	r2,-24(fp)
 201efa4:	e0bffc15 	stw	r2,-16(fp)
      while (n >= LBLOCKSIZE)
 201efa8:	00000e06 	br	201efe4 <memcmp+0x94>
        {
          if (*a1 != *a2) 
 201efac:	e0bffb17 	ldw	r2,-20(fp)
 201efb0:	10c00017 	ldw	r3,0(r2)
 201efb4:	e0bffc17 	ldw	r2,-16(fp)
 201efb8:	10800017 	ldw	r2,0(r2)
 201efbc:	18800d1e 	bne	r3,r2,201eff4 <memcmp+0xa4>
   	    break;
          a1++;
 201efc0:	e0bffb17 	ldw	r2,-20(fp)
 201efc4:	10800104 	addi	r2,r2,4
 201efc8:	e0bffb15 	stw	r2,-20(fp)
          a2++;
 201efcc:	e0bffc17 	ldw	r2,-16(fp)
 201efd0:	10800104 	addi	r2,r2,4
 201efd4:	e0bffc15 	stw	r2,-16(fp)
          n -= LBLOCKSIZE;
 201efd8:	e0bfff17 	ldw	r2,-4(fp)
 201efdc:	10bfff04 	addi	r2,r2,-4
 201efe0:	e0bfff15 	stw	r2,-4(fp)
    {
      /* Otherwise, load and compare the blocks of memory one 
         word at a time.  */
      a1 = (unsigned long*) s1;
      a2 = (unsigned long*) s2;
      while (n >= LBLOCKSIZE)
 201efe4:	e0bfff17 	ldw	r2,-4(fp)
 201efe8:	10800128 	cmpgeui	r2,r2,4
 201efec:	103fef1e 	bne	r2,zero,201efac <memcmp+0x5c>
 201eff0:	00000106 	br	201eff8 <memcmp+0xa8>
        {
          if (*a1 != *a2) 
   	    break;
 201eff4:	0001883a 	nop
          n -= LBLOCKSIZE;
        }

      /* check m mod LBLOCKSIZE remaining characters */

      s1 = (unsigned char*)a1;
 201eff8:	e0bffb17 	ldw	r2,-20(fp)
 201effc:	e0bff915 	stw	r2,-28(fp)
      s2 = (unsigned char*)a2;
 201f000:	e0bffc17 	ldw	r2,-16(fp)
 201f004:	e0bffa15 	stw	r2,-24(fp)
    }

  while (n--)
 201f008:	00001506 	br	201f060 <memcmp+0x110>
    {
      if (*s1 != *s2)
 201f00c:	e0bff917 	ldw	r2,-28(fp)
 201f010:	10c00003 	ldbu	r3,0(r2)
 201f014:	e0bffa17 	ldw	r2,-24(fp)
 201f018:	10800003 	ldbu	r2,0(r2)
 201f01c:	18c03fcc 	andi	r3,r3,255
 201f020:	10803fcc 	andi	r2,r2,255
 201f024:	18800826 	beq	r3,r2,201f048 <memcmp+0xf8>
	return *s1 - *s2;
 201f028:	e0bff917 	ldw	r2,-28(fp)
 201f02c:	10800003 	ldbu	r2,0(r2)
 201f030:	10c03fcc 	andi	r3,r2,255
 201f034:	e0bffa17 	ldw	r2,-24(fp)
 201f038:	10800003 	ldbu	r2,0(r2)
 201f03c:	10803fcc 	andi	r2,r2,255
 201f040:	1885c83a 	sub	r2,r3,r2
 201f044:	00000b06 	br	201f074 <memcmp+0x124>
      s1++;
 201f048:	e0bff917 	ldw	r2,-28(fp)
 201f04c:	10800044 	addi	r2,r2,1
 201f050:	e0bff915 	stw	r2,-28(fp)
      s2++;
 201f054:	e0bffa17 	ldw	r2,-24(fp)
 201f058:	10800044 	addi	r2,r2,1
 201f05c:	e0bffa15 	stw	r2,-24(fp)

      s1 = (unsigned char*)a1;
      s2 = (unsigned char*)a2;
    }

  while (n--)
 201f060:	e0bfff17 	ldw	r2,-4(fp)
 201f064:	10ffffc4 	addi	r3,r2,-1
 201f068:	e0ffff15 	stw	r3,-4(fp)
 201f06c:	103fe71e 	bne	r2,zero,201f00c <memcmp+0xbc>
	return *s1 - *s2;
      s1++;
      s2++;
    }

  return 0;
 201f070:	0005883a 	mov	r2,zero
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 201f074:	e037883a 	mov	sp,fp
 201f078:	df000017 	ldw	fp,0(sp)
 201f07c:	dec00104 	addi	sp,sp,4
 201f080:	f800283a 	ret

0201f084 <__register_exitproc>:
	(type, fn, arg, d),
	int type _AND
	void (*fn) (void) _AND
	void *arg _AND
	void *d)
{
 201f084:	defff804 	addi	sp,sp,-32
 201f088:	dfc00715 	stw	ra,28(sp)
 201f08c:	df000615 	stw	fp,24(sp)
 201f090:	dc000515 	stw	r16,20(sp)
 201f094:	df000604 	addi	fp,sp,24
 201f098:	e13ffb15 	stw	r4,-20(fp)
 201f09c:	e17ffc15 	stw	r5,-16(fp)
 201f0a0:	e1bffd15 	stw	r6,-12(fp)
 201f0a4:	e1fffe15 	stw	r7,-8(fp)

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
#endif

  p = _GLOBAL_ATEXIT;
 201f0a8:	d0a00717 	ldw	r2,-32740(gp)
 201f0ac:	14005217 	ldw	r16,328(r2)
  if (p == NULL)
 201f0b0:	8000041e 	bne	r16,zero,201f0c4 <__register_exitproc+0x40>
    _GLOBAL_ATEXIT = p = _GLOBAL_ATEXIT0;
 201f0b4:	d0a00717 	ldw	r2,-32740(gp)
 201f0b8:	d0e00717 	ldw	r3,-32740(gp)
 201f0bc:	1c005304 	addi	r16,r3,332
 201f0c0:	14005215 	stw	r16,328(r2)
  if (p->_ind >= _ATEXIT_SIZE)
 201f0c4:	80800117 	ldw	r2,4(r16)
 201f0c8:	10800810 	cmplti	r2,r2,32
 201f0cc:	1000131e 	bne	r2,zero,201f11c <__register_exitproc+0x98>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      return -1;
#else
      /* Don't dynamically allocate the atexit array if malloc is not
	 available.  */
      if (!malloc)
 201f0d0:	00800034 	movhi	r2,0
 201f0d4:	10800004 	addi	r2,r2,0
 201f0d8:	1000021e 	bne	r2,zero,201f0e4 <__register_exitproc+0x60>
	return -1;
 201f0dc:	00bfffc4 	movi	r2,-1
 201f0e0:	00003e06 	br	201f1dc <__register_exitproc+0x158>

      p = (struct _atexit *) malloc (sizeof *p);
 201f0e4:	01006404 	movi	r4,400
 201f0e8:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
 201f0ec:	1021883a 	mov	r16,r2
      if (p == NULL)
 201f0f0:	8000021e 	bne	r16,zero,201f0fc <__register_exitproc+0x78>
	{
#ifndef __SINGLE_THREAD__
	  __lock_release_recursive(__atexit_lock);
#endif
	  return -1;
 201f0f4:	00bfffc4 	movi	r2,-1
 201f0f8:	00003806 	br	201f1dc <__register_exitproc+0x158>
	}
      p->_ind = 0;
 201f0fc:	80000115 	stw	zero,4(r16)
      p->_next = _GLOBAL_ATEXIT;
 201f100:	d0a00717 	ldw	r2,-32740(gp)
 201f104:	10805217 	ldw	r2,328(r2)
 201f108:	80800015 	stw	r2,0(r16)
      _GLOBAL_ATEXIT = p;
 201f10c:	d0a00717 	ldw	r2,-32740(gp)
 201f110:	14005215 	stw	r16,328(r2)
#ifndef _REENT_SMALL
      p->_on_exit_args._fntypes = 0;
 201f114:	80006215 	stw	zero,392(r16)
      p->_on_exit_args._is_cxa = 0;
 201f118:	80006315 	stw	zero,396(r16)
      p->_on_exit_args_ptr = NULL;
#endif
#endif
    }

  if (type != __et_atexit)
 201f11c:	e0bffb17 	ldw	r2,-20(fp)
 201f120:	10002426 	beq	r2,zero,201f1b4 <__register_exitproc+0x130>
	  args->_fntypes = 0;
	  args->_is_cxa = 0;
	  p->_on_exit_args_ptr = args;
	}
#else
      args = &p->_on_exit_args;
 201f124:	80802204 	addi	r2,r16,136
 201f128:	e0bffa15 	stw	r2,-24(fp)
#endif
      args->_fnargs[p->_ind] = arg;
 201f12c:	80800117 	ldw	r2,4(r16)
 201f130:	e0fffa17 	ldw	r3,-24(fp)
 201f134:	1085883a 	add	r2,r2,r2
 201f138:	1085883a 	add	r2,r2,r2
 201f13c:	1885883a 	add	r2,r3,r2
 201f140:	e0fffd17 	ldw	r3,-12(fp)
 201f144:	10c00015 	stw	r3,0(r2)
      args->_fntypes |= (1 << p->_ind);
 201f148:	e0bffa17 	ldw	r2,-24(fp)
 201f14c:	10804017 	ldw	r2,256(r2)
 201f150:	80c00117 	ldw	r3,4(r16)
 201f154:	01000044 	movi	r4,1
 201f158:	20c6983a 	sll	r3,r4,r3
 201f15c:	10c6b03a 	or	r3,r2,r3
 201f160:	e0bffa17 	ldw	r2,-24(fp)
 201f164:	10c04015 	stw	r3,256(r2)
      args->_dso_handle[p->_ind] = d;
 201f168:	80800117 	ldw	r2,4(r16)
 201f16c:	e0fffa17 	ldw	r3,-24(fp)
 201f170:	10800804 	addi	r2,r2,32
 201f174:	1085883a 	add	r2,r2,r2
 201f178:	1085883a 	add	r2,r2,r2
 201f17c:	1885883a 	add	r2,r3,r2
 201f180:	e0fffe17 	ldw	r3,-8(fp)
 201f184:	10c00015 	stw	r3,0(r2)
      if (type == __et_cxa)
 201f188:	e0bffb17 	ldw	r2,-20(fp)
 201f18c:	10800098 	cmpnei	r2,r2,2
 201f190:	1000081e 	bne	r2,zero,201f1b4 <__register_exitproc+0x130>
	args->_is_cxa |= (1 << p->_ind);
 201f194:	e0bffa17 	ldw	r2,-24(fp)
 201f198:	10804117 	ldw	r2,260(r2)
 201f19c:	80c00117 	ldw	r3,4(r16)
 201f1a0:	01000044 	movi	r4,1
 201f1a4:	20c6983a 	sll	r3,r4,r3
 201f1a8:	10c6b03a 	or	r3,r2,r3
 201f1ac:	e0bffa17 	ldw	r2,-24(fp)
 201f1b0:	10c04115 	stw	r3,260(r2)
    }
  p->_fns[p->_ind++] = fn;
 201f1b4:	80800117 	ldw	r2,4(r16)
 201f1b8:	10c00044 	addi	r3,r2,1
 201f1bc:	80c00115 	stw	r3,4(r16)
 201f1c0:	10800084 	addi	r2,r2,2
 201f1c4:	1085883a 	add	r2,r2,r2
 201f1c8:	1085883a 	add	r2,r2,r2
 201f1cc:	8085883a 	add	r2,r16,r2
 201f1d0:	e0fffc17 	ldw	r3,-16(fp)
 201f1d4:	10c00015 	stw	r3,0(r2)
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif
  return 0;
 201f1d8:	0005883a 	mov	r2,zero
}
 201f1dc:	e6ffff04 	addi	sp,fp,-4
 201f1e0:	dfc00217 	ldw	ra,8(sp)
 201f1e4:	df000117 	ldw	fp,4(sp)
 201f1e8:	dc000017 	ldw	r16,0(sp)
 201f1ec:	dec00304 	addi	sp,sp,12
 201f1f0:	f800283a 	ret

0201f1f4 <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
 201f1f4:	defff504 	addi	sp,sp,-44
 201f1f8:	dfc00a15 	stw	ra,40(sp)
 201f1fc:	df000915 	stw	fp,36(sp)
 201f200:	dc800815 	stw	r18,32(sp)
 201f204:	dc400715 	stw	r17,28(sp)
 201f208:	dc000615 	stw	r16,24(sp)
 201f20c:	df000904 	addi	fp,sp,36
 201f210:	e13ffb15 	stw	r4,-20(fp)
 201f214:	e17ffc15 	stw	r5,-16(fp)
  __lock_acquire_recursive(__atexit_lock);
#endif

 restart:

  p = _GLOBAL_ATEXIT;
 201f218:	d0a00717 	ldw	r2,-32740(gp)
 201f21c:	14005217 	ldw	r16,328(r2)
  lastp = &_GLOBAL_ATEXIT;
 201f220:	d0a00717 	ldw	r2,-32740(gp)
 201f224:	10805204 	addi	r2,r2,328
 201f228:	e0bff715 	stw	r2,-36(fp)
  while (p)
 201f22c:	00006006 	br	201f3b0 <__call_exitprocs+0x1bc>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
 201f230:	84802204 	addi	r18,r16,136
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 201f234:	80800117 	ldw	r2,4(r16)
 201f238:	147fffc4 	addi	r17,r2,-1
 201f23c:	00004a06 	br	201f368 <__call_exitprocs+0x174>
	{
	  int ind;

	  i = 1 << n;
 201f240:	00800044 	movi	r2,1
 201f244:	1444983a 	sll	r2,r2,r17
 201f248:	e0bff815 	stw	r2,-32(fp)

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
 201f24c:	e0bffc17 	ldw	r2,-16(fp)
 201f250:	10000826 	beq	r2,zero,201f274 <__call_exitprocs+0x80>
 201f254:	90004026 	beq	r18,zero,201f358 <__call_exitprocs+0x164>
 201f258:	88800804 	addi	r2,r17,32
 201f25c:	1085883a 	add	r2,r2,r2
 201f260:	1085883a 	add	r2,r2,r2
 201f264:	9085883a 	add	r2,r18,r2
 201f268:	10c00017 	ldw	r3,0(r2)
 201f26c:	e0bffc17 	ldw	r2,-16(fp)
 201f270:	1880391e 	bne	r3,r2,201f358 <__call_exitprocs+0x164>
	    continue;

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
 201f274:	88800084 	addi	r2,r17,2
 201f278:	1085883a 	add	r2,r2,r2
 201f27c:	1085883a 	add	r2,r2,r2
 201f280:	8085883a 	add	r2,r16,r2
 201f284:	10800017 	ldw	r2,0(r2)
 201f288:	e0bff915 	stw	r2,-28(fp)
	  if (n == p->_ind - 1)
 201f28c:	80800117 	ldw	r2,4(r16)
 201f290:	10bfffc4 	addi	r2,r2,-1
 201f294:	1440041e 	bne	r2,r17,201f2a8 <__call_exitprocs+0xb4>
	    p->_ind--;
 201f298:	80800117 	ldw	r2,4(r16)
 201f29c:	10bfffc4 	addi	r2,r2,-1
 201f2a0:	80800115 	stw	r2,4(r16)
 201f2a4:	00000506 	br	201f2bc <__call_exitprocs+0xc8>
	  else
	    p->_fns[n] = NULL;
 201f2a8:	88800084 	addi	r2,r17,2
 201f2ac:	1085883a 	add	r2,r2,r2
 201f2b0:	1085883a 	add	r2,r2,r2
 201f2b4:	8085883a 	add	r2,r16,r2
 201f2b8:	10000015 	stw	zero,0(r2)

	  /* Skip functions that have already been called.  */
	  if (!fn)
 201f2bc:	e0bff917 	ldw	r2,-28(fp)
 201f2c0:	10002726 	beq	r2,zero,201f360 <__call_exitprocs+0x16c>
	    continue;

	  ind = p->_ind;
 201f2c4:	80800117 	ldw	r2,4(r16)
 201f2c8:	e0bffa15 	stw	r2,-24(fp)

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
 201f2cc:	90000426 	beq	r18,zero,201f2e0 <__call_exitprocs+0xec>
 201f2d0:	90c04017 	ldw	r3,256(r18)
 201f2d4:	e0bff817 	ldw	r2,-32(fp)
 201f2d8:	1884703a 	and	r2,r3,r2
 201f2dc:	1000031e 	bne	r2,zero,201f2ec <__call_exitprocs+0xf8>
	    fn ();
 201f2e0:	e0bff917 	ldw	r2,-28(fp)
 201f2e4:	103ee83a 	callr	r2
 201f2e8:	00001406 	br	201f33c <__call_exitprocs+0x148>
	  else if ((args->_is_cxa & i) == 0)
 201f2ec:	90c04117 	ldw	r3,260(r18)
 201f2f0:	e0bff817 	ldw	r2,-32(fp)
 201f2f4:	1884703a 	and	r2,r3,r2
 201f2f8:	1000091e 	bne	r2,zero,201f320 <__call_exitprocs+0x12c>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
 201f2fc:	8c45883a 	add	r2,r17,r17
 201f300:	1085883a 	add	r2,r2,r2
 201f304:	9085883a 	add	r2,r18,r2
 201f308:	10c00017 	ldw	r3,0(r2)
 201f30c:	e0bff917 	ldw	r2,-28(fp)
 201f310:	180b883a 	mov	r5,r3
 201f314:	e13ffb17 	ldw	r4,-20(fp)
 201f318:	103ee83a 	callr	r2
 201f31c:	00000706 	br	201f33c <__call_exitprocs+0x148>
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
 201f320:	8c45883a 	add	r2,r17,r17
 201f324:	1085883a 	add	r2,r2,r2
 201f328:	9085883a 	add	r2,r18,r2
 201f32c:	10c00017 	ldw	r3,0(r2)
 201f330:	e0bff917 	ldw	r2,-28(fp)
 201f334:	1809883a 	mov	r4,r3
 201f338:	103ee83a 	callr	r2

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
 201f33c:	80c00117 	ldw	r3,4(r16)
 201f340:	e0bffa17 	ldw	r2,-24(fp)
 201f344:	18bfb41e 	bne	r3,r2,201f218 <__call_exitprocs+0x24>
 201f348:	e0bff717 	ldw	r2,-36(fp)
 201f34c:	10800017 	ldw	r2,0(r2)
 201f350:	143fb11e 	bne	r2,r16,201f218 <__call_exitprocs+0x24>
 201f354:	00000306 	br	201f364 <__call_exitprocs+0x170>

	  i = 1 << n;

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
	    continue;
 201f358:	0001883a 	nop
 201f35c:	00000106 	br	201f364 <__call_exitprocs+0x170>
	  else
	    p->_fns[n] = NULL;

	  /* Skip functions that have already been called.  */
	  if (!fn)
	    continue;
 201f360:	0001883a 	nop
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
 201f364:	8c7fffc4 	addi	r17,r17,-1
 201f368:	883fb50e 	bge	r17,zero,201f240 <__call_exitprocs+0x4c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
 201f36c:	00800034 	movhi	r2,0
 201f370:	10800004 	addi	r2,r2,0
 201f374:	10001026 	beq	r2,zero,201f3b8 <__call_exitprocs+0x1c4>
	break;

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
 201f378:	80800117 	ldw	r2,4(r16)
 201f37c:	10000a1e 	bne	r2,zero,201f3a8 <__call_exitprocs+0x1b4>
 201f380:	80800017 	ldw	r2,0(r16)
 201f384:	10000826 	beq	r2,zero,201f3a8 <__call_exitprocs+0x1b4>
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
 201f388:	80c00017 	ldw	r3,0(r16)
 201f38c:	e0bff717 	ldw	r2,-36(fp)
 201f390:	10c00015 	stw	r3,0(r2)
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
 201f394:	8009883a 	mov	r4,r16
 201f398:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
	  p = *lastp;
 201f39c:	e0bff717 	ldw	r2,-36(fp)
 201f3a0:	14000017 	ldw	r16,0(r2)
 201f3a4:	00000206 	br	201f3b0 <__call_exitprocs+0x1bc>
	}
      else
	{
	  lastp = &p->_next;
 201f3a8:	e43ff715 	stw	r16,-36(fp)
	  p = p->_next;
 201f3ac:	84000017 	ldw	r16,0(r16)

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
 201f3b0:	803f9f1e 	bne	r16,zero,201f230 <__call_exitprocs+0x3c>
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 201f3b4:	00000106 	br	201f3bc <__call_exitprocs+0x1c8>
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
	break;
 201f3b8:	0001883a 	nop
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
#endif

}
 201f3bc:	0001883a 	nop
 201f3c0:	e6fffd04 	addi	sp,fp,-12
 201f3c4:	dfc00417 	ldw	ra,16(sp)
 201f3c8:	df000317 	ldw	fp,12(sp)
 201f3cc:	dc800217 	ldw	r18,8(sp)
 201f3d0:	dc400117 	ldw	r17,4(sp)
 201f3d4:	dc000017 	ldw	r16,0(sp)
 201f3d8:	dec00504 	addi	sp,sp,20
 201f3dc:	f800283a 	ret

0201f3e0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 201f3e0:	defffd04 	addi	sp,sp,-12
 201f3e4:	df000215 	stw	fp,8(sp)
 201f3e8:	df000204 	addi	fp,sp,8
 201f3ec:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 201f3f0:	d0274f45 	stb	zero,-25283(gp)
 201f3f4:	e0bfff17 	ldw	r2,-4(fp)
 201f3f8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 201f3fc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 201f400:	10000226 	beq	r2,zero,201f40c <_exit+0x2c>
    ALT_SIM_FAIL();
 201f404:	002af070 	cmpltui	zero,zero,43969
 201f408:	00000106 	br	201f410 <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 201f40c:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 201f410:	003fff06 	br	201f410 <_exit+0x30>
